[
    {
        "problem_tier": 11,
        "solution_code": "#include <iostream>\nusing namespace std;\ntypedef long long ll;\ntypedef struct {\nll x1, x2, y1, y2;\n} rect;\nint main() {\nll x1, x2, y1, y2;\nrect r1, r2;\nscanf(\"%lld%lld%lld%lld\", &x1, &y1, &x2, &y2);\nr1.x1 = x1;\nr1.x2 = x2;\nr1.y1 = y1;\nr1.y2 = y2;\nscanf(\"%lld%lld%lld%lld\", &x1, &y1, &x2, &y2);\nr2.x1 = x1;\nr2.x2 = x2;\nr2.y1 = y1;\nr2.y2 = y2;\nif (r1.x1 == r2.x2 || r1.x2 == r2.x1) {\nif (r1.y1 == r2.y2 || r1.y2 == r2.y1)\nprintf(\"POINT\");\nelse if ((r1.y2 - r1.y1) + (r2.y2 - r2.y1) > max(r2.y2 - r1.y1, r1.y2 - r2.y1))\nprintf(\"LINE\");\nelse\nprintf(\"NULL\");\n}\nelse if ((r1.x2 - r1.x1) + (r2.x2 - r2.x1) > max(r2.x2 - r1.x1, r1.x2 - r2.x1)) {\nif (r1.y1 == r2.y2 || r1.y2 == r2.y1)\nprintf(\"LINE\");\nelse if ((r1.y2 - r1.y1) + (r2.y2 - r2.y1) > max(r2.y2 - r1.y1, r1.y2 - r2.y1))\nprintf(\"FACE\");\nelse\nprintf(\"NULL\");\n}\nelse\nprintf(\"NULL\");\nreturn 0;\n}"
    },
    {
        "problem_tier": 11,
        "solution_code": "#include <iostream>\n#include <algorithm>\n#include <vector>\n#include <map>\nusing namespace std;\nconst int MOD = 1e9;\ntypedef long long ll;\nint N, M, a;\nbool visited[40000];\nvector<int> prime;\nmap<int, int> A, B;\nvoid chk(int n, int b) {\nfor(auto num : prime) {\nif(n % num == 0 && b == 0) {\nA[num]++;\nchk(n / num, 0);\nreturn;\n}\nelse if(n % num == 0 && b == 1) {\nB[num]++;\nchk(n / num, 1);\nreturn;\n}\n}\nif(n != 1 && b == 0) {\nA[n]++;\n}\nelse if(n != 1 && b == 1) {\nB[n]++;\n}\n}\nint main() {\nios_base::sync_with_stdio(0);\ncin.tie(0);\ncout.tie(0);\ncin >> N;\nfor(int i = 0; i < N; i++) {\ncin >> a;\nchk(a, 0);\n}\ncin >> M;\nfor(int i = 0; i < M; i++) {\ncin >> a;\nchk(a, 1);\n}\nll ans = 1;\nbool over = false;\nfor(auto it : A) {\nint now = it.first;\nif(!B.count(now)) continue;\nint cnt = min(A[now], B[now]);\nwhile(cnt--) {\nans *= now;\nif(ans > MOD) {\nover = true;\nans %= MOD;\n}\n}\n}\nif(over) {\nans %= MOD;\ncout.width(9);\ncout.fill('0');\ncout << ans << \"\\n\";\n}\nelse {\ncout << ans << \"\\n\";\n}\nreturn 0;\n}"
    },
    {
        "problem_tier": 5,
        "solution_code": "#include<iostream>\n#include<string>\n#include<algorithm>\n#include<vector>\nusing namespace std;\nint main() {\nstring A, B;\ncin >> A >> B;\nint i = A.length(), j = B.length();\nvector<int> res;\nfor (; i >= 0 && j >= 0; i--, j--) {\nint a = A[i] - '0';\nint b = B[j] - '0';\nres.push_back(a + b);\n}\nwhile (i >= 0)\nres.push_back(A[i--] - '0');\nwhile (j >= 0)\nres.push_back(B[j--] - '0');\nfor (int i = res.size() - 1; i > 0; i--) {\ncout << res[i];\n}\nreturn 0;\n}"
    },
    {
        "problem_tier": 11,
        "solution_code": "#include <iostream>\n#include <algorithm>\nusing namespace std;\nint main() {\nios::sync_with_stdio(false);\ncin.tie(nullptr);\nint A, B;\ncin >> A >> B;\nstring C = to_string(A);     sort(C.begin(), C.end(), greater<>());\nint ans = -1;\ndo {\nif (C.front() == '0')\ncontinue;         if (stoi(C) <= B) {             ans = stoi(C);\nbreak;\n}\n} while (prev_permutation(C.begin(), C.end()));\ncout << ans << endl;\nreturn 0;\n}"
    },
    {
        "problem_tier": 14,
        "solution_code": "#include <iostream>\n#include <vector>\nusing namespace std;\nchar type[123458];\nlong long num[123458];\nvector<long long> tree[123458];\nlong long dfs(int node) {\nlong long cnt = 0;\nfor (int i = 0; i < tree[node].size(); i++) {\ncnt += dfs(tree[node][i]);\n}\nif (type[node] == 'W') {\ncnt = cnt - num[node];\nif (cnt < 0)\nreturn 0;\nelse\nreturn cnt;\n} else {\nreturn cnt + num[node];\n}\n}\nint main() {\nios_base::sync_with_stdio(false);\ncin.tie(NULL);\ncout.tie(NULL);\nlong long n;\ncin >> n;\nchar animal;\nlong long numbers;\nlong long node;\nfor (long long i = 2; i <= n; i++) {\ncin >> animal >> numbers >> node;\ntype[i] = animal;\nnum[i] = numbers;\ntree[node].push_back(i);\n}\ntype[1] = 'S';\nnum[1] = 0;\ncout << dfs(1) << \"\\n\";\nreturn 0;\n}"
    },
    {
        "problem_tier": 13,
        "solution_code": "#include <iostream>\n#include <queue>\nusing namespace std;\nint N, M;\nint Hx, Hy;\nint Ex, Ey;\nint map[1001][1001];\nint visit[1001][1001][2];\nint dx[] = {1, 0, 0, -1};\nint dy[] = {0, 1, -1, 0};\nvoid bfs(int x, int y) {\nqueue<pair<pair<int, int>, pair<int, int>>> q;\nq.push({{x, y}, {0, 1}});\nwhile (!q.empty()) {\nint cx = q.front().first.first;\nint cy = q.front().first.second;\nint depth = q.front().second.first;\nint key = q.front().second.second;\nq.pop();\nif (cx == Ex && c y == Ey) {\ncout << depth;\nreturn;\n}\nif (visit[cx][cy][key]) continue;\nvisit[cx][cy][key] = 1;\nfor (int i = 0; i < 4; i++) {\nint nx = cx + dx[i];\nint ny = cy + dy[i];\nif (nx <= 0 || nx > N || ny <= 0 || ny > M) continue;\nif (map[nx][ny] == 1 && key == 1)\nq.push({{nx, ny}, {depth + 1, 0}});\nif (map[nx][ny] == 0)\nq.push({{nx, ny}, {depth + 1, key}});\n}\n}\ncout << \"-1\";\nreturn;\n}\nint main() {\nios::sync_with_stdio(false);\ncin.tie(0);\ncout.tie(0);\ncin >> N >> M;\ncin >> Hx >> Hy;\ncin >> Ex >> Ey;\nfor (int i = 1; i <= N; i++) {\nfor (int j = 1; j <= M; j++) {\ncin >> map[i][j];\n}\n}\nbfs(Hx, Hy);\nreturn 0;\n}"
    },
    {
        "problem_tier": 9,
        "solution_code": "#include <iostream>\n#include <string>\n#include <sstream>\n#include <algorithm>\nusing namespace std;\nint main(void) {\nstring input;\ngetline(cin, input);\nint pos = 0;\nfor (int i = 0; i < input.size(); i++) {\nif (input[i] == ' ') {\npos = i;\nbreak;\n}\n}\nstring type = input.substr(0, pos);\nstring vars = input.substr(pos+1, input.size()-pos);\nstringstream ss(vars);\nstring token;\nwhile (getline(ss, token, ',')) {\nif (token.front() == ' ') {\ntoken.erase(token.begin());\n}\nif (token.back() == ';') {\ntoken.pop_back();\n}\nint alpha_pos = 0;\nstring alpha = \"\", var = \"\";\nfor (int i = 0; i < token.size(); i++) {\nif (!isalpha(token[i])) {\nalpha_pos = i;\nbreak;\n}\n}\nalpha = token.substr(0, alpha_pos);\nif (alpha != \"\") {\nfor (int i = token.size()-1; i >= alpha_pos; i--) {\nif (token[i] == '[') {\nvar += \"]\";\n} else if (token[i] == ']') {\nvar += \"[\";\n} else {\nvar += token[i];\n}\n}\ncout << type + var << \" \" << alpha << \";\\n\";\n} else {\ncout << type << \" \" << token << \";\\n\";\n}\n}\nreturn 0;\n}"
    },
    {
        "problem_tier": 11,
        "solution_code": "#include <iostream>\n#include <vector>\nusing namespace std;\nint main() {\nios::sync_with_stdio(false);\ncin.tie(NULL);\ncout.tie(NULL);\nint R, C, Q;\ncin >> R >> C >> Q;\nvector<vector<int>> board(R + 1, vector<int>(C + 1, 0));\nvector<vector<int>> sum(R + 1, vector<int>(C + 1, 0));\nfor (int i = 1; i <= R; i++) {\nfor (int j = 1; j <= C; j++) {\ncin >> board[i][j];\n}\n}\nfor (int i = 1; i <= R; i++) {\nfor (int j = 1; j <= C; j++) {\nsum[i][j] = sum[i][j - 1] + board[i][j];\n}\n}\nfor (int i = 1; i <= C; i++) {\nfor (int j = 1; j <= R; j++) {\nsum[j][i] = sum[j - 1][i] + sum[j][i];\n}\n}\nwhile (Q--) {\nint r1, c1, r2, c2;\ncin >> r1 >> c1 >> r2 >> c2;\nint s = sum[r2][c2] - sum[r1 - 1][c2] - sum[r2][c1 - 1] + sum[r1 - 1][c1 - 1];\nint size = (r2 - r1 + 1) * (c2 - c1 + 1);\ncout << s / size << '\\n';\n}\nreturn 0;\n}"
    },
    {
        "problem_tier": 19,
        "solution_code": "#include <iostream>\n#include <vector>\nusing namespace std;\nvoid solve(int N, int K) {\nvector<int> segmentTree;\nint index = 1;\nauto init = [&](int node, int s, int e) {\nif (s == e) return segmentTree[node] = 1;\nint mid = (s + e) / 2;\nreturn segmentTree[node] = init(2 * node, s, mid) + init(2 * node + 1, mid + 1, e);\n};\nauto update = [&](int node, int s, int e, int del) {\nsegmentTree[node]--;\nif (s == e) return 0;\nelse {\nint mid = (s + e) / 2;\nif (del <= mid) return update(2 * node, s, mid, del);\nelse return update(2 * node + 1, mid + 1, e, del);\n}\n};\nauto query = [&](int node, int s, int e, int order) {\nif (s == e) return;\nint mid = (s + e) / 2;\nif (order <= segmentTree[2 * node]) return query(2 * node, s, mid, order);\nelse return query(2 * node + 1, mid + 1, e, order - segmentTree[2 * node]);\n};\ninit(1, 1, N);\ncout << \"<\";\nfor (int i = 0; i < N; i++) {\nint size = N - i;\nindex += K - 1;\nif (index % size == 0) index = size;\nelse if (index > size) index %= size;\nint num = query(1, 1, N, index);\nupdate(1, 1, N, num);\nif (i == N - 1) cout << num;\nelse cout << num << \", \";\n}\ncout << \">\";\n}\nint main() {\nios_base::sync_with_stdio(0);\ncin.tie(NULL);\nint N, K;\ncin >> N >> K;\nsolve(N, K);\nreturn 0;\n}"
    },
    {
        "problem_tier": 19,
        "solution_code": "#include <iostream>\n#include <vector>\n#include <queue>\n#include <algorithm>\nusing namespace std;\n#define MAX_N 801\n#define INF 987654321\nint N, P;\nint cap[MAX_N][MAX_N], flow[MAX_N][MAX_N];\nvector<int> adj[MAX_N];\nint edmondsKarp() {\nint source = 1, sink = 2;\nint totalFlow = 0;\nwhile (1) {\nqueue<int> q;\nvector<int> parent(MAX_N, -1);\nq.push(source);\nparent[source] = source;\nwhile (!q.empty()) {\nint cur = q.front();\nq.pop();\nif (cur == sink) break;\nfor (int next : adj[cur]) {\nif (cap[cur][next] - flow[cur][next] > 0 && parent[next] == -1) {\nq.push(next);\nparent[next] = cur;\n}\n}\n}\nif (parent[sink] == -1) break;\nint minFlow = INF;\nfor (int i = sink; i != source; i = parent[i]) {\nminFlow = min(minFlow, cap[parent[i]][i] - flow[parent[i]][i]);\n}\nfor (int i = sink; i != source; i = parent[i]) {\nflow[parent[i]][i] += minFlow;\nflow[i][parent[i]] -= minFlow;\n}\ntotalFlow += minFlow;\n}\nreturn totalFlow;\n}\nint main() {\ncin >> N >> P;\nfor (int i = 1; i <= N; i++) {\nadj[i].push_back(i + N);\nadj[i + N].push_back(i);\ncap[i][i + N] = 1;\n}\nfor (int i = 0; i < P; i++) {\nint from, to;\ncin >> from >> to;\nadj[from + N].push_back(to);\nadj[to].push_back(from + N);\ncap[from + N][to] = 1;\nadj[to + N].push_back(from);\nadj[from].push_back(to + N);\ncap[to + N][from] = 1;\n}\nint ans = edmondsKarp();\ncout << ans << endl;\nreturn 0;\n}"
    },
    {
        "problem_tier": 14,
        "solution_code": "#include<iostream>\n#include<cstring>\nusing namespace std;\n#define MAX 101\nint N, M, K;\nchar MAP[MAX][MAX];\nint DP[MAX][MAX][80];\nstring Dest;\nint Dest_Len;\nint dx[] = { 0, 0, 1, -1 };\nint dy[] = { 1, -1, 0, 0 };\nvoid Input(){\ncin >> N >> M >> K;\nfor (int i = 0; i < N; i++) {\nfor (int j = 0; j < M; j++) {\ncin >> MAP[i][j];\n}\n}\ncin >> Dest;\nDest_Len = Dest.length();\nmemset(DP, -1, sizeof(DP));\n}\nint DFS(int x, int y, int Idx){\nif (DP[x][y][Idx] != -1) return DP[x][y][Idx];\nif (Idx >= Dest_Len) return 1;\nDP[x][y][Idx] = 0;\nfor (int i = 0; i < 4; i++) {\nfor (int k = 1; k <= K; k++) {\nint nx = x + dx[i] * k;\nint ny = y + dy[i] * k;\nif (nx < 0 || ny < 0 || nx >= N || ny >= M) continue;\nif (MAP[nx][ny] != Dest[Idx]) continue;\nDP[x][y][Idx] = DP[x][y][Idx] + DFS(nx, ny, Idx + 1);\n}\n}\nreturn DP[x][y][Idx];\n}\nvoid Solution(){\nchar Temp = Dest[0];\nint Answer = 0;\nfor (int i = 0; i < N; i++) {\nfor (int j = 0; j < M; j++) {\nif (MAP[i][j] == Temp) {\nAnswer = Answer + DFS(i, j, 1);\n}\n}\n}\ncout << Answer << endl;\n}\nint main(void){\nios::sync_with_stdio(false);\ncin.tie(NULL);\ncout.tie(NULL);\nSolve();\nreturn 0;\n}"
    },
    {
        "problem_tier": 19,
        "solution_code": "#include<iostream>\n#include<string>\n#include<algorithm>\nusing namespace std;\n#define INF 987654321\ntypedef long long ll;\ntypedef pair<int, int> ii;\ntypedef tuple<int, int, int> iii;\n#define pb push_back\nint seq[501];\nint N, M, K;\nbool compare(int i, int j) {\nreturn j < i;\n}\nint main() {\ncin >> N >> M >> K;\nint lower_bound = M + K - 1;\nint upper_bound = M * K;\nif (lower_bound <= N && N <= upper_bound) {\nfor (int i = 0; i < N; i++) {\nseq[i] = i + 1;\n}\nint final_group_idx = N - K;\nsort(seq + final_group_idx, seq + N, compare);\nint n_elem;\nint remainder;\nif (M == 1) {\nn_elem = 0;\nremainder = 0;\n} else {\nn_elem = (N - K) / (M - 1);\nremainder = (N - K) % (M - 1);\n}\nint start = 0;\nint end = 0;\nfor (int i = 1; i < M; i++) {\nif (n_elem < K && remainder) {\nend += n_elem + 1;\nremainder--;\n} else {\nend += n_elem;\n}\nsort(seq + start, seq + end, compare);\nstart = end;\n}\nfor (int i = 0; i < N; i++) {\ncout << seq[i] << \" \";\n}\ncout << '\\n';\n} else {\ncout << \"-1\\n\";\n}\nreturn 0;\n}"
    },
    {
        "problem_tier": 4,
        "solution_code": "#include <iostream>\n#include <string>\nusing namespace std;\nint main() {\nios::sync_with_stdio(false);\ncin.tie(NULL);\nstring K;\nint L;\ncin >> K >> L;\nfor (int i = 2; i < L; ++i) {\nint ans = 0;\nint tmp = 1;\nfor (int j = K.length() - 1; j >= 0; --j) {\nans = (ans + (K[j] - '0') * tmp) % i;\ntmp *= 10;\ntmp %= i;\n}\nif (ans == 0) {\ncout << \"BAD\" << i;\nreturn 0;\n}"
    },
    {
        "problem_tier": 13,
        "solution_code": "#include <iostream>\nusing namespace std;\nint dp[31];\nint main() {\nios_base::sync_with_stdio(false);\ncin.tie(NULL);\ncout.tie(NULL);\nint n;\ncin >> n;\ndp[0] = 1;\ndp[1] = 1;\nfor (int i = 2; i <= 30; i++) {\ndp[i] = dp[i - 1] + dp[i - 2] * 2;\n}\nif (n % 2 == 1) {\ncout << (dp[n] + dp[(n - 1) / 2]) / 2 << \"\\n\";\n} else {\ncout << (dp[n] + dp[n / 2] + dp[n / 2 - 1] * 2) / 2 << \"\\n\";\n}\nreturn 0;\n}"
    },
    {
        "problem_tier": 5,
        "solution_code": "#include<iostream>\nusing namespace std;\nint main(){\nint t;\ncin >> t;\nwhile(t--){\nint n;\ncin >> n;\nstring stringN = to_string(n);\nstring stringSquare = to_string(n*n);\nif(stringSquare.find(stringN) == stringSquare.size() - stringN.size()){\ncout << \"YES\\n\";\n}\nelse{\ncout << \"NO\\n\";\n}\n}\nreturn 0;\n}"
    },
    {
        "problem_tier": 9,
        "solution_code": "#include <iostream>\n#include <vector>\n#include <algorithm>\n#define MAX 300001\n#define LL long long\nusing namespace std;\nint N, Q;\nvector<int> Vec;\nLL Sum[MAX];\nLL Answer = 0;\nbool Comp(int A, int B) {\nreturn (A < B);\n}\nvoid Input() {\ncin >> N >> Q;\nfor (int i = 0; i < N; i++) {\nint A;\ncin >> A;\nVec.push_back(A);\n}\nsort(Vec.begin(), Vec.end(), Comp);\n}\nvoid Settings() {\nfor (int i = 1; i <= N; i++) {\nSum[i] = Sum[i - 1] + Vec[i - 1];\n}\n}\nvoid Find_Answer() {\nwhile (Q--) {\nint L, R;\ncin >> L >> R;\ncout << Sum[R] - Sum[L - 1] << \"\\n\";\n};\n}\nint main() {\ncin.tie(NULL);\ncout.tie(NULL);\nios::sync_with_stdio(false);\nInput();\nSettings();\nFind_Answer();\nreturn 0;\n}"
    },
    {
        "problem_tier": 4,
        "solution_code": "#include <iostream>\nusing namespace std;\nint main() {\nios_base::sync_with_stdio(false);\ncin.tie(NULL);\nint q;\ncin >> q;\nwhile (q--) {\nint a;\ncin >> a;\nif ((a & (-a)) == a)\ncout << 1 << '\\n';\nelse\ncout << 0 << '\\n';\n}\nreturn 0;\n}"
    },
    {
        "problem_tier": 3,
        "solution_code": "#include<iostream>\nusing namespace std;\nint getSeaLevel(int p){\nint diff = p-100;\nif(diff < 0)\nreturn 1;\nif(diff == 0)\nreturn 0;\nreturn -1;\n}\nint main(){\nint b, p;\ncin>>b;\np = 5*b - 400;\ncout<<p<<\"\\n\"<<getSeaLevel(p);\nreturn 0;\n}"
    },
    {
        "problem_tier": 5,
        "solution_code": "#include <iostream>\n#include <string>\nusing namespace std;\nint n, k;\nint cnt;\nint main() {\nios_base::sync_with_stdio(0);\ncin.tie(0);\ncin >> n >> k;\nbool isk;\nfor (int i = 0; i <= n; i++) {\nfor (int j = 0; j <= 59; j++) {\nfor (int u = 0; u <= 59; u++) {\nisk = 0;\nstring tmph = to_string(i);\nint sizeh = tmph.size();\nfor (int z = 0; z < sizeh; z++) {\nif (tmph[z] - '0' == k) {\nisk = 1;\n}\n}\nstring tmpm = to_string(j);\nint sizem = tmpm.size();\nfor (int z = 0; z < sizem; z++) {\nif (tmpm[z] - '0' == k) {\nisk = 1;\n}\n}\nstring tmps = to_string(u);\nint sizes = tmps.size();\nfor (int z = 0; z < sizes; z++) {\nif (tmps[z] - '0' == k) {\nisk = 1;\n}\n}\nif (isk == 1)\ncnt++;\n}\n}\n}\ncout << cnt;\nreturn 0;\n}"
    },
    {
        "problem_tier": 3,
        "solution_code": "#include<iostream>\n#include<string>\n#include<algorithm>\nusing namespace std;\nint main(){\nios::sync_with_stdio(false);\ncin.tie(NULL);\nstring str;\ncin >> str;\ncout << str.size() + count(str.begin(), str.end(), ':') + count(str.begin(), str.end(), '_') * 5;\nreturn 0;\n}"
    },
    {
        "problem_tier": 10,
        "solution_code": "#include <iostream>\n#include <string>\nusing namespace std;\nint temp[10][7] = {\n{1,1,1,0,1,1,1},      {0,0,1,0,0,1,0},      {1,0,1,1,1,0,1},      {1,0,1,1,0,1,1},      {0,1,1,1,0,1,0},      {1,1,0,1,0,1,1},      {1,1,0,1,1,1,1},      {1,0,1,0,0,1,0},      {1,1,1,1,1,1,1},      {1,1,1,1,0,1,1},  };\nvoid monitor(char c, int idx) {\nint x = c - '0';\nif (idx % 3 == 0) {\ncout << \" \";\nif (temp[x][idx] == 1) {\nfor (int i = 0; i < s; i++)\ncout << \"-\";\n} else {\nfor (int i = 0; i < s; i++)\ncout << \" \";\n}\ncout << \" \";\n} else {\nif (temp[x][idx] == 1) {\ncout << \"|\";\n} else\ncout << \" \";\nif (idx % 3 == 1) {\nfor (int i = 0; i < s; i++)\ncout << \" \";\n} else\ncout << \" \";\n}\n}\nint main() {\nios_base::sync_with_stdio(false);\ncin.tie(NULL);\ncout.tie(NULL);\nint s = 0;\nstring n = \"\";\ncin >> s >> n;\nfor (int j = 0; j < n.size(); j++) {\nmonitor(n[j], 0);\n}\ncout << \"\\n\";\nfor (int a = 0; a < s; a++) {\nfor (int j = 0; j < n.size(); j++) {\nfor (int i = 1; i < 3; i++) {\nmonitor(n[j], i);\n}\n}\ncout << \"\\n\";\n}\nfor (int j = 0; j < n.size(); j++) {\nmonitor(n[j], 3);\n}\ncout << \"\\n\";\nfor (int a = 0; a < s; a++) {\nfor (int j = 0; j < n.size(); j++) {\nfor (int i = 4; i < 6; i++) {\nmonitor(n[j], i);\n}\n}\ncout << \"\\n\";\n}\nfor (int j = 0; j < n.size(); j++) {\nmonitor(n[j], 6);\n}\ncout << \"\\n\";\nreturn 0;\n}"
    },
    {
        "problem_tier": 20,
        "solution_code": "#include <iostream>\n#include <vector>\n#include <algorithm>\nusing namespace std;\ntypedef struct {\nint a, b, c;\n} grade;\ngrade student[500001];\nvector<int> tree(2000001, 100000000);\nvoid update(int idx, int delta) {\ntree[idx] = delta;\nidx /= 2;\nwhile (idx >= 1) {\nif (tree[idx * 2] > tree[idx * 2 + 1])\ntree[idx] = tree[idx * 2 + 1];\nelse\ntree[idx] = tree[idx * 2];\nidx /= 2;\n}\n}\nint getMin(int left, int right) {\nint ret = 100000000;\nwhile (left <= right) {\nif (left % 2)\nret = min(ret, tree[left]);\nif (right % 2 == 0)\nret = min(ret, tree[right]);\nleft = (left + 1) / 2;\nright = (right - 1) / 2;\n}\nreturn ret;\n}\nbool compare(grade g1, grade g2) {\nif (g1.a < g2.a)\nreturn true;\nreturn false;\n}\nint main() {\nint n, input, ans = 0, fi = 1;\nscanf(\"%d\", &n);\nwhile (fi < 500000)\nfi *= 2;\nfor (int i = 1; i <= n; i++) {\nscanf(\"%d\", &input);\nstudent[input].a = i;\n}\nfor (int i = 1; i <= n; i++) {\nscanf(\"%d\", &input);\nstudent[input].b = i;\n}\nfor (int i = 1; i <= n; i++) {\nscanf(\"%d\", &input);\nstudent[input].c = i;\n}\nsort(student + 1, student + 1 + n, compare);\nfor (int i = 1; i <= n; i++) {\nupdate(fi + student[i].b - 1, student[i].c);\nif (student[i].a == 1 || student[i].b == 1 || student[i].c == 1)\nans++;\nelse if (getMin(fi, fi + student[i].b - 2) > student[i].c)\nans++;\n}\nprintf(\"%d\", ans);\nreturn 0;\n}"
    },
    {
        "problem_tier": 6,
        "solution_code": "#include <iostream>\n#include <vector>\n#include <string>\nusing namespace std;\nchar card[202][202];\nint r, c;\nint a, b;\nvoid makeCard() {\nfor (int i = 0; i < r; i++) {\nfor (int j = c; j < 2 * c; j++) {\ncard[i][j] = card[i][(c - 1) - (j - c)];\n}\n}\nfor (int i = r; i < 2 * r; i++) {\nfor (int j = 0; j < 2 * c; j++) {\ncard[i][j] = card[(r - 1) - (i - r)][j];\n}\n}\n}\nvoid changeCard() {\nif (card[a][b] == '.') {\ncard[a][b] = '#';\n} else {\ncard[a][b] = '.';\n}\n}\nint main() {\ncin >> r >> c;\nfor (int i = 0; i < r; i++) {\nstring line;\ncin >> line;\nfor (int j = 0; j < c; j++) {\ncard[i][j] = line[j];\n}\n}\ncin >> a >> b;\na--;\nb--;\nmakeCard();\nchangeCard();\nfor (int i = 0; i < 2 * r; i++) {\nfor (int j = 0; j < 2 * c; j++) {\ncout << card[i][j];\n}\ncout << endl;\n}\nreturn 0;\n}"
    },
    {
        "problem_tier": 4,
        "solution_code": "#include <iostream>\n#include <algorithm>\nusing namespace std;\nint main() {\nint T, N;\ncin >> T;\nfor (int i = 0; i < T; ++i) {\ncin >> N;\nint ans = 0;\nfor (int j = 0; j < N; ++j) {\nint a, b, c;\ncin >> a >> b >> c;\nint profit = max({ a, b, c });\nif (profit <= 0) continue;\nans += profit;\n}\ncout << ans << endl;\n}\nreturn 0;\n}"
    },
    {
        "problem_tier": 4,
        "solution_code": "#include <iostream>\n#include <algorithm>\nusing namespace std;\nint main() {\nint t;\ncin >> t;\nfor(int i = 1; i <= t; i++) {\nint a[3];\ncin >> a[0] >> a[1] >> a[2];\nsort(a, a + 3);\ncout << \"Case #\" << i << \": \";\nif(a[0] + a[1] <= a[2]) {\ncout << \"invalid!\" << endl;\n} else if(a[0] == a[1] && a[1] == a[2]) {\ncout << \"equilateral\" << endl;\n} else if(a[0] == a[1] || a[1] == a[2]) {\ncout << \"isosceles\" << endl;\n} else {\ncout << \"scalene\" << endl;\n}\n}\nreturn 0;\n}"
    },
    {
        "problem_tier": 19,
        "solution_code": "#include <stdio.h>\n#include <iostream>\n#include <cstdio>\n#include <algorithm>\nusing namespace std;\nusing pii = pair<int,int>;\npii tree[400005];\nint loc[100005];\npii init(int node, int s, int e) {\nif(s == e) return tree[node] = {s, s};\nint mid = (s + e) >> 1;\npii left = init(2 * node, s, mid);\npii right = init(2 * node + 1, mid + 1, e);\nreturn tree[node] = {min(left.first, right.first), max(left.second, right.second)};\n}\npii query(int node, int s, int e, int qs, int qe) {\nif(e < qs || qe < s) return {1e9, -1e9};\nif(qs <= s && e <= qe) return tree[node];\nint mid = (s + e) >> 1;\npii left = query(2 * node, s, mid, qs, qe);\npii right = query(2 * node + 1, mid + 1, e, qs, qe);\nreturn {min(left.first, right.first), max(left.second, right.second)};\n}\npii update(int node, int s, int e, int idx, int num) {\nif(idx < s || idx > e) return tree[node];\nif(s == e) return tree[node] = {num, num};\nint mid = (s + e) >> 1;\npii left = update(2 * node, s, mid, idx, num);\npii right = update(2 * node + 1, mid + 1, e, idx, num);\nreturn tree[node] = {min(left.first, right.first), max(left.second, right.second)};\n}\nvoid solve() {\nint n, k;\nscanf(\"%d%d\", &n, &k);\ninit(1, 0, n-1);\nfor(int i = 0; i < n; i++) loc[i] = i;\nwhile(k--) {\nint q, a, b;\nscanf(\"%d%d%d\", &q, &a, &b);\nif(!q) {\nupdate(1, 0, n-1, loc[a], b);\nupdate(1, 0, n-1, loc[b], a);\nswap(loc[a], loc[b]);\n} else {\nauto [m, M] = query(1, 0, n-1, a, b);\nif(a == m && b == M) printf(\"YES\\n\");\nelse printf(\"NO\\n\");\n}\n}\n}\nint main() {\nint t;\nscanf(\"%d\", &t);\nwhile(t--) {\nsolve();\n}\n}"
    },
    {
        "problem_tier": 5,
        "solution_code": "#include <iostream>\n#include <string>\n#include <algorithm>\n#include <cmath>\nusing namespace std;\nstring solve(unsigned n) {\nstring s;\nint cnt = 0;\nwhile (n > 0) {\ns += to_string(n % 9);\nn /= 9;\ncnt++;\n}\nreverse(s.begin(), s.end());\nreturn s;\n}\nint main() {\nint a;\ncin >> a;\nstring result = solve(a);\ncout << result << endl;\nreturn 0;\n}"
    },
    {
        "problem_tier": 3,
        "solution_code": "#include <iostream>\n#include <algorithm>\nusing namespace std;\nint main() {\nint nums[3];\nfor (int i = 0; i < 3; i++) {\ncin >> nums[i];\n}\nsort(nums, nums+3);\ncout << nums[1] << endl;\nreturn 0;\n}"
    },
    {
        "problem_tier": 7,
        "solution_code": "#include<iostream>\n#include<vector>\n#include<algorithm>\n#include<string>\nusing namespace std;\nint N, K, ans;\nvector<int> setK, permutation;\nvoid dfs(int depth, int length) {\nif (depth == length) {\nint madeNum = 0;\nfor (auto p : permutation) {\nmadeNum += p;\nmadeNum *= 10;\n}\nmadeNum /= 10;\nif (N >= madeNum)\nans = max(ans, madeNum);\nreturn;\n}\nfor (int i = 0; i < K; i++) {\npermutation.push_back(setK[i]);\ndfs(depth + 1, length);\npermutation.pop_back();\n}\n}\nint main() {\ncin >> N >> K;\nsetK.resize(K);\nfor (int i = 0; i < K; i++)\ncin >> setK[i];\nfor (int i = 1; i <= to_string(N).size(); i++)\ndfs(0, i);\ncout << ans;\nreturn 0;\n}"
    },
    {
        "problem_tier": 5,
        "solution_code": "#include <iostream>\n#include <string>\nusing namespace std;\nint main() {\nint T;\ncin >> T;\nfor (int j = 0; j < T; j++) {\nint a, b;\nstring str, newstr;\ncin >> a >> b >> str;\nfor (int i = 0; i < str.length(); i++) {\nint converted = (char)(((a * ((int)str.at(i) - 65) + b) % 26) + 65);\nnewstr += converted;\n}\ncout << newstr << endl;\n}\nreturn 0;\n}"
    },
    {
        "problem_tier": 10,
        "solution_code": "#include <iostream>\n#include <queue>\n#include <climits>\n#include <vector>\nusing namespace std;\nint a, b, N, M;\nvector<int> adj[1001];\nvector<int> dist(1001, INT_MAX);\nint djikstra() {\npriority_queue<pair<int, int>, vector<pair<int, int>>, greater<pair<int, int>>> pq;\ndist[a] = 0;\npq.push({a, 0});\nwhile (!pq.empty()) {\nint source = pq.top().first;\nint distance = pq.top().second;\npq.pop();\nif (distance > dist[source]) continue;\nfor (int i = 0; i < adj[source].size(); i++) {\nint destination = adj[source][i];\nint cost = distance + 1;\nif (dist[destination] > cost) {\ndist[destination] = cost;\npq.push({destination, cost});\n}\n}\n}\nif (dist[b] == INT_MAX)\nreturn -1;\nelse\nreturn dist[b];\n}\nint main(void) {\ncin >> a >> b >> N >> M;\nfor (int i = 0; i < M; i++) {\nint n, k;\ncin >> n >> k;\nadj[n].push_back(k);\nadj[k].push_back(n);\n}\ncout << djikstra() << '\\n';\nreturn 0;\n}"
    },
    {
        "problem_tier": 14,
        "solution_code": "#include <iostream>\n#include <vector>\n#include <algorithm>\nusing namespace std;\nint N;\nvector<int> adj[100001];\nint order[100001];\nint given_path[100001];\nbool visited[100001];\nbool compare(int a, int b) {\nreturn order[a] < order[b];\n}\nvoid DFS(int node) {\nvisited[node] = true;\nfor (int i = 0; i < adj[node].size(); i++) {\nint next = adj[node][i];\nif (!visited[next])\nDFS(next);\n}\n}\nint main() {\nios_base::sync_with_stdio(false);\ncin.tie(NULL);\ncout.tie(NULL);\ncin >> N;\nfor (int i = 1; i < N; i++) {\nint a, b;\ncin >> a >> b;\nadj[a].push_back(b);\nadj[b].push_back(a);\n}\nfor (int i = 1; i <= N; i++) {\ncin >> given_path[i];\norder[given_path[i]] = i;\n}\nfor (int i = 1; i <= N; i++) {\nsort(adj[i].begin(), adj[i].end(), compare);\n}\nvector<int> dfs_order;\ndfs_order.push_back(0);\nif (given_path[1] == 1)\nDFS(1);\nfor (int i = 1; i <= N; i++) {\nif (!visited[given_path[i]]) {\ncout << 0;\nreturn 0;\n}"
    },
    {
        "problem_tier": 7,
        "solution_code": "#include <iostream>\n#include <vector>\n#include <algorithm>\nusing namespace std;\nbool isPalindrome(string str) {\nint len = str.length();\nfor (int i = 0; i < len / 2; i++) {\nif (str[i] != str[len - i - 1])\nreturn false;\n}\nreturn true;\n}\nvoid solution() {\nint word;\ncin >> word;\nvector<string> v;\nstring tmp;\nfor (int j = 0; j < word; j++) {\ncin >> tmp;\nv.push_back(tmp);\n}\nfor (int j = 0; j < word; j++) {\nfor (int k = 0; k < word; k++) {\nif (j == k)\ncontinue;\nif (isPalindrome(v[j] + v[k])) {\ncout << v[j] + v[k] << '\\n';\nreturn;\n}\n}\n}\ncout << \"0\\n\";\n}\nint main() {\nios_base::sync_with_stdio(0);\ncin.tie(0);\ncout.tie(0);\nint test;\ncin >> test;\nfor (int i = 0; i < test; i++) {\nsolution();\n}\nreturn 0;\n}"
    },
    {
        "problem_tier": 3,
        "solution_code": "#include <iostream>\n#include <queue>\n#include <math.h>\nusing namespace std;\nint main() {\nios::sync_with_stdio(false);\ncin.tie(NULL);\nint N, point1 = 0, point2 = 0;\ncin >> N;\nchar ch;\nqueue<char> q;\nfor (int n = 0; n < N; ++n) {\ncin >> ch;\nq.push(ch);\n}\nwhile (!q.empty()) {\nch = q.front();\nq.pop();\nif (ch == 'D')\n++point1;\nelse\n++point2;\nif (abs(point1 - point2) == 2)\nbreak;\n}\ncout << point1 << ':' << point2;\nreturn 0;\n}"
    },
    {
        "problem_tier": 7,
        "solution_code": "#include <iostream>\nusing namespace std;\nint dp[11] = {0,};\nint solve(int n) {\nif (n <= 1) return 0;\nif (dp[n] != 0) return dp[n];\nint div = n / 2;\ndp[n] = (div * (n - div)) + solve(div) + solve(n - div);\nreturn dp[n];\n}\nint main() {\nios_base::sync_with_stdio(0);\ncin.tie(0);\ncout.tie(0);\nint n;\ncin >> n;\ncout << solve(n) << '\\n';\nreturn 0;\n}"
    },
    {
        "problem_tier": 5,
        "solution_code": "#include <iostream>\n#include <string>\nusing namespace std;\nint main() {\nint n, total;\nstring num;\ncin >> n;\nfor (int i = 0; i < n; i++) {\ncin >> num;\ntotal = stoi(num, nullptr, 2);\ncout << total << \"\\n\";\n}\nreturn 0;\n}"
    },
    {
        "problem_tier": 6,
        "solution_code": "#include<iostream>\n#include<vector>\nusing namespace std;\nint main() {\nios_base::sync_with_stdio(false);\ncin.tie(0);\nint N, M;\ncin >> N >> M;\nvector<string> v, scale;\nfor (int i = 0; i < N; i++) {\nstring inp;\ncin >> inp;\nv.push_back(inp);\n}\nfor (int i = 0; i < N; i++) {\nstring inp;\ncin >> inp;\nscale.push_back(inp);\n}\nfor (int idx = 0; idx < v.size(); idx++) {\nfor (int i = 0; i < v[idx].length(); i++) {\nfor (int k = i * 2; k < i * 2 + 2; k++) {\nif (v[idx][i] != scale[idx][k]) {\ncout << \"NotEyfa\";\nreturn 0;\n}"
    },
    {
        "problem_tier": 19,
        "solution_code": "#include<iostream>\n#include<algorithm>\n#include<cstring>\n#include<vector>\n#include<stack>\n#define pii pair<int,int>\nconst int MAX = 20005;\nusing namespace std;\nint N, M, sccnum, cnt;\nint order[MAX*2], sn[MAX*2], ans[MAX];\nbool finished[MAX*2];\nvector<int> graph[MAX*2];\nstack<int> st;\nvector<pii> tsorder;\nint makenot(int n){\nif(n%2) return n+1;\nelse return n-1;\n}\nint dfs(int curr){\norder[curr] = ++cnt;\nst.push(curr);\nint ret = order[curr];\nfor(int next : graph[curr]){\nif(order[next] == 0) ret = min(ret, dfs(next));\nelse if(!finished[next]) ret = min(ret, order[next]);\n}\nif(ret == order[curr]){\nwhile(1){\nint t = st.top();\nst.pop();\nsn[t] = sccnum;\nfinished[t] = true;\nif(t == curr) break;\n}\nsccnum++;\n}\nreturn ret;\n}\nint main(){\n#ifndef ONLINE_JUDGE\nfreopen(\"input.txt\", \"r\", stdin);\n#endif\nscanf(\"%d %d\", &N, &M);\nint u, v;\nfor(int i=0; i<M; i++){\nscanf(\"%d %d\", &u, &v);\nu = (u > 0 ? u*2-1 : (-u)*2);\nv = (v > 0 ? v*2-1 : (-v)*2);\ngraph[makenot(u)].push_back(v);\ngraph[makenot(v)].push_back(u);\n}\nfor(int i=1; i<=N*2; i++){\nif(order[i] == 0) dfs(i);\n}\nfor(int i=1; i<=N; i++){\nif(sn[i*2-1] == sn[i*2]){\nprintf(\"0\\n\");\nreturn 0;\n}"
    },
    {
        "problem_tier": 6,
        "solution_code": "#include<iostream>\nusing namespace std;\nint main(){\nint A, B, C;\ncin >> A >> B >> C;\nC %= 2;\nwhile(C--){\nA ^= B;\n}\ncout << A << endl;\n}\n"
    },
    {
        "problem_tier": 12,
        "solution_code": "#include <iostream>\n#include <vector>\nusing namespace std;\nvoid to_binary(int num) {\nvector<int> v;\nwhile (num >= 1) {\nv.push_back(num % 2);\nnum /= 2;\n}\nfor (int i = v.size() - 1; i >= 0; i--) {\nif (v[i] == 0)\ncout << \"4\";\nelse\ncout << \"7\";\n}\n}\nint main() {\nint num;\ncin >> num;\nto_binary(num + 1);\nreturn 0;\n}"
    },
    {
        "problem_tier": 6,
        "solution_code": "#include <iostream>\n#include <vector>\nusing namespace std;\nchar changeChar(char c) {\nswitch(c) {\ncase '.':\nreturn '.';\ncase 'O':\nreturn 'O';\ncase '-':\nreturn '|';\ncase '|':\nreturn '-';\ncase '/':\nreturn '\\\\';\ncase '\\\\':\nreturn '/';\ncase '^':\nreturn '<';\ncase '<':\nreturn 'v';\ncase 'v':\nreturn '>';\ncase '>':\nreturn '^';\n}\n}\nint main() {\nint n, m;\ncin >> n >> m;\nvector<string> grid(n);\nfor(int i=0; i<n; i++){\ncin >> grid[i];\n}\nvector<string> result(m, string(n, ' '));\nfor(int i=0; i<n; i++){\nfor(int j=0; j<m; j++){\nresult[j][n-1-i] = changeChar(grid[i][j]);\n}\n}\nfor(int i=0; i<m; i++){\ncout << result[i] << endl;\n}\nreturn 0;\n}"
    },
    {
        "problem_tier": 2,
        "solution_code": "#include <iostream>\nint main() {\nint a, b;\nstd::cin >> a >> b;\nif (a < b)\nstd::cout << \"-1\\n\";\nelse if (a > b)\nstd::cout << \"1\\n\";\nelse\nstd::cout << \"0\\n\";\nreturn 0;\n}"
    },
    {
        "problem_tier": 7,
        "solution_code": "#include <iostream>\nusing namespace std;\nint month[12] = {31, 28, 31, 30, 31, 30, 31, 31, 30, 31, 30, 31};\nbool isLeapYear(int year){\nif(year % 4 == 0)\nif(year % 100 != 0 || year % 400 == 0)\nreturn true;\nreturn false;\n}\nint dayCount(int y, int m, int d){\nint day = 0;\nfor(int i = 0; i < y; ++i){\nday += 365;\nif(isLeapYear(i))\nday += 1;\n}\nfor(int i = 0; i + 1 < m; ++i){\nif(i == 1)\nday += isLeapYear(y);\nday += month[i];\n}\nday += d;\nreturn day;\n}\nint main(){\nint year_1, month_1, day_1;\nint year_2, month_2, day_2;\nint result, count = 0;\nint day1, day2;\ncin >> year_1 >> month_1 >> day_1;\ncin >> year_2 >> month_2 >> day_2;\nday1 = dayCount(year_1, month_1, day_1);\nday2 = dayCount(year_2, month_2, day_2);\nif(year_2 - year_1 >= 1000 && dayCount(0, month_1, day_1) <= dayCount(0, month_2, day_2)){\ncout << \"gg\";\nreturn 0;\n}"
    },
    {
        "problem_tier": 12,
        "solution_code": "#include <iostream>\nusing namespace std;\nint parent[300001];\nint getParent(int x){\nif(parent[x] == x)\nreturn x;\nreturn parent[x] = getParent(parent[x]);\n}\nvoid unionParent(int a, int b){\na = getParent(a);\nb = getParent(b);\nif(a < b)\nparent[b] = a;\nelse\nparent[a] = b;\n}\nint main(){\nint n;\ncin >> n;\nfor(int i=1; i<=n; i++){\nparent[i] = i;\n}\nfor(int i=0; i<n-2; i++){\nint a, b;\ncin >> a >> b;\nunionParent(a, b);\n}\nfor(int i=2; i<=n; i++){\nif(getParent(1) != getParent(i)){\ncout << 1 << \" \" << i;\nbreak;\n}\n}\nreturn 0;\n}"
    },
    {
        "problem_tier": 12,
        "solution_code": "#include <iostream>\n#include <vector>\n#include <queue>\n#include <climits>\n#define MAX 100001\n#define LL long long\n#define INF 1e12\nusing namespace std;\nint N, M;\nvector<pair<int, LL>> Edge[MAX];\nbool Ward[MAX];\nLL Cost[MAX];\nvoid Input() {\ncin >> N >> M;\nfor (int i = 0; i < N; i++) {\nCost[i] = INF;\nint A;\ncin >> A;\nWard[i] = (A == 1) ? true : false;\n}\nfor (int i = 0; i < M; i++) {\nint A, B, C;\ncin >> A >> B >> C;\nif (Ward[A] || Ward[B]) {\nif ((A != N - 1) && (B != N - 1)) {\ncontinue;\n}\n}\nEdge[A].push_back(make_pair(B, C));\nEdge[B].push_back(make_pair(A, C));\n}\n}\nvoid Dijkstra() {\npriority_queue<pair<LL, int>> PQ;\nPQ.push(make_pair(0, 0));\nCost[0] = 0;\nwhile (!PQ.empty()) {\nLL CurCost = -PQ.top().first;\nint CurX = PQ.top().second;\nPQ.pop();\nif (Cost[CurX] < CurCost) {\ncontinue;\n}\nfor (int i = 0; i < Edge[CurX].size(); i++) {\nLL nextCost = Edge[CurX][i].second;\nint nextX = Edge[CurX][i].first;\nif (Cost[nextX] > CurCost + nextCost) {\nCost[nextX] = CurCost + nextCost;\nPQ.push(make_pair(-Cost[nextX], nextX));\n}\n}\n}\n}\nvoid Find_Answer() {\nif (Cost[N - 1] == INF) {\ncout << -1 << \"\\n\";\n}\nelse {\ncout << Cost[N - 1] << \"\\n\";\n}\n}\nint main() {\nInput();\nDijkstra();\nFind_Answer();\nreturn 0;\n}"
    },
    {
        "problem_tier": 5,
        "solution_code": "#include <iostream>\nusing namespace std;\nint main() {\nint n;\ncin >> n;\nfor(int i = 1; i <= n; i++) {\nbool c = true;\nfor(int j = 1; j <= 10; j++) {\nint a;\ncin >> a;\nif(a != (j - 1) % 5 + 1)\nc = false;\n}\nif(c == true)\ncout << i << '\\n';\n}\nreturn 0;\n}"
    },
    {
        "problem_tier": 17,
        "solution_code": "#include <iostream>\nusing namespace std;\n#define ll long long\n#define pii pair<int,int>\nll memo[2001][2001]; int m;\nvector<int> getLuca(ll val, int mod){\nvector<int> ret;\nwhile(val > 0){\nint remainder = val % mod;\nret.push_back(remainder);\nval /= mod;\n}\nreturn ret;\n}\nll comb(int n, int r){\nif(n < r) return 0;\nif(n/2 < r) r = n - r;\nll& ret = memo[n][r];\nif(ret != -1) return ret;\nif(r == 0) return ret = 1;\nelse if(r == 1) return ret = n;\nreturn ret = (comb(n-1, r-1) + comb(n-1, r)) % m;\n}\nint main(){\nios_base::sync_with_stdio(false);\ncin.tie(nullptr);\ncout.tie(nullptr);\nmemset(memo, -1, sizeof(memo));\nll n, k, res = 1;\ncin >> n >> k >> m;\nvector<int> lucaN, lucaK;\nlucaN = getLuca(n, m);\nlucaK = getLuca(k, m);\nint minIdx = min(lucaN.size(), lucaK.size());\nfor(int i = 0; i < minIdx; ++i){\nint n = lucaN[i];\nint r = lucaK[i];\nres = res * comb(n, r);\nres %= m;\n}\ncout << res << \"\\n\";\nreturn 0;\n}"
    },
    {
        "problem_tier": 17,
        "solution_code": "#include <iostream>\n#include <algorithm>\n#include <vector>\nusing namespace std;\nclass SegmentTree {\npublic:\nSegmentTree() {}\nint update(int node, int start, int end, int index, int num) {\nif (index < start || index > end) {\nreturn mTree[node];\n} else if (start == end) {\nmTree[node] += num;\nreturn mTree[node];\n}\nint mid = (start + end) / 2;\nmTree[node] = update(node * 2, start, mid, index, num) + update(node * 2 + 1, mid + 1, end, index, num);\nreturn mTree[node];\n}\nint query(int node, int start, int end, int num) {\nif (start == end) {\nreturn start;\n}\nint mid = (start + end) / 2;\nif (mTree[node * 2] >= num) {\nreturn query(node * 2, start, mid, num);\n} else {\nreturn query(node * 2 + 1, mid + 1, end, num - mTree[node * 2]);\n}\n}\nprivate:\nint mTree[65536 * 4];\n};\nint main() {\nios::sync_with_stdio(false);\ncin.tie(NULL);\ncout.tie(NULL);\nint N, K;\ncin >> N >> K;\nvector<int> arr(N);\nfor (int i = 0; i < N; i++) {\ncin >> arr[i];\n}\nSegmentTree seg;\nfor (int i = 0; i < K; i++) {\nseg.update(1, 0, 65536, arr[i], 1);\n}\nlong long ans = seg.query(1, 0, 65536, (K + 1) / 2);\nfor (int i = K; i < N; i++) {\nseg.update(1, 0, 65536, arr[i], 1);\nseg.update(1, 0, 65536, arr[i - K], -1);\nint mid = seg.query(1, 0, 65536, (K + 1) / 2);\nans += mid;\n}\ncout << ans << \"\\n\";\nreturn 0;\n}"
    },
    {
        "problem_tier": 12,
        "solution_code": "#include <iostream>\n#include <algorithm>\n#include <vector>\nusing namespace std;\nint main(){\nint d, n;\ncin >> d >> n;\nvector<int> oven(d+1);\nvector<int> dough(n+1);\noven[0] = 1e9+1;\nfor(int i=1; i<=d; i++){\ncin >> oven[i];\noven[i] = min(oven[i], oven[i-1]);     }\nfor(int i=1; i<=n; i++){\ncin >> dough[i];\n}\nint pos = d+1;     int prev;\nfor(int i=1; i<=n; i++){\nprev = dough[i-1];\nif(!pos)             break;\nif(dough[i] <= prev){             pos--;\ncontinue;\n}\nint low = 0;\nint high = pos-1;\nwhile(low <= high){\nint mid = (low + high) / 2;\nif(dough[i] <= oven[mid]){\npos = mid;\nlow = mid + 1;\n} else {\nhigh = mid - 1;\n}\n}\n}\ncout << pos << '\\n';\nreturn 0;\n}"
    },
    {
        "problem_tier": 9,
        "solution_code": "#include<bits/stdc++.h>\nusing namespace std;\nint arr[1000001];\nint main() {\nint N, K, ans = 0;\ncin >> N >> K;\nfor (int i = 0; i < N; i++) {\nint g, x;\ncin >> g >> x;\narr[x] = g;\n}\nK = 2 * K + 1;\nint sum = 0;\nfor (int i = 0; i <= 1000001; i++) {\nif (i >= K) {\nsum -= arr[i - K];\n}\nsum += arr[i];\nans = max(ans, sum);\n}\ncout << ans;\nreturn 0;\n}"
    },
    {
        "problem_tier": 12,
        "solution_code": "#include <iostream>\n#include <vector>\n#include <algorithm>\nusing namespace std;\nint main() {\nint T;\ncin >> T;\nwhile (T--) {\nint N;\ncin >> N;\nvector<int> coins(N);\nfor (int i = 0; i < N; i++) {\ncin >> coins[i];\n}\nint M;\ncin >> M;\nvector<int> dp(M + 1);\ndp[0] = 1;\nfor (int i = 0; i < N; i++) {\nfor (int j = coins[i]; j <= M; j++) {\ndp[j] += dp[j - coins[i]];\n}\n}\ncout << dp[M] << endl;\n}\nreturn 0;\n}"
    },
    {
        "problem_tier": 18,
        "solution_code": "#include <iostream>\n#include <vector>\n#include <stack>\nusing namespace std;\nint N, Q;\nvector<int> parent;\nstack<pair<int, pair<int, int>>> st;\nstack<string> ans;\nint find(int x) {\nif (parent[x] == x)\nreturn x;\nreturn parent[x] = find(parent[x]);\n}\nvoid merge(int x, int y) {\nx = find(x);\ny = find(y);\nif (x != y)\nparent[y] = x;\n}\nvoid solve() {\nparent[1] = 1;\nwhile (!st.empty()) {\nint op = st.top().first;\nif (op == 0) {\nint b = st.top().second.first;\nmerge(b, parent[b]);\n}\nelse {\nint c = st.top().second.first;\nint d = st.top().second.second;\nif (find(c) == find(d))\nans.push(\"YES\");\nelse\nans.push(\"NO\");\n}\nst.pop();\n}\nwhile (!ans.empty()) {\ncout << ans.top() << endl;\nans.pop();\n}\n}\nint main() {\ncin.tie(0);\ncout.tie(0);\ncin >> N >> Q;\nparent.resize(N + 1);\nfor (int i = 2; i <= N; i++) {\nint parent_node;\ncin >> parent_node;\nparent[i] = parent_node;\n}\nfor (int i = 1; i <= N - 1 + Q; i++) {\nint x, b, c, d;\ncin >> x;\nif (x == 0) {\ncin >> b;\nst.push({ 0, {b, parent[b]} });\n}\nelse {\ncin >> c >> d;\nst.push({ x, {c, d} });\n}\n}\nsolve();\nreturn 0;\n}"
    },
    {
        "problem_tier": 9,
        "solution_code": "#include<bits/stdc++.h>\nusing namespace std;\nint main() {\nint N;\nlong long t[10000];\nlong long min = 0;\ncin >> N;\nfor(int i = 0; i < N; i++){\ncin >> t[i];\n}\nsort(t, t + N);\nif(N % 2 == 1){\nmin = t[N - 1];         N--;\nfor(int i = 0; i < N / 2; i++){\nlong long M = t[i] + t[(N - 1) - i];\nif(M > min){                 min = M;             }\n}\n}\nelse{\nfor(int i = 0; i < N / 2; i++){\nlong long M = t[i] + t[(N - 1) - i];\nif(M > min){                 min = M;             }\n}\n}\ncout << min;\nreturn 0;\n}"
    },
    {
        "problem_tier": 13,
        "solution_code": "#include <iostream>\n#include <algorithm>\n#include <vector>\n#include <cstring>\nusing namespace std;\nint cache[101];\nvector<pair<int, int>> arr;\nint N;\nint dp(int src) {\nint& ret = cache[src];\nif (ret != -1) {\nreturn ret;\n}\nint k = 0;\nfor (int i = 0; i <= N; ++i) {\nif (i == src) continue;\nif ((arr[src].first >= arr[i].first && arr[src].second >= arr[i].second) ||\n(arr[src].second >= arr[i].first && arr[src].first >= arr[i].second)) {\nk = max(k, dp(i));\n}\n}\nif (k == 0) return ret = 1;\nelse return ret = k + 1;\n}\nint main(void) {\nmemset(cache, -1, sizeof(cache));\ncin >> N;\narr.push_back({1000, 1000});\nfor (int i = 0; i < N; ++i) {\nint a, b;\ncin >> a >> b;\narr.push_back({a, b});\n}\ndp(0);\ncout << cache[0] - 1 << endl;\nreturn 0;\n}"
    },
    {
        "problem_tier": 5,
        "solution_code": "#include <iostream>\nusing namespace std;\nint main() {\nint pre, cur;\nbool isDecsend = true;\ncin >> pre;\nwhile (cin >> cur) {\nif (isDecsend && pre > cur)\nisDecsend = false;\npre = cur;\n}\nif (isDecsend)\ncout << \"Good\" << endl;\nelse\ncout << \"Bad\" << endl;\nreturn 0;\n}"
    },
    {
        "problem_tier": 17,
        "solution_code": "#include <iostream>\n#include <vector>\n#define MAXN 100001\nusing namespace std;\nint n;\nint arr[MAXN];\nint tmp[MAXN];\nlong long mergeSort(int start, int end) {\nif (start >= end) return 0;\nint mid = (start + end) / 2;\nlong long inv_count = 0;\ninv_count += mergeSort(start, mid);\ninv_count += mergeSort(mid+1, end);\nint left = start, right = mid+1, idx = start;\nwhile (left <= mid || right <= end) {\nif (right > end || (left <= mid && arr[left] < arr[right])) {\ntmp[idx++] = arr[left++];\n} else {\ninv_count += (mid - left + 1);\ntmp[idx++] = arr[right++];\n}\n}\nfor (int i = start; i <= end; i++) {\narr[i] = tmp[i];\n}\nreturn inv_count;\n}\nint main() {\ncin >> n;\nfor (int i = 0; i < n; i++) {\ncin >> arr[i];\n}\nlong long inv_count = mergeSort(0, n-1);\ncout << inv_count;\nreturn 0;\n}"
    },
    {
        "problem_tier": 3,
        "solution_code": "#include <iostream>\nusing namespace std;\nint main() {\nint n;\nwhile (1) {\ncin >> n;\nif (n == 0) break;\nfor (int i = 1; i <= n; i++) {\nfor (int j = 1; j <= i; j++) {\ncout << \"*\";\n}\ncout << endl;\n}\n}\nreturn 0;\n}"
    },
    {
        "problem_tier": 10,
        "solution_code": "#include<iostream>\n#include<bitset>\n#include<sstream>\n#include<vector>\n#include<set>\nusing namespace std;\nbitset<20> bits[100010];\nvoid solution(int command, int train, int chair) {\nswitch(command) {\ncase 1:\nbits[train].set(chair, true);\nbreak;\ncase 2:\nbits[train].set(chair, false);\nbreak;\ncase 3:\n{\nunsigned long val = bits[train].to_ulong();\nval = val << 1;\nbitset<20> tmp(val);\nbits[train] = tmp;\n}\nbreak;\ncase 4:\n{\nunsigned long val = bits[train].to_ulong();\nval = val >> 1;\nbitset<20> tmp(val);\nbits[train] = tmp;\n}\nbreak;\n}\n}\nint main() {\ncin.tie(0);\ncout.tie(0);\nios::sync_with_stdio(false);\nint N, M;\ncin >> N >> M;\nwhile(M-- >= 0) {\nstring line;\nstring input[3];\ngetline(cin, line);\nistringstream ss(line);\nss >> input[0] >> input[1] >> input[2];\nint command = atoi(input[0].c_str());\nint train = atoi(input[1].c_str());\nint chair = atoi(input[2].c_str());\nsolution(command, train-1, chair-1);\n}\nint ans = 1;\nvector<string> visited = { bits[0].to_string() };\nfor(int i=1; i<N; i++) {\nstring val = bits[i].to_string();\nbool overlap = false;\nfor(string str : visited) {\nif(str.compare(val) == 0) {\noverlap = true;\nbreak;\n}\n}\nif(!overlap) {\nans++;\nvisited.push_back(bits[i].to_string());\n}\n}\ncout << ans;\nreturn 0;\n}"
    },
    {
        "problem_tier": 6,
        "solution_code": "#include <iostream>\n#include <vector>\n#include <algorithm>\nusing namespace std;\nint main() {\nint n, l, k, s = 0;\nvector<pair<int, int>> v;\ncin >> n >> l >> k;\nfor (int i = 0; i < n; i++) {\nint a, b;\ncin >> a >> b;\nv.push_back(make_pair(a, b));\n}\nsort(v.begin(), v.end(), [](const pair<int, int>& a, const pair<int, int>& b) {\nif (a.second == b.second)\nreturn a.first > b.first;\nreturn a.second > b.second;\n});\nfor (int i = 0; i < n; i++) {\nif (k == 0)\nbreak;\nif (l >= v[i].second) {\ns += 140;\nk--;\n}\n}\nfor (int i = 0; i < n; i++) {\nif (k == 0)\nbreak;\nif (l >= v[i].first && l < v[i].second) {\ns += 100;\nk--;\n}\n}\ncout << s << endl;\nreturn 0;\n}"
    },
    {
        "problem_tier": 16,
        "solution_code": "#include<bits/stdc++.h>\n#define fastio ios_base::sync_with_stdio(0),cin.tie(0),cout.tie(0)\nusing namespace std;\nint seg_odd[400000];\nint seg_even[400000];\nint update_even(int node_index, int node_left, int node_right, int index, int value) {\nif (index < node_left || node_right < index) return seg_even[node_index];\nif (node_left == node_right) {\nif (value % 2 == 0) return seg_even[node_index] = 1;\nelse return seg_even[node_index] = 0;\n} else {\nint mid = (node_left + node_right) / 2;\nreturn seg_even[node_index] = update_even(node_index * 2, node_left, mid, index, value) + update_even(node_index * 2 + 1, mid + 1, node_right, index, value);\n}\n}\nint update_odd(int node_index, int node_left, int node_right, int index, int value) {\nif (index < node_left || node_right < index) return seg_odd[node_index];\nif (node_left == node_right) {\nif (value % 2 == 1) return seg_odd[node_index] = 1;\nelse return seg_odd[node_index] = 0;\n} else {\nint mid = (node_left + node_right) / 2;\nreturn seg_odd[node_index] = update_odd(node_index * 2, node_left, mid, index, value) + update_odd(node_index * 2 + 1, mid + 1, node_right, index, value);\n}\n}\nint query(int node_index, int node_left, int node_right, int query_left, int query_right, int check) {\nif (query_right < node_left || node_right < query_left) return 0;\nif (query_left <= node_left && node_right <= query_right) {\nif (check == 0) return seg_even[node_index];\nelse return seg_odd[node_index];\n}\nint mid = (node_left + node_right) / 2;\nreturn query(node_index * 2, node_left, mid, query_left, query_right, check) + query(node_index * 2 + 1, mid + 1, node_right, query_left, query_right, check);\n}\nint main(void) {\nfastio;\nmemset(seg_odd, 0, sizeof(seg_odd));\nmemset(seg_even, 0, sizeof(seg_even));\nint N, M;\ncin >> N;\nfor (int i = 1; i <= N; i++) {\nint val;\ncin >> val;\nupdate_odd(1, 1, N, i, val);\nupdate_even(1, 1, N, i, val);\n}\ncin >> M;\nfor (int i = 0; i < M; i++) {\nint a, b, c;\ncin >> a >> b >> c;\nif (a == 1) {\nupdate_odd(1, 1, N, b, c);\nupdate_even(1, 1, N, b, c);\n} else if (a == 2) {\ncout << query(1, 1, N, b, c, 0) << \"\\n\";\n} else {\ncout << query(1, 1, N, b, c, 1) << \"\\n\";\n}\n}\nreturn 0;\n}"
    },
    {
        "problem_tier": 16,
        "solution_code": "#include <iostream>\n#include <vector>\n#include <map>\n#include <algorithm>\nusing namespace std;\nint row, col, result = 10000;\nmap<string, int> m;\nstruct info {\nint x, y;\n};\ninfo tmp;\nvector<info> red;\nvector<info> blue;\nchar arr[10][10];\nint dx[4] = {0, 1, 0, -1};\nint dy[4] = {-1, 0, 1, 0};\nbool check(int ry, int rx, int by, int bx, int cnt) {\nstring str = \"\";\nstr += (ry + '0');\nstr += (rx + '0');\nstr += (by + '0');\nstr += (bx + '0');\nif (m.find(str) == m.end()) {\nm[str] = cnt;\nreturn true;\n} else if (m[str] > cnt) {\nm[str] = cnt;\nreturn true;\n}\nreturn false;\n}\nvoid start(int cnt) {\nif (cnt >= result) return;\nint crx, cry, cbx, cby, nrx, nry, nbx, nby;\ncrx = red[0].x;\ncry = red[0].y;\ncbx = blue[0].x;\ncby = blue[0].y;\nfor (int i = 0; i < 4; i++) {\nnrx = crx + dx[i];\nnry = cry + dy[i];\nnbx = cbx + dx[i];\nnby = cby + dy[i];\nbool r_finish = false, b_finish = false;\nif (arr[nry][nrx] != '#') {\nif (arr[nry][nrx] == 'O') r_finish = true;\nelse {\nwhile (1) {\nnrx += dx[i];\nnry += dy[i];\nif (arr[nry][nrx] == 'O') {\nr_finish = true;\nbreak;\n}\nelse if (arr[nry][nrx] == '#') {\nnrx -= dx[i];\nnry -= dy[i];\nbreak;\n}\n}\n}\n} else {\nnrx -= dx[i];\nnry -= dy[i];\n}\nif (arr[nby][nbx] != '#') {\nif (arr[nby][nbx] == 'O') b_finish = true;\nelse {\nwhile (1) {\nnbx += dx[i];\nnby += dy[i];\nif (arr[nby][nbx] == 'O') {\nb_finish = true;\nbreak;\n}\nelse if (arr[nby][nbx] == '#') {\nnbx -= dx[i];\nnby -= dy[i];\nbreak;\n}\n}\n}\n} else {\nnbx -= dx[i];\nnby -= dy[i];\n}\nif (b_finish) continue;\nif (r_finish) {\nresult = min(result, cnt + 1);\nreturn;\n}\nif (nrx == nbx && nry == nby) {\nif (i == 0) {\nif (cry > cby) nry += 1;\nelse nby += 1;\n}\nelse if (i == 1) {\nif (crx > cbx) nbx -= 1;\nelse nrx -= 1;\n}\nelse if (i == 2) {\nif (cry > cby) nby -= 1;\nelse n"
    },
    {
        "problem_tier": 7,
        "solution_code": "#include <iostream>\n#include <vector>\n#include <algorithm>\nusing namespace std;\ntypedef long long ll;\nint main(void) {\nios_base::sync_with_stdio(false);\ncin.tie(0);\nint n;\ncin >> n;\nvector<string> v(n);\nvector<ll> answer;\nfor (int i = 0; i < n; i++) {\ncin >> v[i];\nreverse(v[i].begin(), v[i].end());\nanswer.push_back(stoll(v[i]));\n}\nsort(answer.begin(), answer.end());\nfor (int i = 0; i < n; i++) {\ncout << answer[i] << \"\\n\";\n}\nreturn 0;\n}"
    },
    {
        "problem_tier": 6,
        "solution_code": "#include <iostream>\n#include <vector>\n#include <string>\n#include <climits>\nusing namespace std;\nint getDifference(vector<string> a, vector<string> b) {\nint cnt = 0;\nfor (int i = 0; i < a.size(); i++) {\nfor (int j = 0; j < a[i].size(); j++) {\nif (a[i][j] != b[i][j]) {\ncnt++;\n}\n}\n}\nreturn cnt;\n}\nint main() {\nint n;\ncin >> n;\nvector<vector<string>> picture;\nint minPic[2];\nint minPivot = INT_MAX;\nfor (int pic = 0; pic < n; pic++) {\nvector<string> s;\nfor (int i = 0; i < 5; i++) {\nstring tmp;\ncin >> tmp;\ns.push_back(tmp);\n}\npicture.push_back(s);\n}\nfor (int i = 0; i < n; i++) {\nvector<string> onePic = picture[i];\nfor (int j = i + 1; j < n; j++) {\nvector<string> secondPic = picture[j];\nint difference = getDifference(onePic, secondPic);\nif (difference < minPivot) {\nminPivot = difference;\nminPic[0] = i + 1;\nminPic[1] = j + 1;\n}\n}\n}\ncout << minPic[0] << \" \" << minPic[1] << endl;\nreturn 0;\n}"
    },
    {
        "problem_tier": 5,
        "solution_code": "#include<iostream>\n#include<iomanip>\nusing namespace std;\ndouble factorial(int n){\ndouble f = 1;\nfor (int i = 2; i <= n; i++)\nf *= i;\nreturn f;\n}\nint main(){\ncout << \"n e\" << '\\n';\ncout << \"- -----------\" << '\\n';\nfor (int n = 0; n <= 2; n++){\ndouble sum = 0;\nfor (int i = 0; i <= n; i++){\nint denominator = 1;\nfor (int j = i; j > 0; j--){\ndenominator *= j;\n}\nsum += (1 / (double)denominator);\n}\ncout << n << \" \" << sum << '\\n';\n}\nfor (int n = 3; n <= 9; n++){\ndouble sum = 0;\nfor (int i = 0; i <= n; i++){\nint denominator = 1;\nfor (int j = i; j > 0; j--){\ndenominator *= j;\n}\nsum += (1 / (double)denominator);\n}\ncout << n << \" \" << fixed << setprecision(9) << sum << '\\n';\n}\nreturn 0;\n}"
    },
    {
        "problem_tier": 2,
        "solution_code": "#include <iostream>\nusing namespace std;\nint main() {\nios::sync_with_stdio(false);\ncin.tie(nullptr);\nbool isFail = false;\nfor (int i = 0; i < 8; i++) {\nint bit;\ncin >> bit;\nif (bit == 9)\nisFail = true;\n}\nif (isFail)\ncout << \"F\\n\";\nelse\ncout << \"S\\n\";\nreturn 0;\n}"
    },
    {
        "problem_tier": 5,
        "solution_code": "#include <iostream>\n#include <string>\n#include <sstream>     #include <vector>\n#include <algorithm>\nusing namespace std;\nint main() {\nint test;\ncin >> test;\ncin.ignore();\nfor(int i=0; i<test; i++){\nstring str;\ngetline(cin, str);\nvector<string> vec;\nstringstream ss(str);\nstring word;\nwhile(ss >> word){\nvec.push_back(word);\n}\nfor(int i=2; i<vec.size(); i++){\ncout << vec[i] << \" \";\n}\ncout << vec[0] << \" \" << vec[1] << \"\\n\";\n}\nreturn 0;\n}"
    },
    {
        "problem_tier": 9,
        "solution_code": "#include <iostream>\n#include <vector>\n#include <algorithm>\nusing namespace std;\nbool compare(int i, int j) {\nreturn i > j;\n}\nint main() {\nint N, A, B, C;     cin >> N >> A >> B >> C;\nvector<int> d;\nfor (int i = 0; i < N; i++) {\nint t;\ncin >> t;\nd.push_back(t);\n}\nsort(d.begin(), d.end(), compare);\nint doughCal = C / A;     int bestCal = doughCal;     int totalPrice = A;     int totalCal = C;\nfor (int i = 0; i < N; i++) {\ntotalPrice += B;\ntotalCal += d[i];\nif (bestCal < totalCal / totalPrice) {\nbestCal = totalCal / totalPrice;\n}\n}\ncout << bestCal;\nreturn 0;\n}"
    },
    {
        "problem_tier": 13,
        "solution_code": "#include <iostream>\n#include <map>\nusing namespace std;\nint main() {\nint n, k;\ncin >> n >> k;\nmap<long long, long long> ma;\nlong long va[200005];\nlong long cnt = 0;\nfor(int i = 1; i <= n; i++) {\ncin >> va[i];\nva[i] += va[i-1];\nif(va[i] == k) cnt++;\n}\nfor(int i = 1; i <= n; i++) {\ncnt += ma[va[i] - k];\nma[va[i]]++;\n}\ncout << cnt;\nreturn 0;\n}"
    },
    {
        "problem_tier": 3,
        "solution_code": "#include <iostream>\nusing namespace std;\nint main() {\nwhile (1) {\ndouble x;\ncin >> x;\nif (x < 0) {\nbreak;\n}\nprintf(\"Objects weighing %.2f on Earth will weigh %.2f on the moon.\\n\", x, x * 0.167);\n}\nreturn 0;\n}"
    },
    {
        "problem_tier": 5,
        "solution_code": "#include <iostream>\n#include <cmath>\nusing namespace std;\nint main() {\nint T;\ncin >> T;\nwhile (T--) {\nint k;\ncin >> k;\nint res = pow(2, k) - 1;\ncout << res << endl;\n}\nreturn 0;\n}"
    },
    {
        "problem_tier": 19,
        "solution_code": "#include <iostream>\n#include <algorithm>\nusing namespace std;\nint N, K;\nint bulb[201];\nint dp[201][201];\nint query(int start, int end){\nif(start == end) return 0;\nif(dp[start][end]) return dp[start][end];\nif(start-1 == end) return bulb[start] != bulb[end];\nint ret = 987654321;\nfor(int i=start; i<end; i++){\nret = min(ret, query(start,i) + query(i+1,end) + (bulb[i] != bulb[end]));\n}\nreturn dp[start][end] = ret;\n}\nint main(){\ncin.tie(NULL);\nios_base::sync_with_stdio(false);\ncin >> N >> K;\nfor(int i=1; i<=N; i++){\ncin >> bulb[i];\n}\ncout << query(1,N) << \"\\n\";\nreturn 0;\n}"
    },
    {
        "problem_tier": 9,
        "solution_code": "#include <iostream>\nusing namespace std;\ntypedef long long ll;\nint main() {\nint n, k;\nwhile (1) {\ncin >> n >> k;\nif (n == 0) break;\nif (k > n - k) k = n - k;\nll res = 1;\nfor (int i = 1; i <= k; i++)\nres = res * (n - i + 1) / i;\ncout << res << '\\n';\n}\nreturn 0;\n}"
    },
    {
        "problem_tier": 11,
        "solution_code": "#include <iostream>\n#include <algorithm>\n#include <string>\nusing namespace std;\nint dp[1001];\nint main() {\nint N;\nstring street;\ncin >> N;\ncin >> street;\nfor(int i = 0; i < N; i++) {\ndp[i] = 1e9;\n}\ndp[0] = 0;\nfor(int i = 0; i < N; i++) {\nif(street[i] == 'B') {\nfor(int j = i+1; j < N; j++) {\nif(street[j] == 'O') {\ndp[j] = min(dp[j], dp[i] + (j - i) * (j - i));\n}\n}\n}\nelse if(street[i] == 'O') {\nfor(int j = i+1; j < N; j++) {\nif(street[j] == 'J') {\ndp[j] = min(dp[j], dp[i] + (j - i) * (j - i));\n}\n}\n}\nelse if(street[i] == 'J') {\nfor(int j = i+1; j < N; j++) {\nif(street[j] == 'B') {\ndp[j] = min(dp[j], dp[i] + (j - i) * (j - i));\n}\n}\n}\n}\nif(dp[N-1] == 1e9) {\ncout << -1;\n}\nelse {\ncout << dp[N-1];\n}\nreturn 0;\n}"
    },
    {
        "problem_tier": 4,
        "solution_code": "#include <iostream>\nusing namespace std;\nint main() {\nint n, m;\ncin >> n >> m;\nint cnt = 1;\nfor (int i = 0; i < n; i++) {\nfor (int j = 0; j < m; j++) {\ncout << cnt;\ncnt++;\nif (j != m - 1) {\ncout << \" \";\n}\n}\ncout << \"\\n\";\n}\nreturn 0;\n}"
    },
    {
        "problem_tier": 13,
        "solution_code": "#include <iostream>\n#include <cstring>\nusing namespace std;\nint dp[10001];\nint main() {\nwhile (1) {\nint n;\ndouble m;\ncin >> n >> m;\nif (n == 0 && m == 0.00) break;\nint m_100 = (int)(m * 100 + 0.5);\nmemset(dp, 0, sizeof(dp));\nfor (int i = 0; i < n; i++) {\nint c;\ndouble p;\ncin >> c >> p;\nint p_100 = (int)(p * 100 + 0.5);\nfor (int j = p_100; j <= m_100; j++) {\ndp[j] = max(dp[j], dp[j - p_100] + c);\n}\n}\ncout << dp[m_100] << endl;\n}\nreturn 0;\n}"
    },
    {
        "problem_tier": 9,
        "solution_code": "#include<iostream>\n#include<algorithm>\n#include<string>\nusing namespace std;\nint main() {\ncin.tie(NULL);\ncout.tie(NULL);\nios_base::sync_with_stdio(false);\nint N;\ncin >> N;\nstring s;\ncin >> s;\nchar before = 'B';\nbool flag = true;\nint job = 1;\nfor (int i = 0; i < N; i++) {\nif (s[i] == before) {\nif (flag) job++;\nflag = false;\n}\nelse {\nflag = true;\n}\n}\nbefore = 'R';\nflag = true;\nint job2 = 1;\nfor (int i = 0; i < N; i++) {\nif (s[i] == before) {\nif (flag) job2++;\nflag = false;\n}\nelse {\nflag = true;\n}\n}\ncout << min(job, job2);\nreturn 0;\n}"
    },
    {
        "problem_tier": 5,
        "solution_code": "#include<iostream>\nusing namespace std;\nint main() {\nint n;\ncin >> n;\nstring name;\ncin >> name;\nint sum = 0;\nfor(int i=0; i<n; i++) {\nchar c = name[i];\nsum += c - 'A' + 1;\n}\ncout << sum << endl;\nreturn 0;\n}"
    },
    {
        "problem_tier": 9,
        "solution_code": "#include <iostream>\n#include <vector>\n#include <algorithm>\n#define MAX 1000000000\nusing namespace std;\nstruct point{\nint pos;\nint color;\n};\nvector<point> v(MAX);\nvoid solve(int N){\nint diff;\nlong long sum = 0;\nfor(int i=0;i<N;i++){\nvector<int> distance;\nfor(int j=0;j<N;j++){\nif(j==i)\ncontinue;\nif(v[i].color != v[j].color)\ncontinue;\ndiff = abs(v[i].pos - v[j].pos);\ndistance.push_back(diff);\n}\nif(distance.empty())\ncontinue;\nelse{\nsort(distance.begin(), distance.end());\nsum += distance[0];\n}\n}\ncout << sum << \"\\n\";\n}\nint main(){\nios_base::sync_with_stdio(false);\ncin.tie(NULL);\ncout.tie(NULL);\nint N;\ncin >> N;\nfor(int i=0;i<N;i++)\ncin >> v[i].pos >> v[i].color;\nsolve(N);\nreturn 0;\n}"
    },
    {
        "problem_tier": 15,
        "solution_code": "#include <iostream>\n#include <vector>\n#include <queue>\n#include <map>\n#include <algorithm>\n#include <cstring>\n#define fastio ios_base::sync_with_stdio(false); cin.tie(0); cout.tie(0);\n#define INF 1e9+7\n#define pii pair<int,int>\ntypedef long long ll;\nusing namespace std;\nstruct State {\npii st;\nint cnt;\n};\nint A, B, C, D;\nmap<pii,int> visited;\nvoid input() {\ncin >> A >> B >> C >> D;\n}\nvoid bfs() {\nint answer = INF;\npii start = {0,0};\nqueue<State> que;\nque.push({start,0});\nvisited[start] = 1;\nwhile(!que.empty()) {\npii now = que.front().st;\nint now_cnt = que.front().cnt;\nque.pop();\npii next;\nif(now.first == C && now.second == D) {\nanswer = min(answer, now_cnt);\n}\nnext = {A, now.second};\nif(!visited[next]) {\nvisited[next] = 1;\nque.push({next, now_cnt + 1});\n}\nnext = {now.first, B};\nif(!visited[next]) {\nvisited[next] = 1;\nque.push({next, now_cnt + 1});\n}\nnext = {0, now.second};\nif(!visited[next]) {\nvisited[next] = 1;\nque.push({next, now_cnt + 1});\n}\nnext = {now.first, 0};\nif(!visited[next]) {\nvisited[next] = 1;\nque.push({next, now_cnt + 1});\n}\nint b_left = B - now.second;\nif(now.first >= b_left)\nnext = {now.first - b_left, B};\nelse\nnext = {0, now.first + now.second};\nif(!visited[next]) {\nvisited[next] = 1;\nque.push({next, now_cnt + 1});\n}\nint a_left = A - now.first;\nif(now.second >= a_left)\nnext = {A, now.second - a_left};\nelse\nnext = {now.first + now.second, 0};\nif(!visited[next]) {\nvisited[next] = 1;\nque.push({next, now_cnt + 1});\n}\n}\nif(answer == INF)\ncout << -1;\nelse\ncout << answer;\n}\nvoid solve() {\nbfs();\n}\nint main() {\ninput();\nsolve();\nreturn 0;\n}"
    },
    {
        "problem_tier": 4,
        "solution_code": "#include <iostream>\nusing namespace std;\nint main() {\nint sample, system;\nint answer;\nint sample_flag = 0, system_flag = 0;\ncin >> sample >> system;\nwhile (sample--) {\nint s, man;\ncin >> s >> man;\nif (s != man)\nsample_flag = 1;\n}\nwhile (system--) {\nint s, man;\ncin >> s >> man;\nif (s != man)\nsystem_flag = 1;\n}\nif (sample_flag == 0 && system_flag)\ncout << \"Why Wrong!!!\" << \"\\n\";\nelse if (sample_flag == 0 && system_flag == 0)\ncout << \"Accepted\" << \"\\n\";\nelse\ncout << \"Wrong Answer\" << \"\\n\";\nreturn 0;\n}"
    },
    {
        "problem_tier": 3,
        "solution_code": "#include <iostream>\n#include <cmath>\nint main() {\nint square;\nstd::cin >> square;\ndouble side = std::sqrt(square);\ndouble perimeter = side * 4;\nstd::cout << std::fixed;\nstd::cout.precision(8);\nstd::cout << perimeter;\nreturn 0;\n}"
    },
    {
        "problem_tier": 15,
        "solution_code": "#include<bits/stdc++.h>\nusing namespace std;\nint p;\nint m, n;\nint main() {\nios_base::sync_with_stdio(0);\ncin.tie(0);\ncin >> p;\ncin >> m >> n;\nvector<int> pizzaA(m);\nvector<int> pizzaB(n);\nfor(int i=0; i<m; i++){\ncin >> pizzaA[i];\n}\nfor(int i=0; i<n; i++){\ncin >> pizzaB[i];\n}\nvector<int> sum1(1,0);\nfor(int i=0; i<m; i++){\nint sum=0;\nfor(int j=i; j<i+m-1; j++){\nsum += pizzaA[j % m];\nsum1.push_back(sum);\n}\n}\nsum1.push_back(accumulate(pizzaA.begin(), pizzaA.end(), 0));\nvector<int> sum2(1,0);\nfor(int i=0; i<n; i++){\nint sum=0;\nfor(int j=i; j<i+n-1; j++){\nsum += pizzaB[j % n];\nsum2.push_back(sum);\n}\n}\nsum2.push_back(accumulate(pizzaB.begin(), pizzaB.end(), 0));\nsort(sum1.begin(), sum1.end());\nsort(sum2.begin(), sum2.end());\nint res=0;\nfor(int i=0; i<sum1.size(); i++){\nint value = p - sum1[i];\nif(value < 0){\nbreak;\n}\nint low = lower_bound(sum2.begin(), sum2.end(), value) - sum2.begin();\nint high = upper_bound(sum2.begin(), sum2.end(), value) - sum2.begin();\nres += high - low;\n}\ncout << res;\nreturn 0;\n}"
    },
    {
        "problem_tier": 6,
        "solution_code": "#include<iostream>\n#include<vector>\nusing namespace std;\nint main() {\nint a, b;\ncin >> a >> b;\nvector<int> vec;\nfor(int i=1; i<=1000; i++) {\nfor(int j=1; j<=i; j++) {\nvec.push_back(i);\n}\n}\nint sum = 0;\nfor(int i=a-1; i<=b-1; i++) {\nsum += vec[i];\n}\ncout << sum;\nreturn 0;\n}"
    },
    {
        "problem_tier": 13,
        "solution_code": "#include <bits/stdc++.h>\nusing namespace std;\n#define MAX 5001\nint N, M;\nint arr[MAX];\nint res = INT_MAX;\nbool isPossible(int mid){\nint cnt = 1;\nint minV = arr[0], maxV = arr[0];\nfor(int i=1; i<N; i++){\nif(arr[i] < minV) minV = arr[i];\nif(arr[i] > maxV) maxV = arr[i];\nif((maxV - minV) > mid){\ncnt++;\nminV = arr[i];\nmaxV = arr[i];\n}\n}\nreturn cnt <= M;\n}\nint main(){\nios_base::sync_with_stdio(0);\ncin.tie(0);\ncin >> N >> M;\nfor(int i=0; i<N; i++){\ncin >> arr[i];\n}\nint right = *max_element(arr, arr+N);\nint left = 0;\nwhile(left <= right){\nint mid = (left + right) / 2;\nif(isPossible(mid)){\nif(res > mid) res = mid;\nright = mid - 1;\n}else{\nleft = mid + 1;\n}\n}\ncout << res;\nreturn 0;\n}"
    },
    {
        "problem_tier": 7,
        "solution_code": "#include <iostream>\n#include <unordered_set>\nusing namespace std;\nvoid fast_io() {\nios_base::sync_with_stdio(false);\ncin.tie(NULL);\ncout.tie(NULL);\n}\nint main() {\nfast_io();\nwhile (1) {\nint n, m;\nint ans = 0;\nunordered_set<int> sangeunCD;\ncin >> n >> m;\nif (n == 0 && m == 0) break;\nfor (int i = 0; i < n; i++) {\nint cd;\ncin >> cd;\nsangeunCD.insert(cd);\n}\nfor (int i = 0; i < m; i++) {\nint sunyoungCD;\ncin >> sunyoungCD;\nif (sangeunCD.count(sunyoungCD)) ans++;\n}\ncout << ans << '\\n';\n}\nreturn 0;\n}"
    },
    {
        "problem_tier": 13,
        "solution_code": "#include <iostream>\n#include <stack>\n#include <vector>\n#include <limits>\n#include <cmath>\nusing namespace std;\n#define MAX_VALUE 1000000000\nint main() {\nios_base::sync_with_stdio(false);\ncin.tie(NULL);\nstring command;\nwhile (true) {\nvector<string> program;\nstack<long long> st;\nbool error = false;\nwhile (true) {\ncin >> command;\nif (command == \"QUIT\") {\nreturn 0;\n}"
    },
    {
        "problem_tier": 12,
        "solution_code": "#include <iostream>\n#include <string>\n#include <map>\nusing namespace std;\nbool isPalindrome(string s) {\nfor (int i = 0; i < s.size() / 2; i++) {\nif (s[i] != s[s.size() - 1 - i])\nreturn false;\n}\nreturn true;\n}\nbool isAllSame(string s) {\nmap<char, int> alphaMap;\nfor (int i = 0; i < s.size(); i++)\nalphaMap[s[i]] = 1;\nreturn alphaMap.size() == 1;\n}\nint main() {\nstring s;\ncin >> s;\nif (isAllSame(s)) {\ncout << -1;\nreturn 0;\n}"
    },
    {
        "problem_tier": 15,
        "solution_code": "#include <iostream>\n#include <vector>\n#include <algorithm>\nusing namespace std;\nvector<vector<int>> arr(51);\nint temp[51] = {0}, parent[51] = {0}, child[51] = {0};\nint n, a, tick = 1, ans = 0;\nint compare(int a, int b){\nreturn a > b;\n}\nint dfs(int idx){\nif(!arr[idx].size()){\nreturn 1;\n}\nint ret = 0;\nvector<int> v;\nfor(int i=0; i<arr[idx].size(); i++){\nv.push_back(dfs(arr[idx][i]));\n}\nsort(v.begin(), v.end(), compare);\nfor(int i=0; i<v.size(); i++){\nret = max(ret, v[i]+i);\n}\nreturn ret+1;\n}\nint main(){\ncin >> n >> a;\nfor(int i=1; i<n; i++){\ncin >> parent[i];\narr[parent[i]].push_back(i);\nchild[parent[i]]++;\n}\ncout << dfs(0) - 1;\nreturn 0;\n}"
    },
    {
        "problem_tier": 6,
        "solution_code": "#include <iostream>\n#include <bitset>\n#include <string>\nusing namespace std;\nint main() {\nios_base::sync_with_stdio(false);\ncin.tie(0);\nint t;\ncin >> t;\nbitset<200> a, b;\nwhile (t--) {\ncin >> a >> b;\nbitset<200> c;\nint flag = 0;\nfor (int i = 0; i < a.size(); i++) {\nif (a[i] + b[i] + flag == 3) {\nc[i] = 1;\nflag = 1;\n} else if (a[i] + b[i] + flag == 2) {\nc[i] = 0;\nflag = 1;\n} else if (a[i] + b[i] + flag == 1) {\nc[i] = 1;\nflag = 0;\n} else if (a[i] + b[i] + flag == 0) {\nc[i] = 0;\nflag = 0;\n}\n}\nstring ans = \"\";\nflag = 0;\nfor (int i = 199; i >= 0; i--) {\nif (c[i]) {\nflag = 1;\nans = ans + to_string(c[i]);\n} else if (flag) {\nans = ans + to_string(c[i]);\n}\n}\nif (ans == \"\") {\ncout << \"0\\n\";\n} else {\ncout << ans << \"\\n\";\n}\n}\nreturn 0;\n}"
    },
    {
        "problem_tier": 16,
        "solution_code": "#include<iostream>\n#include<vector>\n#include<queue>\nusing namespace std;\nconst int WATER = 0;\nconst int IMPOSSIBLE = 1;\nconst int POSSIBLE = 2;\nconst int GREEN = 0;\nconst int RED = 1;\ntypedef pair<int,int> pii;\nstruct Node{\nint color, r, c;\n};\nint N, M, G, R;\nint board[50][50];\nvector<pii> startPos;\nint dr[] = {-1, 1, 0, 0};\nint dc[] = {0, 0, -1, 1};\nint simulate(int green, int red){\nqueue<Node> q;\nvector<vector<vector<int>>> visit(2, vector<vector<int>>(50, vector<int>(50, 0)));\nint P = startPos.size();\nint flowerCnt = 0;\nfor(int i=0; i<P; i++){\nint r = startPos[i].first;\nint c = startPos[i].second;\nif((green & (1 << i)) != 0){\nq.push({GREEN, r, c});\nvisit[GREEN][r][c] = 1;\n}\nif((red & (1 << i)) != 0){\nq.push({RED, r, c});\nvisit[RED][r][c] = 1;\n}\n}\nwhile(!q.empty()){\nint color = q.front().color;\nint r = q.front().r;\nint c = q.front().c;\nint v = visit[color][r][c];\nq.pop();\nif(visit[GREEN][r][c] == visit[RED][r][c]){\nflowerCnt++;\ncontinue;\n}\nfor(int i=0; i<4; i++){\nint nr = r + dr[i];\nint nc = c + dc[i];\nif(nr < 0 || nr >= N || nc < 0 || nc >= M) continue;\nif(board[nr][nc] == WATER || visit[color][nr][nc]) continue;\nif(visit[1-color"
    },
    {
        "problem_tier": 10,
        "solution_code": "#include <iostream>\n#include <vector>\n#include <algorithm>\n#include <cstring>\nusing namespace std;\nchar map[399][397];\nvoid drawStar(int n, int x, int y) {\nint width = 4 * n - 3;\nint height = width + 2;\nfor (int i = 1; i < width; i++)\nmap[x][y--] = '*';\nfor (int i = 1; i < height; i++)\nmap[x++][y] = '*';\nfor (int i = 1; i < width; i++)\nmap[x][y++] = '*';\nfor (int i = 1; i < height - 2; i++)\nmap[x--][y] = '*';\nmap[x][y] = '*';\ny--;\nmap[x][y] = '*';\nif (n == 2) {\nmap[x][y-1] = '*';\nmap[x+1][y-1] = '*';\nmap[x+2][y-1] = '*';\nreturn;\n}\ndrawStar(n-1, x, y-1);\n}\nint main(void) {\nint n;\ncin >> n;\nif (n == 1) {\nprintf(\"*\");\nreturn 0;\n}"
    },
    {
        "problem_tier": 18,
        "solution_code": "#include <iostream>\n#include <vector>\nusing namespace std;\nint N;\nvector<vector<int>> arr;\nvector<vector<int>> bit;\nvoid update(int y, int x, int value) {\nwhile (y <= N) {\nint j = x;\nwhile (j <= N) {\nbit[y][j] += value;\nj += (j & -j);\n}\ny += (y & -y);\n}\n}\nint sum(int y, int x) {\nint s = 0;\nwhile (y > 0) {\nint j = x;\nwhile (j > 0) {\ns += bit[y][j];\nj -= (j & -j);\n}\ny -= (y & -y);\n}\nreturn s;\n}\nint main() {\nios_base::sync_with_stdio(false);\ncin.tie(NULL);\ncout.tie(NULL);\ncin >> N;\narr.resize(N + 1, vector<int>(N + 1));\nbit.resize(N + 1, vector<int>(N + 1));\nfor (int i = 1; i <= N; i++) {\nfor (int j = 1; j <= N; j++) {\ncin >> arr[i][j];\nupdate(i, j, arr[i][j]);\n}\n}\nint M;\ncin >> M;\nfor (int i = 0; i < M; i++) {\nint type;\ncin >> type;\nif (type) {\nint y1, x1, y2, x2;\ncin >> y1 >> x1 >> y2 >> x2;\ncout << sum(y2, x2) - sum(y1 - 1, x2) - sum(y2, x1 - 1) + sum(y1 - 1, x1 - 1) << \"\\n\";\n} else {\nint y, x, value;\ncin >> y >> x >> value;\nupdate(y, x, value - arr[y][x]);\narr[y][x] = value;\n}\n}\nreturn 0;\n}"
    },
    {
        "problem_tier": 15,
        "solution_code": "#include<iostream>\n#include<string>\n#include<algorithm>\n#include<vector>\nusing namespace std;\nint T, n;\nint makeNum[9] = {0, 0, 1, 7, 4, 2, 0, 8, 10};\nlong long dp[101];\nvoid getMin() {\nfor (int i = 1; i < 9; i++) {\ndp[i] = makeNum[i];     }\ndp[6] = 6;\nfor (int i = 9; i < 101; i++) {\ndp[i] = dp[i-2] * 10 + makeNum[2];\nfor (int j = 3; j < 8; j++) {\ndp[i] = min(dp[i], dp[i-j] * 10 + makeNum[j]);\n}\n}\n}\nint main() {\nios_base::sync_with_stdio(false);\ncin.tie(0);\ncout.tie(0);\ncin >> T;\ngetMin();\nwhile (T--) {\ncin >> n;\ncout << dp[n] << \" \";\nif (n % 2 == 1) {             cout << 7;\nn -= 3;\n}\nwhile (n != 0) {\ncout << 1;\nn -= 2;\n}\ncout << \"\\n\";\n}\nreturn 0;\n}"
    },
    {
        "problem_tier": 14,
        "solution_code": "#include <bits/stdc++.h>\nusing namespace std;\nstruct Edge {\nint v1, v2, flag;\n};\nconst int MAX = 1001;\nint n, m, parent[MAX];\nvector<Edge> edges;\nbool compare1(const Edge& a, const Edge& b) {\nreturn a.flag < b.flag;\n}\nbool compare2(const Edge& a, const Edge& b) {\nreturn a.flag > b.flag;\n}\nvoid init() {\nfor (int i = 0; i < MAX; i++) {\nparent[i] = i;\n}\n}\nint Find(int a) {\nif (a == parent[a]) {\nreturn a;\n}\nreturn parent[a] = Find(parent[a]);\n}\nvoid Union(int a, int b) {\nint pa = Find(a), pb = Find(b);\nparent[pa] = pb;\n}\nint main(void) {\nios_base::sync_with_stdio(false);\ncin.tie(nullptr);\ncout.tie(nullptr);\ncin >> n >> m;\nfor (int i = 0; i < m + 1; i++) {\nint a, b, c;\ncin >> a >> b >> c;\nedges.push_back({a, b, c});\n}\ninit();\nsort(edges.begin(), edges.end(), compare1);\nint ans1 = 0, ans2 = 0;\nfor (auto& edge : edges) {\nif (Find(edge.v1) != Find(edge.v2)) {\nUnion(edge.v1, edge.v2);\nif (!edge.flag)\nans1++;\n}\n}\ninit();\nsort(edges.begin(), edges.end(), compare2);\nfor (auto& edge : edges) {\nif (Find(edge.v1) != Find(edge.v2)) {\nUnion(edge.v1, edge.v2);\nif (!edge.flag)\nans2++;\n}\n}\ncout << (int)(pow(ans1, 2) - pow(ans2, 2)) << '\\n';\nreturn 0;\n}"
    },
    {
        "problem_tier": 6,
        "solution_code": "#include <iostream>\n#include <vector>\n#include <string>\nint main() {\nint T;\nstd::cin >> T;\nwhile (T--) {\nint H, W;\nstd::cin >> H >> W;\nstd::vector<std::string> board(H);\nfor (int i = 0; i < H; ++i) {\nstd::cin >> board[i];\n}\nfor (int i = 0; i < H; ++i) {\nfor (int j = W - 1; j >= 0; --j) {\nstd::cout << board[i][j];\n}\nstd::cout << \"\\n\";\n}\n}\nreturn 0;\n}"
    },
    {
        "problem_tier": 7,
        "solution_code": "#include <iostream>\n#include <vector>\n#include <cmath>\nusing namespace std;\nbool is_prime(int num) {\nif (num == 2) return true;\nfor (int i = 2; i <= sqrt(num); i++) {\nif (num % i == 0) return false;\n}\nreturn true;\n}\nint main() {\nios::sync_with_stdio(false);\ncin.tie(NULL);\nint n;\ncin >> n;\nint last = 0;\nint i = 2;\nint sum;\nwhile (true) {\nif (is_prime(i)) {\nsum = last * i;\nif (sum > n) {\nbreak;\n}\nlast = i;\n}\ni++;\n}\ncout << sum << endl;\nreturn 0;\n}"
    },
    {
        "problem_tier": 10,
        "solution_code": "#include <iostream>\n#include <vector>\n#include <algorithm>\nusing namespace std;\nint main() {\nios_base::sync_with_stdio(false);\ncin.tie(NULL);\ncout.tie(NULL);\nint n, m;\ncin >> n >> m;\nvector<vector<int>> a(n, vector<int>(m));\nvector<vector<int>> dp(n, vector<int>(m));\nfor (int i = 0; i < n; i++) {\nfor (int j = 0; j < m; j++) {\ncin >> a[i][j];\n}\n}\ndp[0][0] = a[0][0];\nfor (int i = 1; i < n; i++) {\ndp[i][0] = dp[i - 1][0] + a[i][0];\n}\nfor (int j = 1; j < m; j++) {\ndp[0][j] = dp[0][j - 1] + a[0][j];\n}\nfor (int i = 1; i < n; i++) {\nfor (int j = 1; j < m; j++) {\ndp[i][j] = max(dp[i - 1][j], dp[i][j - 1]) + a[i][j];\n}\n}\ncout << dp[n - 1][m - 1] << \"\\n\";\nreturn 0;\n}"
    },
    {
        "problem_tier": 8,
        "solution_code": "#include <iostream>\n#include <vector>\n#include <algorithm>\nusing namespace std;\nint main() {\nint n;\ncin >> n;\nvector<int> v(n);\nfor (int i = 0; i < n; i++) {\ncin >> v[i];\n}\nsort(v.begin(), v.end());\nint ans = 1;\nfor (int i = 0; i < n; i++) {\nint k = 1;\nfor (int j = i + 1; j < i + 5; j++) {\nif (v[j] - v[i] < 5 && v[j] - v[i] > 0)\nk++;\n}\nans = max(ans, k);\n}\nif (ans >= 5)\ncout << 0;\nelse\ncout << 5 - ans << '\\n';\nreturn 0;\n}"
    },
    {
        "problem_tier": 13,
        "solution_code": "#include<iostream>\nusing namespace std;\nint dp[101][101][2] = {0,};\nint main(){\nint t, n, k;\ncin >> t;\ndp[1][0][0] = 1;     dp[1][0][1] = 1;\nfor(int i=2; i<=100; i++){\nfor(int j=0; j<i; j++){\ndp[i][j][0] = dp[i-1][j][0] + dp[i-1][j][1];\ndp[i][j][1] = dp[i-1][j][0] + dp[i-1][j-1][1];\n}\n}\nwhile(t--){\ncin >> n >> k;\ncout << dp[n][k][0] + dp[n][k][1] << \"\\n\";\n}\nreturn 0;\n}"
    },
    {
        "problem_tier": 9,
        "solution_code": "#include <iostream>\n#include <algorithm>\nint main() {\nstd::string num;\nstd::cin >> num;\nbool found = false;\ndo {\nint nextNum = std::stoi(num);\nif (nextNum > std::stoi(num)) {             std::cout << nextNum << std::endl;\nfound = true;\nbreak;\n}\n} while (std::next_permutation(num.begin(), num.end()));\nif (!found)\nstd::cout << 0 << std::endl;\nreturn 0;\n}"
    },
    {
        "problem_tier": 18,
        "solution_code": "#include<iostream>\n#include<vector>\n#include<queue>\nusing namespace std;\nint dy[4] = {0, 0, 1, -1};\nint dx[4] = {1, -1, 0, 0};\nvector<vector<int>> bfs(vector<vector<char>>& map, int y, int x) {\nint h = map.size();\nint w = map[0].size();\nvector<vector<int>> dist(h, vector<int>(w, -1));\nqueue<pair<int, int>> q;\nq.push({y, x});\ndist[y][x] = 0;\nwhile(!q.empty()) {\nint cy = q.front().first;\nint cx = q.front().second;\nq.pop();\nfor(int i=0; i<4; i++) {\nint ny = cy + dy[i];\nint nx = cx + dx[i];\nif(ny < 0 || ny >= h || nx < 0 || nx >= w) continue;             if(map[ny][nx] == '*') continue;             if(dist[ny][nx] != -1) continue;\nif(map[ny][nx] == '#') {\ndist[ny][nx] = dist[cy][cx] + 1;\nq.push({ny, nx});\n} else {\ndist[ny][nx] = dist[cy][cx];\nq.push({ny, nx});\n}\n}\n}\nreturn dist;\n}\nint main() {\nios::sync_with_stdio(false);\ncin.tie(NULL);\nint t;\ncin >> t;\nwhile(t--) {\nint h, w;\ncin >> h >> w;\nvector<vector<char>> map(h+2, vector<char>(w+2, '.'));\nfor(int i=1; i<=h; i++) {\nfor(int j=1; j<=w; j++) {\ncin >> map[i][j];             }\n}\nvector<pair<int, int>> crimes;\ncrimes.push_back({0, 0});         for(int i=1; i<=h; i++) {\nfor(int j=1; j<=w; j++) {\nif(map[i][j] == '$') {\ncrimes.push_back({i, j});\n}\n}\n}\nvector<vector<vector<int>>> door_count(3, vector<vector<int>>(h+2, vector<int>(w+2, 1e9)));\nvector<vector<vector<bool>>> visited(3, vector<vector<bool>>(h+2, vector<bool>(w+2, false)));\nfor(int i=0; i<3; i++) {\nint y = crimes[i].first;\nint x = crimes[i].second;\nvector<vector<int>> dist = bfs(map, y, x);\nfor(int j=0; j<=h+1; j++) {\nfor(int k=0; k<=w+1; k++) {\nif(dist[j][k] != -1) {\ndoor_count[i][j][k] = dist[j][k];\nvisited[i][j][k] = true;\n}\n}\n}\n}\nint result = 1e9;\nfor(int i=0; i<=h+1; i++) {\nfor(int j=0; j<=w+1; j++) {\nif(map[i][j] == '*') continue;\nbool all_visited = true;\nfor(int k=0; k<3; k++) {\nif(!visited[k][i][j]) {\nall_visited = false;\nbreak;\n}\n}\nif(all_visited) {\nint sum = 0;\nfor(int k=0; k<3; k++) {\nsum += door_count[k][i][j];\n}\nif(map[i][j] == '#') sum -= 2;\nresult = min(result, sum);\n}\n}\n}\ncout << result << '\\n';\n}\n}"
    },
    {
        "problem_tier": 9,
        "solution_code": "#include <iostream>\nusing namespace std;\nint H, W, X, Y;\nint A[601][601];\nint B[601][601];\nvoid input_B() {\nfor (int i = 0; i < H + X; i++) {\nfor (int j = 0; j < W + Y; j++) {\ncin >> B[i][j];\n}\n}\n}\nvoid recover_A() {\nfor (int i = X; i < H; i++) {\nfor (int j = Y; j < W; j++) {\nA[i][j] = B[i][j] - A[i-X][j-Y];\n}\n}\n}\nvoid print_A() {\nfor (int i = 0; i < H; i++) {\nfor (int j = 0; j < W; j++) {\ncout << A[i][j] << \" \";\n}\ncout << \"\\n\";\n}\n}\nint main() {\ncin >> H >> W >> X >> Y;\nfor (int i = 0; i < H + X; i++) {\nfor (int j = 0; j < W + Y; j++) {\ncin >> A[i][j];\n}\n}\ninput_B();\nrecover_A();\nprint_A();\nreturn 0;\n}"
    },
    {
        "problem_tier": 4,
        "solution_code": "#include <iostream>\nusing namespace std;\nint main() {\nwhile (true) {\nint a, b, c, d;\ncin >> a >> b >> c >> d;\nif (a == 0 && b == 0 && c == 0 && d == 0)\nbreak;\ncout << c - b << \" \" << d - a << '\\n';\n}\nreturn 0;\n}"
    },
    {
        "problem_tier": 7,
        "solution_code": "#include <iostream>\n#include <string>\nint gcd(int x, int y) {\nint z;\nwhile (y != 0) {\nz = x % y;\nx = y;\ny = z;\n}\nreturn x;\n}\nint lcm(int x, int y) {\nreturn x * y / gcd(x, y);\n}\nint main() {\nstd::string s, t;\nstd::cin >> s >> t;\nstd::string s_tmp = s;\nstd::string t_tmp = t;\nint s_len = s.length();\nint t_len = t.length();\nint lcm_val = lcm(s_len, t_len);\nif (s == t) {\nstd::cout << 1 << \"\\n\";\nreturn 0;\n}"
    },
    {
        "problem_tier": 8,
        "solution_code": "#include <iostream>\n#include <vector>\nusing namespace std;\nint dp[31][31];\nint main() {\nios_base::sync_with_stdio(false);\ncin.tie(NULL);\ncout.tie(NULL);\nint r, c, w, ans = 0;\ncin >> r >> c >> w;\nint row = r + w - 1;\ndp[1][1] = 1;\ndp[2][1] = 1;\ndp[2][2] = 1;\nfor (int i = 3; i <= row; i++) {\nfor (int j = 1; j <= i; j++) {\nif (j == 1 || j == i) {\ndp[i][j] = 1;\n} else {\ndp[i][j] = dp[i-1][j-1] + dp[i-1][j];\n}\n}\n}\nint flag = c;\nfor (int i = r; i <= row; i++) {\nfor (int j = c; j <= flag; j++) {\nans += dp[i][j];\n}\nflag++;\n}\ncout << ans;\nreturn 0;\n}"
    },
    {
        "problem_tier": 11,
        "solution_code": "#include <iostream>\n#include <algorithm>\n#include <vector>\n#include <string>\nusing namespace std;\nint main() {\nint N;\ncin >> N;\nvector<string> words(N);\nfor (int i = 0; i < N; i++) {\ncin >> words[i];\n}\nsort(words.begin(), words.end());\nint answer = N;\nfor (int i = 1; i < N; i++) {\nif (words[i].find(words[i-1]) == 0) {\nanswer--;\n}\n}\ncout << answer << endl;\nreturn 0;\n}"
    },
    {
        "problem_tier": 9,
        "solution_code": "#include <iostream>\n#include <iomanip>\nusing namespace std;\ndouble stoneByColor[51];\ndouble percent[51];\ndouble total = 0;\ndouble ans = 0;\nint M, K;\nint main() {\ncin >> M;\nfor (int i = 0; i < M; i++) {\ncin >> stoneByColor[i];\ntotal += stoneByColor[i];\n}\ncin >> K;\nfor (int i = 0; i < M; i++) {\nif (stoneByColor[i] < K)\ncontinue;\ndouble temp = 1.0;\nfor (int j = 0; j < K; j++) {\ntemp *= (stoneByColor[i] - j) / (total - j);\n}\npercent[i] = temp;\n}\nfor (int i = 0; i < M; i++) {\nans += percent[i];\n}\ncout << fixed;\ncout.precision(15);\ncout << ans;\nreturn 0;\n}"
    },
    {
        "problem_tier": 7,
        "solution_code": "#include <iostream>\n#include <algorithm>\n#include <vector>\n#include <string>\nusing namespace std;\nint main(void) {\nint n;\ncin >> n;\nvector<string> arr(n);\nfor (int i = 0; i < n; i++) {\ncin >> arr[i];\n}\nbool increasing = false;\nfor (int i = 0; i < n - 1; i++) {\nif (arr[i + 1] > arr[i]) {\nincreasing = true;\nbreak;\n}\n}\nif (!increasing) {\ncout << \"DECREASING\";\nreturn 0;\n}"
    },
    {
        "problem_tier": 17,
        "solution_code": "#include <iostream>\n#define MOD 1000000007\ntypedef long long ll;\nusing namespace std;\nll factorial[4000001];\nll pow(ll num, ll remain){\nif(remain == 0) return 1;\nelse if(remain == 1) return num;\nif(remain % 2 == 0){\nll temp = pow(num, remain/2);\nreturn (temp * temp) % MOD;\n} else {\nll temp = pow(num, remain-1);\nreturn (temp * num) % MOD;\n}\n}\nint main(){\nios_base::sync_with_stdio(false);\ncin.tie(NULL);\ncout.tie(NULL);\nfor(int i=1; i<=4000000; i++){\nfactorial[i] = (factorial[i-1] * i) % MOD;\n}\nint T;\ncin >> T;\nwhile(T--){\nint N, K;\ncin >> N >> K;\ncout << factorial[N] * pow((factorial[K] * factorial[N-K]) % MOD, MOD-2) % MOD << \"\\n\";\n}\nreturn 0;\n}"
    },
    {
        "problem_tier": 12,
        "solution_code": "#include <iostream>\nint gcd(int a, int b) {\nreturn a % b ? gcd(b, a % b) : b;\n}\nint calculate(int a, int b) {\nint i = 1, GCD;\nwhile (a != 1) {\ni = (b % a == 0) ? (b / a) : (b / a + 1);\na = a * i - b;\nb = b * i;\nGCD = gcd(a, b);\na /= GCD;\nb /= GCD;\n}\nreturn b;\n}\nint main() {\nint T, a, b;\nstd::cin >> T;\nwhile (T--) {\nstd::cin >> a >> b;\nstd::cout << calculate(a, b) << std::endl;\n}\nreturn 0;\n}"
    },
    {
        "problem_tier": 12,
        "solution_code": "#include<iostream>\n#include<vector>\n#include<algorithm>\nusing namespace std;\nint main() {\nint n;\nscanf(\"%d\", &n);\nvector<int> liquid(n);\nfor(int i=0; i<n; i++)\nscanf(\"%d\", &liquid[i]);\nint left = 0;\nint right = n - 1;\nint result = 2100000000;\nwhile(left < right) {\nint liq1 = liquid[left];\nint liq2 = liquid[right];\nif(abs(liq1 + liq2) < abs(result))\nresult = liq1 + liq2;\nif(liq1 + liq2 < 0)\nleft++;\nelse\nright--;\n}\nprintf(\"%d\\n\", result);\n}"
    },
    {
        "problem_tier": 3,
        "solution_code": "#include <iostream>\nusing namespace std;\nint main() {\nint r, c;\ncin >> r >> c;\nfor (int i = 0; i < r; i++) {\nfor (int j = 0; j < c; j++) {\ncout << \"*\";\n}\ncout << endl;\n}\nreturn 0;\n}"
    },
    {
        "problem_tier": 17,
        "solution_code": "#include <iostream>\nusing namespace std;\nlong long gcd(long long a, long long b) {\nif (b == 0)\nreturn a;\nif (b != 1) {\nlong long x, y;\nx = 1 - ((a / b) * x2);\ny = y1 - ((a / b) * y2);\nx1 = x2;\ny1 = y2;\nx2 = x;\ny2 = y;\n}\nreturn gcd(b, a % b);\n}\nint main() {\nlong long t, K, C;\ncin >> t;\nfor (long long i = 0; i < t; i++) {\ncin >> K >> C;\nif (C == 1) {\nif (K >= 1000000000)\ncout << \"IMPOSSIBLE\\n\";\nelse\ncout << K + 1 << '\\n';\n} else if (K == 1)\ncout << \"1\\n\";\nelse if (gcd(K, C) != 1)\ncout << \"IMPOSSIBLE\\n\";\nelse {\nx1 = 1;\ny1 = 0;\nx2 = 0;\ny2 = 1;\ngcd(K, C);\nwhile (y2 < 0) {\ny2 = y2 + K;\n}\nif (y2 > 1000000000 || y2 == 0)\ncout << \"IMPOSSIBLE\\n\";\nelse\ncout << y2 << '\\n';\n}\n}\nreturn 0;\n}"
    },
    {
        "problem_tier": 4,
        "solution_code": "#include <iostream>\nusing namespace std;\nstring mbti, ans;\nint main() {\ncin >> mbti;\nfor(int i = 0; i < mbti.size(); i++) {\nif(mbti[i] == 'E')\nans += 'I';\nelse if(mbti[i] == 'I')\nans += 'E';\nelse if(mbti[i] == 'S')\nans += 'N';\nelse if(mbti[i] == 'N')\nans += 'S';\nelse if(mbti[i] == 'T')\nans += 'F';\nelse if(mbti[i] == 'F')\nans += 'T';\nelse if(mbti[i] == 'P')\nans += 'J';\nelse\nans += 'P';\n}\ncout << ans;\nreturn 0;\n}"
    },
    {
        "problem_tier": 4,
        "solution_code": "#include <iostream>\n#include <cmath>\nusing namespace std;\nint main() {\ndouble a, b, c;\nint i = 1;\nwhile (1) {\ndouble ans = 0;\ncin >> a >> b >> c;\nif (!a && !b && !c)\nbreak;\ncout << \"Triangle #\" << i << '\\n';\ni++;\nif (a == -1) {\nans = sqrt(c * c - b * b);\nif (ans > 0)\nprintf(\"a = %.3f\\n\", ans);\nelse\ncout << \"Impossible.\\n\";\n}\nelse if (b == -1) {\nans = sqrt(c * c - a * a);\nif (ans > 0)\nprintf(\"b = %.3f\\n\", ans);\nelse\ncout << \"Impossible.\\n\";\n}\nelse  {\nans = sqrt(a * a + b * b);\nif (ans > 0)\nprintf(\"c = %.3f\\n\", ans);\nelse\ncout << \"Impossible.\\n\";\n}\ncout << '\\n';\n}\n}"
    },
    {
        "problem_tier": 2,
        "solution_code": "#include <iostream>\nusing namespace std;\nint main() {\nint N;\ncin >> N;\nint count = 0;\nfor (int i = 1; i <= N; i++) {\nif (i % 3 == 0 || i % 5 == 0) {\ncount++;\n}\n}\ncout << count << endl;\nreturn 0;\n}"
    },
    {
        "problem_tier": 11,
        "solution_code": "#include<iostream>\nusing namespace std;\nint arr[10][10];\nbool check[10][10];\nint answer = -40000;\nint n, m, k;\nint dx[] = {-1, 1, 0, 0};\nint dy[] = {0, 0, -1, 1};\nvoid func(int cnt, int sum) {\nif (cnt == k) {\nif (answer < sum)\nanswer = sum;\nreturn;\n}\nfor (int x = 0; x < n; x++) {\nfor (int y = 0; y < m; y++) {\nif (check[x][y])\ncontinue;\nbool flag = true;\nfor (int i = 0; i < 4; i++) {\nint nx = x + dx[i];\nint ny = y + dy[i];\nif (nx >= 0 && nx < n && ny >= 0 && ny < m) {\nif (check[nx][ny])\nflag = false;\n}\n}\nif (flag) {\ncheck[x][y] = true;\nfunc(cnt + 1, sum + arr[x][y]);\ncheck[x][y] = false;\n}\n}\n}\n}\nint main() {\nios::sync_with_stdio(0);\ncin.tie(0);\ncin >> n >> m >> k;\nfor (int i = 0; i < n; i++) {\nfor (int j = 0; j < m; j++)\ncin >> arr[i][j];\n}\nfunc(0, 0);\ncout << answer << \"\\n\";\nreturn 0;\n}"
    },
    {
        "problem_tier": 8,
        "solution_code": "#include <iostream>\n#include <vector>\n#include <algorithm>\nusing namespace std;\nint main() {\nios_base::sync_with_stdio(false);\ncin.tie(0);\nint N, L;\ncin >> N >> L;\nvector<vector<int>> traffic_lights(N, vector<int>(3));\nfor (int i = 0; i < N; i++) {\ncin >> traffic_lights[i][0] >> traffic_lights[i][1] >> traffic_lights[i][2];\n}\nint time = 1;\nfor (int i = 1; i <= L; i++) {\nfor (int j = 0; j < N; j++) {\nif (i == traffic_lights[j][0] && traffic_lights[j][1] > time % (traffic_lights[j][1] + traffic_lights[j][2])){\ntime += traffic_lights[j][1] - time % (traffic_lights[j][1] + traffic_lights[j][2]);\n}\n}\ntime++;\n}\ncout << time - 1 << endl;\nreturn 0;\n}"
    },
    {
        "problem_tier": 12,
        "solution_code": "#include <iostream>\n#include <vector>\n#define ll long long\n#define MOD 1000000000\nusing namespace std;\nint main() {\nint N;\ncin >> N;\nvector<ll> dp(N+1, 0);\nvector<ll> nums;\nfor (int i = 1; i <= N; i <<= 1)\nnums.push_back(i);\ndp[0] = 1;\nfor (int i = 0; i < nums.size(); i++) {\nfor (int j = nums[i]; j <= N; j++) {\ndp[j] = (dp[j] + dp[j - nums[i]]) % MOD;\n}\n}\ncout << dp[N];\nreturn 0;\n}"
    },
    {
        "problem_tier": 18,
        "solution_code": "#include <iostream>\n#include <vector>\n#include <cstring>\n#include <cmath>\n#include <set>\nusing namespace std;\nint n, lo, hi, a[51][51], v[51][51];\nint di[] = {0,0,1,-1,1,1,-1,-1}, dj[] = {1,-1,0,0,1,-1,1,-1};\nstruct pos {\nint i, j;\n};\nvector<pos> K;\nvoid dfs(int i, int j) {\nif(i < 0 || j < 0 || i >= n || j >= n || v[i][j] || a[i][j] < lo || a[i][j] > hi)\nreturn;\nv[i][j] = 1;\nfor(int d = 0; d < 8; ++d)\ndfs(i + di[d], j + dj[d]);\n}\nbool possible() {\nint cnt = 0;\nfor(int k = 0; k < K.size(); ++k)\nif(v[K[k].i][K[k].j])\n++cnt;\nreturn cnt == K.size();\n}\nint main() {\npos P;\ncin >> n;\nfor(int i = 0; i < n; ++i) {\nchar t[51];\ncin >> t;\nfor(int j = 0; j < n; ++j) {\nif(t[j] == 'P')\nP = {i, j};\nelse if(t[j] == 'K')\nK.push_back({i, j});\n}\n}\nset<int> s;\nfor(int i = 0; i < n; ++i)\nfor(int j = 0; j < n; ++j) {\ncin >> a[i][j];\ns.insert(a[i][j]);\n}\nint result = 1e6;\nset<int>::iterator l = s.begin(), r = s.begin();\nwhile(r != s.end()) {\nwhile(l != s.end()) {\nmemset(v, 0, sizeof(v));\nlo = *l;\nhi = *r;\ndfs(P.i, P.j);\nif(!possible())\nbreak;\nresult = min(result, *r - *l);\n++l;\n}\n++r;\n}\ncout << result;\nreturn 0;\n}"
    },
    {
        "problem_tier": 5,
        "solution_code": "#include <iostream>\n#include <string>\n#include <algorithm>\nusing namespace std;\nbool isPalindrome(string s) {\nint i = 0, j = s.size() - 1;\nwhile (i <= j) {\nif (tolower(s[i]) != tolower(s[j])) {\nreturn false;\n}\ni++;\nj--;\n}\nreturn true;\n}\nint main() {\nint n;\ncin >> n;\ncin.ignore();\nstring s;\nfor (int i = 0; i < n; i++) {\ngetline(cin, s);\nif (isPalindrome(s)) {\ncout << \"Yes\" << endl;\n} else {\ncout << \"No\" << endl;\n}\n}\nreturn 0;\n}"
    },
    {
        "problem_tier": 12,
        "solution_code": "#include <iostream>\n#include <map>\n#include <cmath>\nusing namespace std;\nmap<char,int> roms = {\n{'I',1},\n{'V',5},\n{'X',10},\n{'L',50},\n{'C',100},\n{'D',500},\n{'M',1000}\n};\nint romToNumber(string rom) {\nint len = rom.length();\nint ans = 0;\nfor(int i=0; i<len; i++) {\nif(i+1 != len && roms[rom[i]] < roms[rom[i+1]]) {\nans -= roms[rom[i]];\n} else {\nans += roms[rom[i]];\n}\n}\nreturn ans;\n}\nstring numToRoman(int num) {\nstring len = to_string(num);\nstring ans = \"\";\nswitch(len.size()) {\ncase 4: {\nint thousand = num / 1000;\nwhile(thousand--) ans += 'M';\n}\ncase 3: {\nnum %= 1000;\nint hundred = num / 100;\nif(hundred == 9) {\nans += \"CM\";\n} else if(hundred == 4) {\nans += \"CD\";\n} else if(hundred == 5) {\nans += \"D\";\n} else if(hundred == 1) {\nans += \"C\";\n} else if(hundred < 4) {\nwhile(hundred--) ans += 'C';\n} else if(hundred > 5) {\nans += 'D';\nfor(int i=0; i<hundred-5; i++) ans += 'C';\n}\n}\ncase 2: {\nnum %= 100;\nint tenth = num / 10;\nif(tenth == 9) {\nans += \"XC\";\n} else if(tenth == 4) {\nans += \"XL\";\n} else if(tenth == 5) {\nans += \"L\";\n} else if(tenth == 1) {\nans += \"X\";\n} else if(tenth < 4) {\nwhile(tenth--) ans += 'X';\n} else if(tenth > 5) {\nans += 'L';\nfor(int i=0; i<tenth-5; i++) ans += 'X';\n}\n}\ncase 1: {\nnum %= 10;\nif(num == 9) {\nans += \"IX\";\n} else if(num == 4) {\nans += \"IV\";\n} else if(num == 5) {\nans += \"V\";\n} else if(num < 4) {\nwhile(num--) ans += 'I';\n} else if(num > 5) {\nans += 'V';\nfor(int i=0; i<num-5; i++) ans += 'I';\n}\nbreak;\n}\ndefault:\nbreak;\n}\nreturn ans;\n}\nint main() {\nstring a, b;\ncin >> a >> b;\nint number = romToNumber(a) + romToNumber(b);\ncout << number << '\\n';\ncout << numToRoman(number) << '\\n';\nreturn 0;\n}"
    },
    {
        "problem_tier": 10,
        "solution_code": "#include <iostream>\n#include <string>\n#include <vector>\nusing namespace std;\nint main() {\nint S, K;\nlong long ans = 1;\nlong long tmp1, tmp2;\ncin >> S >> K;\ntmp1 = S / K;\ntmp2 = S % K;\nfor (int i = 0; i < K; i++) {\nif (tmp2 > 0) {\nans *= (tmp1 + 1);\ntmp2--;\n}\nelse\nans *= tmp1;\n}\ncout << ans;\nreturn 0;\n}"
    },
    {
        "problem_tier": 5,
        "solution_code": "#include <iostream>\n#include <cmath>\nint main() {\nint cnt = 1;\nwhile (true) {\ndouble r, w, l;\nstd::cin >> r;\nif (r == 0) break;\nstd::cin >> w >> l;\nif (w >= std::sqrt(r*r - l*l/4) && l >= std::sqrt(r*r - w*w/4)) {\nstd::cout << \"Pizza \" << cnt << \" fits on the table.\\n\";\n} else {\nstd::cout << \"Pizza \" << cnt << \" does not fit on the table.\\n\";\n}\ncnt++;\n}\nreturn 0;\n}"
    },
    {
        "problem_tier": 12,
        "solution_code": "#include <iostream>\n#include <vector>\n#include <algorithm>\nusing namespace std;\nint main() {\ncin.tie(0);\ncout.tie(0);\nios::sync_with_stdio(false);\nint N;\ncin >> N;\nvector<int> v;\nint sum = 0;\nint cnt_2 = 0;\nfor (int i = 0; i < N; i++) {\nint val;\ncin >> val;\nv.push_back(val);\nsum += val;\ncnt_2 += val / 2;\n}\nif (sum % 3 != 0) {\ncout << \"NO\\n\";\n} else {\nif (cnt_2 >= sum / 3) {\ncout << \"YES\\n\";\n} else {\ncout << \"NO\\n\";\n}\n}\nreturn 0;\n}"
    },
    {
        "problem_tier": 17,
        "solution_code": "#include <iostream>\n#include <vector>\nusing namespace std;\nint main() {\nint n, m;\ncin >> n >> m;\nvector<vector<int>> a(n, vector<int>(m));\nfor (int i = 0; i < n; i++) {\nstring s;\ncin >> s;\nfor (int j = 0; j < m; j++) {\na[i][j] = s[j] - '0';\n}\n}\nvector<vector<vector<int>>> dp(n, vector<vector<int>>(m, vector<int>(4)));\nint ans = 0;\nfor (int i = 0; i < n; i++) {\nfor (int j = 0; j < m; j++) {\ndp[i][j][0] = a[i][j];\ndp[i][j][1] = (i > 0 && j > 0) ? dp[i - 1][j - 1][1] + a[i][j] : a[i][j];\ndp[i][j][2] = (i > 0 && j < m - 1) ? dp[i - 1][j + 1][2] + a[i][j] : a[i][j];\ndp[i][j][3] = (i > 0) ? dp[i - 1][j][3] + a[i][j] : a[i][j];\nint k = min({dp[i][j][1], dp[i][j][2], dp[i][j][3]});\nwhile (k > ans) {\nint x = i - 2 * k + 1;\nint y1 = j - k + 1;\nint y2 = j + k - 1;\nif (x >= 0 && y1 >= 0 && y2 < m && dp[x][y1][2] >= 2 * k && dp[x][y2][1] >= 2 * k) {\nans = k;\n}\nk--;\n}\n}\n}\ncout << ans << endl;\nreturn 0;\n}"
    },
    {
        "problem_tier": 4,
        "solution_code": "#include <iostream>\nusing namespace std;\nint main() {\nint n;\ncin >> n;\nint ans = 0;\nfor (int i = 1; i <= 100; i++) {\nfor (int j = 1; j <= 100 - i; j++) {\nfor (int k = 1; k <= 100 - i - j; k++) {\nif (i >= j + 2 && j != 0 && k != 0 && k % 2 == 0 && i + j + k == n) {\nans++;\n}\n}\n}\n}\ncout << ans << '\\n';\nreturn 0;\n}"
    },
    {
        "problem_tier": 13,
        "solution_code": "#include <iostream>\n#include <vector>\nusing namespace std;\ntypedef long long ll;\nvector<pair<int, pair<ll, ll>>> dungeons;\nbool play(ll hp, ll attack) {\nll curHp = hp;\nll curAttack = attack;\nfor (int i = 0; i < dungeons.size(); i++) {\nint state = dungeons[i].first;\nll dmg = dungeons[i].second.first;\nll monsterHp = dungeons[i].second.second;\nif (state == 1) {             ll turnsToMonsterDie = (monsterHp / curAttack) + (monsterHp % curAttack > 0 ? 1 : 0);\nll turnsToKnightDie = (curHp / dmg) + (curHp % dmg > 0 ? 1 : 0);\nif (turnsToMonsterDie > turnsToKnightDie) {\nreturn false;\n} else {\ncurHp -= dmg * (turnsToMonsterDie - 1);\n}\n} else {             curHp += monsterHp;\nif (curHp > hp) {\ncurHp = hp;\n}\ncurAttack += dmg;\n}\n}\nreturn true;\n}\nll binarySearch() {\nll start = 1;\nll end = 9e18;\nwhile (start <= end) {\nll mid = start + (end - start) / 2;\nif (play(mid, dungeons[0].second.first)) {\nend = mid - 1;\n} else {\nstart = mid + 1;\n}\n}\nreturn start;\n}\nint main() {\nios::sync_with_stdio(0);\ncin.tie(0);\nint N, H_atk;\ncin >> N >> H_atk;\nfor (int i = 0; i < N; i++) {\nint t, a, h;\ncin >> t >> a >> h;\ndungeons.push_back({t, {a, h}});\n}\ncout << binarySearch() << '\\n';\nreturn 0;\n}"
    },
    {
        "problem_tier": 3,
        "solution_code": "#include <iostream>\nusing namespace std;\nint main() {\nint k, w, m;\ncin >> k >> w >> m;\nint cnt = 0;\nwhile (k < w) {\nk += m;\ncnt++;\n}\ncout << cnt << endl;\nreturn 0;\n}"
    },
    {
        "problem_tier": 5,
        "solution_code": "#include <iostream>\nusing namespace std;\nint main() {\nint T;\ncin >> T;\nfor (int i = 0; i < T; i++) {\nlong long num1, num2, result;\nchar cacul, equal;\ncin >> num1 >> cacul >> num2 >> equal >> result;\nif (cacul == '+') {\nif (num1 + num2 == result)\ncout << \"correct\" << endl;\nelse\ncout << \"wrong answer\" << endl;\n}\nelse if (cacul == '-') {\nif (num1 - num2 == result)\ncout << \"correct\" << endl;\nelse\ncout << \"wrong answer\" << endl;\n}\nelse if (cacul == '*') {\nif (num1 * num2 == result)\ncout << \"correct\" << endl;\nelse\ncout << \"wrong answer\" << endl;\n}\nelse if (cacul == '/') {\nif (num1 / num2 == result)\ncout << \"correct\" << endl;\nelse\ncout << \"wrong answer\" << endl;\n}\n}\nreturn 0;\n}"
    },
    {
        "problem_tier": 10,
        "solution_code": "#include<iostream>\n#include<set>\n#include<cstring>\nusing namespace std;\n#define endl '\\n'\nint dy[4]={-1,0,0,+1};\nint dx[4]={0,-1,+1,0};\nenum{N,L,R,S};\nenum{RL,RR};\nint D[4][2]={{L,R},{S,N},{N,S},{R,L}};\nint main(){\nios::sync_with_stdio(false);\ncin.tie(nullptr);\nint L;\ncin>>L;\nstring C;\ncin>>C;\nint cy=0,cx=0;\nint lly,ury,llx,urx;\nlly=ury=cy;\nllx=urx=cx;\nset<pair<int,int>> M;\nM.insert({cy,cx});\nint d=S;\nfor(char c:C){\nswitch(c){\ncase 'R': d=D[d][RR]; break;\ncase 'L': d=D[d][RL]; break;\ncase 'F': cy+=dy[d],cx+=dx[d];\nM.insert({cy,cx});\nlly=min(lly,cy),ury=max(ury,cy);\nllx=min(llx,cx),urx=max(urx,cx);\nbreak;\ndefault: throw runtime_error(\"InvalidCommand\");\n}\n}\nint r=ury-lly+1;\nint c=urx-llx+1;\nchar A[r][c];\nmemset(A,'#',sizeof(A));\nfor(auto[y,x]:M){\nA[y-lly][x-llx]='.';\n}\nfor(int i=0;i<r;i++){\nfor(int j=0;j<c;j++){\ncout<<A[i][j];\n}\ncout<<endl;\n}\nreturn 0;\n}"
    },
    {
        "problem_tier": 12,
        "solution_code": "#include <iostream>\n#include <vector>\n#include <algorithm>\nusing namespace std;\nint main() {\nint N;\ncin >> N;\nvector<int> v(N);\nfor (int i = 0; i < N; i++)\ncin >> v[i];\nvector<int> top;\ntop.push_back(v[0]);\nfor (int i = 1; i < v.size(); i++) {\nbool success = false;\nfor (int j = 0; j < top.size(); j++) {\nif (top[j] - 1 == v[i]) {\nsuccess = true;\ntop[j]--;\nbreak;\n}\n}\nif (!success)\ntop.push_back(v[i]);\n}\ncout << top.size();\nreturn 0;\n}"
    },
    {
        "problem_tier": 7,
        "solution_code": "#include <iostream>\n#include <vector>\nusing namespace std;\nint main() {\nint n, m;\nvector<int> booksWeight;\nint answer = 0, sum = 0;\ncin >> n >> m;\nbooksWeight.resize(n);\nfor (int i = 0; i < n; i++) {\ncin >> booksWeight[i];\n}\nfor (int i = 0; i < booksWeight.size(); i++) {\nint pivot = i;\nsum = 0;\nwhile (1) {\nsum += booksWeight[pivot];\nif (sum > m) {\npivot--;\nbreak;\n}\npivot++;\n}\ni = pivot;\nanswer++;\n}\ncout << answer;\nreturn 0;\n}"
    },
    {
        "problem_tier": 14,
        "solution_code": "#include <iostream>\n#include <vector>\n#include <algorithm>\n#include <queue>\nusing namespace std;\nint N;\nvector<int> graph[100001];\nbool visit[100001];\nint order[100001];\nvector<int> bfs_order;\nbool compare(int& a, int& b){\nreturn order[a] < order[b];\n}\nvoid BFS(int v){\nqueue<int> q;\nq.push(v);\nvisit[v] = true;\nbfs_order.push_back(v);\nwhile(!q.empty()){\nint cur = q.front();\nq.pop();\nfor(int i=0; i<graph[cur].size(); i++){\nif(!visit[graph[cur][i]]){\nvisit[graph[cur][i]] = true;\nq.push(graph[cur][i]);\nbfs_order.push_back(graph[cur][i]);\n}\n}\n}\n}\nvoid Answer(){\ncin >> N;\nfor(int i=0; i<N-1; i++){\nint a, b;\ncin >> a >> b;\ngraph[a].push_back(b);\ngraph[b].push_back(a);\n}\nvector<int> temp(N+1);\nfor(int i=1; i<=N; i++){\ncin >> temp[i];\norder[temp[i]] = i;\n}\nfor(int i=1; i<=N; i++){\nsort(graph[i].begin(), graph[i].end(), compare);\n}\nbfs_order.push_back(0);\nif(temp[1] == 1)\nBFS(1);\nif(bfs_order == temp)\ncout << 1;\nelse\ncout << 0;\n}\nint main(){\nios_base::sync_with_stdio(false);\ncin.tie(NULL);\ncout.tie(NULL);\nAnswer();\nreturn 0;\n}"
    },
    {
        "problem_tier": 5,
        "solution_code": "#include <iostream>\nusing namespace std;\nint main() {\nint n;\ncin >> n;\nn = n / 3 - 2;\nint res = 0;\nfor (int i = 1; i <= n; i++) {\nres += i;\n}\ncout << res;\nreturn 0;\n}"
    },
    {
        "problem_tier": 11,
        "solution_code": "#include <iostream>\n#include <algorithm>\n#include <vector>\nusing namespace std;\n#define MAX 300000\nlong long dp[MAX+2];\nint main(){\nios::sync_with_stdio(NULL);\ncin.tie(NULL);\nint N;\ncin >> N;\nvector<int> v;\nfor(int i=1;;i++){\nint num=i*(i+1)*(i+2)/6;\nif(num>MAX) break;\nv.push_back(num);\n}\nfill(dp, dp+MAX+1, 1e9);\nfor(int i=0; i<v.size(); i++)\ndp[v[i]] = 1;\nfor(int i=0; i<v.size(); i++){\nfor(int j=v[i]; j<=N; j++){\ndp[j] = min(dp[j], dp[j-v[i]]+1);\n}\n}\ncout << dp[N];\nreturn 0;\n}"
    },
    {
        "problem_tier": 17,
        "solution_code": "#include <iostream>\n#include <vector>\n#include <queue>\n#include <memory.h>\nusing namespace std;\n#define MIN 0\n#define MAX 2e9\n#define EMPTY 0\nstruct Node {\nint x, y;\n};\ninline int min(int& A, int& B) {\nreturn A < B ? A : B;\n}\ninline int max(int& A, int& B) {\nreturn A > B ? A : B;\n}\nconst int dx[] = { 0, 0, -1, 1 };\nconst int dy[] = { 1, -1, 0, 0 };\nconst int MAX_N = 100 + 5;\nint N, K, ans;\nint map[MAX_N][MAX_N];\nvoid input() {\nscanf(\"%d%d\", &N, &K);\nfor (int i = 1; i <= N; i++) {\nscanf(\"%d\", &map[N][i]);\n}\n}\nvoid addFish() {\nvector<Node> vec;\nint minVal = MAX;\nfor (int x = 1; x <= N; x++) {\nfor (int y = 1; y <= N; y++) {\nif (map[x][y] == EMPTY)\ncontinue;\nif (map[x][y] < minVal) {\nminVal = map[x][y];\nvec.clear();\nvec.push_back({ x, y });\n}\nelse if (map[x][y] == minVal) {\nvec.push_back({ x, y });\n}\n}\n}\nfor (int i = 0; i < vec.size(); ++i) {\nmap[vec[i].x][vec[i].y]++;\n}\n}\nvoid roll() {\nint pivot, w, h;\npivot = w = h = 1;\nfor (int idx = 0;;++idx) {\nif (pivot - 1 + w + h > N)\nbreak;\nfor (int c = pivot; c < pivot + w; c++) {\nfor (int r = N; r > N - h; r--) {\nint nextR = (N - w) + (c - pivot);\nint nextC = (pivot + w) + (N - r);\nmap[nextR][nextC] = map[r][c];\nmap[r][c] = EMPTY;\n}\n}\npivot += (idx"
    },
    {
        "problem_tier": 7,
        "solution_code": "#include <iostream>\n#include <vector>\n#include <string>\nusing namespace std;\nint stroke[26] = {3,2,1,2,3,3,2,3,3,2,2,1,2,2,1,2,2,2,1,2,1,1,1,2,2,1};\nint main(){\nios_base::sync_with_stdio(0);\ncin.tie(0);\ncout.tie(0);\nstring a, b;\ncin >> a >> b;\nvector<int> v;\nfor(int i=0;i<a.length();i++){\nv.push_back(stroke[a[i]-'A']);\nv.push_back(stroke[b[i]-'A']);\n}\nwhile(true){\nvector<int> tmp;\nfor(int i=0;i<v.size()-1;i++)\ntmp.push_back((v[i]+v[i+1])%10);\nv=tmp;\nif(v.size()<=2)\nbreak;\n}\ncout << v[0] << v[1];\nreturn 0;\n}"
    },
    {
        "problem_tier": 4,
        "solution_code": "#include <iostream>\nusing namespace std;\nint main() {\nint n;\nint maxNum = -1;\ncin >> n;\nfor (int i = 0; i < n; i++) {\nint num;\ncin >> num;\nif (num > maxNum) {\nmaxNum = num;\n}\n}\ncout << maxNum << endl;\nreturn 0;\n}"
    },
    {
        "problem_tier": 3,
        "solution_code": "#include <iostream>\n#include <vector>\nusing namespace std;\nint main() {\nint t;\ncin >> t;\ncout << \"Gnomes:\\n\";\nwhile (t--) {\nvector<int> lst(3);\nfor (int i = 0; i < 3; i++)\ncin >> lst[i];\nif ((lst[1] - lst[0]) * (lst[2] - lst[1]) > 0)\ncout << \"Ordered\\n\";\nelse\ncout << \"Unordered\\n\";\n}\nreturn 0;\n}"
    },
    {
        "problem_tier": 3,
        "solution_code": "#include <iostream>\n#include <algorithm>\nusing namespace std;\nint main() {\nint a[3];\nbool f1 = false, f2 = false;\ncin >> a[0] >> a[1] >> a[2];\nsort(a, a + 3);\nif (a[0] == a[1] && a[1] == a[2])\nf1 = true;\nif (a[2] * a[2] == a[0] * a[0] + a[1] * a[1])\nf2 = true;\nif (!f1 && !f2)\ncout << 0;\nelse if (!f1 && f2)\ncout << 1;\nelse if (f1 && !f2)\ncout << 2;\nreturn 0;\n}"
    },
    {
        "problem_tier": 4,
        "solution_code": "#include <iostream>\n#include <vector>\nusing namespace std;\nint main() {\nint n, ballPos, k, ans = 0;\ncin >> n >> ballPos >> k;\nvector<int> cups(n + 1);\nfor(int i = 1; i <= n; i++){\ncups[i] = i;\n}\nfor(int i = 0; i < k; i++){\nint a, b;\ncin >> a >> b;\nswap(cups[a], cups[b]);\n}\nfor(int i = 1; i <= n; i++){\nif(cups[i] == ballPos){\nans = i;\nbreak;\n}\n}\ncout << ans << endl;\nreturn 0;\n}"
    },
    {
        "problem_tier": 18,
        "solution_code": "#include <iostream>\n#include <vector>\n#include <algorithm>\n#include <cstring>\n#include <stack>\nusing namespace std;\nvector<vector<int>> graph;\nvector<vector<int>> re_graph;\nvector<int> scc;\nstack<int> s;\nbool visit[20005];\nvoid dfs(int x) {\nvisit[x] = true;\nfor (int next : graph[x]) {\nif (!visit[next]) {\ndfs(next);\n}\n}\ns.push(x);\n}\nvoid re_dfs(int x, int y) {\nvisit[x] = true;\nscc[x] = y;\nfor (int next : re_graph[x]) {\nif (!visit[next]) {\nre_dfs(next, y);\n}\n}\n}\nint re(int x, int N) {\nreturn x > N ? x - N : x + N;\n}\nint main() {\nios_base::sync_with_stdio(false);\ncin.tie(0);\ncout.tie(0);\nint N, M;\ncin >> N >> M;\ngraph.resize(2 * N + 5);\nre_graph.resize(2 * N + 5);\nscc.resize(2 * N + 5);\nfor (int i = 0; i < M; i++) {\nint u, v;\ncin >> u >> v;\nif (u < 0) u = -u + N;\nif (v < 0) v = -v + N;\ngraph[re(u, N)].push_back(v);\ngraph[re(v, N)].push_back(u);\nre_graph[u].push_back(re(v, N));\nre_graph[v].push_back(re(u, N));\n}\nfor (int i = 1; i <= 2 * N + 1; i++) {\nif (!visit[i]) dfs(i);\n}\nmemset(visit, false, sizeof(visit));\nint idx = 1;\nwhile (!s.empty()) {\nint x = s.top();\ns.pop();\nif (!visit[x]) {\nre_dfs(x, idx++);\n}\n}\nfor (int i = 1; i <= N; i++) {\nif (scc[i] == scc[i + N]) {\ncout << 0 << '\\n';\nreturn 0;\n}"
    },
    {
        "problem_tier": 8,
        "solution_code": "#include <iostream>\n#include <algorithm>\n#include <vector>\n#define endl '\\n'\nusing namespace std;\nbool isPrime(int num) {\nif(num < 2) return false;\nfor(int i=2; i*i<=num; i++) {\nif(num % i == 0) return false;\n}\nreturn true;\n}\nint main() {\nios::sync_with_stdio(false);\ncin.tie(NULL);\ncout.tie(NULL);\nint arr[1000];\nfor(int i=0; i<1000; i++) {\nif(isPrime(i)) {\narr[i] = 1;\n}\nelse {\narr[i] = 0;\n}\n}\nint n;\ncin >> n;\nint cnt = 0;\nint a[3] = {0};\nfor(a[0]=2; a[0]<1000; a[0]++) {\nif(arr[a[0]] == 1) continue;\nfor(a[1]=2; a[1]<1000; a[1]++) {\nif(arr[a[1]] == 1) continue;\nfor(a[2]=2; a[2]<1000; a[2]++) {\nif(arr[a[2]] == 1) continue;\nif(a[0]+a[1]+a[2] == n) {\ncnt++;\nsort(a, a+3);\nfor(int k=0; k<3; k++) {\ncout << a[k] << \" \";\n}\ncout << endl;\n}\n}\nif(cnt > 0) break;\n}\nif(cnt > 0) break;\n}\nif(cnt == 0) cout << 0 << endl;\nreturn 0;\n}"
    },
    {
        "problem_tier": 5,
        "solution_code": "#include<iostream>\n#include<string>\n#define endl \"\\n\"\nusing namespace std;\nvoid Answer(){\nint T;\ncin >> T;\nwhile(T--){\nstring s;\ncin >> s;\nint temp = 0;\nif(s[0] == 'P'){\ncout << \"skipped\" << endl;\n}\nelse{\nstring a = \"\";\nfor(int i=0; i<s.size(); i++){\nif(s[i] == '+'){\ntemp += stoi(a);\na = \"\";\n}\nelse{\na += s[i];\n}\n}\ntemp += stoi(a);\ncout << temp << endl;\n}\n}\n}\nint main(){\nios_base::sync_with_stdio(false);\ncin.tie(NULL);\ncout.tie(NULL);\nAnswer();\n}"
    },
    {
        "problem_tier": 14,
        "solution_code": "#include <iostream>\n#include <cstring>\n#include <algorithm>\nusing namespace std;\nint n;\nint arr[5001];\nint dp[5001][5001];\nint solved(int started, int ended) {\nif (started == ended || started > ended)\nreturn 0;\nint& ret = dp[started][ended];\nif (ret != -1)\nreturn ret;\nret = 0;\nif (arr[started] == arr[ended])\nret += solved(started + 1, ended - 1);\nelse {\nret += min(solved(started, ended - 1) + 1, solved(started + 1, ended) + 1);\n}\nreturn ret;\n}\nint main() {\ncin >> n;\nfor (int i = 0; i < n; i++)\ncin >> arr[i];\nmemset(dp, -1, sizeof(dp));\nint result = solved(0, n - 1);\ncout << result << endl;\nreturn 0;\n}"
    },
    {
        "problem_tier": 6,
        "solution_code": "#include<iostream>\n#include<stdio.h>\nusing namespace std;\nint main() {\nint A, B;\ncin >> A >> B;\ncout << int(A/B) << \".\";\nA = A % B;\nfor(int i = 0; i <= 1000; i++) {\nA *= 10;\ncout << A/B;\nA = A - (A/B) * B;\n}\nreturn 0;\n}"
    },
    {
        "problem_tier": 3,
        "solution_code": "#include <iostream>\n#include <string>\nusing namespace std;\nint main() {\nint n;\nstring s;\ncin >> n >> s;\ncout << s.substr(s.size() - 5);\nreturn 0;\n}"
    },
    {
        "problem_tier": 20,
        "solution_code": "#include<bits/stdc++.h>\nusing namespace std;\nstruct A{\nint num, idx;\n};\nbool cmp(const A& a, const A& b){\nreturn a.num < b.num;\n}\nint main(){\nint n, m, i, j, cnt, start, _end, k;\nscanf(\"%d%d\", &n, &m);\nA a[5000001];\nfor(i=0; i<n; i++){\nscanf(\"%d\", &a[i].num);\na[i].idx = i+1;\n}\nsort(a, a+n, cmp);\nfor(i=0; i<m; i++){\nscanf(\"%d%d%d\", &start, &_end, &k);\ncnt = 0;\nfor(j=0; j<n; j++){\nif(start <= a[j].idx && a[j].idx <= _end)\ncnt++;\nif(cnt == k){\nprintf(\"%d\\n\", a[j].num);\nbreak;\n}\n}\ncnt = 0;\n}\nreturn 0;\n}"
    },
    {
        "problem_tier": 11,
        "solution_code": "#include <iostream>\n#include <vector>\nusing namespace std;\nint gcd(int a, int b){\nint c;\nwhile(b){\nc = a % b;\na = b;\nb = c;\n}\nreturn a;\n}\nint main(){\nint d1, d2, tmp, ans = 0;\nvector<vector<bool>> v;\nscanf(\"%d %d\", &d1, &d2);\nv.resize(d2 + 1);\nfor(int i = 1; i < d1; i++){\nv[i].resize(d2 + 1);\n}\nfor(int i = d1; i <= d2; i++){\nv[i].resize(d2 + 1);\nfor(int j = 1; j <= i; j++){\ntmp = gcd(i, j);\nif(!v[j / tmp][i / tmp]){\nv[j / tmp][i / tmp] = true;\nans++;\n}\n}\n}\nprintf(\"%d\", ans);\nreturn 0;\n}"
    },
    {
        "problem_tier": 11,
        "solution_code": "#include <iostream>\n#include <vector>\n#include <algorithm>\n#include <cmath>\nusing namespace std;\nint n, bead, x;\nint weight[14];\nint ans, sum;\nbool dp[14][2600001];\nvoid solve(int i, int w) {\nif (i > n || dp[i][w])\nreturn;\ndp[i][w] = true;\nsolve(i + 1, w + weight[i]);\nsolve(i + 1, abs(w - weight[i]));\nsolve(i + 1, w);\n}\nint main() {\ncin >> n;\nfor (int i = 0; i < n; i++) {\ncin >> weight[i];\nsum += weight[i];\n}\nsolve(0, 0);\nfor (int i = 1; i <= sum; i++)\nif (dp[n][i] == false)\nans++;\ncout << ans;\nreturn 0;\n}"
    },
    {
        "problem_tier": 18,
        "solution_code": "#include <iostream>\n#include <vector>\n#include <algorithm>\nusing namespace std;\nstruct Point {\nint x, y;\nPoint(int x, int y) : x(x), y(y) {}\n};\nbool cmpY(const Point& a, const Point& b) {\nreturn a.y > b.y;\n}\nbool cmp(const Point& a, const Point& b) {\nreturn a.x < b.x || (a.x == b.x && a.y < b.y);\n}\nvector<Point> arr;\nvector<int> compressed;\nvector<int> seg;\nvoid compress() {\nsort(arr.begin(), arr.end(), cmpY);\ncompressed.clear();\nint rank = -1, prev = INT_MAX;\nfor (const Point& p : arr) {\nif (prev != p.y) {\nrank++;\n}\ncompressed.push_back(rank);\nprev = p.y;\n}\nsort(arr.begin(), arr.end(), cmp);\n}\nint query(int cur, int left, int right, int qlo, int qhi) {\nif (right < qlo || qhi < left) {\nreturn 0;\n}\nif (qlo <= left && right <= qhi) {\nreturn seg[cur];\n}\nint mid = (left + right) / 2;\nint leftSum = query(cur * 2, left, mid, qlo, qhi);\nint rightSum = query(cur * 2 + 1, mid + 1, right, qlo, qhi);\nreturn leftSum + rightSum;\n}\nvoid update(int cur, int left, int right, int pos) {\nif (right < pos || pos < left) {\nreturn;\n}\nif (left == right) {\nseg[cur]++;\nreturn;\n}\nint mid = (left + right) / 2;\nupdate(cur * 2, left, mid, pos);\nupdate(cur * 2 + 1, mid + 1, right, pos);\nseg[cur] = seg[cur * 2] + seg[cur * 2 + 1];\n}\nlong long solve() {\nlong long answer = 0;\nseg.clear();\nseg.resize(arr.size() * 4 + 4, 0);\nfor (const Point& p : arr) {\nanswer += query(1, 0, compressed.size() - 1, 0, p.y);\nupdate(1, 0, compressed.size() - 1, p.y);\n}\nreturn answer;\n}\nint main() {\nios_base::sync_with_stdio(false);\ncin.tie(NULL);\ncout.tie(NULL);\nint t;\ncin >> t;\nwhile (t--) {\nint n;\ncin >> n;\narr.clear();\narr.resize(n);\nfor (int i = 0; i < n; i++) {\nint x, y;\ncin >> x >> y;\narr[i] = Point(x, y);\n}\ncompress();\ncout << solve() << \"\\n\";\n}\nreturn 0;\n}"
    },
    {
        "problem_tier": 17,
        "solution_code": "#include<iostream>\n#include<cstring>\n#include<queue>\n#define endl \"\\n\"\n#define MAX 100\nusing namespace std;\nint N, Max_Value, Min_Value;\nint MAP[MAX][MAX];\nbool Visit[MAX][MAX];\nint dx[] = { 0, 0, 1, -1 };\nint dy[] = { 1, -1, 0, 0 };\nvoid Input() {\nMax_Value = -1;\nMin_Value = 500;\ncin >> N;\nfor (int i = 0; i < N; i++)\n{\nfor (int j = 0; j < N; j++)\n{\ncin >> MAP[i][j];\nif (MAP[i][j] > Max_Value) Max_Value = MAP[i][j];\nif (MAP[i][j] < Min_Value) Min_Value = MAP[i][j];\n}\n}\n}\nbool BFS(int Diff) {\nqueue<pair<int, int>> Q;\nfor (int i = Min_Value; i <= Max_Value; i++)\n{\nmemset(Visit, true, sizeof(Visit));\nfor (int j = 0; j < N; j++)\n{\nfor (int k = 0; k < N; k++)\n{\nif (i <= MAP[j][k] && MAP[j][k] <= i + Diff) Visit[j][k] = false;\n}\n}\nQ.push(make_pair(0, 0));\nwhile (Q.empty() == 0)\n{\nint x = Q.front().first;\nint y = Q.front().second;\nQ.pop();\nif (Visit[x][y] == true) continue;\nVisit[x][y] = true;\nif (x == N - 1 && y == N - 1) return true;\nfor (int i = 0; i < 4; i++)\n{\nint nx = x + dx[i];\nint ny = y + dy[i];\nif (nx >= 0 && ny >= 0 && nx < N && ny < N)\n{\nQ.push(make_pair(nx, ny));\n}\n}\n}\n}\nreturn false;\n}\nvoid Solution() {\nint Start = 0;\nint End = Max_Value - Min_Value;\nint Mid;\nwhile (Start <= End)\n{\nMid = (Start + End) / 2;\nif (BFS(Mid) == true) End = Mid - 1;         else Start = Mid + 1;     }\ncout << End + 1 << endl;\n}\nvoid Solve() {\nInput();\nSolution();\n}\nint main(void) {\nios::sync_with_stdio(false);\ncin.tie(NULL);\ncout.tie(NULL);\nSolve();\nreturn 0;\n}"
    },
    {
        "problem_tier": 4,
        "solution_code": "#include <iostream>\n#include <string>\n#include <algorithm>\nusing namespace std;\nint main() {\nstring s;\nwhile (1) {\ngetline(cin, s);\nif (s == \"***\")\nbreak;\nreverse(s.begin(), s.end());\ncout << s << '\\n';\n}\nreturn 0;\n}"
    },
    {
        "problem_tier": 15,
        "solution_code": "#include <iostream>\nusing namespace std;\nint main() {\nios_base::sync_with_stdio(false);\ncin.tie(NULL);\ncout.tie(NULL);\nlong long int n;\ncin >> n;\nn = n % 5;\nif (n == 0 || n == 2)\ncout << \"CY\";\nelse\ncout << \"SK\";\nreturn 0;\n}"
    },
    {
        "problem_tier": 5,
        "solution_code": "#include <iostream>\n#include <cstring>\n#include <queue>\nusing namespace std;\nint T, N, W, H;\nint res;\nint map[20][20];\nbool chk[20][20];\nint copyMap[20][20];\nint num[5];\nint dy[] = {-1, 0, 1, 0};\nint dx[] = {0, 1, 0, -1};\nvoid bomb(int n) {\nqueue<pair<int, int>> q1;\nfor (int i = 0; i < H; i++) {\nif (map[i][n] != 0) {\nq1.push({i, n});\nchk[i][n] = true;\nbreak;\n}\n}\nwhile (!q1.empty()) {\nint y = q1.front().first;\nint x = q1.front().second;\nq1.pop();\nint range = map[y][x];\nmap[y][x] = 0;\nfor (int j = 1; j < range; j++) {\nfor (int i = 0; i < 4; i++) {\nint ny = y + dy[i] * j;\nint nx = x + dx[i] * j;\nif (ny < 0 || nx < 0 || ny >= H || nx >= W) continue;\nif (map[ny][nx] != 0 && !chk[ny][nx]) {\nchk[ny][nx] = true;\nq1.push({ny, nx});\n}\n}\n}\n}\nfor (int j = 0; j < W; j++) {\nint cnt = H - 1;\nfor (int i = H - 1; i >= 0; i--) {\nif (map[i][j] != 0) {\nint temp = map[i][j];\nmap[i][j] = 0;\nmap[cnt][j] = temp;\ncnt--;\n}\n}\n}\n}\nvoid count() {\nint temp = 0;\nfor (int i = 0; i < H; i++) {\nfor (int j = 0; j < W; j++) {\nif (map[i][j] != 0) {\ntemp++;\n}\n}\n}\nif (res > temp) res = temp;\n}\nvoid dfs(int cnt) {\nif (res == 0) return;\nif (cnt == N) {\nmemcpy(map, copyMap, sizeof(map));\nfor (int i = 0; i < N; i++) {\nmemset(chk, false, sizeof(chk));\nbomb(num[i]);\ncount();\n}\nreturn;\n}\nfor (int i = 0; i < W; i++) {\nnum[cnt] = i;\ndfs(cnt + 1);\n}\n}\nvoid solve() {\ncin >> N >> W >> H;\nres = W * H;\nfor (int i = 0; i < H; i++) {\nfor (int j = 0; j < W; j++) {\ncin >> copyMap[i][j];\n}\n}\ndfs(0);\n}\nint main() {\nfreopen(\"input.txt\", \"r\", stdin);\ncin >> T;\nfor (int i = 1; i <= T; i++) {\nsolve();\ncout << \"#\" << i << \" \" << res << \"\\n\";\n}\nreturn 0;\n}"
    },
    {
        "problem_tier": 6,
        "solution_code": "#include <iostream>\n#include <cmath>\nusing namespace std;\nint reverse(int x) {\nint rev = 0;\nwhile (x > 0) {\nrev = rev * 2 + (x % 2);\nx /= 2;\n}\nreturn rev;\n}\nint solve(int x) {\nreturn reverse(x);\n}\nint main() {\nint n;\ncin >> n;\nint result = solve(n);\ncout << result << endl;\nreturn 0;\n}"
    },
    {
        "problem_tier": 14,
        "solution_code": "#include <iostream>\n#include <vector>\nusing namespace std;\nint main() {\nint N;\ncin >> N;\nvector<long long> DP(N + 1);\nDP[1] = 0;\nDP[2] = 1;\nDP[3] = 2;\nfor (int i = 4; i <= N; i++) {\nDP[i] = ((DP[i - 1] + DP[i - 2]) * (i - 1)) % 1000000000;\n}\ncout << DP[N];\nreturn 0;\n}"
    },
    {
        "problem_tier": 4,
        "solution_code": "#include<iostream>\n#include<vector>\n#include<algorithm>\nusing namespace std;\nint minFunc(int a, int b, int c) {\nvector<int> num = {a, b, c};\nsort(num.begin(), num.end());\nreturn num[0];\n}\nint main()\n{\nint a, b;\nint c;\ncin >> a >> b;\nwhile (a != 0 && b != 0) {\nif (a > b) {\nint temp = a;\na = b;\nb = temp;\n}\nc = minFunc(2*a - b, (a+b)/2, 2*b - a);\ncout << c << \"\\n\";\ncin >> a >> b;\n}\n}"
    },
    {
        "problem_tier": 3,
        "solution_code": "#include <iostream>\nusing namespace std;\nint main() {\nint K, D, A;\nscanf(\"%d/%d/%d\", &K, &D, &A);\nif (K+A < D || !D) {\nprintf(\"hasu\");\n}\nelse {\nprintf(\"gosu\");\n}\nreturn 0;\n}"
    },
    {
        "problem_tier": 11,
        "solution_code": "#include <iostream>\nusing namespace std;\nbool isPrime(int n) {\nif (n <= 1) return false;\nif (n == 2) return true;\nif (n % 2 == 0) return false;\nfor (int i = 3; i * i <= n; i += 2) {\nif (n % i == 0) return false;\n}\nreturn true;\n}\nint main() {\nint n;\ncin >> n;\nint count = 0;\nfor (int i = 2; i <= n; i++) {\nif (isPrime(i)) count++;\n}\ncout << count << endl;\nreturn 0;\n}"
    },
    {
        "problem_tier": 5,
        "solution_code": "#include <iostream>\n#include <vector>\nusing namespace std;\nint main() {\nint n, l, d;\ncin >> n >> l >> d;\nvector<int> songs;      for (int i = 0; i < n; i++) {\nfor (int j = 0; j < l; j++) {\nsongs.push_back(1);          }\nfor (int j = 0; j < 5; j++) {\nsongs.push_back(0);          }\n}\nint idx = 0;      while (true) {\nif (idx >= songs.size()) {\ncout << idx << endl;\nbreak;\n}\nif (songs[idx] == 0) {\nidx += d;          } else {\ncout << idx << endl;\nbreak;\n}\n}\nreturn 0;\n}"
    },
    {
        "problem_tier": 3,
        "solution_code": "#include <iostream>\n#include <algorithm>\nusing namespace std;\nint main() {\nint a[3];\nfor(int i=0; i<3; i++)\ncin >> a[i];\nsort(a, a+3);\ncout << a[1] + a[2];\nreturn 0;\n}"
    },
    {
        "problem_tier": 10,
        "solution_code": "#include<iostream>\n#include<algorithm>\n#include<cstring>\nusing namespace std;\nint N, B, K;\nbool map[100001];\nint main() {\nios::sync_with_stdio(false);\ncin.tie(NULL);\nint now;\nint ans = 100000;\nmemset(map, false, sizeof(map));\ncin >> N >> K >> B;\nfor(int i = 1; i <= B; i++) {\ncin >> now;\nmap[now] = true;\n}\nfor(int i = 1; i <= N - K + 1; i++) {\nint how_many_broken = 0;\nfor(int j = i; j < i + K; j++) {\nif(map[j] == true)\nhow_many_broken++;\n}\nans = min(how_many_broken, ans);\n}\ncout << ans;\nreturn 0;\n}"
    },
    {
        "problem_tier": 5,
        "solution_code": "#include<iostream>\n#include<string>\nusing namespace std;\nint main() {\nint N, flag = 0;\nstring bf, af;\ncin >> N;\ncin >> bf >> af;\nfor (int i = 0; i < bf.size(); ++i) {\nif ((bf.at(i) == af.at(i))^!(N&1)) {\ncout << \"Deletion failed\" << endl;\nflag = 1;\nbreak;\n}\n}\nif (flag == 0)\ncout << \"Deletion succeeded\" << endl;\n}"
    },
    {
        "problem_tier": 13,
        "solution_code": "#include <iostream>\n#include <vector>\n#include <algorithm>\n#define ll long long int\nusing namespace std;\nll sum[100001];\nint main() {\nios_base::sync_with_stdio(false);\ncin.tie(0);\nll N;\ncin >> N;\nvector<pair<ll, ll>> v;\nfor (int i = 0; i < N; i++) {\nll a, b;\ncin >> a >> b;\nv.push_back({a, b});\n}\nsort(v.begin(), v.end());\nsum[0] = v[0].second;\nfor (int i = 1; i < N; i++) {\nsum[i] = sum[i - 1] + v[i].second;\n}\nll start = 0, end = N - 1;\nll idx = 1e9;\nwhile (start <= end) {\nll mid = (start + end) / 2;\nif (sum[mid] >= sum[N - 1] - sum[mid]) {\nend = mid - 1;\nidx = min(idx, v[mid].first);\n}\nelse {\nstart = mid + 1;\n}\n}\ncout << idx;\nreturn 0;\n}"
    },
    {
        "problem_tier": 19,
        "solution_code": "#include <iostream>\n#include <vector>\n#include <algorithm>\n#include <cstring>\nusing namespace std;\nint N;\nint arr[51];\nint dp[51][250001];\nint solve(int index, int diff) {\nif (diff > 250000) return -1e9;\nif (index == N) return diff ? -1e9 : 0;\nint& ret = dp[index][diff];\nif (ret != -1) return ret;\nret = -1e9;\nret = max(ret, solve(index + 1, diff));\nret = max(ret, arr[index] + solve(index + 1, diff + arr[index]));\nif (diff >= arr[index]) ret = max(ret, solve(index + 1, diff - arr[index]) + arr[index]);\nelse ret = max(ret, arr[index] - diff + solve(index + 1, arr[index] - diff));\nreturn ret;\n}\nint main() {\nmemset(dp, -1, sizeof(dp));\ncin >> N;\nfor (int i = 0; i < N; i++) {\ncin >> arr[i];\n}\nint ans = solve(0, 0);\ncout << (ans ? ans : -1) << '\\n';\nreturn 0;\n}"
    },
    {
        "problem_tier": 9,
        "solution_code": "#include <iostream>\n#include <string>\n#include <map>\nusing namespace std;\nint main() {\nint T;\ncin >> T;\nwhile (T--) {\nstring buffer;\ngetline(cin, buffer);\nstring origin;\ngetline(cin, origin);\nmap<string, bool> m;\nwhile (true) {\nstring a, b, c;\ncin >> a >> b >> c;\nif (a == \"what\" && b == \"does\" && c == \"the\") {\ncin >> c;                 break;\n}\nm[c] = true;\n}\nstring res = \"\";\nfor (int i = 0; i < origin.size(); i++) {\nif (origin[i] == ' ') {\nif (!m[res]) {\ncout << res << \" \";\n}\nres = \"\";\n} else {\nres += origin[i];\n}\n}\nif (!m[res]) {\ncout << res << \" \";\n}\ncout << endl;\n}\nreturn 0;\n}"
    },
    {
        "problem_tier": 7,
        "solution_code": "#include <iostream>\n#include <vector>\nusing namespace std;\nvector<int> getNotation(int num, int b) {\nint tmp = num;\nvector<int> notationB;\nwhile (tmp) {\nnotationB.push_back(tmp % b);\ntmp /= b;\n}\nreturn notationB;\n}\nbool canMakePalindrome(vector<int> notationB) {\nint sz = notationB.size();\nfor (int i = 0; i < sz / 2; i++)\nif (notationB[i] != notationB[sz - i - 1])\nreturn false;\nreturn true;\n}\nint main() {\nint t, num;\ncin >> t;\nwhile (t--) {\ncin >> num;\nint isValid = 0;\nfor (int b = 2; b <= 64; b++) {\nvector<int> notationB = getNotation(num, b);\nif (canMakePalindrome(notationB)) {\nisValid = 1;\nbreak;\n}\n}\ncout << isValid << '\\n';\n}\nreturn 0;\n}"
    },
    {
        "problem_tier": 7,
        "solution_code": "#include <iostream>\n#include <cstdio>\n#include <queue>\n#include <algorithm>\n#include <functional>\nusing namespace std;\npriority_queue<double> pq;\nint main() {\nint n;\nscanf(\"%d\", &n);\nfor (int i = 0; i < n; i++) {\ndouble val;\nscanf(\"%lf\", &val);\nif (pq.size() >= 7) {\nif (pq.top() > val) {\npq.pop();\npq.push(val);\n}\n}\nelse\npq.push(val);\n}\nvector<double> vc;\nwhile (!pq.empty()) {\nvc.push_back(pq.top());\npq.pop();\n}\nreverse(vc.begin(), vc.end());\nfor (auto i : vc)\nprintf(\"%.3lf\\n\", i);\nreturn 0;\n}"
    },
    {
        "problem_tier": 9,
        "solution_code": "#include<iostream>\nusing namespace std;\nint dp[51];\nint main() {\nint n;\ncin >> n;\ndp[0] = 1;\ndp[1] = 1;\nfor(int i=2; i<=n; i++){\ndp[i] = (1 + dp[i-2] + dp[i-1]) % 1000000007;\n}\ncout << dp[n];\nreturn 0;\n}"
    },
    {
        "problem_tier": 2,
        "solution_code": "#include <iostream>\nusing namespace std;\nint main() {\nios::sync_with_stdio(false);\ncin.tie(nullptr);\nint x;\ncin >> x;\nint hours = 24 * x;\ncout << hours << \"\\n\";\nreturn 0;\n}"
    },
    {
        "problem_tier": 7,
        "solution_code": "#include <iostream>\nusing namespace std;\nint main() {\nint n;\ncin >> n;\nint count = 0;\nfor (int i = 1; i <= n; i++) {\nfor (int j = i; j <= n; j++) {\nint k = n - (i + j);\nif (i < j + k && j < i + k && k < i + j && j <= k) {\ncount++;\n}\nif (j > k) {\nbreak;\n}\n}\n}\ncout << count;\nreturn 0;\n}"
    },
    {
        "problem_tier": 6,
        "solution_code": "#include <iostream>\n#include <vector>\n#include <string>\nusing namespace std;\nvoid printZoomedArt(vector<string>& art, int zr, int zc) {\nint r_size = art.size();\nint c_size = art[0].length();\nvector<string> zoomedArt(r_size * zr, string(c_size * zc, ' '));\nfor (int i = 0; i < r_size; i++) {\nfor (int j = 0; j < c_size; j++) {\nchar t = art[i][j];\nfor (int a = 0; a < zr; a++) {\nfor (int b = 0; b < zc; b++) {\nzoomedArt[i * zr + a][j * zc + b] = t;\n}\n}\n}\n}\nfor (int i = 0; i < r_size * zr; i++) {\ncout << zoomedArt[i] << endl;\n}\n}\nint main() {\nint r, c, zr, zc;\ncin >> r >> c >> zr >> zc;\nvector<string> article(r);\nfor (int i = 0; i < r; i++) {\ncin >> article[i];\n}\nprintZoomedArt(article, zr, zc);\nreturn 0;\n}"
    },
    {
        "problem_tier": 18,
        "solution_code": "#include<iostream>\n#include<algorithm>\n#include<vector>\n#include<queue>\n#include<cstring>\n#include<string>\n#define INF 987654321\nusing namespace std;\nchar map[11][11], copy_map[11][11];\nint dx[4] = {1, 0, -1, 0};\nint dy[4] = {0, 1, 0, -1};\nvoid turn_on(int x, int y) {\nif(copy_map[x][y] == 'O')\ncopy_map[x][y] = '#';\nelse\ncopy_map[x][y] = 'O';\nfor(int i=0; i<4; i++) {\nint xx = x + dx[i];\nint yy = y + dy[i];\nif(xx >= 0 && xx < 10 && yy >= 0 && yy < 10) {             if(copy_map[xx][yy] == 'O')\ncopy_map[xx][yy] = '#';\nelse\ncopy_map[xx][yy] = 'O';\n}\n}\n}\nvoid reset_map() {\nfor(int i=0; i<10; i++) {\nfor(int j=0; j<10; j++) {\ncopy_map[i][j] = map[i][j];\n}\n}\n}\nbool all_light_on() {\nfor(int i=0; i<10; i++) {\nfor(int j=0; j<10; j++) {\nif(copy_map[i][j] == 'O')\nreturn false;\n}\n}\nreturn true;\n}\nvoid solve() {\nint ans = INF;\nfor(int step=0; step<(1<<10); step++) {         int cnt = 0;\nreset_map();\nfor(int i=0; i<10; i++) {             if(step & (1<<i)) {\ncnt++;\nturn_on(0, i);\n}\n}\nfor(int i=1; i<10; i++) {             for(int j=0; j<10; j++) {\nif(copy_map[i-1][j] == 'O') {\nturn_on(i, j);\ncnt++;\n}\n}\n}\nif(all_light_on())\nans = min(ans, cnt);\n}\nif(ans == INF)\ncout << \"-1\";\nelse\ncout << ans;\n}\nint main() {\ncin.tie(0);\ncout.tie(0);\nfor(int i=0; i<10; i++) {\nfor(int j=0; j<10; j++) {\ncin >> map[i][j];\n}\n}\nsolve();\nreturn 0;\n}"
    },
    {
        "problem_tier": 19,
        "solution_code": "#include <iostream>\n#include <vector>\n#include <algorithm>\nusing namespace std;\nvector<int> tree[400001];\nvoid update(int pos, int val, int node, int left, int right) {\nif (pos < left || pos > right)\nreturn;\ntree[node].push_back(val);\nint mid = (left + right) / 2;\nif (left != right) {         update(pos, val, node * 2, left, mid);\nupdate(pos, val, node * 2 + 1, mid + 1, right);\n}\n}\nint query(int L, int R, int node, int k, int left, int right) {\nif (R < left || right < L)\nreturn 0;\nif (L <= left && right <= R)\nreturn tree[node].end() - upper_bound(tree[node].begin(), tree[node].end(), k);\nint mid = (left + right) / 2;\nreturn query(L, R, node * 2, k, left, mid) + query(L, R, node * 2 + 1, k, mid + 1, right);\n}\nint main() {\nios_base::sync_with_stdio(0);\ncin.tie(0);\nint N;\ncin >> N;\nfor (int i = 1; i <= N; i++) {\nint temp;\ncin >> temp;\nupdate(i, temp, 1, 1, N);     }\nfor (int i = 0; i <= N * 4; i++)\nsort(tree[i].begin(), tree[i].end());\nint M;\ncin >> M;\nwhile (M--) {\nint i, j, k;\ncin >> i >> j >> k;\ncout << query(i, j, 1, k, 1, N) << \"\\n\";\n}\nreturn 0;\n}"
    },
    {
        "problem_tier": 4,
        "solution_code": "#include <iostream>\nusing namespace std;\nint main() {\nint n, ans = 0;\ncin >> n;\nfor (int i = 1; i <= n; i++) {\nif (n % i == 0) {\nans += i;\n}\n}\ncout << ans * 5 - 24 << '\\n';\nreturn 0;\n}"
    },
    {
        "problem_tier": 4,
        "solution_code": "#include <iostream>\n#include <string>\n#include <iomanip>\nusing namespace std;\ndouble getConvertedWeight(double weight, string unit) {\nif (unit == \"kg\") {\nunit = \"lb\";\nreturn weight * 2.2046;\n}\nif (unit == \"lb\") {\nunit = \"kg\";\nreturn weight * 0.4536;\n}\nif (unit == \"l\") {\nunit = \"g\";\nreturn weight * 0.2642;\n}\nunit = \"l\";\nreturn weight * 3.7854;\n}\nint main() {\nint t;\ncin >> t;\nwhile (t--) {\ndouble weight;\nstring unit;\ncin >> weight >> unit;\ncout << fixed;\ncout.precision(4);\ncout << getConvertedWeight(weight, unit) << unit << '\\n';\n}\nreturn 0;\n}"
    },
    {
        "problem_tier": 4,
        "solution_code": "#include <iostream>\nusing namespace std;\nint getFactorial(int n) {\nint result = 1;\nfor (int i = 1; i <= n; i++) {\nresult *= i;\n}\nreturn result;\n}\nint getFactorialSum(int n) {\nint sum = 0, count = 1;\nwhile (n) {\nsum += (n % 10) * getFactorial(count++);\nn /= 10;\n}\nreturn sum;\n}\nint main() {\nios_base::sync_with_stdio(0);\ncin.tie(0);\ncout.tie(0);\nwhile (1) {\nint n, ans = 0;\ncin >> n;\nif (!n) break;\ncout << getFactorialSum(n) << '\\n';\n}\nreturn 0;\n}"
    },
    {
        "problem_tier": 11,
        "solution_code": "#include <iostream>\n#include <string>\n#include <map>\n#include <vector>\n#include <algorithm>\nusing namespace std;\nint N, K;\nvector<string> ans;\nvoid backtracking(int idx, int m, int num, string op) {\nif (idx == m) {\nif (num == N)\nans.push_back(op.substr(1, op.size() - 1));\nreturn;\n}\nbacktracking(idx + 1, m, num + 1, op + \"+1\");\nbacktracking(idx + 1, m, num + 2, op + \"+2\");\nbacktracking(idx + 1, m, num + 3, op + \"+3\");\n}\nint main() {\ncin >> N >> K;\nfor (int i = 1; i <= N; i++)\nbacktracking(0, i, 0, \"\");\nsort(ans.begin(), ans.end());\nif (ans.size() >= K)\ncout << ans[K - 1];\nelse\ncout << \"-1\";\nreturn 0;\n}"
    },
    {
        "problem_tier": 6,
        "solution_code": "#include<iostream>\nusing namespace std;\nstring num[8] = {\n\"000000\",\n\"001111\",\n\"010011\",\n\"011100\",\n\"100110\",\n\"101001\",\n\"110101\",\n\"111010\"\n};\nint main(void) {\nint N;\ncin >> N;\nstring str, result(\"\");\ncin >> str;\nfor (int i = 0; i < N; i++) {\nint check = 0;\nfor (int j = 0; j < 8; j++) {\nint count = 0;\nfor (int k = 0; k < 6; k++) {\nif (str[k] != num[j][k]) {\ncount++;\nif (count > 1) break;\n}\n}\nif (count == 0 || count == 1) {\nresult += j + 65;                 check = 1;                 break;\n}\n}\nif (check == 0) {\ncout << i + 1 << \"\\n\";             return 0;\n}"
    },
    {
        "problem_tier": 4,
        "solution_code": "#include <iostream>\nusing namespace std;\nint main() {\nint a1, a2, b1, b2;\ncin >> a1 >> a2;\ncin >> b1 >> b2;\nwhile (true) {\na2 -= b1;\nb2 -= a1;\nif (a2 < 1 || b2 < 1) {\nbreak;\n}\n}\nif (a2 < 1 && b2 < 1) {\ncout << \"DRAW\" << endl;\n} else {\ncout << \"PLAYER \" << (a2 > b2 ? 'A' : 'B') << endl;\n}\nreturn 0;\n}"
    },
    {
        "problem_tier": 3,
        "solution_code": "#include <iostream>\n#include <cmath>\nusing namespace std;\nint main() {\ndouble side;\ncin >> side;\ndouble perimeter = sqrt(side) * 4;\nprintf(\"%.8f\", perimeter);\nreturn 0;\n}"
    },
    {
        "problem_tier": 13,
        "solution_code": "#include <iostream>\n#include <cmath>\nusing namespace std;\ndouble x, y, c;\ndouble func(double mid) {\ndouble h1 = sqrt(x*x - mid*mid);\ndouble h2 = sqrt(y*y - mid*mid);\nreturn (h1 * h2) / (h1 + h2);\n}\nint main() {\ncin >> x >> y >> c;\ndouble low = 0;\ndouble high = min(x, y);\ndouble result = 0;\nwhile(high - low > 0.000001) {\ndouble mid = (low + high) / 2.0;\nif(func(mid) >= c) {\nresult = mid;\nlow = mid;\n} else {\nhigh = mid;\n}\n}\nprintf(\"%.3lf\\n\", result);\nreturn 0;\n}"
    },
    {
        "problem_tier": 16,
        "solution_code": "#include<bits/stdc++.h>\nusing namespace std;\nint n;\nint ret = INT_MAX;\nint a[24];\nvoid func(int cur) {\nif(cur == n+1) {\nint sum = 0;\nfor(int i=1; i<=(1<<(n-1)); i*=2) {\nint cnt = 0;\nfor(int j=1; j<=n; j++) {\nif(a[j] & i) cnt++;\n}\nsum += min(cnt, n-cnt);\n}\nret = min(ret, sum);\nreturn;\n}\na[cur] = ~a[cur];\nfunc(cur+1);\na[cur] = ~a[cur];\nfunc(cur+1);\n}\nint main() {\nios_base::sync_with_stdio(false);\ncin.tie(NULL);\ncout.tie(NULL);\ncin >> n;\nfor(int i=1; i<=n; i++) {\nstring s;\ncin >> s;\nint v = 1;\nfor(int j=0; j<s.size(); j++) {\nif(s[j] == 'T') a[i] |= v;\nv *= 2;\n}\n}\nfunc(1);\ncout << ret;\nreturn 0;\n}"
    },
    {
        "problem_tier": 9,
        "solution_code": "#include<iostream>\nusing namespace std;\nint main() {\nint k, c;\ncin >> k >> c;\nfor (int i = 0; i < c; i++) {\nint a, b;\ncin >> a >> b;\nint restRound = k - max(a, b);\nif ((a >= b && a - restRound - b > 2) || (a < b && b - restRound - a > 1)) {\ncout << \"0\\n\";\n} else {\ncout << \"1\\n\";\n}\n}\nreturn 0;\n}"
    },
    {
        "problem_tier": 10,
        "solution_code": "#include <iostream>\n#include <queue>\n#include <string.h>\nusing namespace std;\nint sum;\nchar arr[102][102];\nbool check[102][102];\nqueue<pair<int,int>> q;\npair<int,int> p[4] = {{1,0},{-1,0},{0,1},{0,-1}};\nvoid bfs() {\nwhile (!q.empty()) {\npair<int,int> pp = q.front();\nq.pop();\nfor (int i = 0; i < 4; i++) {\nif (arr[pp.first + p[i].first][pp.second + p[i].second] == '#' && check[pp.first + p[i].first][pp.second + p[i].second] == true) {\nq.push(make_pair(pp.first + p[i].first, pp.second + p[i].second));\ncheck[pp.first + p[i].first][pp.second + p[i].second] = false;\n}\n}\n}\nsum++;\nreturn;\n}\nint main() {\nios_base::sync_with_stdio(false);\ncin.tie(NULL);\nint t;\nint x = 1, y = 1;\ncin >> t;\nwhile (t--) {\ncin >> y >> x;\nsum = 0;\nmemset(arr, 0, sizeof(char) * 102);\nmemset(check, true, sizeof(bool) * 102);\nfor (int j = 1; j <= y; j++) {\nfor (int i = 1; i <= x; i++) {\ncin >> arr[j][i];\n}\n}\nfor (int j = 1; j <= y; j++) {\nfor (int i = 1; i <= x; i++) {\nif (arr[j][i] == '#' && check[j][i] == true) {\nq.push(make_pair(j, i));\ncheck[j][i] = false;\nbfs();\n}\n}\n}\ncout << sum << '\\n';\n}\nreturn 0;\n}"
    },
    {
        "problem_tier": 12,
        "solution_code": "#include<iostream>\n#include<algorithm>\n#include<string>\n#include<vector>\nusing namespace std;\nint main() {\nint T;\ncin >> T;\nfor (int t = 0; t < T; t++) {\nstring str;\ncin >> str;\nint K;\ncin >> K;\nint minLen = INT_MAX;\nint maxLen = 0;\nvector<int> cnt(26, 0);\nvector<int> pos[26];\nfor (int i = 0; i < str.length(); i++) {\ncnt[str[i] - 'a']++;\npos[str[i] - 'a'].push_back(i);\n}\nfor (int i = 0; i < 26; i++) {\nif (cnt[i] < K) continue;\nfor (int j = 0; j <= cnt[i] - K; j++) {\nint len = pos[i][j + K - 1] - pos[i][j] + 1;\nminLen = min(minLen, len);\nmaxLen = max(maxLen, len);\n}\n}\nif (minLen == INT_MAX) cout << -1 << \"\\n\";\nelse cout << minLen << \" \" << maxLen << \"\\n\";\n}\nreturn 0;\n}"
    },
    {
        "problem_tier": 19,
        "solution_code": "#include<bits/stdc++.h>\nusing namespace std;\nint main() {\nint R, C;\ncin >> R >> C;\nint pleasure[R][C];\nfor(int i=0; i<R; i++){\nfor(int j=0; j<C; j++){\ncin >> pleasure[i][j];\n}\n}\nstring move = \"\";\npair<int, int> minPos = make_pair(0, 0);\nint minPleasure = pleasure[0][0];\nfor(int i=0; i<R; i++){\nfor(int j=0; j<C; j++){\nif((i+j) % 2 == 1 && pleasure[i][j] < minPleasure){\nminPos = make_pair(i, j);\nminPleasure = pleasure[i][j];\n}\n}\n}\nif(R % 2 == 1){\nfor(int i=0; i<R; i++){\nfor(int j=0; j<C-1; j++){\nif(i % 2 == 0){\nmove += \"R\";                 } else {\nmove += \"L\";                 }\n}\nif(i != R-1){\nmove += \"D\";             }\n}\n}\nelse if(C % 2 == 1){\nfor(int i=0; i<C; i++){\nfor(int j=0; j<R-1; j++){\nif(i % 2 == 0){\nmove += \"D\";                 } else {\nmove += \"U\";"
    },
    {
        "problem_tier": 19,
        "solution_code": "#include <iostream>\n#include <cstring>\n#define MAX 100005\n#define ll long long\nusing namespace std;\nint p[MAX];\nll dist[MAX];\nint find(int node) {\nif (p[node] == -1)\nreturn node;\nint parent = find(p[node]);\ndist[node] += dist[p[node]];\nreturn p[node] = parent;\n}\nvoid merge(int a, int b, int w) {\nint roota = find(a);\nint rootb = find(b);\nif (roota == rootb)\nreturn;\ndist[rootb] = dist[a] - dist[b] + w;\np[rootb] = roota;\nreturn;\n}\nint main() {\nios_base::sync_with_stdio(0);\ncin.tie(0);\ncout.tie(0);\nwhile (1) {\nmemset(p, -1, sizeof(p));\nmemset(dist, 0, sizeof(dist));\ncin >> N >> M;\nif (N == 0 && M == 0)\nbreak;\nchar op;\nint a, b, w;\nfor (int i = 0; i < M; i++) {\ncin >> op;\nif (op == '!') {\ncin >> a >> b >> w;\nmerge(a, b, w);\n}\nelse {\ncin >> a >> b;\nif (find(a) != find(b)) {\ncout << \"UNKNOWN\\n\";\n}\nelse {\ncout << dist[b] - dist[a] << \"\\n\";\n}\n}\n}\n}\nreturn 0;\n}"
    },
    {
        "problem_tier": 14,
        "solution_code": "#include <iostream>\n#include <queue>\n#include <algorithm>\nusing namespace std;\n#define MAX 100\nint N;\nchar Map[MAX][MAX];\nint Dist[MAX][MAX][4];\npair<int, int> Start, End;\nqueue<pair<pair<int, int>, int>> Q;\nint dx[] = {0, 1, 0, -1};\nint dy[] = {1, 0, -1, 0};\npair<int, int> getNext(int dir) {\nint nx, ny;\nif (dir == 0) {\nnx = Start.first - 1;\nny = Start.second;\n}\nelse if (dir == 1) {\nnx = Start.first;\nny = Start.second + 1;\n}\nelse if (dir == 2) {\nnx = Start.first + 1;\nny = Start.second;\n}\nelse {\nnx = Start.first;\nny = Start.second - 1;\n}\nreturn make_pair(nx, ny);\n}\nvoid BFS() {\nwhile (!Q.empty()) {\nint x = Q.front().first.first;\nint y = Q.front().first.second;\nint dir = Q.front().second;\nQ.pop();\nif (x == End.first && y == End.second) {\nreturn;\n}\nint nx, ny;\nnx = x + dx[dir];\nny = y + dy[dir];\nif (nx < 0 || ny < 0 || nx >= N || ny >= N) {\ncontinue;\n}\nif (Map[nx][ny] == '.') {\nif (Dist[nx][ny][dir] > Dist[x][y][dir]) {\nDist[nx][ny][dir] = Dist[x][y][dir];\nQ.push(make_pair(make_pair(nx, ny), dir));\n}\n}\nelse if (Map[nx][ny] == '#') {\ncontinue;\n}\nelse if (Map[nx][ny] == '!') {\nif (Dist[nx][ny][dir] > Dist[x][y][dir]) {\nDist[nx][ny][dir] = Dist[x][y][dir];\nQ.push(make_pair(make_pair(nx, ny), dir));\n}\npair<int, int> next1 = getNext((dir + 1) % 4);\npair<int, int> next2 = getNext((dir + 3) % 4);\nif (Dist[next1.first][next1.second][dir] > Dist[x][y][dir] + 1) {\nDist[next1.first][next1.second][dir] = Dist[x][y][dir] + 1;\nQ.push(make_pair(next1, dir));\n}\nif (Dist[next2.first][next2.second][dir] > Dist[x][y][dir] + 1) {\nDist[next2.first][next2.second][dir] = Dist[x][y][dir] + 1;\nQ.push(make_pair(next2, dir));\n}\n}\n}\n}\nint main() {\ncin >> N;\nfor (int i = 0; i < N; i++) {\ncin >> Map[i];\nfor (int j = 0; j < N; j++) {\nif (Map[i][j] == '#') {\nif (Start.first == 0 && Start.second == 0) {\nStart = make_pair(i, j);\n}\nelse {\nEnd = make_pair(i, j);\n}\n}\nDist[i][j][0] = Dist[i][j][1] = Dist[i][j][2] = Dist[i][j][3] = 10000000;\n}\n}\nfor (int i = 0; i < 4; i++) {\nQ.push(make_pair(Start, i));\nDist[Start.first][Start.second][i] = 0;\n}\nBFS();\nint answer = 10000000;\nfor (int i = 0; i < 4; i++) {\nanswer = min(answer, Dist[End.first][End.second][i]);\n}\ncout << answer << endl;\nreturn 0;\n}"
    },
    {
        "problem_tier": 15,
        "solution_code": "#include<iostream>\n#include<vector>\n#include<queue>\n#include<algorithm>\nusing namespace std;\n#define INF 1000000000\nint parent[1001];\nstruct Edge{\nint start;\nint end;\nint cost;\n};\nbool operator<(Edge x, Edge y){\nreturn x.cost > y.cost;\n}\npriority_queue<Edge, vector<Edge>> arr;\nint find(int x){\nif(parent[x] == x)\nreturn x;\nreturn parent[x] = find(parent[x]);\n}\nvoid merge(int x, int y){\nx = find(x);\ny = find(y);\nif(x == y) return;\nparent[y] = x;\n}\nbool isUnion(int x, int y){\nx = find(x);\ny = find(y);\nif(x == y)\nreturn true;\nreturn false;\n}\nint main(){\nint n, m, k;\ncin >> n >> m >> k;\nvector<int> tmp;\nfor(int i=0; i<1001; i++)\nparent[i] = i;\nfor(int i=0; i<k; i++){\nint x;\ncin >> x;\ntmp.push_back(x);\n}\nfor(int i=1; i<k; i++)\nmerge(tmp[i-1], tmp[i]);\nfor(int i=0; i<m; i++){\nint a, b, c;\ncin >> a >> b >> c;\narr.push({a, b, c});\n}\nint sum = 0;\nwhile(!arr.empty()){\nif(!isUnion(arr.top().start, arr.top().end)){\nsum += arr.top().cost;\nmerge(arr.top().start, arr.top().end);\n}\narr.pop();\n}\ncout << sum;\nreturn 0;\n}"
    },
    {
        "problem_tier": 2,
        "solution_code": "#include <iostream>\nusing namespace std;\nint main() {\nint n;\ncin >> n;\nfor (int i = 0; i < n; i++) {\nint num;\ncin >> num;\ncout << num << \" \" << num << \"\\n\";\n}\nreturn 0;\n}"
    },
    {
        "problem_tier": 22,
        "solution_code": "#include <iostream>\n#include <vector>\nusing namespace std;\nint main() {\nios_base::sync_with_stdio(false);\ncin.tie(0);\ncout.tie(0);\nint n;\ncin >> n;\nvector<int> v(n+2);\nfor (int i = 1; i <= n; i++) {\ncin >> v[i];\n}\nint ans = 0;\nfor (int i = 1; i <= n; i++) {\nif (v[i+1] > v[i+2]) {\nint a = min(v[i], v[i+1]-v[i+2]);\nans += 5 * a;\nv[i] -= a;\nv[i+1] -= a;\nint b = min(v[i], min(v[i+1], v[i+2]));\nans += 7 * b;\nv[i] -= b;\nv[i+1] -= b;\nv[i+2] -= b;\n} else {\nint b = min(v[i], min(v[i+1], v[i+2]));\nans += 7 * b;\nv[i] -= b;\nv[i+1] -= b;\nv[i+2] -= b;\nint a = min(v[i], v[i+1]);\nans += 5 * a;\nv[i] -= a;\nv[i+1] -= a;\n}\nans += 3 * v[i];\n}\ncout << ans << \"\\n\";\nreturn 0;\n}"
    },
    {
        "problem_tier": 13,
        "solution_code": "#include <iostream>\n#include <vector>\n#include <map>\nusing namespace std;\nint main() {\nint n;\ncin >> n;\nvector<int> sequence(n, 0);\nfor (int i = 0; i < n; i++) {\ncin >> sequence[i];\n}\nint start = 0;\nint end = 1;\nmap<int, bool> bomb;\nbomb[sequence[start]] = true;\nlong long answer = 1;\nwhile (start < end && sequence.size() > end) {\nif (bomb[sequence[end]] == true) {\nbomb.erase(sequence[start]);\nstart++;\n}\nif (bomb[sequence[end]] == false && sequence.size() > end) {\nbomb[sequence[end]] = true;\nanswer += bomb.size();\nend++;\n}\n}\ncout << answer << endl;\nreturn 0;\n}"
    },
    {
        "problem_tier": 9,
        "solution_code": "#include <iostream>\n#include <vector>\n#include <queue>\n#include <algorithm>\nusing namespace std;\nint main() {\nint n, m;\ncin >> n >> m;\nvector<int> point;\nfor (int i = 0; i < n; i++) {\nint p, l;\ncin >> p >> l;\nvector<int> v(p);\nfor (int j = 0; j < p; j++) {\ncin >> v[j];\n}\nif (p < l) {\npoint.push_back(1);\n} else {\nsort(v.begin(), v.end());\npoint.push_back(v[p-l]);\n}\n}\nsort(point.begin(), point.end());\nint cnt = 0;\nfor (auto& i : point) {\nif (m >= i) {\ncnt++;\nm -= i;\n}\n}\ncout << cnt;\nreturn 0;\n}"
    },
    {
        "problem_tier": 19,
        "solution_code": "#include <iostream>\n#include <vector>\nusing namespace std;\nint N, M;\nvector<int> arr, tree, lazy;\nint init(int node, int start, int end) {\nif (start == end) {\nreturn tree[node] = arr[start];\n}\nint mid = (start + end) / 2;\nreturn tree[node] = init(node * 2, start, mid) ^ init(node * 2 + 1, mid + 1, end);\n}\nvoid propa(int node, int start, int end) {\nif (lazy[node] != 0) {\nif ((end - start + 1) % 2 == 1) {\ntree[node] ^= lazy[node];\n}\nif (start != end) {\nlazy[node * 2] ^= lazy[node];\nlazy[node * 2 + 1] ^= lazy[node];\n}\nlazy[node] = 0;\n}\n}\nvoid update(int node, int start, int end, int left, int right, int val) {\npropa(node, start, end);\nif (right < start || end < left) return;\nif (left <= start && end <= right) {\nlazy[node] ^= val;\npropa(node, start, end);\nreturn;\n}\nint mid = (start + end) / 2;\nupdate(node * 2, start, mid, left, right, val);\nupdate(node * 2 + 1, mid + 1, end, left, right, val);\ntree[node] = tree[node * 2] ^ tree[node * 2 + 1];\n}\nint query(int node, int start, int end, int left, int right) {\npropa(node, start, end);\nif (right < start || end < left) return 0;\nif (left <= start && end <= right) {\nreturn tree[node];\n}\nint mid = (start + end) / 2;\nint res1 = query(node * 2, start, mid, left, right);\nint res2 = query(node * 2 + 1, mid + 1, end, left, right);\nreturn res1 ^ res2;\n}\nint main() {\nios_base::sync_with_stdio(false);\ncin.tie(NULL);\ncin >> N;\narr.resize(N + 1);\ntree.resize(4 * N + 1);\nlazy.resize(4 * N + 1);\nfor (int i = 1; i < N + 1; i++) {\ncin >> arr[i];\n}\ninit(1, 1, N);\ncin >> M;\nint op, a, b, c;\nfor (int i = 0; i < M; i++) {\ncin >> op;\nif (op == 1) {\ncin >> a >> b >> c;\nupdate(1, 1, N, a + 1, b + 1, c);\n} else {\ncin >> a >> b;\ncout << query(1, 1, N, a + 1, b + 1) << \"\\n\";\n}\n}\nreturn 0;\n}"
    },
    {
        "problem_tier": 3,
        "solution_code": "#include<iostream>\nusing namespace std;\nint main() {\nint A, B, C, D;\ncin >> A >> B >> C >> D;\nif ((A == 8 || A == 9) && (D == 8 || D == 9) && (B == C))\ncout << \"ignore\" << endl;\nelse\ncout << \"answer\" << endl;\nreturn 0;\n}"
    },
    {
        "problem_tier": 8,
        "solution_code": "#include <iostream>\n#include <vector>\nusing namespace std;\nint n, m;\nvector<int> lamp;\nint binarySearch() {\nint start = 0;\nint end = n;\nint mid;\nwhile (start + 1 < end) {\nbool check = false;\nmid = (start + end) / 2;\nif (lamp[0] > mid)\ncheck = true;\nfor (int i = 0; i < m-1; i++) {\nif (lamp[i+1] - lamp[i] > mid * 2) {\ncheck = true;\nbreak;\n}\n}\nif (n - lamp[m-1] > mid)\ncheck = true;\nif (check)\nstart = mid;\nelse\nend = mid;\n}\nreturn end;\n}\nint main() {\nios_base::sync_with_stdio(false);\ncin.tie(0);\ncout.tie(0);\ncin >> n >> m;\nfor (int i = 0; i < m; i++) {\nint light;\ncin >> light;\nlamp.push_back(light);\n}\ncout << binarySearch();\nreturn 0;\n}"
    },
    {
        "problem_tier": 5,
        "solution_code": "#include <iostream>\n#include <unordered_set>\nusing namespace std;\nint main() {\nint current, base;\ncin >> current >> base;\nunordered_set<int> dates;\nfor(int i = 0; i < current; i++) {\nint date;\ncin >> date;\ndates.insert(date);\n}\nint count = 0;\nfor(int i = 0; i < base; i++) {\nint date;\ncin >> date;\nif(dates.find(date) != dates.end()) {\ncount++;\n}\n}\ncout << count << endl;\nreturn 0;\n}"
    },
    {
        "problem_tier": 7,
        "solution_code": "#include<iostream>\n#include<string>\nusing namespace std;\nvoid compare(string s, string t) {\nint piv = 0;\nstring tmp;\nfor (int i = 0; i < t.size(); i++) {\nif (piv < s.size() && t[i] == s[piv])\ntmp += t[i], piv++;\n}\nif (tmp == s)\ncout << \"Yes\\n\";\nelse\ncout << \"No\\n\";\n}\nint main(){\nstring s, t;\nwhile(cin >> s >> t) {\ncompare(s, t);\n}\nreturn 0;\n}"
    },
    {
        "problem_tier": 4,
        "solution_code": "#include <iostream>\n#include <algorithm>\n#include <cmath>\nusing namespace std;\nint main() {\nint x1, y1, x2, y2;\nint x3, y3, x4, y4;\ncin >> x1 >> y1 >> x2 >> y2;\ncin >> x3 >> y3 >> x4 >> y4;\nint X = max(x2, x4) - min(x1, x3);\nint Y = max(y2, y4) - min(y1, y3);\nint A = max(X, Y);\ncout << A * A << '\\n';\nreturn 0;\n}"
    },
    {
        "problem_tier": 13,
        "solution_code": "#include <iostream>\n#include <algorithm>\nusing namespace std;\n#define MOD 1000000\nint N;\nint dp[2][3][1001]; int ans = 0;\nint main() {\nios::sync_with_stdio(false);\ncin.tie(NULL);\ncin >> N;\ndp[0][0][1] = 1;\ndp[1][0][1] = 1;\ndp[0][1][1] = 1;\nfor (int i = 2; i <= N; i++) {\ndp[0][0][i] = dp[0][0][i-1] + dp[0][1][i-1] + dp[0][2][i-1];\ndp[0][1][i] = dp[0][0][i-1];\ndp[0][2][i] = dp[0][1][i-1];\ndp[1][0][i] = dp[0][0][i-1] + dp[0][1][i-1] + dp[0][2][i-1] + dp[1][0][i-1] + dp[1][1][i-1] + dp[1][2][i-1];\ndp[1][1][i] = dp[1][0][i-1];\ndp[1][2][i] = dp[1][1][i-1];\nfor (int j = 0; j < 2; j++) {\nfor (int k = 0; k < 3; k++) {\ndp[j][k][i] %= MOD;\n}\n}\n}\nfor (int j = 0; j < 2; j++) {\nfor (int k = 0; k < 3; k++) {\nans += dp[j][k][N];\n}\n}\nans %= MOD;\ncout << ans << '\\n';\nreturn 0;\n}"
    },
    {
        "problem_tier": 5,
        "solution_code": "#include <iostream>\nusing namespace std;\nint main() {\nint n, k;\nint q, w;\nint a[5] = {0};\nint cnt = 0;\ncin >> n >> k;\nfor (int i = 0; i < n; i++) {\ncin >> q >> w;\nif (w < 3) {\na[0]++;\n} else if (w < 5) {\nif (q) {\na[1]++;\n} else {\na[2]++;\n}\n} else {\nif (q) {\na[3]++;\n} else {\na[4]++;\n}\n}\n}\nfor (int i = 0; i < 5; i++) {\ncnt += a[i] / k + (a[i] % k ? 1 : 0);\n}\ncout << cnt << endl;\nreturn 0;\n}"
    },
    {
        "problem_tier": 8,
        "solution_code": "#include <iostream>\n#include <vector>\n#include <algorithm>\n#include <string>\nusing namespace std;\nint main() {\nint N1 = 0;\nint N2 = 0;\nint T;\ncin >> N1 >> N2;\nstring right, left;\ncin >> right;\ncin >> left;\ncin >> T;\nreverse(right.begin(), right.end());\nstring ant = right + left;\nint time = 0;\nwhile (time < T) {\nfor (int i = 0; i < N1 + N2 - 1; i++) {\nif (right.find(ant[i]) != string::npos && left.find(ant[i+1]) != string::npos) {\nswap(ant[i], ant[i+1]);\ni++;\n}\n}\ntime += 1;\n}\ncout << ant;\nreturn 0;\n}"
    },
    {
        "problem_tier": 4,
        "solution_code": "#include <iostream>\nusing namespace std;\nint main() {\nint t;\ncin >> t;\nwhile (t--) {\nint n;\ncin >> n;\nint sum = 0;\nfor (int i = 1; i <= n; i += 2) {\nsum += i;\n}\ncout << sum << \"\\n\";\n}\nreturn 0;\n}"
    },
    {
        "problem_tier": 10,
        "solution_code": "#include<iostream>\n#include<cmath>\n#include<vector>\n#include<cstring>\nusing namespace std;\nbool isPrime(int num) {\nif(num == 0 || num == 1)\nreturn false;\nfor(int i=2;i*i<=num;i++) {\nif(num % i == 0)\nreturn false;\n}\nreturn true;\n}\nint main() {\nios::sync_with_stdio(false);\ncin.tie(NULL);\ncout.tie(NULL);\nint K;\ncin >> K;\nint cnt = 0;\nint num = 1;\nwhile(cnt < K) {\nnum++;\nif(isPrime(num))\ncnt++;\n}\ncout << num << endl;\nreturn 0;\n}"
    },
    {
        "problem_tier": 10,
        "solution_code": "#include <iostream>\n#include <algorithm>\n#include <vector>\nusing namespace std;\nint main() {\nint n;\ncin >> n;\nvector<int> arr(n);\nvector<int> dp(n, 1);\nfor (int i = 0; i < n; i++) {\ncin >> arr[i];\n}\nint ans = dp[0];\nfor (int i = 1; i < n; i++) {\nfor (int j = 0; j < i; j++) {\nif (arr[j] < arr[i]) {\ndp[i] = max(dp[i], dp[j] + 1);\n}\n}\nans = max(ans, dp[i]);\n}\ncout << ans << endl;\nreturn 0;\n}"
    },
    {
        "problem_tier": 5,
        "solution_code": "#include <iostream>\nusing namespace std;\nint main() {\nint k;\ncin >> k;\nfor (int i = 0; i < k; i++) {\ncout << \"1\";\n}\nfor (int i = 0; i < k - 1; i++) {\ncout << \"0\";\n}\nreturn 0;\n}"
    },
    {
        "problem_tier": 4,
        "solution_code": "#include <iostream>\nusing namespace std;\nint main() {\nint t;\ncin >> t;\nwhile (t--) {\nint n, d, ans = 0;\ncin >> n >> d;\nwhile (n--) {\nint vi, fi, ci;\ncin >> vi >> fi >> ci;\nif (vi * fi / ci >= d)\nans++;\n}\ncout << ans << '\\n';\n}\nreturn 0;\n}"
    },
    {
        "problem_tier": 9,
        "solution_code": "#include <iostream>\n#include <queue>\nusing namespace std;\nint main() {\nios_base::sync_with_stdio(0);\ncin.tie(0);\ncout.tie(0);\nint n;\ncin >> n;\npriority_queue<int> pq;\nwhile (n--) {\nint a;\ncin >> a;\nif (a == 0) {\nif (pq.empty()) {\ncout << -1 << \"\\n\";\n} else {\ncout << pq.top() << \"\\n\";\npq.pop();\n}\n} else {\nwhile (a--) {\nint tmp;\ncin >> tmp;\npq.emplace(tmp);\n}\n}\n}\nreturn 0;\n}"
    },
    {
        "problem_tier": 15,
        "solution_code": "#include <iostream>\n#include <vector>\n#include <cstring>\n#include <fstream>\n#include <algorithm>\n#include <cmath>\nusing namespace std;\nint money, m;\nint corp[20][301];\nint dp[20][301];\nint maxN[20][301];\nint ans[20];\nvoid reconstruct(int cp, int m) {\nif (cp == -1)\nreturn;\nans[cp] = maxN[cp][m];\nreconstruct(cp-1, m-ans[cp]);\n}\nint main() {\nios_base::sync_with_stdio(false);\ncin.tie(NULL);\ncout.tie(NULL);\ncin >> money >> m;\nfor (int i = 1; i <= money; i++) {\nfor (int j = 0; j <= m; j++) {\nint a;\ncin >> a;\nif (j == 0)\ncontinue;\ncorp[j-1][i] = a;\n}\n}\nfor (int i = 0; i < m; i++) {\nfor (int j = 1; j <= money; j++) {\nif (i == 0) {\ndp[i][j] = corp[i][j];\nmaxN[i][j] = j;\n} else {\nint ret = 0;\nfor (int k = 0; k <= j; k++) {\nif (ret < corp[i][k] + dp[i-1][j-k]) {\nret = corp[i][k] + dp[i-1][j-k];\nmaxN[i][j] = k;\n}\n}\ndp[i][j] = ret;\n}\n}\n}\ncout << dp[m-1][money] << endl;\nreconstruct(m-1, money);\nfor (int i = 0; i < m; i++)\ncout << ans[i] << \" \";\nreturn 0;\n}"
    },
    {
        "problem_tier": 4,
        "solution_code": "#include <iostream>\n#include <vector>\nusing namespace std;\nint main() {\nwhile (1) {\nint age;\ncin >> age;\nif (!age) break;\nvector<int> v(age * 2);\nint leaves = 1;\nfor (int i = 0; i < 2 * age; i++)\ncin >> v[i];\nfor (int i = 0; i < age; i++) {\nint splitingFactor = v[i * 2];\nint cut = v[i * 2 + 1];\nleaves = leaves * splitingFactor - cut;\n}\ncout << leaves << '\\n';\n}\nreturn 0;\n}"
    },
    {
        "problem_tier": 13,
        "solution_code": "#include <iostream>\n#include <vector>\n#include <cstring>\nusing namespace std;\nconst int INF = 987654321;\nint N, M;\nint dp[110][110];\nbool restDay[110];\nint price[3] = {10000, 25000, 37000};\nint solve(int day, int coupon) {\nif (day > N) return 0;\nif (dp[day][coupon] != -1) return dp[day][coupon];\nif (restDay[day]) {\ndp[day][coupon] = solve(day+1, coupon);\n} else {\ndp[day][coupon] = INF;\ndp[day][coupon] = min(dp[day][coupon], solve(day+1, coupon) + price[0]);\ndp[day][coupon] = min(dp[day][coupon], solve(day+3, coupon+1) + price[1]);\ndp[day][coupon] = min(dp[day][coupon], solve(day+5, coupon+2) + price[2]);\nif (coupon >= 3) {\ndp[day][coupon] = min(dp[day][coupon], solve(day+1, coupon-3));\n}\n}\nreturn dp[day][coupon];\n}\nint main() {\nios_base::sync_with_stdio(false);\ncin.tie(0);\nmemset(dp, -1, sizeof(dp));\ncin >> N >> M;\nfor (int i = 0; i < M; i++) {\nint d;\ncin >> d;\nrestDay[d] = true;\n}\ncout << solve(1, 0) << endl;\nreturn 0;\n}"
    },
    {
        "problem_tier": 9,
        "solution_code": "#include <iostream>\n#include <stack>\n#include <string>\nusing namespace std;\nstack<char> s;\nint main() {\nstring k;\ncin >> k;\nint ans = 0;\nfor (int i = 0; i < k.size(); i++) {\nif (!s.empty()) {\nif (s.top() == '(' && k[i] == ')') {\ns.pop();\ncontinue;\n} else {\ns.push(k[i]);\n}\n} else {\nif (k[i] == '(')\ns.push(k[i]);\nelse\nans++;\n}\n}\nans += s.size();\ncout << ans << '\\n';\nreturn 0;\n}"
    },
    {
        "problem_tier": 11,
        "solution_code": "#include <iostream>\n#include <vector>\n#include <algorithm>\nusing namespace std;\nint main() {\nint N, K;\ncin >> N >> K;\nvector<int> dolls;\nfor (int i = 0; i < N; i++) {\nint x;\ncin >> x;\nif (x == 1) {\ndolls.push_back(i);\n}\n}\nif (dolls.size() < K) {\ncout << -1;\nreturn 0;\n}"
    },
    {
        "problem_tier": 11,
        "solution_code": "#include<iostream>\n#include<string>\n#include<algorithm>\nusing namespace std;\nint res;\nint p[27];\nbool check(string& s) {\nint len = s.length();\nfor (int i = 0; i < len - 1; i++) {\nif (s[i] == s[i + 1])\nreturn false;\n}\nreturn true;\n}\nvoid dfs(int idx, string cur) {\nif (idx == origin.size()) {\nres++;\nreturn;\n}\nfor (int i = 0; i < 26; i++) {\nif (p[i] == 0)\ncontinue;\nif (cur != \"\" && cur[cur.size() - 1] == (char)('a' + i))\ncontinue;\np[i]--;\ndfs(idx + 1, cur + (char)('a' + i));\np[i]++;\n}\n}\nint main() {\nios::sync_with_stdio(0);\ncin.tie(0);\nstring origin;\ncin >> origin;\nfor (int i = 0; i < origin.size(); i++)\np[origin[i]-'a']++;\ndfs(0, \"\");\ncout << res;\nreturn 0;\n}"
    },
    {
        "problem_tier": 5,
        "solution_code": "#include <iostream>\nusing namespace std;\nchar correct[10001];\nint N;\nint sum, bonus;\nint main() {\nscanf(\"%d\", &N);\nscanf(\"%s\", correct + 1);\nfor (int i = 1; i <= N; i++) {\nif (correct[i] == 'O') {\nsum += (i + bonus);\nbonus++;\n}\nelse {\nbonus = 0;\n}\n}\nprintf(\"%d\\n\", sum);\nreturn 0;\n}"
    },
    {
        "problem_tier": 17,
        "solution_code": "#include <iostream>\n#include <vector>\n#include <queue>\n#include <algorithm>\n#define INF -987654321\nusing namespace std;\ntypedef struct {\nint u, v, w;\n} edge;\nvector<edge> e;\nint n, m, graph[105][105], city[105], pre[105], s, f;\nlong long dist[105];\nbool visit[105];\nbool dfs(int cur) {\nif (cur == f)\nreturn true;\nvisit[cur] = true;\nbool chk = false;\nfor (auto x : e) {\nif (x.u == cur && !visit[x.v])\nchk |= dfs(x.v);\n}\nreturn chk;\n}\nint main() {\ncin >> n >> s >> f >> m;\nfill(&dist[0], &dist[n + 1], INF);\nfor (int i = 0, u, v, w; i < m; i++) {\ncin >> u >> v >> w;\ne.push_back({u, v, w});\n}\nfor (int i = 0; i < n; i++) {\ncin >> city[i];\n}\ndist[s] = city[s];\npre[s] = -1;\nfor (int k = 0; k < n - 1; k++) {\nfor (auto x : e) {\nif (dist[x.u] != INF && (dist[x.v] < dist[x.u] - x.w + city[x.v]))\ndist[x.v] = dist[x.u] - x.w + city[x.v];\n}\n}\nif (dist[f] == INF)\ncout << \"gg\";\nelse {\nfor (auto x : e) {\nif (dist[x.u] != INF && (dist[x.v] < dist[x.u] - x.w + city[x.v]))\nif (dfs(x.u)) {\ncout << \"Gee\";\nreturn 0;\n}"
    },
    {
        "problem_tier": 3,
        "solution_code": "#include<bits/stdc++.h>\nusing namespace std;\nint main(){\nios::sync_with_stdio(false);\ncin.tie(nullptr);\nint n;\ncin >> n;\nint ans = 0;\nfor(int i=0; i<n; i++){\nstring giftycon;\ncin >> giftycon;\nint dayLeft = stoi(giftycon.substr(2));\nif(dayLeft <= 90)\nans++;\n}\ncout << ans << \"\\n\";\nreturn 0;\n}"
    },
    {
        "problem_tier": 11,
        "solution_code": "#include <iostream>\n#include <queue>\nusing namespace std;\nconst int MAX = 100000 + 1;\nint a, b, n, m;\nbool visited[MAX];\nint stone[MAX];\nint main() {\ncin >> a >> b >> n >> m;\nqueue<int> q;\nvisited[n] = true;\nstone[n] = 0;\nq.push(n);\nwhile (!q.empty()) {\nint curr = q.front();\nq.pop();\nif (curr == m) {\ncout << stone[m];\nbreak;\n}\nint dist[8] = {1, -1, a, b, -a, -b, a, b};\nfor (int i = 0; i < 8; i++) {\nint next = curr + dist[i];\nif (next < 0 || next > 100000) continue;\nif (!visited[next]) {\nvisited[next] = true;\nstone[next] = stone[curr] + 1;\nq.push(next);\n}\n}\n}\nreturn 0;\n}"
    },
    {
        "problem_tier": 3,
        "solution_code": "#include <iostream>\nusing namespace std;\nint main() {\nint winCnt = 0;\nfor (int i = 0; i < 6; i++) {\nchar info;\ncin >> info;\nif (info == 'W')\nwinCnt++;\n}\nif (!winCnt)\ncout << -1;\nelse if (winCnt >= 5)\ncout << 1;\nelse if (winCnt >= 3)\ncout << 2;\nelse\ncout << 3;\nreturn 0;\n}"
    },
    {
        "problem_tier": 10,
        "solution_code": "#include <iostream>\n#include <string>\n#include <unordered_map>\n#include <unordered_set>\nusing namespace std;\nint TimeToMinutes(string time) {\nint hours = stoi(time.substr(0, 2));\nint minutes = stoi(time.substr(3, 2));\nreturn hours * 60 + minutes;\n}\nint main() {\nios_base::sync_with_stdio(0);\ncin.tie(0);\ncout.tie(0);\nstring S, E, Q;\ncin >> S >> E >> Q;\nint startMinutes = TimeToMinutes(S);\nint endMinutes = TimeToMinutes(E);\nint streamingEndMinutes = TimeToMinutes(Q);\nunordered_set<string> entry;\nunordered_map<string, pair<int, int>> names;\nwhile (1) {\nstring time, name;\ncin >> time >> name;\nif (time == \"\" && name == \"\") break;\nint timeMinutes = TimeToMinutes(time);\nif (timeMinutes <= startMinutes) {\nentry.insert(name);\n} else if (timeMinutes >= endMinutes && timeMinutes <= streamingEndMinutes) {\nif (entry.find(name) != entry.end()) {\nnames[name].second = timeMinutes;\n}\n}\n}\nint answer = 0;\nfor (auto it = names.begin(); it != names.end(); it++) {\nint entryTime = it->second.first;\nint exitTime = it->second.second;\nif (exitTime >= endMinutes && exitTime <= streamingEndMinutes) {\nanswer++;\n}\n}\ncout << answer << '\\n';\nreturn 0;\n}"
    },
    {
        "problem_tier": 4,
        "solution_code": "#include <iostream>\nusing namespace std;\nint main() {\nint n, k, sum = 0;\ncin >> n >> k;\nwhile (k--) {\nint mul;\ncin >> mul;\nif (mul % 2 == 0)\nsum += mul / 2;\nelse\nsum += mul / 2 + 1;\n}\nif (sum >= n)\ncout << \"YES\" << '\\n';\nelse\ncout << \"NO\" << '\\n';\nreturn 0;\n}"
    },
    {
        "problem_tier": 7,
        "solution_code": "#include<iostream>\nusing namespace std;\nint main() {\nint N, M;\ncin >> N >> M;\nint arr[101][101] = {0,};\nint sum = 0;\nfor (int i = 0; i < N; i++) {\nint x1, y1, x2, y2;\ncin >> x1 >> y1 >> x2 >> y2;\nfor (int x = x1; x <= x2; x++) {\nfor (int y = y1; y <= y2; y++) {\narr[x][y]++;\n}\n}\n}\nfor (int i = 1; i <= 100; i++) {\nfor (int j = 1; j <= 100; j++) {\nif (arr[i][j] > M) {\nsum++;\n}\n}\n}\ncout << sum << endl;\nreturn 0;\n}"
    },
    {
        "problem_tier": 12,
        "solution_code": "#include<iostream>\n#include<vector>\n#include<algorithm>\n#define ll long long\nusing namespace std;\nint N;\nstring num = \"0123456789\";\nvector<ll> asc;\nvoid backtracking(int idx, string temp){\nif(!temp.empty()){\nstring _temp = temp;\nreverse(_temp.begin(), _temp.end());\nasc.push_back(stoll(_temp));\n}\nfor(int i=idx+1; i<10; i++){\ntemp += num[i];\nbacktracking(i, temp);\ntemp.pop_back();\n}\n}\nint main(){\nios_base::sync_with_stdio(false);\ncin.tie(0);\ncin >> N;\nfor(int i=0; i<10; i++){\nstring temp = \"\";\nbacktracking(i, temp += num[i]);\n}\nsort(asc.begin(), asc.end());\nif(N > asc.size())\ncout << -1;\nelse\ncout << asc[N-1];\nreturn 0;\n}"
    },
    {
        "problem_tier": 5,
        "solution_code": "#include <iostream>\n#include <vector>\n#include <algorithm>\nusing namespace std;\nint main() {\nint n, m;\ncin >> n >> m;\nvector<int> k(m);\nfor (int i = 0; i < m; i++) {\ncin >> k[i];\n}\nint sum = 0;\nbool isChecked[n+1] = {0};\nfor (int i = 0; i < m; i++) {\nfor (int j = k[i]; j <= n; j += k[i]) {\nisChecked[j] = true;\n}\n}\nfor (int i = 1; i <= n; i++) {\nif (isChecked[i]) {\nsum += i;\n}\n}\ncout << sum << endl;\nreturn 0;\n}"
    },
    {
        "problem_tier": 9,
        "solution_code": "#include <iostream>\n#define MOD ((int)1e9+7)\nusing namespace std;\nint d[(int)1e3+1][(int)1e3+1];\nint main() {\nint n, m;\ncin >> n >> m;\nd[0][0] = 1;\nfor (int i = 1; i <= n; i++) {\nfor (int j = 1; j <= m; j++) {\nd[i][j] = d[i-1][j-1];\nd[i][j] += d[i][j-1];\nd[i][j] %= MOD;\nd[i][j] += d[i-1][j];\nd[i][j] %= MOD;\n}\n}\ncout << d[n][m];\nreturn 0;\n}"
    },
    {
        "problem_tier": 12,
        "solution_code": "#include <iostream>\n#include <algorithm>\n#include <cstring>\nusing namespace std;\nint N;\nint p[1001];\nint dp[1001][1001];\nint dfs(int start, int end) {\nif (start == end)\nreturn 0;\nint& res = dp[start][end];\nif (res != -1)\nreturn res;\nres = p[start] - p[end];\nif (res < 0)\nres *= -1;\nfor (int i = start; i < end; i++) {\nres = max(res, dfs(start, i) + dfs(i + 1, end));\n}\nreturn res;\n}\nint main() {\ncin >> N;\nfor (int i = 1; i <= N; i++)\ncin >> p[i];\nmemset(dp, -1, sizeof(dp));\ncout << dfs(1, N);\nreturn 0;\n}"
    },
    {
        "problem_tier": 11,
        "solution_code": "#include <iostream>\n#include <vector>\n#include <cmath>\n#include <algorithm>\nusing namespace std;\ndouble rangeSum(const vector<long long>& psum, int a, int b) {\nif (a == 0) return psum[b];\nreturn psum[b] - psum[a - 1];\n}\ndouble standardDeviation(const vector<long long>& sqpsum, const vector<long long>& psum, int a, int b) {\ndouble mean = rangeSum(psum, a, b) / static_cast<long double>(b - a + 1);\ndouble ret = rangeSum(sqpsum, a, b) - 2 * mean * rangeSum(psum, a, b) + (b - a + 1) * mean * mean;\ndouble variance = ret / (b - a + 1);\nreturn sqrt(variance);\n}\nint main() {\nint N, K;\ncin >> N >> K;\nvector<long long> subsumList;\nvector<long long> sqSubsumList;\nint tmp;\nlong long sum = 0;\nlong long sqSum = 0;\nfor (int i = 0; i < N; i++) {\ncin >> tmp;\nsum += tmp;\nsqSum += static_cast<long long>(tmp) * tmp;\nsubsumList.push_back(sum);\nsqSubsumList.push_back(sqSum);\n}\ndouble min_v = numeric_limits<double>::max();\nfor (int s = 0; s < N; s++) {\nfor (int e = s + K - 1; e < N; e++) {\nmin_v = min(min_v, standardDeviation(sqSubsumList, subsumList, s, e));\n}\n}\ncout << min_v << endl;\nreturn 0;\n}"
    },
    {
        "problem_tier": 17,
        "solution_code": "#include<bits/stdc++.h>\nusing namespace std;\nbool cmp(string a, string b) {\nif (a == b) return a < b;\nstring ab = a + b;\nstring ba = b + a;\nif (ab > ba) return true;\nelse return false;\n}\nint main() {\nios_base::sync_with_stdio(false);\ncin.tie(0);\ncout.tie(0);\nint n;\nvector<string> input;\nbool check = false;\ncin >> n;\nfor (int i = 0; i < n; i++) {\nstring a;\ncin >> a;\ninput.push_back(a);\nif (a != \"0\") check = true;\n}\nif (!check) cout << 0;\nelse {\nsort(input.begin(), input.end(), cmp);\nfor (int i = 0; i < n; i++) {\ncout << input[i];\n}\n}\nreturn 0;\n}"
    },
    {
        "problem_tier": 12,
        "solution_code": "#include<iostream>\n#include<vector>\n#include<algorithm>\ntypedef long long ll;\nusing namespace std;\nint n, m, r;\nint arr[301][301];\nbool visited[301][301];\nint dx[] = {0, 1, 0, -1};\nint dy[] = {1, 0, -1, 0};\nbool changeDir(int x, int y, int d){\nint nx = x + dx[d];\nint ny = y + dy[d];\nif(nx > n || nx < 1 || ny > m || ny < 1)\nreturn true;\nif(visited[nx][ny])\nreturn true;\nreturn false;\n}\nint main(){\nios_base::sync_with_stdio(false);\ncin.tie(nullptr);\ncout.tie(nullptr);\ncin >> n >> m >> r;\nfor(int i=1;i<=n;i++){\nfor(int j=1;j<=m;j++){\ncin >> arr[i][j];\n}\n}\nint cnt = min(n, m) / 2;\nfor(int i=1;i<=cnt;i++){\nint x = i, y = i, d = 0;\nwhile(true){\nif(visited[x][y])\nbreak;\nvisited[x][y] = true;\ndq[i].push_back(arr[x][y]);\nif(changeDir(x, y, d))\nd++;\nx = x + dx[d];\ny = y + dy[d];\nif(d == 4)\nbreak;\n}\n}\nfor(int i=1;i<=cnt;i++){\nint k = r % dq[i].size();\nwhile(k--){\ndq[i].push_back(dq[i].front());\ndq[i].pop_front();\n}\n}\nmemset(visited, false, sizeof(visited));\nfor(int i=1;i<=cnt;i++){\nint x = i, y = i, d = 0, k = 0;\nwhile(true){\nif(visited[x][y])\nbreak;\nvisited[x][y] = true;\narr[x][y] = dq[i][k++];\nif(changeDir(x, y, d))\nd++;\nx = x + dx[d];\ny = y + dy[d];\nif(d == 4)\nbreak;\n}\n}\nfor(int i=1;i<=n;i++){\nfor(int j=1;j<=m;j++){\ncout << arr[i][j] << \" \";\n}\ncout << \"\\n\";\n}\nreturn 0;\n}"
    },
    {
        "problem_tier": 14,
        "solution_code": "#include <iostream>\n#include <vector>\n#include <algorithm>\nusing namespace std;\nconst int INF = -1e9;\nint n, m;\nvector<int> arr;\nvector<vector<int>> cache;\nint prefixSum(int start, int end) {\nint sum = 0;\nfor (int i = start; i <= end; i++) {\nsum += arr[i];\n}\nreturn sum;\n}\nint dp(int idx, int rem) {\nif (rem == 0) return 0;\nif (idx < 0) return INF;\nif (cache[idx][rem] != INF) return cache[idx][rem];\nint result = dp(idx - 1, rem);\nfor (int i = idx; i >= 0; i--) {\nint currSum = prefixSum(i, idx);\nint tmp = dp(i - 2, rem - 1) + currSum;\nresult = max(result, tmp);\n}\ncache[idx][rem] = result;\nreturn result;\n}\nint main() {\ncin >> n >> m;\narr.resize(n);\ncache.resize(n, vector<int>(m + 1, INF));\nfor (int i = 0; i < n; i++) {\ncin >> arr[i];\n}\ncout << dp(n - 1, m) << endl;\nreturn 0;\n}"
    },
    {
        "problem_tier": 4,
        "solution_code": "#include <iostream>\nusing namespace std;\nint main() {\nint n;\nwhile (1) {\nint ans = 0;\ncin >> n;\nif (!n) break;\nans += 1 + n * n;         for (int i = 2; i <= n - 1; i++) {\nans += i * i;\n}\nif (n != 1)\ncout << ans << '\\n';\nelse\ncout << 1 << '\\n';\n}\nreturn 0;\n}"
    },
    {
        "problem_tier": 3,
        "solution_code": "#include <iostream>\nusing namespace std;\nint main() {\ncin.tie(NULL);\ncout.tie(NULL);\nios::sync_with_stdio(false);\nint n;\ncin >> n;\nwhile (n > 0) {\nint a, b, c;\nint cnt = 0;\ncin >> a >> b >> c;\nfor (int i = 1; i <= a; i++) {\nfor (int j = 1; j <= b; j++) {\nfor (int k = 1; k <= c; k++) {\nif (i % j == j % k && j % k == k % i)\ncnt++;\n}\n}\n}\ncout << cnt << '\\n';\nn--;\n}\nreturn 0;\n}"
    },
    {
        "problem_tier": 9,
        "solution_code": "#include <iostream>\nusing namespace std;\nint dp[10000001];\nint main() {\nios_base::sync_with_stdio(false);\ncin.tie(NULL);\ncout.tie(NULL);\nint n;\ncin >> n;\ndp[1] = 1;\ndp[2] = 2;\nfor (int i = 3; i <= n; i++) {\ndp[i] = (dp[i-1] + dp[i-2]) % 10;\n}\ncout << dp[n] << endl;\nreturn 0;\n}"
    },
    {
        "problem_tier": 4,
        "solution_code": "#include <iostream>\nusing namespace std;\nint main() {\nint a, b, c;\nwhile (cin >> a >> b >> c) {\ncout << max(b - a, c - b) - 1 << '\\n';\n}\nreturn 0;\n}"
    },
    {
        "problem_tier": 6,
        "solution_code": "#include <iostream>\n#include <string>\n#include <cctype>\nusing namespace std;\nint main() {\nios_base::sync_with_stdio(false);\ncin.tie(nullptr);\nint n;\ncin >> n;\nstring s;\ncin >> s;\nlong long sum = 0;\nlong long res = 0;\nfor (int i = 0; i < n; i++) {\nif (isdigit(s[i])) {\nsum = sum * 10 + (s[i] - '0');\n} else {\nres += sum;\nsum = 0;\n}\n}\nres += sum;\ncout << res << endl;\nreturn 0;\n}"
    },
    {
        "problem_tier": 13,
        "solution_code": "#include<iostream>\nusing namespace std;\n#define MAX 1000001\n#define MOD 1000000007\nlong long int DP[MAX][2];\nint main(){\nios_base::sync_with_stdio(0);\ncin.tie(0);\nint N;\ncin >> N;\nDP[0][0] = 0;\nDP[1][0] = 2;\nDP[2][0] = 7;\nDP[2][1] = 1;\nfor(int i=3;i<=N;i++){\nDP[i][1] = (DP[i-3][0] + DP[i-1][1]) % MOD;\nDP[i][0] = (DP[i-1][0] * 2 + DP[i-2][0] * 3 + DP[i][1] * 2) % MOD;\n}\ncout << DP[N][0] % MOD;\nreturn 0;\n}"
    },
    {
        "problem_tier": 5,
        "solution_code": "#include <iostream>\n#include <vector>\n#include <algorithm>\nusing namespace std;\nint main() {\nwhile (true) {\nstring s;\ngetline(cin, s);\nif (s == \"*\") {\nbreak;\n}\nvector<bool> table(26, false);\nint count = 0;\nfor (int i = 0; i < s.size(); i++) {\nif (s[i] >= 'a' && s[i] <= 'z' && !table[s[i]-'a']) {\ntable[s[i]-'a'] = true;\ncount++;\n}\n}\nif (count == 26) {\ncout << \"Y\" << endl;\n} else {\ncout << \"N\" << endl;\n}\n}\nreturn 0;\n}"
    },
    {
        "problem_tier": 5,
        "solution_code": "#include<iostream>\n#include<string>\n#include<stack>\nusing namespace std;\nbool isPalindrome(string input){\nint inputLength = input.size();\nint start_idx;\nstack<char> pre;\nfor(int i=0;i<inputLength/2;i++){\npre.push(input[i]);\n}\nif(inputLength%2==0){\nstart_idx = inputLength/2;\nwhile(!pre.empty()){\nif(pre.top()!=input[start_idx++])\nreturn false;\nelse{\npre.pop();\n}\n}\n}\nelse{\nstart_idx = inputLength/2+1;\nwhile(!pre.empty()){\nif(pre.top()!=input[start_idx++])\nreturn false;\nelse{\npre.pop();\n}\n}\n}\nreturn true;\n}\nint main(){\nstring input;\ncin>>input;\nif(isPalindrome(input))\ncout<<\"true\"<<endl;\nelse\ncout<<\"false\"<<endl;\nreturn 0;\n}"
    },
    {
        "problem_tier": 1,
        "solution_code": "#include<iostream>\nusing namespace std;\nint main() {\nint a, b;\ncin >> a >> b;\nint answer = a + b - 1;\ncout << answer << endl;\nreturn 0;\n}"
    },
    {
        "problem_tier": 6,
        "solution_code": "#include<iostream>\nusing namespace std;\nint main() {\nint N, K;\nint big = -101;\nint sum = 0;\ncin >> N >> K;\nint *tmp = new int[N];\nfor (int i = 0; i < N; i++) {\ncin >> tmp[i];\n}\nfor (int i = 0; i <= N - K; i++) {\nfor (int j = i; j < i + K; j++) {\nsum += tmp[j];\n}\nif (big < sum) {\nbig = sum;\n}\nsum = 0;\n}\ncout << big;\nreturn 0;\n}"
    },
    {
        "problem_tier": 12,
        "solution_code": "#include<iostream>\nusing namespace std;\nvoid input_data();\nvoid find_min();\nint n, m, k, total_min = 2000001;\nint prefix_sum[2001][2001];\nint main(void) {\nios_base::sync_with_stdio(0);\ncin.tie(0);\ninput_data();\nfind_min();\ncout << total_min << '\\n';\nreturn 0;\n}"
    },
    {
        "problem_tier": 13,
        "solution_code": "#include <iostream>\n#include <vector>\n#include <algorithm>\nusing namespace std;\nbool finish = false;\nint n, r1, r2;\nvector<pair<int, int>> adj[100001];\nbool visited[100001];\nvoid dfs(int idx, int sum, int max_value) {\nif (finish)\nreturn;\nif (idx == r2) {\nfinish = true;\ncout << sum - max_value << '\\n';\nreturn;\n}\nvisited[idx] = true;\nfor (auto i : adj[idx]) {\nint next = i.first;\nint value = i.second;\nif (!visited[next])\ndfs(next, sum + value, max(max_value, value));\n}\n}\nint main() {\ncin >> n >> r1 >> r2;\nfor (int i = 0; i < n - 1; i++) {\nint tmp1, tmp2, v;\ncin >> tmp1 >> tmp2 >> v;\nadj[tmp1].push_back({tmp2, v});\nadj[tmp2].push_back({tmp1, v});\n}\ndfs(r1, 0, 0);\nreturn 0;\n}"
    },
    {
        "problem_tier": 17,
        "solution_code": "#include <iostream>\n#include <vector>\n#include <algorithm>\nusing namespace std;\nvector<int> arr;\nint N;\nlong long solve(int start, int end) {\nif (start == end) return (long long) arr[start] * arr[start];\nint mid = (start + end) / 2;\nlong long ans1 = solve(start, mid);\nlong long ans2 = solve(mid + 1, end);\nint left = mid, right = mid + 1;\nint sum = arr[left] + arr[right];\nint minVal = min(arr[left], arr[right]);\nlong long tempMaxScore = (long long) sum * minVal;\nwhile (left > start || right < end) {\nif (right < end && (left == start || arr[left - 1] < arr[right + 1])) {\nsum += arr[++right];\nminVal = min(minVal, arr[right]);\n} else {\nsum += arr[--left];\nminVal = min(minVal, arr[left]);\n}\ntempMaxScore = max(tempMaxScore, (long long) sum * minVal);\n}\nreturn max({ans1, ans2, tempMaxScore});\n}\nint main() {\ncin.tie(0);\nios::sync_with_stdio(false);\ncin >> N;\narr.resize(N+1);\nfor (int i = 1; i <= N; i++) {\ncin >> arr[i];\n}\ncout << solve(1, N);\nreturn 0;\n}"
    },
    {
        "problem_tier": 5,
        "solution_code": "#include <iostream>\n#include <vector>\nusing namespace std;\nint main() {\nint M;\ncin >> M;\nint a = 1, b = 1, s = 0;\nint r_num = 1;\nbool r = true;\nfor(int i = 0; i < M; i++) {\ncin >> a >> b >> s;\nr_num = (r_num / a) * b;\nr = (s == 1) ? !r : r;\n}\nif(r)\ncout << \"0 \" << r_num << endl;\nelse\ncout << \"1 \" << r_num << endl;\nreturn 0;\n}"
    },
    {
        "problem_tier": 15,
        "solution_code": "#include <iostream>\n#include <vector>\n#include <algorithm>\nusing namespace std;\nconst int INF = 987654321;\nint N, M;\nbool adjs[101][101], visit[101];\nint dist[101][101], maxPassingTime[101];\nvoid FloydWarshall() {\nfor (int i = 1; i <= N; i++) {\nfor (int j = 1; j <= N; j++) {\nif (i == j)\ndist[i][j] = 0;\nelse if (adjs[i][j])\ndist[i][j] = 1;\nelse\ndist[i][j] = INF;\n}\n}\nfor (int k = 1; k <= N; k++) {\nfor (int i = 1; i <= N; i++) {\nfor (int j = 1; j <= N; j++) {\ndist[i][j] = min(dist[i][j], dist[i][k] + dist[k][j]);\n}\n}\n}\n}\nvoid calcPassingTime() {\nfor (int i = 1; i <= N; i++) {\nint maxTime = -1;\nfor (int j = 1; j <= N; j++) {\nif (dist[j][i] == INF)\ncontinue;\nmaxTime = max(maxTime, dist[j][i]);\n}\nmaxPassingTime[i] = maxTime;\n}\n}\nint DFS(int curr) {\nvisit[curr] = true;\nint leader = curr;\nfor (int next = 1; next <= N; next++) {\nif (!adjs[curr][next] || visit[next])\ncontinue;\nint cand = DFS(next);\nif (maxPassingTime[cand] < maxPassingTime[leader])\nleader = cand;\n}\nreturn leader;\n}\nvector<int> pickLeaders() {\nvector<int> leaders;\nfor (int i = 1; i <= N; i++) {\nif (!visit[i])\nleaders.push_back(DFS(i));\n}\nreturn leaders;\n}\nint main() {\nios_base::sync_with_stdio(false);\ncin.tie(NULL);\ncout.tie(NULL);\ncin >> N >> M;\nfor (int i = 0; i < M; i++) {\nint a, b;\ncin >> a >> b;\nadjs[a][b] = true;\nadjs[b][a] = true;\n}\nFloydWarshall();\ncalcPassingTime();\nvector<int> leaders = pickLeaders();\nsort(leaders.begin(), leaders.end());\ncout << leaders.size() << \"\\n\";\nfor (auto leader : leaders)\ncout << leader << \"\\n\";\nreturn 0;\n}"
    },
    {
        "problem_tier": 15,
        "solution_code": "#include <iostream>\n#include <vector>\n#include <algorithm>\nusing namespace std;\nint main() {\nint n;\nwhile (cin >> n) {\nvector<int> d(n, 0);\nint length = 0;\nfor (int i = 0; i < n; i++) {\nint value;\ncin >> value;\nauto p = lower_bound(d.begin(), d.begin() + length, value);\n*p = value;\nif (p == d.begin() + length) length++;\n}\ncout << length << \"\\n\";\n}\nreturn 0;\n}"
    },
    {
        "problem_tier": 11,
        "solution_code": "#include <iostream>\n#include <vector>\nusing namespace std;\nint N;\nvector<int> graph[500001];\nbool visited[500001];\nint odd_height_cnt;\nvoid dfs(int node, int depth){\nif(graph[node].size() == 1 && node != 1){         if(depth & 1) odd_height_cnt++;\nreturn;\n}\nvisited[node] = 1;\nfor(auto next : graph[node]){\nif(!visited[next]){\ndfs(next, depth + 1);\n}\n}\n}\nint main(){\nios_base::sync_with_stdio(false);\ncin.tie(0);\ncin >> N;\nfor(int i = 0; i < N-1; i++){\nint a, b;\ncin >> a >> b;\ngraph[a].push_back(b);\ngraph[b].push_back(a);\n}\ndfs(1, 0);\nif(odd_height_cnt % 2 == 0) cout << \"No\";\nelse cout << \"Yes\";\nreturn 0;\n}"
    },
    {
        "problem_tier": 5,
        "solution_code": "#include <iostream>\n#include <string>\nusing namespace std;\nint main() {\nstring input;\ngetline(cin, input);\nwhile (input != \"EOI\") {\nbool found = false;\nfor (int i = 0; i < input.length() - 3; i++) {\nif (tolower(input[i]) == 'n' && tolower(input[i + 1]) == 'e' && tolower(input[i + 2]) == 'm' && tolower(input[i + 3]) == 'o') {\nfound = true;\nbreak;\n}\n}\nif (found)\ncout << \"Found\" << endl;\nelse\ncout << \"Missing\" << endl;\ngetline(cin, input);\n}\nreturn 0;\n}"
    },
    {
        "problem_tier": 19,
        "solution_code": "#include <iostream>\n#include <vector>\n#include <algorithm>\nusing namespace std;\nconst int MAX = 51;\nstruct Shark{\nint idx, size, speed, intelligence;\nbool operator==(Shark s){\nreturn (size == s.size && speed == s.speed && intelligence == s.intelligence);\n}\nbool operator<=(Shark s){\nreturn (size <= s.size && speed <= s.speed && intelligence <= s.intelligence);\n}\nbool operator>=(Shark s){\nreturn (size >= s.size && speed >= s.speed && intelligence >= s.intelligence);\n}\n};\nclass AlgoCapsule{\npublic:\nvoid Run(){\nInput();\nSolve();\nOutput();\n}\nvoid Input(){\ncin >> N;\nfor(int i=1;i<=N;++i){\ncin >> shark[i].size >> shark[i].speed >> shark[i].intelligence;\nshark[i].idx = i;\n}\n}\nvoid Solve(){\nfor(int i=1;i<=N-1;++i){\nfor(int j=i+1;j<=N;++j){\nif(shark[i] >= shark[j]){\nadj[i].push_back(j);\n}\nelse if(shark[i] <= shark[j]){\nadj[j].push_back(i);\n}\n}\n}\nfor(int k=0;k<2;++k){\nfor(int i=1;i<=N;i++){\nfill(visit, visit+MAX, false);\nif(BipartiteMatching(i))\ncount++;\n}\n}\n}\nvoid Output(){\ncout << N - count;\n}\nbool BipartiteMatching(int start){\nfor(int i=0;i<adj[start].size();++i){\nint x = adj[start][i];\nif(visit[x])\ncontinue;\nvisit[x] = true;\nif(d[x] == 0 || BipartiteMatching(d[x])){\nd[x] = start;\nreturn true;\n}\n}\nreturn false;\n}\nAlgoCapsule(){}\nprivate:\nShark shark[MAX];\nbool visit[MAX];\nint d[MAX];\nvector<int> adj[MAX];\nint N, count = 0;\n};\nint main(){\nios_base::sync_with_stdio(0);\ncin.tie(0);\ncout.tie(0);\nAlgoCapsule AC;\nAC.Run();\nreturn 0;\n}"
    },
    {
        "problem_tier": 11,
        "solution_code": "#include<iostream>\n#include<cstring>\n#include<algorithm>\n#include<vector>\n#include<cmath>\nusing namespace std;\n#define fastio_base::sync_with_stdio(false);\ncin.tie(0), cout.tie(0)\n#define ll long long int\nint dp[100001][3];\nint main() {\nfastio;\nint cnt = 1;\nwhile(1){\nint N;\ncin >> N;\nif(N == 0) break;\nfor(int i = 0; i < N; i++)\ncin >> dp[i][0] >> dp[i][1] >> dp[i][2];\ndp[0][0] = 987654321;\ndp[0][2] += dp[0][1];\nfor(int i = 1; i < N; i++){\ndp[i][0] = min(dp[i-1][0], dp[i-1][1]) + dp[i][0];\ndp[i][1] = min(min(dp[i-1][0], dp[i][0]), min(dp[i-1][1], dp[i-1][2])) + dp[i][1];\ndp[i][2] = min(dp[i-1][1], min(dp[i-1][2], dp[i][1])) + dp[i][2];\n}\ncout << cnt << \".\" << dp[N-1][1] << \"\\n\";\ncnt++;\n}\n}"
    },
    {
        "problem_tier": 8,
        "solution_code": "#include <iostream>\n#include <unordered_map>\nusing namespace std;\nint main() {\nios_base::sync_with_stdio(false);\ncin.tie(0);\nint n;\ncin >> n;\nstring name;\nunordered_map<string, int> umap;\nfor (int i = 0; i < n; i++) {\ncin >> name;\numap[name]++;\n}\nfor (int i = 0; i < n - 1; i++) {\ncin >> name;\numap[name]--;\n}\nfor (auto it = umap.begin(); it != umap.end(); it++) {\nif (it->second != 0)\ncout << it->first << '\\n';\n}\nreturn 0;\n}"
    },
    {
        "problem_tier": 12,
        "solution_code": "#include <iostream>\n#include <vector>\nusing namespace std;\nint T, K, tmp, dir, ret, arr[1004][8], pointer[1004];\nvector<pair<int,int>> v;\nvoid go(){\nfor(pair<int,int> p : v){\nint check[1004] = {0};\ntmp = p.first;\ndir = p.second;\ncheck[tmp] = dir;\nwhile(1){\nif(tmp <= 1) break;\nint c1 = (pointer[tmp] + 6) % 8;\nint c2 = (pointer[tmp-1] + 2) % 8;\nif(arr[tmp][c1] == arr[tmp-1][c2]) break;\nelse{\ndir *= -1;\ncheck[tmp-1] = dir;\n}\ntmp--;\n}\nwhile(1){\nif(tmp >= T) break;\nint c1 = (pointer[tmp] + 2) % 8;\nint c2 = (pointer[tmp+1] + 6) % 8;\nif(arr[tmp][c1] == arr[tmp+1][c2]) break;\nelse{\ndir *= -1;\ncheck[tmp+1] = dir;\n}\ntmp++;\n}\nfor(int i=1; i<=T; i++){\nif(check[i] == -1) pointer[i] = (pointer[i] + 1) % 8;\nelse if(check[i] == 1) pointer[i] = (pointer[i] + 7) % 8;\n}\n}\n}\nint main(){\nios_base::sync_with_stdio(0);\ncin.tie(0);\ncout.tie(0);\ncin >> T;\nstring str;\nfor(int i=1; i<=T; i++){\ncin >> str;\nfor(int k=0; k<str.size(); k++)\narr[i][k] = str[k] - '0';\n}\ncin >> K;\nfor(int i=0; i<K; i++){\ncin >> tmp >> dir;\nv.push_back({tmp, dir});\n}\ngo();\nfor(int i=1; i<=T; i++){\nif(arr[i][pointer[i]] == 1) ret++;\n}\ncout << ret;\nreturn 0;\n}"
    },
    {
        "problem_tier": 16,
        "solution_code": "#include <iostream>\n#include <vector>\nusing namespace std;\nint updateTree(vector<int>& Tree, int Node, int Begin, int End, int Index, int Value) {\nif (Index < Begin || Index > End) return Tree[Node];\nif (Begin == End) return Tree[Node] = Value;\nint Mid = (Begin + End) / 2;\nint leftVal = updateTree(Tree, Node * 2, Begin, Mid, Index, Value);\nint rightVal = updateTree(Tree, Node * 2 + 1, Mid + 1, End, Index, Value);\nreturn Tree[Node] = leftVal * rightVal;\n}\nint calcMul(vector<int>& Tree, int Node, int Begin, int End, int Left, int Right) {\nif (Left > End || Right < Begin) return 1;\nif (Left <= Begin && Right >= End) return Tree[Node];\nint Mid = (Begin + End) / 2;\nint leftVal = calcMul(Tree, Node * 2, Begin, Mid, Left, Right);\nint rightVal = calcMul(Tree, Node * 2 + 1, Mid + 1, End, Left, Right);\nreturn leftVal * rightVal;\n}\nint main() {\nint N, K, Index, Value, Left, Right, Mul;\nchar Q;\nwhile (scanf(\"%d%d\", &N, &K) != EOF) {\nvector<int> Tree;\nvector<pair<char, pair<int, int>>> Query;\nTree.resize(4 * N + 1);\nfor (int i = 1; i <= N; i++) {\nscanf(\"%d\", &Value);\nif (Value > 0) Value = 1;\nelse if (Value < 0) Value = -1;\nupdateTree(Tree, 1, 1, N, i, Value);\n}\nfor (int i = 0; i < K; i++) {\nchar a;\nint b, c;\nscanf(\" %c %d %d\", &a, &b, &c);\nQuery.push_back({a, {b, c}});\n}\nfor (int i = 0; i < K; i++) {\nQ = Query[i].first;\nif (Q == 'C') {\nIndex = Query[i].second.first;\nValue = Query[i].second.second;\nif (Value > 0) Value = 1;\nelse if (Value < 0) Value = -1;\nupdateTree(Tree, 1, 1, N, Index, Value);\n} else if (Q == 'P') {\nLeft = Query[i].second.first;\nRight = Query[i].second.second;\nMul = calcMul(Tree, 1, 1, N, Left, Right);\nif (Mul > 0) printf(\"+\");\nelse if (Mul < 0) printf(\"-\");\nelse printf(\"0\");\n}\n}\nprintf(\"\\n\");\n}\nreturn 0;\n}"
    },
    {
        "problem_tier": 5,
        "solution_code": "#include <iostream>\n#include <string>\n#include <map>\nusing namespace std;\nstring getFilteredString(string s) {\nstring filteredString;\nmap<char, int> filteringMap;\nfor (int i = 0; i <= 9; i++) {\nfilteringMap[i + '0'] = 1;\n}\nfor (int i = 0; i < s.size(); i++) {\nif (!filteringMap[s[i]]) {\nfilteredString += s[i];\n}\n}\nreturn filteredString;\n}\nint main() {\nstring s, k;\ncin >> s >> k;\nstring filtered = getFilteredString(s);\nif (filtered.find(k) != string::npos) {\ncout << 1;\n} else {\ncout << 0;\n}\nreturn 0;\n}"
    },
    {
        "problem_tier": 10,
        "solution_code": "#include<iostream>\n#include<vector>\n#include<algorithm>\n#include<queue>\nusing namespace std;\nvector<vector<int>> v;\nint N;\nint dx[3] = {1,0,1};\nint dy[3] = {0,1,1};\nint find(int i, int k){\npriority_queue<int> pq;\npq.push(v[i][k]);\nfor(int j=0; j<3; j++){\nint nx = i + dx[j];\nint ny = k + dy[j];\npq.push(v[nx][ny]);\n}\npq.pop();\nreturn pq.top();\n}\nvector<vector<int>> divide(vector<vector<int>>& v, int n){\nvector<vector<int>> fin;\nfor(int i=0; i<n; i+=2){\nvector<int> ing;\nfor(int k=0; k<n; k+=2){\ning.push_back(find(i,k));\n}\nfin.push_back(ing);\n}\nreturn fin;\n}\nint main(){\nios_base::sync_with_stdio(false);\ncin.tie(0);\ncin>>N;\nfor(int i=0; i<N; i++){\nvector<int> temp;\nfor(int k=0; k<N; k++){\nint inp;\ncin>>inp;\ntemp.push_back(inp);\n}\nv.push_back(temp);\n}\nwhile(v.size() != 1){\nvector<vector<int>> temp = divide(v, v[0].size());\nv = temp;\n}\ncout<<v[0][0];\nreturn 0;\n}"
    },
    {
        "problem_tier": 3,
        "solution_code": "#include <iostream>\nusing namespace std;\nint main() {\nint arr[4];\nint result = 0;\nfor(int i=0; i<4; i++) {\nscanf(\"%d\", &arr[i]);\nif(i > 0) {\nif(arr[i-1] < arr[i]) {\nresult += 1;\n}\nelse if(arr[i-1] > arr[i]) {\nresult += 10;\n}\nelse {\nresult += 0;\n}\n}\n}\nif(result == 0) {\nprintf(\"FishAtConstantDepth\\n\");\n}\nelse if(result == 3) {\nprintf(\"FishRising\\n\");\n}\nelse if(result == 30) {\nprintf(\"FishDiving\\n\");\n}\nelse {\nprintf(\"NoFish\\n\");\n}\nreturn 0;\n}"
    },
    {
        "problem_tier": 3,
        "solution_code": "#include <iostream>\nusing namespace std;\nint main() {\nios::sync_with_stdio(false);\ncin.tie(NULL);\nint N, A, B, C, ans = 0;\ncin >> N >> A >> B >> C;\nans += (N > A) ? A : N;\nans += (N > B) ? B : N;\nans += (N > C) ? C : N;\ncout << ans;\nreturn 0;\n}"
    },
    {
        "problem_tier": 16,
        "solution_code": "#include <iostream>\n#include <vector>\n#include <cstring>\nusing namespace std;\n#define MAX 5\nstruct Fish {\nint x, y, dir;\n};\nint n = 4, m, s, maxEating;\nint tempRoute[3], route[3];\nint smellMap[MAX][MAX];\nvector<Fish> fishMap[MAX][MAX], cMap[MAX][MAX];\npair<int, int> shark;\nint fdx[] = {0, 0, -1, -1, -1, 0, 1, 1, 1};\nint fdy[] = {0, -1, -1, 0, 1, 1, 1, 0, -1};\nint sdx[] = {0, -1, 0, 1, 0};\nint sdy[] = {0, 0, -1, 0, 1};\nint changeDir(int dir) {\nswitch (dir) {\ncase 1:\nreturn 8;\ncase 2:\nreturn 1;\ncase 3:\nreturn 2;\ncase 4:\nreturn 3;\ncase 5:\nreturn 4;\ncase 6:\nreturn 5;\ncase 7:\nreturn 6;\ncase 8:\nreturn 7;\n}\n}\nvoid input() {\ncin >> m >> s;\nfor (int i = 0; i < m; i++) {\nint x, y, d;\ncin >> x >> y >> d;\nx--; y--;\nFish f = {x, y, d};\nfishMap[x][y].push_back(f);\n}\ncin >> shark.first >> shark.second;\nshark.first--; shark.second--;\n}\nvoid copyMap(vector<Fish> A[][MAX], vector<Fish> B[][MAX]) {\nfor (int i = 0; i < n; i++) {\nfor (int j = 0; j < n; j++) {\nA[i][j] = B[i][j];\n}\n}\n}\nvoid copyFish() {\ncopyMap(cMap, fishMap);\n}\nvoid moveFish() {\nvector<Fish> tempMap[MAX][MAX];\nfor (int i = 0; i < n; i++) {\nfor (int j = 0; j < n; j++) {\nfor (int k = 0; k < fishMap[i][j].size(); k++) {\nint x = fishMap[i][j][k].x;\nint y = fishMap[i][j][k].y;\nint dir = fishMap[i][j][k].dir;\nint nx = x;\nint ny = y;\nbool Flag = false;\nfor (int l = 0; l < 8; l++) {\nnx = x + fdx[dir];\nny = y + fdy[dir];\nif (nx >= 0 && ny >= 0 && nx < n && ny < n) {\nif ((nx != shark.first || ny != shark.second) && smellMap[nx][ny] == 0) {\nFlag = true;\nbreak;\n}\n}\ndir = changeDir(dir);\n}\nif (Flag == true) {\nFish f = {nx, ny, dir};\ntempMap[nx][ny].push_back(f);\n} else {\nFish f = {x, y, dir};\ntempMap[x][y].push_back(f);\n}\n}\n}\n}\ncopyMap(fishMap, tempMap);\n}\nint routeSimulation() {\nbool visit[MAX][MAX] = {false,};\nint x = shark.first;\nint y = shark.second;\nint eat = 0;\nfor (int i = 0; i < 3; i++) {\nint dir = tempRoute[i];\nint nx = x + sdx[dir];\nint ny = y + sdy[dir];\nif (nx < 0 || ny < 0 || nx >= n || ny >= n) return -1;\nif (visit[nx][ny] == false) {\nvisit[nx][ny] = true;\neat += fishMap[nx][ny].size();\n}\nx = nx;\ny = ny;\n}\nreturn eat;\n}\nvoid findRoute(int cnt) {\nif (cnt == 3) {\nint eatNum = routeSimulation();\nif (eatNum > maxEating) {\nfor (int i = 0; i < 3; i++) {\nroute[i] = tempRoute[i];\n}\nmaxEating = eatNum;\n}\nreturn;\n}\nfor (int i = 1; i <= 4; i++) {\ntempRoute[cnt] = i;\nfindRoute(cnt + 1);\n}\n}\nvoid moveShark(int time) {\nvector<Fish> tempMap[MAX][MAX];\ncopyMap(tempMap, fishMap);\nint x = shark.first;\nint y = shark.second;\nfor (int i = 0; i < 3; i++) {\nint dir = route[i];\nint nx = x + sdx[dir];\nint ny = y + sdy[dir];\nif (tempMap[nx][ny].size() != 0) {\nsmellMap[nx][ny] = time;\ntempMap[nx][ny].clear();\n}\nx = nx;\ny = ny;\nshark.first = x;\nshark.second = y;\n}\ncopyMap(fishMap, tempMap);\n}\nvoid aboutShark(int time) {\nmaxEating = -1;\nfindRoute(0);\nmoveShark(time);\n}\nvoid removeSmell(int time) {\nfor (int i = 0; i < n; i++) {\nfor (int j = 0; j < n; j++) {\nif (smellMap[i][j] == 0) continue;\nif (time - smellMap[i][j] == 2) {\nsmellMap[i][j] = 0;\n}\n}\n}\n}\nvoid bornFish() {\nfor (int i = 0; i < n; i++) {\nfor (int j = 0; j < n; j++) {\nfor (int k = 0; k < cMap[i][j].size(); k++) {\nfishMap[i][j].push_back(cMap[i][j][k]);\n}\n}\n}\n}\nint findAnswer() {\nint ret = 0;\nfor (int i = 0; i < n; i++) {\nfor (int j = 0; j < n; j++) {\nret += fishMap[i][j].size();\n}\n}\nreturn ret;\n}\nint main() {\ninput();\nint answer = 0;\nfor (int time = 0; time <= m; time++) {\naboutShark(time);\nbornFish();\nremoveSmell(time);\nanswer = max(answer, findAnswer());\ncopyFish();\n}\ncout << answer << endl;\nreturn 0;\n}\n"
    },
    {
        "problem_tier": 16,
        "solution_code": "#include <iostream>\n#include <vector>\nusing namespace std;\nint table[19][200001];\nint m, q;\nvoid init() {\ncin >> m;\nfor (int i = 1; i <= m; i++) {\nint num;\ncin >> num;\ntable[0][i] = num;\n}\nfor (int i = 1; i < 19; i++) {\nfor (int j = 1; j <= m; j++) {\nint tmp = table[i-1][j];\ntable[i][j] = table[i-1][tmp];\n}\n}\n}\nint solve(int n, int x) {\nint cur = x;\nfor (int k = 0; k < 19; k++) {\nif (n & (1 << k)) {\ncur = table[k][cur];\n}\n}\nreturn cur;\n}\nint main() {\nios::sync_with_stdio(false);\ncin.tie(NULL);\ncout.tie(NULL);\ninit();\ncin >> q;\nwhile (q--) {\nint n, x;\ncin >> n >> x;\nint res = solve(n, x);\ncout << res << '\\n';\n}\nreturn 0;\n}"
    },
    {
        "problem_tier": 12,
        "solution_code": "#include<iostream>\n#include<cmath>\n#include<queue>\n#include<unordered_set>\n#define INF 10000000000000\nusing namespace std;\ntypedef long long ll;\nll s, t;\nbool flag = false;\nvoid input() {\ncin >> s >> t;\n}\nvoid solve() {\nunordered_set<ll> hashmap;\nqueue<pair<ll, string>> q;\nq.push({s, \"\"});\nwhile(!q.empty()) {\nll cur = q.front().first;\nstring str = q.front().second;\nq.pop();\nif (cur == t) {\nflag = true;\ncout << str;\nreturn;\n}\nll next = cur * cur;\nif (hashmap.find(next) == hashmap.end()) {\nhashmap.insert(next);\nq.push({cur * cur, str + \"*\"});\n}\nnext = cur + cur;\nif (hashmap.find(next) == hashmap.end()) {\nhashmap.insert(next);\nq.push({cur + cur, str + \"+\"});\n}\nnext = cur - cur;\nif (hashmap.find(next) == hashmap.end()) {\nhashmap.insert(next);\nq.push({cur - cur, str + \"-\"});\n}\nif (cur != 0) {\nnext = cur / cur;\nif (hashmap.find(next) == hashmap.end()) {\nhashmap.insert(next);\nq.push({cur / cur, str + \"/\"});\n}\n}\n}\n}\nint main() {\nios::sync_with_stdio(false);\ncin.tie(nullptr);\ncout.tie(nullptr);\ninput();\nif (s == t) {\ncout << \"0\";\n} else {\nsolve();\nif (!flag) {\ncout << \"-1\";\n}\n}\nreturn 0;\n}"
    },
    {
        "problem_tier": 2,
        "solution_code": "#include <iostream>\n#include <string>\nusing namespace std;\nbool hasVowel(char c){\nstring vowel = \"aeiou\";\nfor(auto v : vowel){\nif(v == c)\nreturn true;\n}\nreturn false;\n}\nint main(){\nint n, ans = 0;\ncin >> n;\nstring s;\ncin >> s;\nfor(int i = 0; i < n; i++){\nif(hasVowel(s[i]))\nans++;\n}\ncout << ans;\nreturn 0;\n}"
    },
    {
        "problem_tier": 3,
        "solution_code": "#include <iostream>\nint main() {\nint s, m, l, score;\nstd::cin >> s >> m >> l;\nscore = 1 * s + 2 * m + 3 * l;\nif (score >= 10)\nstd::cout << \"happy\";\nelse\nstd::cout << \"sad\";\nreturn 0;\n}"
    },
    {
        "problem_tier": 4,
        "solution_code": "#include <iostream>\nusing namespace std;\nint main() {\nint t;\ncin >> t;\nwhile (t--) {\nint student;\nlong long totalCandy = 0;\ncin >> student;\nfor (int i = 0; i < student; i++) {\nlong long candy;\ncin >> candy;\ntotalCandy = (totalCandy + candy) % student;\n}\nif (totalCandy % student)\ncout << \"NO\" << endl;\nelse\ncout << \"YES\" << endl;\n}\nreturn 0;\n}"
    },
    {
        "problem_tier": 18,
        "solution_code": "#include <iostream>\n#include <vector>\n#include <cstring>\nusing namespace std;\nint N, M;\nint want[110];\nbool visit[110];\nvector<int> v[110];\nbool solve(int x) {\nfor (int i = 0; i < v[x].size(); ++i) {\nint index = v[x][i];\nif (visit[index]) {\ncontinue;\n}\nvisit[index] = true;\nif (want[index] == 0 || solve(want[index])) {\nwant[index] = x;\nreturn true;\n}\n}\nreturn false;\n}\nint main() {\nint count = 0;\ncin >> N >> M;\nmemset(want, 0, sizeof(want));\nfor (int i = 0; i < M; ++i) {\nint people, num;\ncin >> people >> num;\nv[people].push_back(num);\n}\nfor (int i = 1; i <= N; ++i) {\nmemset(visit, false, sizeof(visit));\nif (solve(i)) {\n++count;\n}\n}\ncout << count << endl;\nreturn 0;\n}"
    },
    {
        "problem_tier": 6,
        "solution_code": "#include<iostream>\n#include<algorithm>\n#include<vector>\n#include<map>\nusing namespace std;\nint main() {\nint n;\nwhile (1) {\ncin >> n;\nif (!n) break;\nvector<string> v(n);\nmap<string, int> m;\nfor (int i = 0; i < n; i++) {\ncin >> v[i];\nstring tmp;\nfor (int j = 0; j < v[i].size(); j++) {\nif ('A' <= v[i][j] && v[i][j] <= 'Z') {\ntmp += v[i][j] - 'A' + 'a';\n} else {\ntmp += v[i][j];\n}\n}\nm[tmp] = i;\n}\ncout << v[m.begin()->second] << '\\n';\n}\nreturn 0;\n}"
    },
    {
        "problem_tier": 4,
        "solution_code": "#include <iostream>\nusing namespace std;\nint main() {\nios::sync_with_stdio(false);\ncin.tie(NULL);\ncout.tie(NULL);\nint num = 0;\nwhile(1) {\nint a;\ncin >> a;\nif(cin.eof() == 1) {\nbreak;\n}\nif(a > 0) {\nnum++;\n}\n}\ncout << num << endl;\nreturn 0;\n}"
    },
    {
        "problem_tier": 9,
        "solution_code": "#include <iostream>\n#include <map>\nusing namespace std;\nint main(){\nios_base::sync_with_stdio(false);\ncin.tie(NULL);\nint N, M;\ncin >> N >> M;\nmultimap<int, string> m;\nfor(int i=0; i<N; i++){\nstring title;\nint power;\ncin >> title >> power;\nm.insert({power, title});\n}\nfor(int i=0; i<M; i++){\nint input;\ncin >> input;\ncout << (m.lower_bound(input))->second << '\\n';\n}\nreturn 0;\n}"
    },
    {
        "problem_tier": 7,
        "solution_code": "#include <iostream>\n#include <vector>\n#include <algorithm>\nusing namespace std;\nvoid solve() {\nint P;\ncin >> P;\nfor (int tc = 0; tc < P; tc++) {\nint num;\ncin >> num;\nint students[20];\nfor (int i = 0; i < 20; i++) {\ncin >> students[i];\n}\nint result = 0;\nfor (int i = 0; i < 20; i++) {\nfor (int j = i; j < 20; j++) {\nif (students[i] > students[j]) {\nresult += 1;\n}\n}\n}\ncout << num << \" \" << result << \"\\n\";\n}\n}\nint main() {\nsolve();\nreturn 0;\n}"
    },
    {
        "problem_tier": 15,
        "solution_code": "#include<bits/stdc++.h>\n#define fastio ios::sync_with_stdio(false),cin.tie(0),cout.tie(0)\n#define INF 123456789\n#define endl '\\n'\nusing namespace std;\ntypedef long long ll;\nint N, K, M;\nvector<vector<int>> hypertube;\nvector<vector<int>> station;\nvoid input(){\ncin>>N>>K>>M;\nstation.resize(N+1);\nhypertube.resize(M+1);\nfor(int i=1;i<=M;i++){\nfor(int j=0;j<K;j++){\nint node;\ncin>>node;\nhypertube[i].push_back(node);\nstation[node].push_back(i);\n}\n}\n}\nint solution(){\nvector<int> visited(N+1,-1);\nvector<int> visitedTube(M+1,-1);\nqueue<pair<int,int>> q;\nq.push({1,1});\nvisited[1]=1;\nwhile(!q.empty()){\nint node=q.front().first;\nint dist=q.front().second;\nq.pop();\nif(node==N) return dist;\nfor(int next=0;next<station[node].size();next++){\nint nextTube=station[node][next];\nif(visitedTube[nextTube]==-1){\nvisitedTube[nextTube]=1;\nfor(int station=0;station<hypertube[nextTube].size();station++){\nint nextStation=hypertube[nextTube][station];\nif(visited[nextStation]==-1){\nvisited[nextStation]=visited[node]+1;\nq.push({nextStation,visited[nextStation]});\n}\n}\n}\n}\n}\nreturn -1;\n}\nint main(){\nfastio;\ninput();\ncout<<solution()<<endl;\nreturn 0;\n}"
    },
    {
        "problem_tier": 2,
        "solution_code": "#include <iostream>\nusing namespace std;\nint main() {\nios::sync_with_stdio(false);\ncin.tie(nullptr);\nint n;\ncin >> n;\nint sum = n * (n + 1) / 2;\nint sumSqrd = sum * sum;\nint sumOfCubed = 0;\nfor (int i = 1; i <= n; i++) {\nsumOfCubed += pow(i, 3);\n}\ncout << sum << \"\\n\" << sumSqrd << \"\\n\" << sumOfCubed << \"\\n\";\nreturn 0;\n}"
    },
    {
        "problem_tier": 13,
        "solution_code": "#include<iostream>\n#include<string>\n#include<unordered_map>\n#include<algorithm>\nusing namespace std;\nint n, m, k, answer = 0;\nint main() {\nios::sync_with_stdio(false);\ncin.tie(0);\ncout.tie(0);\ncin >> n >> m;\nunordered_map<string, pair<int, int>> ma;\nfor(int i=0;i<n;i++){\nstring str;\ncin >> str;\nma[str].first++;\nif(ma[str].second == 0){\nint cnt = 0;\nfor(int j=0;j<str.length();j++){\nif(str[j] == '0')\ncnt++;\n}\nma[str].second = cnt;\n}\n}\ncin >> k;\nfor(auto o : ma){\nint cnt = o.second.second;\nif(cnt <= k && cnt % 2 == k % 2){\nanswer = max(answer, o.second.first);\n}\n}\ncout << answer;\nreturn 0;\n}"
    },
    {
        "problem_tier": 5,
        "solution_code": "#include <iostream>\nusing namespace std;\nint main() {\ncin.tie(NULL);\ncout.tie(NULL);\nios_base::sync_with_stdio(false);\nint T;\ncin >> T;\nwhile (T--) {\nint n;\ncin >> n;\nint heils = n;\nint max = n;\nwhile (heils != 1) {\nif (max < heils)\nmax = heils;\nif (heils % 2 == 0)\nheils /= 2;\nelse\nheils = heils * 3 + 1;\n}\ncout << max << '\\n';\n}\nreturn 0;\n}"
    },
    {
        "problem_tier": 12,
        "solution_code": "#include <iostream>\n#include <stack>\n#include <vector>\n#include <set>\n#include <string>\n#include <utility>\nusing namespace std;\nstring str;\nvector<pair<int,int>> v;\nstack<int> st;\nset<string> s;\nbool check[201];\nvoid DFS(int n, int cnt){\nif(n == v.size()){\nif(cnt > 0){\nstring tmp = \"\";\nfor(int i=0; i<str.length(); i++){\nif(check[i])\ntmp += str[i];\n}\ns.insert(tmp);\n}\nreturn;\n}\nelse{\nDFS(n+1, cnt);\ncheck[v[n].first] = false;\ncheck[v[n].second] = false;\nDFS(n+1, cnt+1);\ncheck[v[n].first] = true;\ncheck[v[n].second] = true;\n}\n}\nint main(){\ncin >> str;\nfor(int i=0; i<str.length(); i++){\ncheck[i] = true;\nif(str[i] == '(')\nst.push(i);\nelse if(str[i] == ')'){\nv.push_back(make_pair(st.top(), i));\nst.pop();\n}\n}\nDFS(0, 0);\nfor(auto iter=s.begin(); iter!=s.end(); iter++){\ncout << *iter << \"\\n\";\n}\nreturn 0;\n}"
    },
    {
        "problem_tier": 9,
        "solution_code": "#include <iostream>\n#include <deque>\nusing namespace std;\nint main() {\nint t;\ncin >> t;\nwhile (t--) {\nint n;\ncin >> n;\ndeque<char> dq;\nfor (int i = 0; i < n; i++) {\nchar c;\ncin >> c;\nif (dq.empty()) {\ndq.push_back(c);\n} else if (c <= dq.front()) {\ndq.push_front(c);\n} else {\ndq.push_back(c);\n}\n}\nfor (auto it = dq.begin(); it != dq.end(); it++) {\ncout << *it;\n}\ncout << endl;\n}\nreturn 0;\n}"
    },
    {
        "problem_tier": 15,
        "solution_code": "#include <iostream>\n#include <vector>\n#include <queue>\n#include <algorithm>\nusing namespace std;\nint solve(int N, int L, int P, vector<pair<int, int>>& fuel) {\npriority_queue<int> pq;\nint idx = 0, cnt = 0;\nwhile (L > P) {\nwhile (fuel[idx].first <= P && idx < N) {\npq.push(fuel[idx].second);\nidx++;\n}\nif (!pq.empty()) {\nP += pq.top();\npq.pop();\ncnt++;\n}\nelse if (idx == N || fuel[idx].first > P) {\ncnt = -1;\nbreak;\n}\n}\nreturn cnt;\n}\nint main() {\nint N, L, P;\nvector<pair<int, int>> fuel;\ncin >> N;\nfor (int i = 0; i < N; i++) {\nint a, b;\ncin >> a >> b;\nfuel.push_back({a, b});\n}\ncin >> L >> P;\nsort(fuel.begin(), fuel.end());\nint result = solve(N, L, P, fuel);\ncout << result;\nreturn 0;\n}"
    },
    {
        "problem_tier": 6,
        "solution_code": "#include <iostream>\n#include <string>\n#include <vector>\n#include <algorithm>\nusing namespace std;\nstring sum(string x, string y) {\nint num;\nint carry = 0;\nstring result;\nreverse(x.begin(), x.end());\nreverse(y.begin(), y.end());\nwhile (x.length() < y.length()) {\nx += '0';\n}\nwhile (x.length() > y.length()) {\ny += '0';\n}\nfor (int i = 0; i < x.length(); ++i) {\nnum = (x[i] - '0' + y[i] - '0' + carry) % 10;\nresult += to_string(num);\ncarry = (x[i] - '0' + y[i] - '0' + carry) / 10;\n}\nif (carry != 0) {\nresult += to_string(carry);\n}\nreverse(result.begin(), result.end());\nreturn result;\n}\nint main(int argc, char* argv[]) {\nint n;\nstring a;\nstring b;\nstring result;\ncin >> n;\na = \"0\";\nb = \"1\";\nif (n == 0) {\nresult = \"0\";\n}\nif (n == 1) {\nresult = \"1\";\n}\nfor (int i = 2; i <= n; ++i) {\nresult = sum(a, b);\na = b;\nb = result;\n}\ncout << result << endl;\nreturn 0;\n}"
    },
    {
        "problem_tier": 15,
        "solution_code": "#include <iostream>\n#include <algorithm>\n#include <vector>\n#include <cstring>\n#include <queue>\n#define INF 0x7f7f7f7f\nusing namespace std;\nint n, m, ans = 0x7f7f7f7f;\nint dx[6] = { 0,0,-1,1,0,0 };\nint dy[6] = { -1,1,0,0,0,0 };\nint dz[6] = { 0,0,0,0,1,-1 };\nint d[6][6][6];\nint ck[6][6][6];\nint real_board[6][6][6];\nint board[6][6][6];\nint base[5] = { 1,2,3,4,5 };\nstruct xyz {\nint z, x, y;\n};\nvoid pile(int base[]) {\nint cnt = 0;\nwhile (cnt < 5) {\nfor (int i = 1; i <= 5; i++) {\nfor (int j = 1; j <= 5; j++) {\nboard[cnt+1][i][j] = real_board[base[cnt]][i][j];\n}\n}\ncnt++;\n}\n}\nvoid rotate(int which) {\nint tmp[6][6] = { 0 };\nfor (int i = 1; i <= 5; i++)\nfor (int j = 1; j <= 5; j++)\ntmp[i][j] = board[which][i][j];\nfor (int i = 1; i <= 5; i++)\nfor (int j = 1; j <= 5; j++)\nboard[which][6 - j][i] = tmp[i][j];\n}\nint bfs(int a, int b, int c) {\nif (!board[1][1][1] || !board[5][5][5])return INF;\nqueue <struct xyz> q;\nfor (int i = 1; i <= 5; i++) {\nfor (int j = 1; j <= 5; j++) {\nfor (int k = 1; k <= 5; k++)\nd[i][j][k] = INF;\n}\n}\nq.push({ a,b,c });\nd[1][1][1] = 0;\nwhile (!q.empty()) {\nint x = q.front().x;\nint y = q.front().y;\nint z = q.front().z;\nint tmp = d[z][x][y];\nq.pop();\nfor (int i = 0; i < 6; i++) {\nint nx = x + dx[i];\nint ny = y + dy[i];\nint nz = z + dz[i];\nif (1 <= nx && nx <= 5 && 1 <= ny && ny <= 5 && 1 <= nz && nz <= 5) {\nif (board[nz][nx][ny] == 1 && d[nz][nx][ny] > tmp+1) {\nd[nz][nx][ny] = tmp+1;\nq.push({ nz,nx,ny });\n}\n}\n}\n}\nreturn d[5][5][5];\n}\nvoid dfs(int cnt) {\nif (cnt == 6) {\nans = min(ans, bfs(1,1,1));\nreturn;\n}\nfor (int j = 0; j < 4; j++) {\nrotate(cnt);\ndfs(cnt + 1);\n}\n}\nint main() {\nfor (int i = 1; i <= 5; i++)\nfor (int j = 1; j <= 5; j++)\nfor (int k = 1; k <= 5; k++)\ncin >> real_board[i][j][k];\ndo {\npile(base);\ndfs(1);\n} while (next_permutation(base, base + 5));\nif (ans == INF)\ncout << -1 << '\\n';\nelse\ncout << ans << '\\n';\n}"
    },
    {
        "problem_tier": 2,
        "solution_code": "#include <iostream>\n#include <vector>\n#include <algorithm>\nusing namespace std;\nbool compare(string a, string b) {\nreturn a.length() < b.length();\n}\nint main() {\nint n;\ncin >> n;\nvector<string> words(n);\nfor (int i = 0; i < n; i++) {\ncin >> words[i];\n}\nsort(words.begin(), words.end(), compare);\nfor (int i = 0; i < n; i++) {\ncout << words[i] << \"\\n\";\n}\nreturn 0;\n}"
    },
    {
        "problem_tier": 6,
        "solution_code": "#include <iostream>\n#include <string>\nusing namespace std;\nint main() {\nstring input;\nstring temp;\nint sum = 0;\nwhile (getline(cin, input)) {\nfor (int i = 0; i < input.length(); i++) {\nif (input[i] != ',') {\ntemp += input[i];\n} else {\nsum += stoi(temp);\ntemp.clear();\n}\n}\n}\nsum += stoi(temp);\ncout << sum;\nreturn 0;\n}"
    },
    {
        "problem_tier": 12,
        "solution_code": "#include <iostream>\n#include <vector>\n#include <algorithm>\nusing namespace std;\nint N, L, R, X;\nint arr[15];\nbool visit[15];\nint ans = 0;\nbool cmp(int a, int b) {\nreturn a > b;\n}\nvoid solve(int index, int cnt, int sum) {\nif (cnt >= 2) {\nint maxnum, minnum;\nfor (int i = 0; i < N; i++) {\nif (visit[i] == true) {\nmaxnum = arr[i];\nbreak;\n}\n}\nfor (int i = N - 1; i >= 0; i--) {\nif (visit[i] == true) {\nminnum = arr[i];\nbreak;\n}\n}\nif (sum >= L && sum <= R && (maxnum - minnum) >= X) {\nans++;\n}\n}\nfor (int i = index; i < N; i++) {\nvisit[i] = true;\nsolve(i + 1, cnt + 1, sum + arr[i]);\nvisit[i] = false;\n}\n}\nint main() {\nios_base::sync_with_stdio(false);\ncin.tie(0);\ncin >> N >> L >> R >> X;\nfor (int i = 0; i < N; i++) {\nint a;\ncin >> a;\narr[i] = a;\n}\nsort(arr, arr + N, cmp);\nsolve(0, 0, 0);\ncout << ans << \"\\n\";\nreturn 0;\n}"
    },
    {
        "problem_tier": 8,
        "solution_code": "#include <iostream>\nusing namespace std;\nint main() {\nios::sync_with_stdio(0);\ncin.tie(NULL);\nint t;\ncin >> t;\nwhile (t--) {\nint n;\nstring before, after;\nint Wcount = 0;\nint Bcount = 0;\ncin >> n >> before >> after;\nfor (int i = 0; i < n; i++) {\nif (after.at(i) != before.at(i)) {\nif (before.at(i) == 'W')\nWcount++;\nelse\nBcount++;\n}\n}\nif (Wcount > Bcount)\ncout << Wcount << \"\\n\";\nelse\ncout << Bcount << \"\\n\";\nWcount = 0;\nBcount = 0;\n}\nreturn 0;\n}"
    },
    {
        "problem_tier": 4,
        "solution_code": "#include <iostream>\n#include <vector>\n#include <utility>\n#include <algorithm>\nusing namespace std;\nint main() {\nint n;\ncin >> n;\nif (n == 0) {\ncout << \"divide by zero\";\nreturn 0;\n}"
    },
    {
        "problem_tier": 4,
        "solution_code": "#include <iostream>\nusing namespace std;\nint main() {\nint T;\ncin >> T;\nwhile (T--) {\nint N, C;\ncin >> N >> C;\nif (N % C == 0)\ncout << N / C << '\\n';\nelse\ncout << N / C + 1 << '\\n';\n}\nreturn 0;\n}"
    },
    {
        "problem_tier": 9,
        "solution_code": "#include<iostream>\n#include<algorithm>\nusing namespace std;\ntypedef long long ll;\nstruct PT {\nint x, y;\n};\nPT p[4];\nint dis[4][4];\nbool cmp(PT a, PT b) {\nif (a.x < b.x) return true;\nelse if (a.x == b.x) {\nif (a.y < b.y) return true;\nelse return false;\n}\nelse return false;\n}\nll distSquare(PT a, PT b) {\nreturn (a.x - b.x)*(a.x - b.x) + (a.y - b.y)*(a.y - b.y);\n}\nint main(void) {\nint n;\ncin >> n;\nwhile (n--) {\nfor (int i = 0; i < 4; i++) {\ncin >> p[i].x >> p[i].y;\n}\nsort(p, p + 4, cmp);\nfor (int i = 0; i < 4; i++) {\nfor (int j = 0; j < 4; j++) {\nif (i == j) continue;                 dis[i][j] = distSquare(p[i], p[j]);\n}\n}\nif (dis[0][1] == dis[0][2] && dis[3][2] == dis[3][1] &&\ndis[0][3] == dis[1][2])             cout << 1 << '\\n';\nelse\ncout << 0 << '\\n';\n}\nreturn 0;\n}"
    },
    {
        "problem_tier": 15,
        "solution_code": "#include <iostream>\n#include <vector>\n#include <queue>\nusing namespace std;\nvector<vector<vector<pair<int,int>>>> graph;\nvector<vector<int>> visited;\nvector<vector<bool>> is_turnon;\nint x_d[] = {0, 0, -1, 1};\nint y_d[] = {1, -1, 0, 0};\nbool withinRange(int x, int y, int N) {\nif (x < N && x >= 0 && y < N && y >= 0)\nreturn true;\nelse\nreturn false;\n}\nint main() {\nint N, M;\nscanf(\"%d%d\", &N, &M);\ngraph.assign(N, vector<vector<pair<int,int>>>(N, vector<pair<int,int>>({})));\nvisited.assign(N, vector<int>(N, 0));\nis_turnon.assign(N, vector<bool>(N, false));\nint x, y, a, b;\nfor (int i = 0; i < M; i++) {\nscanf(\"%d%d%d%d\", &x, &y, &a, &b);\ngraph[y-1][x-1].push_back({a-1, b-1});\n}\nis_turnon[0][0] = true;\nint cnt = 1;\nqueue<pair<int,int>> q;\nq.push({0,0});\nwhile (!q.empty()) {\npair<int,int> ele = q.front();\nq.pop();\nint cur_x = ele.first;\nint cur_y = ele.second;\nvisited[cur_y][cur_x] = -1;\nfor (int d = 0; d < 4; d++) {\nint next_x = cur_x + x_d[d];\nint next_y = cur_y + y_d[d];\nif (withinRange(next_x, next_y, N) && visited[next_y][next_x] != -1) {\nvisited[next_y][next_x] = 1;\nif (is_turnon[next_y][next_x]) {\nq.push({next_x, next_y});\n}\n}\n}\nfor (int k = 0; k < graph[cur_y][cur_x].size(); k++) {\nint temp_x = graph[cur_y][cur_x][k].first;\nint temp_y = graph[cur_y][cur_x][k].second;\nif (visited[temp_y][temp_x] == -1 || is_turnon[temp_y][temp_x] == true)\ncontinue;\nis_turnon[temp_y][temp_x] = true;\ncnt++;\nif (visited[temp_y][temp_x] == 1) {\nq.push({temp_x, temp_y});\n}\n}\n}\nprintf(\"%d\", cnt);\nreturn 0;\n}"
    },
    {
        "problem_tier": 12,
        "solution_code": "#include<iostream>\n#include<algorithm>\n#include<cmath>\n#include<vector>\n#include<string>\nusing namespace std;\nint n, m;\nvector<string> input;\nint answer = -1;\nint toSquare(int num){\nint squareRoot = sqrt(num);\nif(squareRoot * squareRoot == num)\nreturn num;\nelse\nreturn -1;\n}\nint main(){\nios::sync_with_stdio(false);\ncin.tie(0);\ncout.tie(0);\ncin >> n >> m;\nfor(int i=0; i<n; i++){\nstring str;\ncin >> str;\ninput.push_back(str);\n}\nfor(int r=0; r<n; r++){\nfor(int c=0; c<m; c++){\nfor(int dr=-n+1; dr<n; dr++){\nfor(int dc=-m+1; dc<m; dc++){\nif(dr == 0 && dc == 0)\ncontinue;\nint a = r, b = c;\nstring str = \"\";\nwhile(a >= 0 && a < n && b >= 0 && b < m){\nstr += input[a][b];\nanswer = max(answer, toSquare(stoi(str)));\na += dr;\nb += dc;\n}\n}\n}\n}\n}\nif(n == 1 && m == 1){\ncout<<toSquare(stoi(input[0]));\n}\nelse\ncout << answer;\nreturn 0;\n}"
    },
    {
        "problem_tier": 3,
        "solution_code": "#include <iostream>\nusing namespace std;\nint main() {\nint a[3], b[3], ans = 0;\nfor (int i = 0; i < 3; i++)\ncin >> a[i];\nfor (int i = 0; i < 3; i++)\ncin >> b[i];\nfor (int i = 0; i < 3; i++) {\nif (a[i] < b[i])\nans += b[i] - a[i];\n}\ncout << ans;\nreturn 0;\n}"
    },
    {
        "problem_tier": 3,
        "solution_code": "#include <iostream>\nusing namespace std;\nint main() {\nint p[4];\nint x, y, r;\nint ret = 0;\nfor (int i = 0; i < 4; i++)\ncin >> p[i];\ncin >> x >> y >> r;\nfor (int i = 0; i < 4; i++) {\nif (p[i] == x)\nret = i + 1;\n}\ncout << ret;\nreturn 0;\n}"
    },
    {
        "problem_tier": 7,
        "solution_code": "#include <iostream>\n#include <vector>\n#include <algorithm>\n#include <cmath>\nusing namespace std;\nint main(){\nint a, b, n;\ncin >> a >> b >> n;\nvector<int> v;\nfor(int i = 0; i < n; i++){\nint num;\ncin >> num;\nv.push_back(num);\n}\nsort(v.begin(), v.end());\nvector<int> res;\nfor(int i = 0; i < n; i++){\nres.push_back(abs(v[i] - b));\n}\nsort(res.begin(), res.end());\nif(res[0] >= abs(a - b)){\ncout << abs(a - b) << '\\n';\n}\nelse{\ncout << 1 + res[0] << '\\n';\n}\nreturn 0;\n}"
    },
    {
        "problem_tier": 13,
        "solution_code": "#include <iostream>\n#include <vector>\n#include <algorithm>\n#define INF 1e9\nusing namespace std;\nstruct Nutrient {\nint protein, fat, carbohydrate, vitamin, price;\n};\nint N, min_cost = INF;\nvector<vector<int>> result;\nvector<Nutrient> nutrients;\nbool cmp(vector<int> a, vector<int> b) {\nreturn a.size() < b.size();\n}\nvoid select(int start, int count, vector<int> idx) {\nint total_protein = 0, total_fat = 0, total_carbohydrate = 0, total_vitamin = 0, total_price = 0;\nfor (auto i : idx) {\ntotal_protein += nutrients[i].protein;\ntotal_fat += nutrients[i].fat;\ntotal_carbohydrate += nutrients[i].carbohydrate;\ntotal_vitamin += nutrients[i].vitamin;\ntotal_price += nutrients[i].price;\n}\nif (total_protein >= nutrients[N].protein && total_fat >= nutrients[N].fat &&\ntotal_carbohydrate >= nutrients[N].carbohydrate && total_vitamin >= nutrients[N].vitamin) {\nif (min_cost > total_price) {\nmin_cost = total_price;\nresult.clear();\nresult.push_back(idx);\n} else if (min_cost == total_price) {\nresult.push_back(idx);\n}\n}\nfor (int i = start; i < N; i++) {\nidx.push_back(i);\nselect(i + 1, count + 1, idx);\nidx.pop_back();\n}\n}\nint main() {\nios_base::sync_with_stdio(false);\ncin.tie(NULL);\ncout.tie(NULL);\ncin >> N;\nnutrients.resize(N + 1);\nfor (int i = 0; i < N; i++) {\ncin >> nutrients[i].protein >> nutrients[i].fat >>\nnutrients[i].carbohydrate >> nutrients[i].vitamin >> nutrients[i].price;\n}\nselect(0, 0, {});\nsort(result.begin(), result.end(), cmp);\nif (min_cost == INF) {\ncout << \"-1\\n\";\nreturn 0;\n}"
    },
    {
        "problem_tier": 9,
        "solution_code": "#include <iostream>\n#include <algorithm>\nusing namespace std;\nint main() {\nlong long x, y, w, s;\ncin >> x >> y >> w >> s;\nlong long case_A = (x + y) * w;     long long max_diagonal = max(x, y);     long long mod = (x + y) % 2;\nlong long res = min(case_A, (max_diagonal - mod) * s + mod * w);\nlong long min_diagonal = min(x, y);     long long remainder_x = x - min_diagonal;     long long remainder_y = y - min_diagonal;\nres = min(res, min_diagonal * s + (remainder_x + remainder_y) * w);\ncout << res;\nreturn 0;\n}"
    },
    {
        "problem_tier": 4,
        "solution_code": "#include <iostream>\nusing namespace std;\nint main() {\nint a, b, c, d;\nint deliver[3];\nint ans[3] = {0, 0, 0};\ncin >> a >> b >> c >> d;\nfor (int i = 0; i < 3; i++) {\ncin >> deliver[i];\nint dog1 = deliver[i] % (a + b);\nint dog2 = deliver[i] % (c + d);\nif (dog1 <= a && dog1 != 0)\nans[i]++;\nif (dog2 <= c && dog2 != 0)\nans[i]++;\n}\nfor (int i = 0; i < 3; i++)\ncout << ans[i] << '\\n';\nreturn 0;\n}"
    },
    {
        "problem_tier": 17,
        "solution_code": "#include <iostream>\n#include <bits/stdc++.h>\nusing namespace std;\nusing ll = long long;\nint n, k;\nll fact[16];\nstring seq[16];\nll dp[1 << 15][100];\nint tenmodk[51];\nint seqmodk[16];\nll gcd(ll a, ll b) {\nreturn !b ? a : gcd(b, a % b);\n}\nint powermodk(int a, int b) {\nif (!b)\nreturn 1;\nif (b & 1)\nreturn powermodk(a, b - 1) * a % k;\nreturn powermodk(a * a % k, b / 2);\n}\nint main() {\ncin.tie(0);\nios::sync_with_stdio(false);\ncin >> n;\nfact[0] = 1;\nfor (int i = 1; i <= n; ++i) {\nfact[i] = fact[i - 1] * i;\ncin >> seq[i - 1];\n}\ncin >> k;\nfor (int i = 0; i <= 50; ++i)\ntenmodk[i] = powermodk(10, i);\nfor (int i = 0; i < n; ++i) {\nint pre = 0;\nfor (int j = 0; j < seq[i].size(); ++j)\npre = (pre * 10 + (seq[i][j] - '0')) % k;\nseqmodk[i] = pre;\n}\ndp[0][0] = 1;\nfor (int i = 0; i < (1 << n); ++i) {\nfor (int j = 0; j < k; ++j) {\nif (!dp[i][j])\ncontinue;\nfor (int x = 0; x < n; ++x)\nif (!(i & (1 << x)))\ndp[i | (1 << x)][(j * tenmodk[seq[x].size()] + seqmodk[x]) % k] += dp[i][j];\n}\n}\nll div = gcd(dp[(1 << n) - 1][0], fact[n]);\ncout << dp[(1 << n) - 1][0] / div << \"/\" << fact[n] / div;\nreturn 0;\n}"
    },
    {
        "problem_tier": 12,
        "solution_code": "#include<bits/stdc++.h>\nusing namespace std;\n#define MAX 11\nint res;\nint MAP[MAX][MAX];\nbool visited[MAX];\nvoid go(int index, int sum){\nif(index == MAX){\nif(res < sum)\nres = sum;\nreturn;\n}\nfor(int i=0; i<MAX; i++){\nif(!visited[i] && MAP[index][i] != 0){\nvisited[i] = true;\ngo(index+1, sum+MAP[index][i]);\nvisited[i] = false;\n}\n}\n}\nint main(){\nios_base::sync_with_stdio(0);\ncin.tie(0);\nvector<int> vec;\nfor(int i=0; i<11; i++){\nvec.push_back(i);\n}\nint C;\ncin >> C;\nwhile(C--){\nfor(int i=0; i<11; i++){\nfor(int j=0; j<11; j++){\ncin >> MAP[i][j];\n}\n}\nmemset(visited, false, sizeof(visited));\nres = 0;\ngo(0, 0);\ncout << res << \"\\n\";\n}\nreturn 0;\n}"
    },
    {
        "problem_tier": 4,
        "solution_code": "#include <iostream>\n#include <cmath>\nusing namespace std;\nint main()\n{\nint n,a=0,b;\ncin>>n;\nn-=1;\nwhile (true){\na++;\nif (a*a+a==n)break;\n}\ncout<<a;\nreturn 0;\n}"
    },
    {
        "problem_tier": 6,
        "solution_code": "#include <iostream>\n#include <iomanip>\nusing namespace std;\nstruct Score {\nchar letterGrade;\nchar sign;\n};\ndouble calculateGradePoints(Score score) {\ndouble gradePoints = 0;\nswitch(score.letterGrade) {\ncase 'A': gradePoints = 4; break;\ncase 'B': gradePoints = 3; break;\ncase 'C': gradePoints = 2; break;\ncase 'D': gradePoints = 1; break;\ndefault: break;\n}\nif (score.sign == '+') {\ngradePoints += 0.3;\n} else if (score.sign == '-') {\ngradePoints -= 0.3;\n}\nreturn gradePoints;\n}\nint main() {\nint tc, hak, cnt = 0;\ndouble res = 0, tmp = 0;\nchar sbj[103];\nScore sco;\ncin >> tc;\nfor (int i = 0; i < tc; i++) {\ncin >> sbj >> hak >> sco.letterGrade >> sco.sign;\ntmp = calculateGradePoints(sco);\ncnt += hak;\nres += tmp * hak;\ntmp = sco.sign = 0;\n}\ncout << fixed << setprecision(2) << res / cnt + 0.0001 << endl;\nreturn 0;\n}"
    },
    {
        "problem_tier": 9,
        "solution_code": "#include<iostream>\n#include<vector>\n#include<algorithm>\nusing namespace std;\nint N;\ndouble ans;\nvector<double> drink;\nint main(){\ncin >> N;\nfor(int i=0; i<N; i++){\ndouble x;\ncin >> x;\ndrink.push_back(x);\n}\nsort(drink.begin(), drink.end());\nans = drink.back();\nfor(int i=0; i<N-1; i++){\nans += (drink[i]/2);\n}\ncout << ans;\nreturn 0;\n}"
    },
    {
        "problem_tier": 5,
        "solution_code": "#include <iostream>\nusing namespace std;\nint main(){\nint A, B, C, M;\nint num = 0;\nint tired = 0;\ncin >> A >> B >> C >> M;\nfor(int i=0; i<24; i++){\nif(tired + A <= M){\ntired += A;\nnum++;\n}\nelse{\ntired -= C;\nif(tired < 0) tired = 0;\n}\n}\ncout << num * B;\nreturn 0;\n}"
    },
    {
        "problem_tier": 4,
        "solution_code": "#include <stdio.h>\n#include <math.h>\nint main() {\ndouble a;\nscanf(\"%lf\", &a);\ndouble value = a * a * sqrt(3)/4;\nprintf(\"%.10lf\", value);\nreturn 0;\n}"
    },
    {
        "problem_tier": 4,
        "solution_code": "#include <iostream>\n#include <algorithm>\n#include <cstring>\nusing namespace std;\nint main() {\nint n, m;\nint x, y, z;\nint result = 0;\nint arr[10010];\nmemset(arr, 0, sizeof(arr));\ncin >> n >> m;\nz = m;\nfor (int i = 1; i <= n; ++i) {\ncin >> x;\ncin >> y;\nz += x - y;\nif (z < 0) {\ncout << 0 << endl;\nreturn 0;\n}"
    },
    {
        "problem_tier": 4,
        "solution_code": "#include <iostream>\nusing namespace std;\nint main() {\nint t;\ncin >> t;\nfor(int k=0; k<t; k++) {\nint gundal[6] = {1, 2, 3, 3, 4, 10};\nint sauron[7] = {1, 2, 2, 2, 3, 5, 10};\nint sum_a = 0, sum_b = 0;\nfor(int i=0; i<6; i++) {\nint d;\ncin >> d;\nsum_a += gundal[i] * d;\n}\nfor(int i=0; i<7; i++) {\nint d;\ncin >> d;\nsum_b += sauron[i] * d;\n}\ncout << \"Battle \" << k+1 << \": \";\nif(sum_a == sum_b) {\ncout << \"No victor on this battle field\" << endl;\n} else if(sum_a > sum_b) {\ncout << \"Good triumphs over Evil\" << endl;\n} else if(sum_a < sum_b) {\ncout << \"Evil eradicates all trace of Good\" << endl;\n}\n}\nreturn 0;\n}"
    },
    {
        "problem_tier": 12,
        "solution_code": "#include<iostream>\n#include<vector>\n#include<algorithm>\nusing namespace std;\nint main() {\nint x, n;\nwhile (cin >> x >> n) {\nx *= 10000000;\nvector<int> vec;\nint temp;\nfor (int i = 0; i < n; i++) {\ncin >> temp;\nvec.push_back(temp);\n}\nsort(vec.begin(), vec.end());\nint low = 0, high = vec.size() - 1;\nbool flag = false;\nwhile (low < high) {\nint sum = vec[low] + vec[high];\nif (sum == x) {\nflag = true;\nbreak;\n}\nif (sum < x) {\nlow++;\n}\nelse {\nhigh--;\n}\n}\nif (flag)\ncout << \"yes \" << vec[low] << ' ' << vec[high] << endl;\nelse\ncout << \"danger\" << endl;\n}\nreturn 0;\n}"
    },
    {
        "problem_tier": 5,
        "solution_code": "#include<iostream>\n#include<map>\n#include<cmath>\nusing namespace std;\nint convert(){\nstring s;\ncin >> s;\nmap<char, int> m;\nm['-'] = 0;\nm['\\\\'] = 1;\nm['('] = 2;\nm['@'] = 3;\nm['?'] = 4;\nm['>'] = 5;\nm['&'] = 6;\nm['%'] = 7;\nm['/'] = -1;\nint num = 0;\nint indice = s.size() - 1;\nfor(int i=0; i<s.size(); i++, indice--)\nnum += pow(8, indice) * m[s[i]];\nreturn num;\n}\nint main(){\nwhile(1){\nint result = convert();\nif(result == 0) break;\ncout << result << '\\n';\n}\nreturn 0;\n}"
    },
    {
        "problem_tier": 14,
        "solution_code": "#include <bits/stdc++.h>\n#define INF 0x3f3f3f3f\n#define fastio ios_base::sync_with_stdio(0); cin.tie(0); cout.tie(0);\nusing namespace std;\nstruct Node{\nint num = INF, idx = INF;\n};\nint nums[100001], n, k, q;\nvector<Node> tree(400001);\nbool operator<(const Node& a, const Node& b){\nif(a.num == b.num) return a.idx < b.idx;\nreturn a.num < b.num;\n}\nNode init(int start, int end, int node){\nif(start == end) return tree[node] = {nums[start], start};\nint mid = (start + end) / 2;\nreturn tree[node] = min(init(start, mid, node*2), init(mid+1, end, node*2+1));\n}\nNode update(int start, int end, int node, int index, int num){\nif(index < start || end < index) return tree[node];\nif(start == end) return tree[node] = {num, index};\nint mid = (start + end) / 2;\nreturn tree[node] = min(update(start, mid, node*2, index, num), update(mid+1, end, node*2+1, index, num));\n}\nNode query(int start, int end, int node, int left, int right){\nif(end < left || start > right) return {INF, INF};\nif(left <= start && end <= right) return tree[node];\nint mid = (start + end) / 2;\nreturn min(query(start, mid, node*2, left, right), query(mid+1, end, node*2+1, left, right));\n}\nint main(){\nfastio;\ncin >> n;\nfor(int i = 0; i < n; i++) cin >> nums[i];\ncin >> q;\ninit(0, n-1, 1);\nwhile(q--){\nint op;\ncin >> op;\nif(op == 1){\nint a, b;\ncin >> a >> b;\nupdate(0, n-1, 1, a-1, b);\n} else{\nNode ans = query(0, n-1, 1, 0, n-1);\ncout << ans.idx + 1 << '\\n';\n}\n}\n}"
    },
    {
        "problem_tier": 5,
        "solution_code": "#include <iostream>\n#include <string>\nusing namespace std;\nint main() {\nios_base::sync_with_stdio(false);\ncin.tie(0);\nint N;\ncin >> N;\ncin.ignore();\nfor (int i = 0; i < N; i++) {\nstring s;\ngetline(cin, s);\nint cnt = 0;\nfor (int j = 0; j < s.length(); j++) {\ncnt++;\nif (s[j] == ' ') break;\n}\ncout << \"god\";\nfor (int k = cnt; k < s.length(); k++) {\nif (s[k] != ' ') cout << s[k];\n}\ncout << \"\\n\";\n}\nreturn 0;\n}"
    },
    {
        "problem_tier": 10,
        "solution_code": "#include<iostream>\n#include<algorithm>\nusing namespace std;\nint dx[] = {0, 0, 1, -1};\nint dy[] = {1, -1, 0, 0};\nint r, c;\nchar map[11][11];\nchar ans[11][11];\nint getLastYidx() {\nint idx = 0;\nfor(int i=0; i<r; i++){\nfor(int j=0; j<c; j++){\nif(ans[i][j] == 'X')\nidx = max(idx, i);\n}\n}\nreturn idx;\n}\npair<int, int> getLastXidx() {\nint idxX = 0;\nint idxY = 0;\nfor(int i=0; i<r; i++){\nfor(int j=0; j<c; j++){\nif(ans[i][j] == 'X')\nidxX = max(idxX, i), idxY = max(idxY, j);\n}\n}\nreturn {idxX, idxY};\n}\npair<int, int> getFirstXidx() {\nint idxX = 1000;\nint idxY = 1000;\nfor(int i=0; i<r; i++){\nfor(int j=0; j<c; j++){\nif(ans[i][j] == 'X')\nidxX = min(idxX, i), idxY = min(idxY, j);\n}\n}\nreturn {idxX, idxY};\n}\nint main() {\ncin >> r >> c;\nfor(int i=0; i<r; i++)\ncin >> map[i];\nfor(int i=0; i<r; i++){\nfor(int j=0; j<c; j++){\nif(map[i][j] != 'X')\ncontinue;\nint cnt = 0;\nfor(int k=0; k<4; k++){\nint x = i + dx[k];\nint y = j + dy[k];\nif(x < 0 || x >= r || y < 0 || y >= c) {\ncnt++;\ncontinue;\n}\nif(map[x][y] == '.')\ncnt++;\n}\nif(cnt >= 3)\nmap[i][j] = '.';\n}\n}\nfor(int i=0; i<r; i++) {\nfor(int j=0; j<c; j++) {\nif(map[i][j] == 'X')\nans[i][j] = map[i][j];\n}\n}\npair<int, int> firstIdx = getFirstXidx();\npair<int, int> lastIdx = getLastXidx();\nfor(int i=firstIdx.first; i<=lastIdx.first; i++) {\nfor(int j=firstIdx.second; j<=lastIdx.second; j++) {\nif(ans[i][j] != 'X')\ncout << '.';\nelse\ncout << ans[i][j];\n}\ncout << '\\n';\n}\n}\n"
    },
    {
        "problem_tier": 5,
        "solution_code": "#include <iostream>\n#include <string>\nusing namespace std;\nint main() {\nstring plain_text, key, cipher_text;\ngetline(cin, plain_text);\ncin >> key;\nfor (int i = 0; i < plain_text.length(); i++) {\nif (plain_text[i] == ' ')\ncipher_text += ' ';\nelse {\nchar tmp = plain_text[i] - (key[i % key.length()] - 'a') - 1;\nif (tmp < 'a')\ntmp += 26;\ncipher_text += tmp;\n}\n}\ncout << cipher_text << endl;\nreturn 0;\n}"
    },
    {
        "problem_tier": 8,
        "solution_code": "#include <iostream>\n#include <algorithm>\n#include <vector>\nusing namespace std;\nint main() {\nios_base::sync_with_stdio(false);\ncin.tie(0);\ncout.tie(0);\nint n, a, mmin;\ncin >> n;\nvector<int> v;\nfor (int i = 0; i < 2 * n; i++) {\ncin >> a;\nv.push_back(a);\n}\nsort(v.begin(), v.end());\nmmin = 1e9;\nfor (int i = 0; i < n; i++) {\nint num = v[i] + v[2 * n - i - 1];\nmmin = min(mmin, num);\n}\ncout << mmin << '\\n';\nreturn 0;\n}"
    },
    {
        "problem_tier": 9,
        "solution_code": "#include<iostream>\n#include<string>\nusing namespace std;\nbool checkJava(const string& str){\nif(str[0] > 'z' || str[0] < 'a')\nreturn false;\nfor(int i = 0; i < str.length(); i++){\nif(!((str[i] >= 'a' && str[i] <= 'z') || (str[i] >= 'A' && str[i] <= 'Z'))){\nreturn false;\n}\n}\nreturn true;\n}\nbool checkCpp(const string& str){\nif(str[0] == '_' || str[str.length() - 1] == '_')\nreturn false;\nfor(int i = 0; i < str.length(); i++){\nif(i > 0){\nif(str[i - 1] == '_' && str[i] == '_')\nreturn false;\n}\nif((str[i] > 'z' || str[i] < 'a') && str[i] != '_'){\nreturn false;\n}\n}\nreturn true;\n}\nstring CppToJava(const string& str){\nstring converted = \"\";\nfor(int i = 1; i < str.length(); i++){\nif(str[i] == '_'){\nstr[i + 1] = (char)str[i + 1] - 32;\nstr.erase(i, 1);\n}\n}\nreturn str;\n}\nvoid JavaToCpp(const string& str){\ncout << str[0];\nfor(int i = 1; i < str.length(); i++){\nif(str[i] >= 'A' && str[i] <= 'Z'){\ncout << \"_\" << (char)(str[i] + 32);\n}\nelse{\ncout << str[i];\n}\n}\n}\nvoid ProblemSolved(){\nstring str;\ncin >> str;\nif(checkJava(str)){\nJavaToCpp(str);\n}\nelse if(checkCpp(str)){\ncout << CppToJava(str);\n}\nelse{\ncout << \"Error!\";\n}\nreturn;\n}\nint main(){\nios_base::sync_with_stdio(false);\ncin.tie(0);\nProblemSolved();\nreturn 0;\n}"
    },
    {
        "problem_tier": 12,
        "solution_code": "#include <iostream>\n#include <string>\nusing namespace std;\nstring solve(int n) {\nif (n == 1) {\nreturn \"m\";\n}\nelse if (n <= 4) {\nreturn \"o\";\n}\nelse {\nint k = 1;\nint length = 3;\nwhile (n > length) {\nk++;\nlength = 2 * length + k + 3;\n}\nint midLength = (length - k - 3) / 2;\nint t = (length - midLength) / 2;\nif (n <= t) {\nmidLength--;\nlength = t;\n}\nelse if (n > t + midLength) {\nn -= (t + midLength);\nmidLength--;\nlength = t;\n}\nelse {\nn -= t;\n}\nreturn solve(n);\n}\n}\nint main() {\nint n;\ncin >> n;\ncout << solve(n) << endl;\nreturn 0;\n}"
    },
    {
        "problem_tier": 14,
        "solution_code": "#include<iostream>\n#include<vector>\n#include<algorithm>\nusing namespace std;\nint N, num[50];\nint main(){\nios::sync_with_stdio(0);\ncin.tie(0);\ncout.tie(0);\ncin >> N;\nfor(int i = 0; i < N; i++)\ncin >> num[i];\nif(N == 1){\ncout << \"A\\n\";\nreturn 0;\n}"
    },
    {
        "problem_tier": 12,
        "solution_code": "#include<iostream>\n#include<algorithm>\n#include<vector>\nusing namespace std;\nint main(){\nios_base::sync_with_stdio(false);\ncin.tie(nullptr);\ncout.tie(nullptr);\nint N, S;\ncin>>N;\nvector<int> v(N,0);\nfor(int i=0;i<N;++i)\ncin>>v[i];\ncin>>S;\nfor(int i=0;i<N;i++){\nint max=v[i];\nint maxi=i;\nfor(int j=i+1;j<N;j++){\nif(S-(j-i)>=0){\nif(max<v[j]){\nmax=v[j];\nmaxi=j;\n}\n}\n}\nfor(int j=maxi;j>i;j--)\nswap(v[j],v[j-1]);\nS-=(maxi-i);\nif(S<=0)\nbreak;\n}\nfor(int i=0;i<v.size();i++)\ncout<<v[i]<<\"\";\nreturn 0;\n}"
    },
    {
        "problem_tier": 13,
        "solution_code": "#include <iostream>\n#include <algorithm>\n#include <vector>\nusing namespace std;\nint n, m, l;\nvector<int> v;\nbool chk(int mid) {\nint cnt = 0;\nfor (int i = 1; i < v.size(); i++) {\nint dist = v[i] - v[i-1];\ncnt += dist / mid;\nif (dist % mid == 0) {\ncnt--;\n}\n}\nreturn cnt > m;\n}\nint main(void) {\nios_base::sync_with_stdio(0);\ncin.tie(0);\ncout.tie(0);\ncin >> n >> m >> l;\nv.push_back(0);\nv.push_back(l);\nfor (int i = 0; i < n; i++) {\nint x;\ncin >> x;\nv.push_back(x);\n}\nsort(v.begin(), v.end());\nint st = 1, en = l;\nint mid, ret = 0;\nwhile (st <= en) {\nmid = (st + en) / 2;\nif (chk(mid)) {\nst = mid + 1;\n}\nelse {\nret = mid;\nen = mid - 1;\n}\n}\ncout << ret;\nreturn 0;\n}"
    },
    {
        "problem_tier": 5,
        "solution_code": "#include <iostream>\n#include <cstring>\nusing namespace std;\nchar a[100001];\nchar b[100001];\nint main() {\ncin >> a >> b;\nfor (int i = 0; i < strlen(a); i++) {\nif (a[i] == '1' && b[i] == '1')\ncout << '1';\nelse\ncout << '0';\n}\ncout << '\\n';\nfor (int i = 0; i < strlen(a); i++) {\nif (a[i] == '1' || b[i] == '1')\ncout << '1';\nelse\ncout << '0';\n}\ncout << '\\n';\nfor (int i = 0; i < strlen(a); i++) {\nif (a[i] != b[i])\ncout << '1';\nelse\ncout << '0';\n}\ncout << '\\n';\nfor (int i = 0; i < strlen(a); i++) {\nif (a[i] == '1')\ncout << '0';\nelse\ncout << '1';\n}\ncout << '\\n';\nfor (int i = 0; i < strlen(a); i++) {\nif (b[i] == '1')\ncout << '0';\nelse\ncout << '1';\n}\ncout << '\\n';\nreturn 0;\n}"
    },
    {
        "problem_tier": 13,
        "solution_code": "#include<bits/stdc++.h>\nusing namespace std;\nunordered_set <int> S;\nint n, r, a[1001];\nint main(){\ncin >> n;\nfor (int i{}; i < n; scanf(\"%d\", &a[i++]));\nsort(a, a + n);\nfor (int i{}; i < n; i++){\nfor (int j{}; j <= i; j++){\nif (S.insert(a[i] + a[j])){\nif (S.count(a[i] - a[j])){\nr = max(r, a[i]);\n}\n}\n}\n}\ncout << r;\n}"
    },
    {
        "problem_tier": 3,
        "solution_code": "#include <iostream>\nusing namespace std;\nint main() {\nint A, B;\ncin >> A >> B;\nif (A == B) {\ncout << A << endl;\n}\nelse if (A > B) {\ncout << A << endl;\n}\nelse {\ncout << B << endl;\n}\nreturn 0;\n}"
    },
    {
        "problem_tier": 6,
        "solution_code": "#include <iostream>\n#include <vector>\nusing namespace std;\nint main() {\nwhile (1) {\nvector<int> num;\nint x, ans = 0;\nwhile (1) {\ncin >> x;\nif (x == -1) break;\nif (x) {\nnum.push_back(x);\ncontinue;\n}\nfor (int i = 0; i < num.size(); i++) {\nfor (int j = 0; j < num.size(); j++) {\nif (num[i] == num[j] * 2) ans++;\n}\n}\ncout << ans << '\\n';\nnum.clear();\nans = 0;\n}\n}\nreturn 0;\n}"
    },
    {
        "problem_tier": 9,
        "solution_code": "#include<iostream>\n#include<algorithm>\n#include<vector>\nusing namespace std;\nbool visited[10000];\nint get_num(int a, int b, int c, int d) {\nint num1 = a * 1000 + b * 100 + c * 10 + d;\nint num2 = b * 1000 + c * 100 + d * 10 + a;\nint num3 = c * 1000 + d * 100 + a * 10 + b;\nint num4 = d * 1000 + a * 100 + b * 10 + c;\nreturn min({num1, num2, num3, num4});\n}\nvoid get_all_clock_num() {\nfor (int i = 1; i < 10; i++) {\nfor (int j = 1; j < 10; j++) {\nfor (int k = 1; k < 10; k++) {\nfor (int l = 1; l < 10; l++) {\nint clock = get_num(i, j, k, l);\nif (visited[clock] == false) {\nvisited[clock] = true;\n}\n}\n}\n}\n}\n}\nint main(void) {\nint a, b, c, d;\ncin >> a >> b >> c >> d;\nint input = get_num(a, b, c, d);\nget_all_clock_num();\nint sol = 0;\nfor (int i = 1111; i <= input; i++) {\nif (visited[i] == true)\nsol++;\n}\ncout << sol;\nreturn 0;\n}"
    },
    {
        "problem_tier": 4,
        "solution_code": "#include<iostream>\nusing namespace std;\nint main() {\nfor (int a = 6; a <= 100; a++) {\nfor (int b = 2; b < a; b++) {\nfor (int c = b + 1; c < a; c++) {\nfor (int d = c + 1; d < a; d++) {\nif (a * a * a == b * b * b + c * c * c + d * d * d) {\ncout << \"Cube = \" << a << \", Triple = (\" << b << \",\" << c << \",\" << d << \")\\n\";\n}\n}\n}\n}\n}\nreturn 0;\n}"
    },
    {
        "problem_tier": 18,
        "solution_code": "#include <iostream>\n#include <vector>\n#include <stack>\nusing namespace std;\nint N, M;\nvector<vector<int>> adj;\nvector<vector<int>> trans_adj;\nvector<vector<int>> SCC;\nvector<int> discovered;\nvector<int> sccid;\nstack<int> stk;\nint vertex_cnt, scc_cnt;\nint SCCDFS(int now) {\nint ret = discovered[now] = vertex_cnt++;\nstk.push(now);\nfor (auto& next : adj[now]) {\nif (discovered[next] == -1) {\nret = min(ret, SCCDFS(next));\n}\nelse if (sccid[next] == -1) {\nret = min(ret, discovered[next]);\n}\n}\nif (ret == discovered[now]) {\nvector<int> scc;\nwhile (1) {\nint temp = stk.top();\nstk.pop();\nscc.push_back(temp);\nsccid[temp] = scc_cnt;\nif (temp == now) break;\n}\nSCC.push_back(scc);\nscc_cnt++;\n}\nreturn ret;\n}\nvoid init() {\nadj.clear();\ntrans_adj.clear();\ndiscovered.clear();\nsccid.clear();\nSCC.clear();\nvertex_cnt = scc_cnt = 0;\ncin >> N >> M;\nadj.resize(N + 1, vector<int>());\ntrans_adj.resize(N + 1, vector<int>());\ndiscovered.resize(N + 1, -1);\nsccid.resize(N + 1, -1);\nint u, v;\nfor (int i = 0; i < M; i++) {\ncin >> u >> v;\nadj[u].push_back(v);\ntrans_adj[v].push_back(u);\n}\n}\nvoid solve() {\nfor (int i = 1; i <= N; i++) {\nif (discovered[i] != -1) continue;\nSCCDFS(i);\n}\nvector<int> in_degree(scc_cnt, 0);\nfor (int i = 1; i <= N; i++) {\nfor (auto& w : adj[i]) {\nif (sccid[w] == sccid[i]) continue;\nin_degree[sccid[w]]++;\n}\n}\nint result = 0;\nfor (int i = 0; i < scc_cnt; i++) {\nif (in_degree[i] == 0) result++;\n}\ncout << result << \"\\n\";\n}\nint main() {\nios::sync_with_stdio(0), cin.tie(0);\nint test;\ncin >> test;\nwhile (test--) {\ninit();\nsolve();\n}\nreturn 0;\n}"
    },
    {
        "problem_tier": 6,
        "solution_code": "#include <iostream>\n#include <vector>\nusing namespace std;\nstring phone1, phone2;\nvector<int> v;\nvoid init() {\ncin >> phone1 >> phone2;\nfor (int i = 0; i < 8; i++) {\nv.push_back(int(phone1[i]) - 48);\nv.push_back(int(phone2[i]) - 48);\n}\n}\nvoid solve(vector<int> v) {\nif (v.size() == 2) {\ncout << v[0] << v[1];\nreturn;\n}\nvector<int> v2;\nfor (int i = 1; i < v.size(); i++) {\nv2.push_back((v[i - 1] + v[i]) % 10);\n}\nsolve(v2);\n}\nint main() {\ninit();\nsolve(v);\nreturn 0;\n}"
    },
    {
        "problem_tier": 5,
        "solution_code": "#include <iostream>\n#include <vector>\n#include <algorithm>\nusing namespace std;\nint main() {\nint n;\ncin >> n;\nstring s;\ncin >> s;\nstring s1[3] = {\"ABC\",\"BABC\",\"CCAABB\"};\nstring res[3] = {\"Adrian\",\"Bruno\",\"Goran\"};\nvector<string> v;\nfor (int i = 0; i < 3; i++) {\nstring temp = s1[i];\nwhile (s1[i].size() <= 100)\ns1[i] += temp;\n}\nint maxcnt = 0;\nfor (int i = 0; i < 3; i++) {\nint cnt = 0;\nfor (int j = 0; j < n; j++) {\nif (s1[i][j] == s[j])\ncnt++;\n}\nif (maxcnt < cnt) {\nv.clear();\nv.push_back(res[i]);\nmaxcnt = cnt;\n}\nelse if (maxcnt == cnt) {\nv.push_back(res[i]);\n}\n}\nsort(v.begin(), v.end());\ncout << maxcnt << \"\\n\";\nfor (auto it : v)\ncout << it << endl;\nreturn 0;\n}"
    },
    {
        "problem_tier": 18,
        "solution_code": "#include <iostream>\n#include <vector>\n#include <string>\n#include <algorithm>\nint bitmask[10][1 << 10];\nchar board[10][10];\nvoid dfs(const int index, std::string& line);\nint dp(std::vector<std::string>& lines, int lineNumber, int beforeBits, int& n, int& m);\nvoid solve(void);\nvoid dfs(std::vector<std::string>& lines, int dfsArray[10], int index, int& m) {\nif (m == index) {\nstd::string str;\nfor (int a : dfsArray)\nstr += std::to_string(a);\nlines.push_back(str);\nreturn;\n}\ndfsArray[index] = 0;\ndfs(lines, dfsArray, index + 1, m);\nif (0 < index && dfsArray[index - 1] != 0)\nreturn;\ndfsArray[index] = 1;\ndfs(lines, dfsArray, index + 1, m);\n}\nint dp(std::vector<std::string>& lines, int lineNumber, int beforeBits, int& n, int& m) {\nif (n == lineNumber)\nreturn 0;\nif (-1 < bitmask[lineNumber][beforeBits])\nreturn bitmask[lineNumber][beforeBits];\nint answer = 0;\nfor (auto line : lines) {\nint bits = 0;\nint count = 0;\nfor (int i = 0; i < m; i++) {\nif ('0' == line[i])\ncontinue;\nif ('x' == board[lineNumber][i])\ncontinue;\nif (0 < i && beforeBits & (1 << (i - 1)))\ncontinue;\nif (i < m && beforeBits & (1 << (i + 1)))\ncontinue;\ncount++;\nbits |= (1 << i);\n}\nanswer = std::max(answer, dp(lines, lineNumber + 1, bits, n, m) + count);\n}\nbitmask[lineNumber][beforeBits] = answer;\nreturn answer;\n}\nvoid solve(void) {\nstd::fill(bitmask[0], bitmask[0] + (10 * (1 << 10)), -1);\nstd::fill(board[0], board[0] + (10 * 10), 0);\nint n, m;\nstd::cin >> n >> m;\nfor (int i = 0; i < n; i++)\nfor (int j = 0; j < m; j++)\nstd::cin >> board[i][j];\nint dfsArray[10];\nstd::vector<std::string> lines;\ndfs(lines, dfsArray, 0, m);\nstd::cout << dp(lines, 0, 0, n, m) << '\\n';\n}\nint main(void) {\nstd::ios::sync_with_stdio(false);\nstd::cin.tie(NULL);\nstd::cout.tie(NULL);\nint testCase;\nstd::cin >> testCase;\nfor (int t = 0; t < testCase; t++)\nsolve();\nreturn 0;\n}"
    },
    {
        "problem_tier": 5,
        "solution_code": "#include<iostream>\n#include<bitset>\n#include<string>\nusing namespace std;\nint main() {\nstring b1, b2;\ncin >> b1 >> b2;\nbitset<64> num1(stoull(b1, 0, 2));\nbitset<64> num2(stoull(b2, 0, 2));\nbitset<64> result = num1 * num2;\ncout << result.to_ullong() << endl;\nreturn 0;\n}"
    },
    {
        "problem_tier": 7,
        "solution_code": "#include <iostream>\n#include <string>\nusing namespace std;\nint main() {\nint n;\nchar digit;\ncin >> n >> digit;\nint repeated = 0;\nfor (int i = 0; i < n; i++) {\nstring num = to_string(i + 1);\nfor (int k = 0; k < num.length(); k++) {\nif (num[k] == digit)\nrepeated++;\n}\n}\ncout << repeated << \"\\n\";\nreturn 0;\n}"
    },
    {
        "problem_tier": 3,
        "solution_code": "#include <iostream>\nint main() {\nint speedLimit, currentSpeed;\nstd::cin >> speedLimit >> currentSpeed;\nint speedDiff = currentSpeed - speedLimit;\nif (speedDiff <= 0) {\nstd::cout << \"Congratulations, you are within the speed limit!\";\n} else {\nstd::cout << \"You are speeding and your fine is $\";\nif (speedDiff >= 1 && speedDiff <= 20) {\nstd::cout << 100;\n} else if (speedDiff >= 21 && speedDiff <= 30) {\nstd::cout << 270;\n} else if (speedDiff > 30) {\nstd::cout << 500;\n}\nstd::cout << \".\";\n}\nreturn 0;\n}"
    },
    {
        "problem_tier": 6,
        "solution_code": "#include<iostream>\nusing namespace std;\nint main() {\nint T;\ncin >> T;\nwhile (T--) {\nint M, N;\ncin >> M >> N;\nint grid[101][101];\nfor (int i = 0; i < M; i++) {\nfor (int j = 0; j < N; j++) {\ncin >> grid[i][j];\n}\n}\nint totalDis = 0;\nfor (int col = 0; col < N; col++) {\nint dump = 0;\nfor (int row = M - 1; row >= 0; row--) {\nif (grid[row][col] == 1) {\ntotalDis += (M - 1) - row - dump;\ndump++;\n}\n}\n}\ncout << totalDis << endl;\n}\nreturn 0;\n}"
    },
    {
        "problem_tier": 19,
        "solution_code": "#include <iostream>\n#include <algorithm>\n#include <cstring>\n#define INF 987654321\nusing namespace std;\nint dp[3][10001];\nint N, W, enemy[2][10001];\nvoid solve(void) {\nfor (int i = 2; i <= N; i++) {\nint outer = 2 - (enemy[0][i] + enemy[0][i - 1] <= W);\nint inner = 2 - (enemy[1][i] + enemy[1][i - 1] <= W);\nint horizon = 2 - (enemy[0][i] + enemy[1][i] <= W);\ndp[0][i] = min(dp[2][i - 1] + 1, dp[1][i - 1] + outer);\ndp[1][i] = min(dp[2][i - 1] + 1, dp[0][i - 1] + inner);\ndp[2][i] = min({dp[2][i - 1] + horizon, dp[0][i] + 1, dp[1][i] + 1, dp[2][i - 2] + outer + inner});\n}\nreturn;\n}\nint main() {\nios::sync_with_stdio(0);\ncin.tie(0);\ncout.tie(0);\nint T;\ncin >> T;\nwhile (T--) {\ncin >> N >> W;\nfor (int i = 0; i < 2; i++)\nfor (int j = 1; j <= N; j++)\ncin >> enemy[i][j];\nif (N == 1) {\ncout << 2 - (enemy[0][1] + enemy[1][1] <= W) << '\\n';\ncontinue;\n}\nint ans = INF;\nmemset(dp, 0, sizeof(dp));\ndp[0][1] = dp[1][1] = 1;\ndp[2][1] = 2 - (enemy[0][1] + enemy[1][1] <= W);\nsolve();\nans = min(ans, dp[2][N]);\nif (enemy[0][N] + enemy[0][1] <= W) {\ndp[2][0] = INF;\ndp[0][1] = 1;\ndp[1][1] = INF;\ndp[2][1] = 2;\nsolve();\nans = min(ans, dp[1][N]);\n}\nif (enemy[1][N] + enemy[1][1] <= W) {\ndp[2][0] = INF;\ndp[1][1] = 1;\ndp[0][1] = INF;\ndp[2][1] = 2;\nsolve();\nans = min(ans, dp[0][N]);\n}\nif (enemy[0][N] + enemy[0][1] <= W && enemy[1][N] + enemy[1][1] <= W) {\ndp[2][0] = INF;\ndp[0][1] = dp[1][1] = INF;\ndp[2][1] = 2;\nsolve();\nans = min(ans, dp[2][N - 1]);\n}\ncout << ans << '\\n';\n}\nreturn 0;\n}"
    },
    {
        "problem_tier": 9,
        "solution_code": "#include<iostream>\n#include<stack>\nusing namespace std;\nvoid fast_io(void){\nios_base::sync_with_stdio(false);\ncin.tie(NULL);\ncout.tie(NULL);\n}\nint main(){\nfast_io();\nint n, res=0;\nstack<pair<int,int>> s;\ncin >> n;\nwhile(n--){\nbool num;\ncin >> num;\nif(num){       int a, b;\ncin >> a >> b;\ns.push(make_pair(a, b));\n}\nif(!s.empty()){\ns.top().second--;\nif(s.top().second == 0){         res += s.top().first;\ns.pop();\n}\n}\n}\ncout << res;\n}"
    },
    {
        "problem_tier": 5,
        "solution_code": "#include<iostream>\n#include<string>\nusing namespace std;\nint main() {\nint t;\ncin >> t;\nwhile (t--) {\nstring num1, num2;\ncin >> num1 >> num2;\nint cnt = 0;\nfor (int i = 0; i < num1.length(); i++) {\nif (num1[i] != num2[i])\ncnt++;\n}\ncout << \"Hamming distance is \" << cnt << \".\" << endl;\n}\nreturn 0;\n}"
    },
    {
        "problem_tier": 4,
        "solution_code": "#include<iostream>\n#include<string.h>\nusing namespace std;\nint main(){\nchar s1[21];\nchar s2[21];\nchar s3[21];\nscanf(\"%s%s%s\", s1, s2, s3);\nif (s1[strlen(s1) - 1] == s2[0] && s2[strlen(s2) - 1] == s3[0] && s3[strlen(s3) - 1] == s1[0])\nprintf(\"good\");\nelse\nprintf(\"bad\");\nreturn 0;\n}"
    },
    {
        "problem_tier": 15,
        "solution_code": "#include <bits/stdc++.h>\nusing namespace std;\ntypedef long long ll;\nll d[56];\nll solution(ll n);\nint main() {\nios_base::sync_with_stdio(false);\ncin.tie(0);\ncout.tie(0);\nd[0] = 1;\nll n, n2;\ncin >> n >> n2;\nfor (int i = 1; i <= 55; i++) {\nd[i] = d[i - 1] * 2 + ((ll)1 << i);\n}\ncout << solution(n2) - solution(n - 1) << '\\n';\nreturn 0;\n}"
    },
    {
        "problem_tier": 4,
        "solution_code": "#include <iostream>\n#include <string>\nusing namespace std;\nint main() {\nint n, ans = 0;\ncin >> n;\nfor (int i = 1; i <= n; i++) {\nstring strN = to_string(i);\nint sum = 0;\nfor (int j = 0; j < strN.size(); j++) {\nsum += strN[j] - '0';\n}\nif (i % sum == 0) ans++;\n}\ncout << ans;\nreturn 0;\n}"
    },
    {
        "problem_tier": 5,
        "solution_code": "#include<iostream>\nusing namespace std;\nint main() {\nint A, B, C, X, Y;\ncin >> A >> B >> C >> X >> Y;\nint minPrice = 0;\nif (A + B > 2 * C) {\nint minNum = min(X, Y);\nminPrice += minNum * 2 * C;\nX -= minNum;\nY -= minNum;\n}\nminPrice += min(X, Y) * min(A, B) * 2;\ncout << minPrice << endl;\nreturn 0;\n}"
    },
    {
        "problem_tier": 17,
        "solution_code": "#include<iostream>\n#include<queue>\nusing namespace std;\nconst int MAX = 500000;\nbool visited[2][MAX+1];\nint main() {\nint N, K;\ncin >> N >> K;\nint answer = -1;\nint time = 0;\nqueue<pair<int, int>> q;\nq.push(make_pair(N, 0));\nvisited[0][N] = true;\nwhile (!q.empty()) {\nint size = q.size();\nint nk = K + (time * (time + 1) / 2);\nif (nk < 0 || nk > MAX) {\nbreak;\n}\nwhile (size--) {\nint curX = q.front().first;\nint curTime = q.front().second;\nq.pop();\nif (curX == nk && visited[time % 2][nk]) {\nanswer = time;\ngoto END;\n}\nif (curX - 1 >= 0 && !visited[(curTime + 1) % 2][curX - 1]) {\nq.push(make_pair(curX - 1, curTime + 1));\nvisited[(curTime + 1) % 2][curX - 1] = true;\n}\nif (curX + 1 <= MAX && !visited[(curTime + 1) % 2][curX + 1]) {\nq.push(make_pair(curX + 1, curTime + 1));\nvisited[(curTime + 1) % 2][curX + 1] = true;\n}\nif (curX * 2 <= MAX && !visited[(curTime + 1) % 2][curX * 2]) {\nq.push(make_pair(curX * 2, curTime + 1));\nvisited[(curTime + 1) % 2][curX * 2] = true;\n}\n}\ntime++;\n}\nEND:\ncout << answer << endl;\nreturn 0;\n}"
    },
    {
        "problem_tier": 13,
        "solution_code": "#include <iostream>\n#include <string>\n#include <queue>\nusing namespace std;\nint main(){\nios::sync_with_stdio(false);\ncin.tie(NULL);\ncout.tie(NULL);\nint N, K;\ncin >> N >> K;\nstring Student[300010];\nfor (int i = 0; i < N; i++){\ncin >> Student[i];\n}\nqueue<int> Q[21];\nlong long Answer = 0;\nfor (int i = 0; i < N; i++){\nint Len = Student[i].length();\nwhile (!Q[Len].empty() && i - Q[Len].front() > K){\nQ[Len].pop();\n}\nAnswer += Q[Len].size();\nQ[Len].push(i);\n}\ncout << Answer << endl;\nreturn 0;\n}"
    },
    {
        "problem_tier": 12,
        "solution_code": "#include <iostream>\n#include <vector>\n#include <algorithm>\n#include <queue>\nusing namespace std;\nint main() {\nint n, room, start, end;\nint answer = 1;\ntypedef pair<int, int> pii;\nvector<pii> v;\npriority_queue<int, vector<int>, greater<int>> lastTime;\ncin >> n;\nfor (int i = 0; i < n; i++) {\ncin >> room >> start >> end;\nv.push_back({start, end});\n}\nsort(v.begin(), v.end());\nfor (int i = 0; i < v.size(); i++) {\nint startTime = v[i].first;\nint endTime = v[i].second;\nif (lastTime.empty()) {\nlastTime.push(endTime);\n}\nelse {\nif (lastTime.top() > startTime) {                 answer++;\n}\nelse {                 lastTime.pop();             }\nlastTime.push(endTime);         }\n}\ncout << answer;\nreturn 0;\n}"
    },
    {
        "problem_tier": 13,
        "solution_code": "#include <iostream>\n#define MOD 1000000007\nusing namespace std;\nlong long power(long long n, long long m){\nlong long ret = 1;\nwhile(m){\nif(m & 1)\nret = ret * n % MOD;\nm = m / 2;\nn = n * n % MOD;\n}\nreturn ret;\n}\nint main(){\nios_base::sync_with_stdio(false);\ncin.tie(0);\ncout.tie(0);\nint M;\nlong long ans = 0;\ncin >> M;\nfor(int i = 0; i < M; i++){\nlong long N, S;\ncin >> N >> S;\nans += (S * (power(N, MOD - 2))) % MOD;\n}\ncout << ans % MOD;\nreturn 0;\n}"
    },
    {
        "problem_tier": 17,
        "solution_code": "#include<iostream>\n#include<vector>\n#include<cstring>\n#define rep(i,n) for(int i=0;i<n;++i)\n#define REP(i,n) for(int i=1;i<=n;++i)\n#define FAST cin.tie(NULL); cout.tie(NULL); ios::sync_with_stdio(false)\nusing namespace std;\nint fail[1000000];\nint main(){\nFAST;\nstring S;\nint slen;\nwhile(1){\ncin>>S;\nif(S==\".\") break;\nslen = S.size();\nmemset(fail, 0, sizeof(fail));\nfor(int i=1, j=0;i<slen;++i){\nwhile(j && S[i]!=S[j]) j = fail[j-1];\nif(S[i] == S[j]) fail[i] = ++j;\n}\nif(slen % (slen - fail[slen-1])) cout << 1 << '\\n';\nelse cout << slen / (slen - fail[slen-1]) << '\\n';\n}\nreturn 0;\n}"
    },
    {
        "problem_tier": 13,
        "solution_code": "#include <iostream>\n#include <string>\nusing namespace std;\nstring a;\nstring angel;\nstring devil;\nint dp[100][21] = {0};\nint dp2[100][21] = {0};\nint result = 0;\nint main() {\ncin >> a;\ncin >> angel;\ncin >> devil;\nfor (int i = 0; i < angel.size(); i++) {\nif (angel[i] == a[0]) dp[i][0] = 1;\nif (devil[i] == a[0]) dp2[i][0] = 1;\n}\nfor (int i = 0; i < angel.size(); i++) {\nfor (int j = 1; j < a.size(); j++) {\nif (angel[i] == a[j]) {\nint cnt = 0;\nfor (int k = 0; k < i; k++) {\nif (dp2[k][j-1] != 0) cnt += dp2[k][j-1];\n}\ndp[i][j] = cnt;\n}\nif (devil[i] == a[j]) {\nint cnt = 0;\nfor (int k = 0; k < i; k++) {\nif (dp[k][j-1] != 0) cnt += dp[k][j-1];\n}\ndp2[i][j] = cnt;\n}\n}\n}\nfor (int i = 0; i < angel.size(); i++) {\nresult += dp[i][a.size()-1];\nresult += dp2[i][a.size()-1];\n}\ncout << result << endl;\nreturn 0;\n}"
    },
    {
        "problem_tier": 3,
        "solution_code": "#include <iostream>\nusing namespace std;\nint main() {\nios::sync_with_stdio(false);\ncin.tie(nullptr);\nint d, h, m;\ncin >> d >> h >> m;\nint minute = 11 + 11 * 60 + 11 * 1440;\nint answer = m + h * 60 + d * 1440 - minute;\nif (answer < 0) {\ncout << -1 << '\\n';\n} else {\ncout << answer << '\\n';\n}\nreturn 0;\n}"
    },
    {
        "problem_tier": 15,
        "solution_code": "#include <iostream>\n#include <vector>\n#include <climits>\nusing namespace std;\nvector<int> v;\ntypedef long long ll;\nll l, h, n, q;\nbool check(ll mid) {\nll cnt = q;\nfor (int i = 0; i < v.size(); i++) {\ncnt += mid / v[i];\n}\nreturn cnt >= n;\n}\nint main() {\nl = 1;\nh = 60000000000;\ncin >> n;\ncin >> q;\nfor (int i = 0; i < q; i++) {\nint a;\ncin >> a;\nv.push_back(a);\n}\nif (n <= q) {         cout << n;\nreturn 0;\n}"
    },
    {
        "problem_tier": 12,
        "solution_code": "#include <iostream>\n#include <string>\nusing namespace std;\nint get_length(int n);\nvoid go(int start, int end);\nint N, K;\nint main(void) {\ncin >> N >> K;\nif (get_length(N) < K) {\ncout << -1 << '\\n';\nreturn 0;\n}"
    },
    {
        "problem_tier": 13,
        "solution_code": "#include <iostream>\n#include <vector>\n#include <algorithm>\nusing namespace std;\nint T, L;\nunsigned long long mod = 1000000007;\nunsigned long long dp[5001];\nunsigned long long recur(int Length) {\nif (Length == 0)\nreturn 1;\nif (dp[Length] > 0)\nreturn dp[Length];\nfor (int i = 2; i <= Length; i += 2) {\ndp[Length] += (recur(i - 2) * recur(Length - i));\ndp[Length] %= mod;\n}\nreturn dp[Length];\n}\nint main() {\nios::sync_with_stdio(false);\ncin.tie(NULL);\ncout.tie(NULL);\ncin >> T;\nwhile (T--) {\ncin >> L;\nif (L % 2 != 0)\ncout << 0 << '\\n';\nelse\ncout << recur(L) << '\\n';\n}\nreturn 0;\n}"
    },
    {
        "problem_tier": 3,
        "solution_code": "#include <iostream>\n#include <string>\nusing namespace std;\nint main() {\nstring jinhoMBTI, friendMBTI;\nint n, ans = 0;\ncin >> jinhoMBTI >> n;\nwhile(n--) {\ncin >> friendMBTI;\nif(jinhoMBTI == friendMBTI)\nans++;\n}\ncout << ans;\nreturn 0;\n}"
    },
    {
        "problem_tier": 11,
        "solution_code": "#include <iostream>\n#include <algorithm>\nusing namespace std;\nint main() {\nint t;\ncin >> t;\nwhile (t--) {\nint l, n, x;\ncin >> l >> n;\nint shortest = -1, longest = -1;\nfor (int i = 0; i < n; i++) {\ncin >> x;\nshortest = max(shortest, min(x, l-x));\nlongest = max(longest, max(x, l-x));\n}\ncout << shortest << ' ' << longest << '\\n';\n}\nreturn 0;\n}"
    },
    {
        "problem_tier": 5,
        "solution_code": "#include <iostream>\n#include <algorithm>\n#include <cmath>\nusing namespace std;\ntypedef long long ll;\nint main() {\nint n;\nll arr[10100];\ncin >> n;\nfor (int i = 0; i < n; i++) {\ncin >> arr[i];\n}\nll ans = 0;\nfor (int i = 0; i < n; i++) {\nfor (int j = 0; j < n; j++) {\nans += abs(arr[i] - arr[j]);\n}\n}\ncout << ans << endl;\nreturn 0;\n}"
    },
    {
        "problem_tier": 14,
        "solution_code": "#include<iostream>\n#include<vector>\n#include<algorithm>\nusing namespace std;\nint main() {\nint n;\ncin >> n;\nvector<int> arr(n+1);\nvector<int> dp(n+1);\nfor (int i = 1; i <= n; i++) {\nint num;\ncin >> num;\narr[num] = i;\n}\nint ans = 0;\nfor (int i = 1; i <= n; i++) {\nif (arr[i] > arr[i-1])\ndp[i] = dp[i-1] + 1;\nelse\ndp[i] = 1;\nans = max(ans, dp[i]);\n}\ncout << n - ans << endl;\nreturn 0;\n}"
    },
    {
        "problem_tier": 6,
        "solution_code": "#include <iostream>\nusing namespace std;\nint n, m, dir, cnt, curR = 1, curC = 1;\nint ck[101][101];\nint dr[] = {0, 1, 0, -1};\nint dc[] = {1, 0, -1, 0};\nint main() {\ncin >> n >> m;\nck[1][1] = 1;\nwhile (1) {\ncurR += dr[dir];\ncurC += dc[dir];\nif (1 > curR || curR > n || 1 > curC || curC > m || ck[curR][curC]) {\ncurR -= dr[dir];\ncurC -= dc[dir];\ndir = (dir + 1) % 4;\nif (ck[curR + dr[dir]][curC + dc[dir]])\nbreak;\ncnt++;\n}\nck[curR][curC] = 1;\n}\ncout << cnt;\nreturn 0;\n}"
    },
    {
        "problem_tier": 19,
        "solution_code": "#include <iostream>\n#include <vector>\n#define MAX 1001\nusing namespace std;\nint n, m, k;\nvector<int> tasksList[MAX];\nint d[MAX];\nbool check[MAX];\nbool dfs(int x) {\nfor (int i = 0; i < tasksList[x].size(); i++) {\nint t = tasksList[x][i];\nif (check[t]) continue;\ncheck[t] = true;\nif (d[t] == 0 || dfs(d[t])) {\nd[t] = x;\nreturn true;\n}\n}\nreturn false;\n}\nint main() {\nscanf(\"%d %d %d\", &n, &m, &k);\nfor (int i = 1; i <= n; i++) {\nint taskNum;\nscanf(\"%d\", &taskNum);\nfor (int j = 0; j < taskNum; j++) {\nint task;\nscanf(\"%d\", &task);\ntasksList[i].push_back(task);\n}\n}\nint count = 0;\nfor (int i = 1; i <= n; i++) {\nfill(check, check + MAX, false);\nif (dfs(i)) count++;\n}\nint extra = 0;\nfor (int p = 1; p <= n && extra < k; p++) {\nfill(check, check + MAX, false);\nif (dfs(p)) extra++;\n}\ncout << count + extra << endl;\nreturn 0;\n}"
    },
    {
        "problem_tier": 12,
        "solution_code": "#include <iostream>\n#include <vector>\n#include <algorithm>\n#include <queue>\nusing namespace std;\nint main() {\nios_base::sync_with_stdio(0);\ncin.tie(0);\nint N;\ncin >> N;\npriority_queue<pair<int, int>, vector<pair<int, int>>, greater<pair<int, int>>> pq;\npriority_queue<int, vector<int>, greater<int>> tmp;\nfor (int i = 0; i < N; i++) {\nint start, end;\ncin >> start >> end;\npq.push({start, end});\n}\nint cnt = 0;\nwhile (!pq.empty()) {\nwhile (!tmp.empty() && tmp.top() <= pq.top().first) {\ntmp.pop();\n}\ntmp.push(pq.top().second);\npq.pop();\ncnt = max(cnt, (int)tmp.size());\n}\ncout << cnt << \"\\n\";\nreturn 0;\n}"
    },
    {
        "problem_tier": 6,
        "solution_code": "#include<iostream>\n#include<algorithm>\n#include<string>\nusing namespace std;\nint L1 = 0, O1 = 0, V1 = 0, E1 = 0;\nstring name1;\nint n;\nstring name2[51];\nint score[51] = {0};\nvoid countLoveCharacter(string name, int &L, int &O, int &V, int &E) {\nfor (int i = 0; i < name.size(); i++) {\nif (name[i] == 'L') {\nL++;\n}\nelse if (name[i] == 'O') {\nO++;\n}\nelse if (name[i] == 'V') {\nV++;\n}\nelse if (name[i] == 'E') {\nE++;\n}\n}\n}\nint main() {\ncin >> name1;\ncin >> n;\ncountLoveCharacter(name1, L1, O1, V1, E1);\nint L2, O2, V2, E2, max_score = -1, max_count = 0, max_num = 0;\nfor (int i = 0; i < n; i++) {\ncin >> name2[i];\nL2 = O2 = V2 = E2 = 0;\ncountLoveCharacter(name2[i], L2, O2, V2, E2);\nscore[i] = (L1 + L2 + O1 + O2) * (L1 + L2 + V1 + V2) * (L1 + L2 + E1 + E2) * (O1 + O2 + V1 + V2) * (O1 + O2 + E1 + E2) * (V1 + V2 + E1 + E2) % 100;\n}\nfor (int i = 0; i < n; i++) {\nif (score[i] > max_score) {\nmax_score = score[i];\n}\n}\nfor (int i = 0; i < n; i++) {\nif (score[i] == max_score) {\nmax_count++;\n}\n}\nif (max_count == 1) {\nfor (int i = 0; i < n; i++) {\nif (score[i] == max_score) {\ncout << name2[i];\n}\n}\n}\nelse {\nfor (int i = 0; i < n; i++) {\nif (score[i] == max_score) {\nmax_num = i;\nbreak;\n}\n}\nfor (int i = max_num + 1; i < n; i++) {\nif (score[i] == max_score && name2[i] < name2[max_num]) {\nmax_num = i;\n}\n}\ncout << name2[max_num];\n}\nreturn 0;\n}"
    },
    {
        "problem_tier": 19,
        "solution_code": "#include <iostream>\n#include <vector>\n#include <cstring>\nusing namespace std;\nvector<int> odd, even, lv, rv, ans;\nint n, m, p[2222], par[55], vis[55], a[55];\nvoid eratoss() {\np[2] = 1;\nfor (int i = 3; i <= 2000; i += 2) p[i] = 1;\nfor (int i = 3; i <= 2000; i += 2) {\nif (!p[i]) continue;\nfor (int j = i; i*j <= 2000; j += 2) {\np[i*j] = 0;\n}\n}\n}\nint match(int x) {\nfor (int nx : rv) {\nif (vis[nx] || !p[a[x] + a[nx]]) continue;\nvis[nx] = 1;\nif (!~par[nx] || match(par[nx])) {\npar[nx] = x;\nreturn 1;\n}\n}\nreturn 0;\n}\nvoid solve(int select) {\nint ret = 0;\nmemset(par, -1, sizeof(par));\nfor (int i = 1; i < lv.size(); i++) {\nmemset(vis, 0, sizeof(vis));\nvis[select] = 1;\nret += match(lv[i]);\n}\nif (ret == lv.size() - 1) ans.push_back(a[select]);\n}\nint main() {\nios::sync_with_stdio(0);\ncin.tie(0);\ncin >> n;\neratoss();\nfor (int i = 0; i < n; i++) {\ncin >> a[i];\nif (a[i] % 2) odd.push_back(i);\nelse even.push_back(i);\n}\nif (a[0] % 2) {\nlv = odd;\nrv = even;\n} else {\nlv = even;\nrv = odd;\n}\nif (lv.size() != rv.size()) {\ncout << -1;\nreturn 0;\n}"
    },
    {
        "problem_tier": 8,
        "solution_code": "#include <iostream>\n#include <vector>\nusing namespace std;\nint main() {\nint N;\ncin >> N;\nvector<long long> arr(N);\nlong long sum = 0;\nfor (int i = 0; i < N; i++) {\ncin >> arr[i];\nsum += arr[i];\n}\nlong long answer = 0;\nfor (int i = 0; i < N; i++) {\nanswer += arr[i] * (sum - arr[i]);\n}\ncout << answer / 2 << endl;\nreturn 0;\n}"
    },
    {
        "problem_tier": 18,
        "solution_code": "#include <iostream>\n#include <vector>\n#include <algorithm>\n#include <queue>\n#include <string>\n#include <set>\n#include <map>\n#include <cstring>\n#include <functional>\n#include <cmath>\n#include <stack>\n#define SIZE 30\nconst int INF = 2000000000;\nusing namespace std;\ntypedef long long int ll;\nstruct Trie{\nTrie* node[SIZE];\nint alpha_cnt;\nbool is_finish, is_child;\nTrie(){\nfill(node, node+SIZE, nullptr);\nalpha_cnt = 0;\nis_finish = is_child = false;\n}\n~Trie(){\nfor(int i=0; i<SIZE; i++){\nif(node[i])\ndelete node[i];\n}\n}\nvoid insert(const string& word, int index){\nif(index >= word.size()){\nis_finish = true;\nreturn;\n}\nelse if(index < word.size()){\nint word_index = word[index] - 'a';\nif(node[word_index] == NULL){\nalpha_cnt++;\nis_child = true;\nnode[word_index] = new Trie();\n}\nnode[word_index]->insert(word, index+1);\n}\n}\nint find(const string& word, int index, int cnt){\nif(index >= word.size()){\nreturn cnt;\n}\nint res = 0;\nint word_index = word[index] - 'a';\nif(index != 0 && (alpha_cnt != 1 || (alpha_cnt == 1 && is_finish == true)) && node[word_index] != NULL){\nres = node[word_index]->find(word, index+1, cnt+1);\n}\nelse{\nres = node[word_index]->find(word, index+1, cnt);\n}\nreturn res;\n}\n};\nint main(void){\nios::sync_with_stdio(false);\ncin.tie(NULL);\ncout.tie(NULL);\nwhile(1){\nint N;\ncin >> N;\nif(cin.eof() == true)\nbreak;\nTrie root;\nvector<string> words;\nfor(int i=0; i<N; i++){\nstring word;\ncin >> word;\nwords.push_back(word);\nroot.insert(word, 0);\n}\ndouble res = 0;\nfor(auto word : words){\nres += root.find(word, 0, 0) + 1;\n}\ncout << fixed;\ncout.precision(2);\ncout << res / double(N) << \"\\n\";\n}\nreturn 0;\n}"
    },
    {
        "problem_tier": 7,
        "solution_code": "#include <iostream>\n#include <algorithm>\n#include <vector>\nusing namespace std;\nint main() {\nint n;\ncin >> n;\nvector<int> v(n);\nfor (int i = 0; i < n; i++) {\ncin >> v[i];\n}\nsort(v.begin(), v.end());\nfor (auto el : v) {\ncout<< el << \" \";\n}\nreturn 0;\n}"
    },
    {
        "problem_tier": 3,
        "solution_code": "#include <iostream>\nusing namespace std;\nint main(){\nint b, p;\ncin >> b >> p;\nint ham = 0;\nwhile(b >= 2 && p > 0){\nb -= 2;\np--;\nham++;\n}\ncout << ham << endl;\n}"
    },
    {
        "problem_tier": 5,
        "solution_code": "#include <iostream>\n#include <vector>\nusing namespace std;\nint main() {\nint n;\nvector<int> p;\ncin >> n;\nfor (int i = 0; i < n; i++) {\nint temp;\ncin >> temp;\np.push_back(temp);\n}\nif (p[1] - p[0] == p[2] - p[1]) {\ncout << p[n - 1] + (p[1] - p[0]);\n}\nelse {\ncout << p[n - 1] * (p[1] / p[0]);\n}\nreturn 0;\n}"
    },
    {
        "problem_tier": 12,
        "solution_code": "#include <iostream>\n#include <cstring>\n#include <algorithm>\n#include <cmath>\nusing namespace std;\nint n = 0, k = 0;\nint open1, open2;\nint arr[21] = {0,};\nint dp[21][21][21];\nint solved(int o1, int o2, int cnt){\nif(cnt == k+1)\nreturn 0;\nint& ret = dp[o1][o2][cnt];\nif(ret != -1)\nreturn ret;\nret = 0;\nret = min(abs(arr[cnt]-o1)+solved(arr[cnt], o2, cnt+1), abs(arr[cnt]-o2)+solved(o1, arr[cnt], cnt+1));\nreturn ret;\n}\nint main(){\nios_base::sync_with_stdio(0);\ncin.tie(0), cout.tie(0);\nmemset(dp, -1, sizeof(dp));\ncin >> n;\ncin >> open1 >> open2;\ncin >> k;\nfor(int i=1; i<=k; i++)\ncin >> arr[i];\ncout << solved(open1, open2, 1) << endl;\nreturn 0;\n}"
    },
    {
        "problem_tier": 6,
        "solution_code": "#include<iostream>\nusing namespace std;\nint main() {\nios::sync_with_stdio(false);\ncin.tie(0);\ncout.tie(0);\nint N, m = 10, t;\ncin >> N;\nwhile(N > m) {\nt = N % m;\nN -= t;\nif(t >= 5 * (m / 10))\nN += m;         m *= 10;\n}\ncout << N;\nreturn 0;\n}"
    },
    {
        "problem_tier": 3,
        "solution_code": "#include <iostream>\n#include <cmath>\nusing namespace std;\nint main() {\ndouble m, a, b;\ncin >> a >> b;\nm = (b - a) / 400;\ncout << fixed;\ncout.precision(6);\ncout << 1 / (1 + pow(10, m)) << endl;\nreturn 0;\n}"
    },
    {
        "problem_tier": 17,
        "solution_code": "#include <iostream>\n#include <vector>\n#include <queue>\n#include <climits>\n#define INF LLONG_MAX\nusing namespace std;\ntypedef long long ll;\ntypedef pair<ll, int> pli;\nint N, M, K;\nvector<pair<int, ll>> city[10001];\nll dist[10001][21];\nll dijkstra() {\nfor(int i=1; i<=N; i++) {\nfor(int j=0; j<=K; j++) {\ndist[i][j] = INF;\n}\n}\npriority_queue<pli, vector<pli>, greater<pli>> pq;\npq.push({0, 1});\ndist[1][0] = 0;\nwhile(!pq.empty()) {\nll cost = pq.top().first;\nint cur = pq.top().second;\npq.pop();\nif(dist[cur][K] < cost) continue;\nfor(auto next : city[cur]) {\nint nxt = next.first;\nll nxtCost = cost + next.second;\nif(dist[nxt][K] > nxtCost) {\ndist[nxt][K] = nxtCost;\npq.push({nxtCost, nxt});\n}\nfor(int i=0; i<K; i++) {\nif(dist[nxt][i] > cost) {\ndist[nxt][i] = cost;\npq.push({cost, nxt});\n}\n}\n}\n}\nll minDist = INF;\nfor(int i=0; i<=K; i++) {\nminDist = min(minDist, dist[N][i]);\n}\nreturn minDist;\n}\nint main() {\ncin >> N >> M >> K;\nfor(int i=0; i<M; i++) {\nint a, b;\nll c;\ncin >> a >> b >> c;\ncity[a].push_back({b, c});\ncity[b].push_back({a, c});\n}\ncout << dijkstra() << endl;\nreturn 0;\n}"
    },
    {
        "problem_tier": 8,
        "solution_code": "#include <iostream>\n#include <string>\nusing namespace std;\nbool flag;\nint dx[8] = { -2, -2, -1, -1, 1, 1, 2, 2 };\nint dy[8] = { -1, 1, -2, 2, -2, 2, -1, 1 };\nint visited[6][6];\nint main() {\nstring str;\ncin >> str;\nint srow = 5 - (str[1] - '1');\nint scol = str[0] - 'A';\nint prow = srow;\nint pcol = scol;\nvisited[prow][pcol] = 1;\nfor (int i = 0; i < 35; i++) {\ncin >> str;\nint row = 5 - (str[1] - '1');\nint col = str[0] - 'A';\nflag = false;\nfor (int j = 0; j < 8; j++) {\nint mx = prow + dx[j];\nint my = pcol + dy[j];\nif (mx < 0 || mx >= 6 || my < 0 || my >= 6) continue;\nif (mx == row && my == col && visited[mx][my] == 0) {\nvisited[row][col] = 1;\nflag = true;\nbreak;\n}\n}\nif (flag) {\nprow = row;\npcol = col;\n} else {\ncout << \"Invalid\";\nreturn 0;\n}"
    },
    {
        "problem_tier": 16,
        "solution_code": "#include<iostream>\n#include<vector>\nusing namespace std;\ntypedef long long ll;\nstruct Segtree {\nint n;\nvector<ll> negative, zero;\nvector<ll> A;\nSegtree(vector<ll>& X) {\nA = X;\nn = A.size();\nnegative.resize(n*4);\nzero.resize(n*4);\ninit(0, n-1, 1);\n}\nvoid init(int left, int right, int node) {\nif (left == right) {\nnegative[node] = (A[left] < 0) ? 1 : 0;\nzero[node] = (A[left] == 0) ? 1 : 0;\nreturn;\n}\nint mid = (left + right) / 2;\ninit(left, mid, node*2);\ninit(mid+1, right, node*2+1);\nnegative[node] = negative[node*2] + negative[node*2+1];\nzero[node] = zero[node*2] + zero[node*2+1];\n}\nll query(int left, int right, int node, int nodeLeft, int nodeRight, bool zeroSum) {\nif (nodeRight < left || nodeLeft > right) return 0;\nif (left <= nodeLeft && nodeRight <= right) {\nif (zeroSum) return zero[node];\nelse return negative[node];\n}\nint mid = (nodeLeft + nodeRight) / 2;\nll l = query(left, right, node*2, nodeLeft, mid, zeroSum);\nll r = query(left, right, node*2+1, mid+1, nodeRight, zeroSum);\nreturn l + r;\n}\nchar query(int left, int right) {\nll negativeCnt = query(left, right, 1, 0, n-1, false);\nll zeroCnt = query(left, right, 1, 0, n-1, true);\nif (zeroCnt > 0) return '0';\nelse return (negativeCnt % 2) ? '-' : '+';\n}\nvoid update(int idx, ll val, int node, int nodeLeft, int nodeRight) {\nif (idx < nodeLeft || idx > nodeRight) return;\nif (A[idx] == 0 && val != 0) zero[node]--;\nelse if (A[idx] != 0 && val == 0) zero[node]++;\nif (A[idx] < 0 && val >= 0) negative[node]--;\nelse if (A[idx] >= 0 && val < 0) negative[node]++;\nif (nodeLeft == nodeRight) return;\nint mid = (nodeLeft + nodeRight) / 2;\nupdate(idx, val, node*2, nodeLeft, mid);\nupdate(idx, val, node*2+1, mid+1, nodeRight);\n}\nvoid update(int idx, ll val) {\nupdate(idx, val, 1, 0, n-1);\nA[idx] = val;\n}\n};\nint main() {\nios_base::sync_with_stdio(false);\ncin.tie(NULL);\ncout.tie(NULL);\nint N, K;\nwhile (cin >> N >> K) {\nvector<ll> X(N);\nfor (int i = 0; i < N; i++) {\ncin >> X[i];\n}\nSegtree ST(X);\nchar t;\nll a, b;\nfor (int i = 0; i < K; i++) {\ncin >> t >> a >> b;\nif (t == 'C') {\nST.update(a-1, b);\n}\nelse {\ncout << ST.query(a-1, b-1);\n}\n}\ncout << \"\\n\";\n}\nreturn 0;\n}"
    },
    {
        "problem_tier": 9,
        "solution_code": "#include <iostream>\n#include <string>\n#include <cmath>\nusing namespace std;\nint y_arr[4] = {-1, 0, 1, 0}; int x_arr[4] = {0, 1, 0, -1};\nint main() {\nint t = 0;\nint y = 0, x = 0, dir = 0;\nint minx = 0, miny = 0, maxx = 0, maxy = 0;\nstring arr;\ncin >> t;\nwhile (t--) {\ncin >> arr;\nfor (int i = 0; i < arr.size(); i++) {\nint ny, nx;\nif (arr[i] == 'F') {\ny += y_arr[dir % 4];\nx += x_arr[dir % 4];\n}\nelse if (arr[i] == 'B') {\ny += y_arr[(dir + 2) % 4];\nx += x_arr[(dir + 2) % 4];\n}\nelse if (arr[i] == 'R') {\ndir++;\n}\nelse if (arr[i] == 'L') {\ndir--;\nif (dir < 0)\ndir += 4;\n}\nif (maxx < x)\nmaxx = x;\nif (maxy < y)\nmaxy = y;\nif (minx > x)\nminx = x;\nif (miny > y)\nminy = y;\n}\ncout << ((maxy - miny) * (maxx - minx)) << \"\\n\";\n}\nreturn 0;\n}"
    },
    {
        "problem_tier": 4,
        "solution_code": "#include <iostream>\n#include <algorithm>\nusing namespace std;\nint main() {\nint N, M;\ncin >> N >> M;\nint maxHelmet = 0;\nfor (int i = 0; i < N; i++) {\nint num;\ncin >> num;\nmaxHelmet = max(maxHelmet, num);\n}\nint maxVest = 0;\nfor (int i = 0; i < M; i++) {\nint num;\ncin >> num;\nmaxVest = max(maxVest, num);\n}\ncout << maxHelmet + maxVest << '\\n';\nreturn 0;\n}"
    },
    {
        "problem_tier": 4,
        "solution_code": "#include <iostream>\nusing namespace std;\nint main() {\nint t;\ncin >> t;\nwhile (t--) {\nint mintime;\ncin >> mintime;\nif (mintime == 1) {\ncout << 0 << '\\n';\n} else {\nint cand = 1;\nwhile (true) {\nint endtime = cand + cand * cand;\nif (endtime > mintime) {\ncout << cand - 1 << '\\n';\nbreak;\n} else {\ncand += 1;\n}\n}\n}\n}\nreturn 0;\n}"
    },
    {
        "problem_tier": 18,
        "solution_code": "#include <iostream>\n#include <vector>\n#include <algorithm>\nusing namespace std;\n```\n변수 및 배열 선언:\n```cpp\nint V,E;\nvector<int> Edge[100001];\nint visited[100001];\nvector<pair<int,int>> answer;\n```\nDFS 함수:\n```cpp\nint DFS(int Parent, int Start, int Order) {\nint res = Order;\nvisited[Start] = Order;     for (int i=0; i<Edge[Start].size(); i++) {\nint Next = Edge[Start][i];         if (Parent == Next) {\ncontinue;\n}\nif (visited[Next] == 0) {             int Next_Order = DFS(Start, Next, Order+1);             if (Next_Order > visited[Start]) {\nanswer.push_back(make_pair(min(Start,Next), max(Start,Next)));\n}\nres = min(res, Next_Order);\n} else {\nres = min(res, visited[Next]);\ncontinue;\n}\n}\nreturn res;\n}\n```\n입력 함수:\n```cpp\nvoid Input() {\ncin >> V >> E;\nfor (int i=0; i<E; i++) {\nint A, B;\ncin >> A >> B;\nEdge[A].push_back(B);\nEdge[B].push_back(A);\n}\n}\n```\n설정 및 탐색 함수:\n```cpp\nvoid Settings() {\nfor (int i=1; i<=V; i++) {\nsort(Edge[i].begin(), Edge[i].end());\n}\nfor (int i=1; i<=V; i++) {\nif (visited[i] == 0) {\nDFS(0, i, 1);\n}\n}\n}\n```\n결과 출력 함수:\n```cpp\nvoid Find_Answer() {\nsort(answer.begin(), answer.end());\ncout << answer.size() << \"\\n\";\nfor (int i=0; i<answer.size(); i++) {\nint S = answer[i].first;\nint E = answer[i].second;\ncout << S << \" \" << E << \"\\n\";\n}\n}\n```\n메인 함수:\n```cpp\nint main() {\nInput();\nSettings();\nFind_Answer();\nreturn 0;\n}"
    },
    {
        "problem_tier": 6,
        "solution_code": "#include<iostream>\n#include<string>\nusing namespace std;\nstring inp;\nint go(string s, int index, char last){\nif(index == s.size())\nreturn 1;\nchar start = (s[index] == 'c' ? 'a' : '0');\nchar end = (s[index] == 'c' ? 'z' : '9');\nint ans = 0;\nfor(int i=start; i<=end; i++){\nif(i != last){\nans += go(s, index+1, i);\n}\n}\nreturn ans;\n}\nint main(){\nios_base::sync_with_stdio(false);\ncin.tie(NULL);\ncin >> inp;\ncout << go(inp, 0, '') << endl;\nreturn 0;\n}"
    },
    {
        "problem_tier": 7,
        "solution_code": "#include <iostream>\nusing namespace std;\nvoid fast_io() {\nios_base::sync_with_stdio(false);\ncin.tie(NULL);\ncout.tie(NULL);\n}\nint main() {\nfast_io();\nint w[9], s[9];\nfor (int i = 0; i < 9; i++) {\ncin >> w[i];\n}\nfor (int i = 0; i < 9; i++) {\ncin >> s[i];\n}\nint is_wwinbefore = 0;\nint w_score = 0;\nint s_score = 0;\nfor (int i = 0; i < 9; i++) {\nw_score += w[i];\nif (w_score > s_score) {\nis_wwinbefore = 1;\n}\ns_score += s[i];\n}\nif (w_score < s_score && is_wwinbefore == 1) {\ncout << \"Yes\";\n} else {\ncout << \"No\";\n}\nreturn 0;\n}"
    },
    {
        "problem_tier": 4,
        "solution_code": "#include <iostream>\n#include <algorithm>\n#include <climits>\nusing namespace std;\nint main() {\nios_base::sync_with_stdio(false);\ncin.tie(NULL);\ncout.tie(NULL);\nint t;\ncin >> t;\nwhile (t--) {\nint n;\ncin >> n;\nint minNum = INT_MAX;\nint maxNum = INT_MIN;\nfor (int i = 0; i < n; i++) {\nint x;\ncin >> x;\nminNum = min(minNum, x);\nmaxNum = max(maxNum, x);\n}\ncout << minNum << \" \" << maxNum << \"\\n\";\n}\nreturn 0;\n}"
    },
    {
        "problem_tier": 12,
        "solution_code": "#include <iostream>\n#include <cmath>\n#include <algorithm>\n#include <vector>\nusing namespace std;\nint main() {\nios_base::sync_with_stdio(false);\ncin.tie(NULL);\ncout.tie(NULL);\nlong long g;\ncin >> g;\nbool flag = false;\nvector<long long> square;\nfor (long long i = 1; i <= 100000; i++) {\nsquare.push_back(i * i);\n}\nfor (long long w = 1; w <= 100000; w++) {\nauto x = lower_bound(square.begin(), square.end(), w * w - g);\nif (*x == w * w - g) {\nflag = true;\ncout << w << '\\n';\n}\n}\nif (flag == false) {\ncout << -1;\n}\nreturn 0;\n}"
    },
    {
        "problem_tier": 9,
        "solution_code": "#include <iostream>\n#include <string>\n#include <iomanip>\nusing namespace std;\nint main() {\nint n, t1 = 0, t2 = 0, A = 0, B = 0, prev = 0;\nstring a;\ncin >> n;\nfor (int i = 0; i < n; i++) {\nint team, tmp;\ncin >> team >> a;\ntmp = (stoi(a.substr(0, 2)) * 60) + stoi(a.substr(3, 2));\nif (A > B) {\nt1 += tmp - prev;\n}\nelse if (A < B) {\nt2 += tmp - prev;\n}\nif (team == 1) {\nA++;\n}\nelse {\nB++;\n}\nprev = tmp;\n}\nif (A > B) {\nt1 += (48 * 60) - prev;\n}\nelse if (A < B) {\nt2 += (48 * 60) - prev;\n}\ncout << setfill('0') << setw(2) << t1 / 60 << \":\" << setw(2) << t1 % 60 << \"\\n\";\ncout << setfill('0') << setw(2) << t2 / 60 << \":\" << setw(2) << t2 % 60 << \"\\n\";\nreturn 0;\n}"
    },
    {
        "problem_tier": 11,
        "solution_code": "#include <iostream>\n#include <algorithm>\n#include <string>\nusing namespace std;\nint n, cnt, ans = 987654321;\nstring s;\nvoid group(char x){\ncnt = 0;\nbool ch = false;\nfor(int i=0; i<s.size(); i++){\nif(s[i] != x)\nch = true;\nelse if(ch && s[i] == x)\ncnt++;\n}\nif(ans > cnt)\nans = cnt;\nch = false;\ncnt = 0;\nfor(int i=s.size()-1; i>=0; i--){\nif(s[i] != x)\nch = true;\nelse if(ch && s[i] == x)\ncnt++;\n}\nif(ans > cnt)\nans = cnt;\n}\nint main(){\nios_base::sync_with_stdio(false);\ncin.tie(NULL);\ncout.tie(NULL);\ncin >> n;\ncin >> s;\ngroup('R');\ngroup('B');\ncout << ans << \"\\n\";\nreturn 0;\n}"
    },
    {
        "problem_tier": 14,
        "solution_code": "#include<iostream>\n#include<vector>\n#include<algorithm>\nusing namespace std;\nstruct Edge {\nint u, v, w;\n};\nint parent[1001];\nint find(int x) {\nif (x == parent[x]) return x;\nreturn parent[x] = find(parent[x]);\n}\nvoid merge(int a, int b) {\na = find(a);\nb = find(b);\nif (a < b) parent[b] = a;\nelse parent[a] = b;\n}\nint main() {\nint n, m;\ncin >> n >> m;\nvector<char> college_types(n + 1);\nfor (int i = 1; i <= n; i++) {\ncin >> college_types[i];\nparent[i] = i;\n}\nvector<Edge> edges;\nfor (int i = 0; i < m; i++) {\nint u, v, w;\ncin >> u >> v >> w;\nedges.push_back({ u, v, w });\n}\nsort(edges.begin(), edges.end(), [](Edge& a, Edge& b) {\nreturn a.w < b.w;\n});\nint ans = 0;\nint edgeCnt = 0;\nfor (auto e : edges) {\nif (college_types[e.u] == college_types[e.v])\ncontinue;\nif (edgeCnt == n - 1)\nbreak;\nif (find(e.u) != find(e.v)) {\nmerge(e.u, e.v);\nans += e.w;\nedgeCnt++;\n}\n}\nint treeNum = 0;\nvector<int> ck(n + 1);\nfor (int i = 1; i <= n; i++) {\nif (ck[i])\ncontinue;\ntreeNum++;\nqueue<int> q;\nq.push(i);\nck[i] = 1;\nwhile (!q.empty()) {\nint x = q.front();\nq.pop();\nfor (auto next : graph[x]) {\nif (ck[next])\ncontinue;\nck[next] = 1;\nq.push(next);\n}\n}\n}\nint vectexNum = 0;\nfor (int i = 1; i <= n; i++) {\nif (ck[i])\nvectexNum++;\n}\nif (vectexNum == n && treeNum == 1)\ncout << ans;\nelse\ncout << -1;\nreturn 0;\n}"
    },
    {
        "problem_tier": 4,
        "solution_code": "#include <iostream>\nusing namespace std;\nint main() {\nint k, q;\nint time = 0;\ncin >> k >> q;\nwhile (q--) {\nint t;\nchar ans;\ncin >> t >> ans;\ntime += t;\nif (time >= 210) {             cout << k;\nbreak;\n}\nif (ans == 'T') {             k++;\nif (k == 9) k = 1;\n}\n}\nreturn 0;\n}"
    },
    {
        "problem_tier": 12,
        "solution_code": "#include <bits/stdc++.h>\n#include <iostream>\n#include <vector>\n#include <algorithm>\n#pragma warning(disable:4996)\nusing namespace std;\nbool visit[51];\nint dfs(string&S, int idx) {\nint cnt = 0;\nfor (int i = idx; i < S.size(); i++) {\nif (S[i] == '(' && !visit[i]) {\nvisit[i] = true;\nint num = S[i-1] - '0';\ncnt--;\ncnt += num * dfs(S, i+1);\n} else if (S[i] == ')' && !visit[i]) {\nvisit[i] = true;\nreturn cnt;\n} else if (!visit[i]) {\nvisit[i] = true;\ncnt++;\n}\n}\nreturn cnt;\n}\nint main() {\nint T;\nint N, M, K, H;\nint X, Y;\nstring answer = \"\";\nstring S;\ncin >> S;\ncout << dfs(S, 0) << endl;\nreturn 0;\n}"
    },
    {
        "problem_tier": 4,
        "solution_code": "#include <iostream>\nusing namespace std;\nint main() {\nint ans = 0;\nint n;\ncin >> n;\nfor (int i = 1; i <= 500; i++) {\nfor (int j = i; j <= 500; j++) {\nif (j * j == i * i + n)\nans++;\n}\n}\ncout << ans << '\\n';\nreturn 0;\n}"
    },
    {
        "problem_tier": 8,
        "solution_code": "#include<iostream>\n#include<vector>\n#include<algorithm>\n#include<set>\nusing namespace std;\nint main(){\nint N;\ncin >> N;\nvector<string> student_num;\nint length = 1;\nint result;\nfor(int i=0;i<N;i++){\nstring input;\ncin >> input;\nreverse(input.begin(),input.end());\nstudent_num.push_back(input);\n}\nwhile(1){\nset<string> s;\nfor(int i=0;i<N;i++){\ns.insert(student_num[i].substr(0,length));\n}\nif(s.size()==N){\nbreak;\n}\nelse{\nlength++;\n}\n}\nresult = length;\ncout << result;\nreturn 0;\n}"
    },
    {
        "problem_tier": 13,
        "solution_code": "#include <iostream>\n#include <vector>\n#include <cmath>\nusing namespace std;\ntypedef long long ll;\ntypedef pair<ll, ll> P;\ntypedef tuple<ll, ll, ll> T;\nll MAX = 1e+17;\nvector<T> vec;\nvector<ll> parent;\nbool isGroup(ll idx1, ll idx2) {\nauto& [x1, y1, dist1] = vec[idx1];\nauto& [x2, y2, dist2] = vec[idx2];\ndouble dist = sqrt((x1-x2)*(x1-x2) + (y1-y2)*(y1-y2));\nif (dist <= dist1 + dist2) return true;\nreturn false;\n}\nll find(ll a) {\nif (parent[a] == a) return a;\nparent[a] = find(parent[a]);\nreturn parent[a];\n}\nvoid merge(ll a, ll b) {\na = find(a), b = find(b);\nif (a == b) return;\nif (a > b) parent[a] = b;\nelse parent[b] = a;\n}\nint main() {\nios_base::sync_with_stdio(false);\ncin.tie(NULL);\ncout.tie(NULL);\nll tc;\ncin >> tc;\nwhile(tc--) {\nvec.clear();\nparent.clear();\nll n;\ncin >> n;\nvec.assign(n+1, {0, 0, 0});\nparent.assign(n+1, 0);\nfor (ll i = 1; i <= n; i++) {\nparent[i] = i;\nll x, y, r;\ncin >> x >> y >> r;\nvec[i] = make_tuple(x, y, r);\n}\nfor (ll i = 1; i <= n; i++) {\nfor (ll j = i+1; j <= n; j++) {\nif (isGroup(i, j)) merge(i, j);\n}\n}\nset<ll> ans;\nfor (ll i = 1; i <= n; i++) {\nans.emplace(find(i));\n}\ncout << ans.size() << \"\\n\";\n}\nreturn 0;\n}"
    },
    {
        "problem_tier": 9,
        "solution_code": "#include<iostream>\n#include<algorithm>\nusing namespace std;\nint main() {\nint n;\ncin >> n;\nint num[20000];\nfor (int i = 0; i < n; i++) {\ncin >> num[i];\n}\nsort(num, num + n);\nint ans;\nif (n % 2 == 0) {\nans = num[n / 2 - 1];\n}\nelse {\nans = num[n / 2];\n}\ncout << ans << endl;\nreturn 0;\n}"
    },
    {
        "problem_tier": 9,
        "solution_code": "#include <iostream>\n#include <algorithm>\n#include <vector>\nusing namespace std;\nint t; int n;\nint two;\nint five;\nint temp;\nvector<int> v;\nvoid sol(int num) {\nwhile (num > 1) {\ntemp = num;\nwhile (num > 1) {\nif (num % 2 == 0) {\ntwo++;\nnum /= 2;\n}\nelse break;\n}\nnum = temp;\nwhile (num > 1) {\nif (num % 5 == 0) {\nfive++;\nnum /= 5;\n}\nelse break;\n}\nnum = temp - 1;\n}\n}\nint main() {\ncin >> t;\nfor (int i = 0; i < t; i++) {\ncin >> n;\nsol(n);\nif (two >= five) v.push_back(five);\nelse v.push_back(two);\ntwo = 0;\nfive = 0;\n}\nfor (int j = 0; j < t; j++) {\ncout << v[j] << endl;\n}\nreturn 0;\n}"
    },
    {
        "problem_tier": 13,
        "solution_code": "#include <iostream>\n#include <vector>\nusing namespace std;\nint n, m;\nvector<int> par[100001];\nvector<int> re, diff;\nvoid dfs(int current) {\nre[current] += diff[current];\nfor (int i = 0; i < par[current].size(); i++) {\nint child = par[current][i];\ndiff[child] += diff[current];\ndfs(child);\n}\n}\nint main() {\nios_base::sync_with_stdio(0);\ncin.tie(0), cout.tie(0);\ncin >> n >> m;\nre.resize(n + 1);\ndiff.resize(n + 1);\nfor (int i = 2; i <= n; i++) {\nint t;\ncin >> t;\npar[t].push_back(i);\n}\nfor (int i = 0; i < m; i++) {\nint a, b;\ncin >> a >> b;\ndiff[a] += b;\n}\ndfs(1);\nfor (int i = 1; i <= n; i++) {\ncout << re[i] << \" \";\n}\ncout << '\\n';\nreturn 0;\n}"
    },
    {
        "problem_tier": 5,
        "solution_code": "#include <iostream>\n#include <string>\nusing namespace std;\nint main() {\nstring str;\ngetline(cin, str);\nint length = str.length();\nbool flag;\nfor (int i = 0; i < length; i++) {\nflag = false;\nif (str[i] == 'a' || str[i] == 'e' || str[i] == 'i' || str[i] == 'o' || str[i] == 'u') {\ncout << str[i];\ni += 2;\nflag = true;\n}\ncout << str[i];\nif (flag)\ni += 2;\n}\ncout << '\\n';\n}"
    },
    {
        "problem_tier": 14,
        "solution_code": "#include <iostream>\n#include <vector>\n#include <cstring>\n#include <queue>\n#define MAX 3000 + 1\nusing namespace std;\nint N;\nbool Cycle;\nbool Visit[MAX];\nbool Check_Cycle_Station[MAX];\nvector<int> Station[MAX];\nvoid Input() {\ncin >> N;\nfor (int i = 0; i < N; i++) {\nint a, b;\ncin >> a >> b;\nStation[a].push_back(b);\nStation[b].push_back(a);\n}\n}\nvoid DFS(int Cur, int Start, int line) {\nif (Cur == Start && line >= 2) {\nCycle = true;\nreturn;\n}\nVisit[Cur] = true;\nfor (int i = 0; i < Station[Cur].size(); i++) {\nint Next = Station[Cur][i];\nif (Visit[Next] == false) {\nDFS(Next, Start, line + 1);\n}\nelse {\nif (Next == Start && line >= 2) {\nDFS(Next, Start, line);\n}\n}\nif (Cycle == true)\nreturn;\n}\n}\nint BFS(int a) {\nmemset(Visit, false, sizeof(Visit));\nqueue<pair<int, int>> Q;\nQ.push(make_pair(a, 0));\nVisit[a] = true;\nwhile (Q.empty() == 0) {\nint Cur = Q.front().first;\nint Cnt = Q.front().second;\nQ.pop();\nif (Check_Cycle_Station[Cur] == true)\nreturn Cnt;\nfor (int i = 0; i < Station[Cur].size(); i++) {\nint Next = Station[Cur][i];\nif (Visit[Next] == false) {\nVisit[Next] = true;\nQ.push(make_pair(Next, Cnt + 1));\n}\n}\n}\n}\nvoid Solution() {\nfor (int i = 1; i <= N; i++) {\nmemset(Visit, false, sizeof(Visit));\nCycle = false;\nint Start_Station = i;\nDFS(i, Start_Station, 0);\nif (Cycle == true) {\nCheck_Cycle_Station[i] = true;\n}\n}\nvector<int> Answer;\nfor (int i = 1; i <= N; i++) {\nif (Check_Cycle_Station[i] == true) {\nAnswer.push_back(0);\ncontinue;\n}\nAnswer.push_back(BFS(i));\n}\nfor (int i = 0; i < Answer.size(); i++) {\ncout << Answer[i] << \" \";\n}\ncout << endl;\n}\nint main(void) {\nios::sync_with_stdio(false);\ncin.tie(NULL);\ncout.tie(NULL);\nSolve();\nreturn 0;\n}"
    },
    {
        "problem_tier": 3,
        "solution_code": "#include <iostream>\n#include <string>\nusing namespace std;\nint main(){\nstring s;\ncin >> s;\nif(s.substr(0,3)==\"555\")\ncout << \"YES\";\nelse\ncout << \"NO\";\n}"
    },
    {
        "problem_tier": 15,
        "solution_code": "#include <iostream>\n#include <vector>\n#include <queue>\n#include <algorithm>\n#define MAX 101\nusing namespace std;\nint require_parts[MAX];\nint degree[MAX];\nvector<pair<int,int>> v[MAX];\nvector<int> nomal_parts;\nint N,M;\nint X,Y,K;\nvoid Input(){\ncin >> N >> M;\nfor(int i=0;i<M;i++){\ncin >> X >> Y >> K;\nv[X].push_back({Y,K});\ndegree[Y]++;\n}\n}\nvoid solution(){\nqueue<int> q;\nq.push(N);\nrequire_parts[N] = 1;\nwhile(!q.empty()){\nint current = q.front();\nq.pop();\nif(v[current].empty())\nnomal_parts.push_back(current);\nfor(int i=0;i<v[current].size();i++){\nint parts_idx = v[current][i].first;\nint parts_cnt = v[current][i].second;\nrequire_parts[parts_idx] += require_parts[current] * parts_cnt;             if(--degree[parts_idx] == 0)\nq.push(parts_idx);\n}\n}\nsort(nomal_parts.begin(),nomal_parts.end());\nfor(int i=0;i<nomal_parts.size();i++){\ncout << nomal_parts[i] << \" \" << require_parts[nomal_parts[i]] << \"\\n\";\n}\n}\nint main(void){\nInput();\nsolution();\nreturn 0;\n}"
    },
    {
        "problem_tier": 12,
        "solution_code": "#include <iostream>\n#include <vector>\nusing namespace std;\nint T, K;\nvector<pair<int, int>> coins;\nint dp[10001] = {};\nint main() {\ncin >> T >> K;\nfor (int i = 0; i < K; i++) {\nint p, n;\ncin >> p >> n;\ncoins.push_back({ p, n });\n}\ndp[0] = 1;\nfor (int i = 0; i < K; i++) {\nint cp = coins[i].first;\nint cn = coins[i].second;\nfor (int t = T - cp; t >= 0; t--) {\nif (dp[t] == 0) continue;\nfor (int j = 1; j <= cn; j++) {\nint nt = t + cp * j;\nif (nt > T) break;\ndp[nt] += dp[t];\n}\n}\n}\ncout << dp[T];\nreturn 0;\n}"
    },
    {
        "problem_tier": 8,
        "solution_code": "#include <iostream>\nusing namespace std;\nint main() {\nint n;\ncin >> n;\nfor (int i = 0; i < n; i++) {\nfor (int j = 0; j < i; j++) {\ncout << \" \";\n}\nfor (int j = 0; j < n; j++) {\ncout << \"*\";\n}\nfor (int j = 0; j < 2 * (n - i - 1); j++) {\ncout << \" \";\n}\nfor (int j = 0; j < n; j++) {\ncout << \"*\";\n}\ncout << endl;\n}\nfor (int i = 0; i < n - 1; i++) {\nfor (int j = 0; j < n - i - 2; j++) {\ncout << \" \";\n}\nfor (int j = 0; j < n; j++) {\ncout << \"*\";\n}\nfor (int j = 0; j < i * 2 + 1; j++) {\ncout << \" \";\n}\nfor (int j = 0; j < n; j++) {\ncout << \"*\";\n}\ncout << endl;\n}\nreturn 0;\n}"
    },
    {
        "problem_tier": 5,
        "solution_code": "#include <iostream>\n#include <string>\nusing namespace std;\nstring arr[8] = {\"000\", \"001\", \"010\", \"011\", \"100\", \"101\", \"110\", \"111\"};\nint main() {\nstring binary;\ncin >> binary;\nint length = binary.length();\nif (length % 3 != 0) {\nfor (int i = 0; i < 3 - length % 3; i++) {\nbinary.insert(0, \"0\");\n}\nlength += 3 - length % 3;\n}\nfor (int i = 0; i < length; i += 3) {\nstring oct = binary.substr(i, 3);\nfor (int j = 0; j < 8; j++) {\nif (oct == arr[j]) {\ncout << j;\n}\n}\n}\nreturn 0;\n}"
    },
    {
        "problem_tier": 8,
        "solution_code": "#include <iostream>\n#include <algorithm>\nusing namespace std;\nint main(void) {\nint N, M;\ncin >> N >> M;\nint* arr = new int[M];\nfor (int i = 0; i < M; i++) {\ncin >> arr[i];\n}\nsort(arr, arr + M, greater<int>());\nint max = 0;\nint idx;\nfor (int i = 0; i < M; i++) {\nif (i < N) {             if (arr[i] * (i + 1) > max) {                 max = arr[i] * (i + 1);\nidx = i;\n}\n} else {\nbreak;\n}\n}\ncout << arr[idx] << \" \" << max;\nreturn 0;\n}"
    },
    {
        "problem_tier": 4,
        "solution_code": "#include <iostream>\n#include <string>\n#define endl \"\\n\"\nusing namespace std;\nvoid Answer(){\nint T;\ncin >> T;\ncin.ignore();\nwhile(T--){\nstring s;\ngetline(cin, s);\nint result = 0;\nstring N = \"\";\nfor(int i=0; i<s.size(); i++){\nif(s[i] == ' '){\nresult += stoi(N);\nN = \"\";\n}\nelse{\nN += s[i];\n}\n}\nresult += stoi(N);\ncout << result << endl;\n}\n}\nint main(){\nios_base::sync_with_stdio(false);\ncin.tie(NULL);\ncout.tie(NULL);\nAnswer();\n}"
    },
    {
        "problem_tier": 11,
        "solution_code": "#include <iostream>\n#include <algorithm>\nusing namespace std;\ntypedef long long ll;\nint N, M;\nint color[300001];\nbool check(int n) {\nint num = 0;\nfor (int i = 0; i < M; i++) {\nint a = color[i] / n;\nint b = color[i] % n;\nnum += a;\nif (b) num++;\n}\nif (num <= N) return true;\nreturn false;\n}\nint main() {\ncin >> N >> M;\nint high = 0, low = 1;\nfor (int i = 0; i < M; i++) {\ncin >> color[i];\nif (high < color[i]) high = color[i];\n}\nwhile (low <= high) {\nint mid = (low + high) / 2;\nbool pos = true;\nif (!check(mid)) pos = false;\nif (pos) high = mid - 1;\nelse low = mid + 1;\n}\ncout << low;\nreturn 0;\n}"
    },
    {
        "problem_tier": 12,
        "solution_code": "#include <iostream>\n#include <vector>\n#include <cmath>\nusing namespace std;\nconst int MAX = 10000001;\nint main() {\nios_base::sync_with_stdio(false);\ncin.tie(nullptr);\nvector<bool> sieve(MAX, true);\nsieve[0] = sieve[1] = false;\nfor (int i = 2; i < MAX; i++) {\nif (sieve[i]) {\nfor (int j = 2; i * j < MAX; j++) {\nsieve[i * j] = false;\n}\n}\n}\nlong long A, B;\ncin >> A >> B;\nint cnt = 0;\nfor (int i = 2; i < MAX; i++) {\nif (i * i > B) {\nbreak;\n}\nif (sieve[i]) {\nlong long temp = i * i;\nwhile (temp <= B) {\nif (temp >= A) {\ncnt++;\n}\ntemp *= i;\n}\n}\n}\ncout << cnt << endl;\nreturn 0;\n}"
    },
    {
        "problem_tier": 18,
        "solution_code": "#include <iostream>\n#include <vector>\nusing namespace std;\nusing ll = long long;\nvector<ll> v, tree;\nvoid update(int start, int end, int node, int left, int right, int value){\nif(end < left || right < start)\nreturn;\nif(left <= start && end <= right){\ntree[node] += value;\nreturn;\n}\nint mid = (start + end) / 2;\nupdate(start, mid, node * 2, left, right, value);\nupdate(mid + 1, end, node * 2 + 1, left, right, value);\n}\nvoid init(int start, int end, int node){\nif(start == end){\ntree[node] = v[start];\nreturn;\n}\nint mid = (start + end) / 2;\ntree[node] = 0;\ninit(start, mid, node * 2);\ninit(mid + 1, end, node * 2 + 1);\n}\nll findX(int start, int end, int node, int idx, ll ans){\nif(idx < start || end < idx)\nreturn 0;\nans += tree[node];\nif(start == end)\nreturn ans;\nint mid = (start + end) / 2;\nreturn findX(start, mid, node * 2, idx, ans) + findX(mid + 1, end, node * 2 + 1, idx, ans);\n}\nint main(void){\nios_base::sync_with_stdio(0);\ncin.tie(0), cout.tie(0);\nint n, m;\ncin >> n;\nv.resize(n);\ntree.resize(n * 4);\nfor(int i = 0; i < n; i++){\ncin >> v[i];\n}\ninit(0, n - 1, 1);\ncin >> m;\nfor(int i = 0; i < m; i++){\nint a, b, c, d;\ncin >> a;\nif(a == 1){\ncin >> b >> c >> d;\nupdate(0, n - 1, 1, b - 1, c - 1, d);\n}\nelse{\ncin >> b;\ncout << findX(0, n - 1, 1, b - 1, 0) << \"\\n\";\n}\n}\nreturn 0;\n}"
    },
    {
        "problem_tier": 8,
        "solution_code": "#include <iostream>\n#include <queue>\nusing namespace std;\nint main() {\nqueue<int> q;\nint size;\ncin >> size;\nint num;\nwhile (true) {\ncin >> num;\nif (num == -1)\nbreak;\nif (num > 0) {\nif (q.size() < size)\nq.push(num);\n}\nif (num == 0)\nq.pop();\n}\nif (q.empty())\ncout << \"empty\" << endl;\nelse {\nwhile (!q.empty()) {\ncout << q.front() << \" \";\nq.pop();\n}\n}\nreturn 0;\n}"
    },
    {
        "problem_tier": 9,
        "solution_code": "#include <iostream>\n#include <map>\n#include <vector>\n#include <string>\n#include <algorithm>\nusing namespace std;\nint main() {\nint N, M;\nvector<string>::iterator iter;\nstring gName;\nmap<string, vector<string>> group;\nmap<string, string> member;\ncin >> N >> M;\nfor (int i = 0; i < N; i++) {\nint num;\nstring name;\nvector<string> mem;\ncin >> gName >> num;\nfor (int j = 0; j < num; j++) {\ncin >> name;\nmem.push_back(name);\nmember.insert(make_pair(name, gName));\n}\nsort(mem.begin(), mem.end());\ngroup.insert(make_pair(gName, mem));\n}\nfor (int i = 0; i < M; i++) {\nstring p;\nint type;\ncin >> p >> type;\nif (type == 1) {\ncout << member[p] << endl;\n}\nelse {\nfor (iter = group[p].begin(); iter != group[p].end(); iter++) {\ncout << *iter << endl;\n}\n}\n}\nreturn 0;\n}"
    },
    {
        "problem_tier": 15,
        "solution_code": "#include <iostream>\n#include <queue>\n#include <vector>\nusing namespace std;\nint N;\nchar map[50][50];\nbool visited[2][50][50];\nstruct Pos {\nint y, x, shape;\n};\nqueue<Pos> q;\nint dy[] = { -1, 1, 0, 0, 0 };\nint dx[] = { 0, 0, -1, 1, 0 };\nbool isInside(int y, int x) {\nreturn y >= 0 && y < N && x >= 0 && x < N;\n}\nbool canMove(int y, int x, int shape) {\nif (!visited[shape][y][x] && isInside(y, x) && map[y][x] != '1') {\nreturn true;\n}\nreturn false;\n}\nbool bfs(Pos start, Pos end) {\nvisited[start.shape][start.y][start.x] = true;\nq.push(start);\nwhile (!q.empty()) {\nint y = q.front().y;\nint x = q.front().x;\nint shape = q.front().shape;\nq.pop();\nif (y == end.y && x == end.x && shape == end.shape) {\nreturn true;\n}\nfor (int i = 0; i < 5; i++) {\nint ny = y + dy[i];\nint nx = x + dx[i];\nint nshape = shape;\nif (i == 4) {                 if (shape == 0) {                     if (isInside(ny, nx - 1) && isInside(ny, nx + 1) && map[ny][nx - 1] != '1' && map[ny][nx + 1] != '1') {\nnshape = 1;\n}\n} else {                     if (isInside(ny - 1, nx) && isInside(ny + 1, nx) && map[ny - 1][nx] != '1' && map[ny + 1][nx] != '1') {\nnshape = 0;\n}\n}\n}\nif (canMove(ny, nx, nshape)) {\nvisited[nshape][ny][nx] = true;\nq.push({ ny, nx, nshape });\n}\n}\n}\nreturn false;\n}\nint main() {\nios::sync_with_stdio(false);\ncin.tie(0);\ncin >> N;\nPos start, end;\nfor (int i = 0; i < N; i++) {\nfor (int j = 0; j < N; j++) {\ncin >> map[i][j];\nif (map[i][j] == 'B') {\nif (start.shape == -1) {\nstart = { i, j, -1 };\n} else {\nstart.shape = (i == start.y) ? 0 : 1;\n}\n} else if (map[i][j] == 'E') {\nif (end.shape == -1) {\nend = { i, j, -1 };\n} else {\nend.shape = (i == end.y) ? 0 : 1;\n}\n}\n}\n}\nif (bfs(start, end)) {\ncout << \"1\\n\";\n} else {\ncout << \"0\\n\";\n}\nreturn 0;\n}\n"
    },
    {
        "problem_tier": 4,
        "solution_code": "#include <iostream>\n#include <cmath>\nusing namespace std;\nint main() {\ndouble h, w, n, m;\ncin >> h >> w >> n >> m;\nlong long result = ceil(h / (n + 1)) * ceil(w / (m + 1));\ncout << result;\nreturn 0;\n}"
    },
    {
        "problem_tier": 16,
        "solution_code": "#include <iostream>\n#include <vector>\n#include <cmath>\nusing namespace std;\nint N, M;\nint board[50][50];\nvector<int> order;\nint dx[] = { 0, 1, 0, -1 };\nint dy[] = { -1, 0, 1, 0 };\nvoid blizzard(int d, int s) {\nint x = N / 2;\nint y = N / 2;\nfor (int i = 1; i <= s; ++i) {\nx += dx[d];\ny += dy[d];\nboard[x][y] = 0;      }\n}\nvoid destroyBeads() {\nvector<int> tmp;\nwhile (!order.empty()) {\nint dir = order.back();\norder.pop_back();\nint x = N / 2;\nint y = N / 2;\nfor (int i = 0; i < s; ++i) {\nx += dx[dir];\ny += dy[dir];\ntmp.push_back(board[x][y]);\n}\n}\nint idx = 0;\nwhile (idx < tmp.size()) {\nint cnt = 0;\nint cur = tmp[idx];\nwhile (idx < tmp.size() && tmp[idx] == cur) {\n++cnt;\n++idx;\n}\nif (cnt >= 4) {\nfor (int i = 0; i < cnt; ++i) {\ntmp.pop_back();\n}\n}\n}\nint tmpIdx = 0;\nwhile (!order.empty()) {\nint dir = order.back();\norder.pop_back();\nint x = N / 2;\nint y = N / 2;\nfor (int i = 0; i < s; ++i) {\nx += dx[dir];\ny += dy[dir];\nif (tmpIdx < tmp.size()) {\nboard[x][y] = tmp[tmpIdx++];\n} else {\nboard[x][y] = 0;\n}\n}\n}\n}\nvoid moveBeads() {\nvector<int> tmp;\nwhile (!order.empty()) {\nint dir = order.back();\norder.pop_back();\nint x = N / 2;\nint y = N / 2;\nfor (int i = 0; i < s; ++i) {\nx += dx[dir];\ny += dy[dir];\ntmp.push_back(board[x][y]);\n}\n}\nint idx = 0;\nwhile (idx < tmp.size()) {\nint cnt = 0;\nint cur = tmp[idx];\nwhile (idx < tmp.size() && tmp[idx] == cur) {\n++cnt;\n++idx;\n}\norder.push_back(cnt);\norder.push_back(cur);\n}\nwhile (order.size() < N * N) {\norder.push_back(0);\n}\nint tmpIdx = 0;\nwhile (!order.empty()) {\nint dir = order.back();\norder.pop_back();\nint x = N / 2;\nint y = N / 2;\nfor (int i = 0; i < s; ++i) {\nx += dx[dir];\ny += dy[dir];\nif (tmpIdx < tmp.size()) {\nboard[x][y] = tmp[tmpIdx++];\n} else {\nboard[x][y] = 0;\n}\n}\n}\n}\nint main() {\ncin >> N >> M;\nfor (int i = 0; i < N; ++i) {\nfor (int j = 0; j < N; ++j) {\ncin >> board[i][j];\n}\n}\nint d, s;\nfor (int i = 0; i < M; ++i) {\ncin >> d >> s;\nblizzard(d - 1, s);\ndestroyBeads();\nmoveBeads();\n}\nint answer = 0;\nint cnt = 1;\nfor (int i = 0; i < N; ++i) {\nfor (int j = 0; j < cnt; ++j) {\nanswer += board[i][j];\n}\nif (i < N / 2) {\ncnt++;\n} else {\ncnt--;\n}\n}\ncout << answer << endl;\nreturn 0;\n}"
    },
    {
        "problem_tier": 6,
        "solution_code": "#include <iostream>\n#include <vector>\n#include <algorithm>\nusing namespace std;\nclass Student {\npublic:\nint idx;\nint total;\nint point3;\nint point2;\nStudent() : idx(0), total(0), point3(0), point2(0) {}\nStudent(int idx, int a, int b, int c) : idx(idx), total(a), point3(b), point2(c) {}\nbool operator<(const Student& other) {\nif (total == other.total) {\nif (point3 == other.point3) {\nreturn point2 > other.point2;\n}\nreturn point3 > other.point3;\n}\nreturn total > other.total;\n}\nbool operator==(const Student& other) {\nif (total == other.total && point3 == other.point3 && point2 == other.point2)\nreturn true;\nelse\nreturn false;\n}\n};\nvoid addPoint(vector<Student>& v, int idx, int point) {\nif (point == 3)\nv[idx].point3++;\nelse if (point == 2)\nv[idx].point2++;\nv[idx].total += point;\n}\nint main() {\nios_base::sync_with_stdio(0);\ncin.tie(0);\nint n;\ncin >> n;\nvector<Student> v(3);\nfor (int i = 0; i < 3; i++)\nv[i].idx = i + 1;\nfor (int i = 0; i < n; i++) {\nint a, b, c;\ncin >> a >> b >> c;\naddPoint(v, 0, a);\naddPoint(v, 1, b);\naddPoint(v, 2, c);\n}\nsort(v.begin(), v.end());\nif (v[0] == v[1])\ncout << 0 << ' ' << v[0].total << '\\n';\nelse\ncout << v[0].idx << ' ' << v[0].total << '\\n';\nreturn 0;\n}"
    },
    {
        "problem_tier": 6,
        "solution_code": "#include <iostream>\n#include <string>\nusing namespace std;\nint main() {\nstring str;\ncin >> str;\nint i = 0;\nbool flag = true;\nwhile (i < str.length()) {\nif (str[i] == 'p' && str[i + 1] == 'i') {\ni += 2;\n}\nelse if (str[i] == 'k' && str[i + 1] == 'a') {\ni += 2;\n}\nelse if (str[i] == 'c' && str[i + 1] == 'h' && str[i + 2] == 'u') {\ni += 3;\n}\nelse {\nflag = false;\nbreak;\n}\n}\nif (flag) {\ncout << \"YES\" << endl;\n}\nelse {\ncout << \"NO\" << endl;\n}\nreturn 0;\n}"
    },
    {
        "problem_tier": 5,
        "solution_code": "#include <iostream>\n#include <set>\nusing namespace std;\nint main() {\nint k;\ncin >> k;\nwhile (k--) {\nint p, m;\ncin >> p >> m;\nset<int> s;\nfor (int i = 0; i < p; i++) {\nint n;\ncin >> n;\ns.insert(n);\n}\ncout << p - s.size() << '\\n';\n}\nreturn 0;\n}"
    },
    {
        "problem_tier": 8,
        "solution_code": "#include <iostream>\n#include <vector>\n#include <queue>\nusing namespace std;\nbool canWin(int n, vector<vector<int>>& board) {\nvector<vector<bool>> visited(n, vector<bool>(n, false));\nqueue<pair<int, int>> q;\nq.push(make_pair(0, 0));\nvisited[0][0] = true;\nwhile (!q.empty()) {\nint x = q.front().first;\nint y = q.front().second;\nq.pop();\nif (board[x][y] == -1) {\nreturn true;\n}\nint jump = board[x][y];\nif (y + jump < n && !visited[x][y + jump]) {\nq.push(make_pair(x, y + jump));\nvisited[x][y + jump] = true;\n}\nif (x + jump < n && !visited[x + jump][y]) {\nq.push(make_pair(x + jump, y));\nvisited[x + jump][y] = true;\n}\n}\nreturn false;\n}\nint main() {\nint n;\ncin >> n;\nvector<vector<int>> board(n, vector<int>(n));\nfor (int i = 0; i < n; i++) {\nfor (int j = 0; j < n; j++) {\ncin >> board[i][j];\n}\n}\nif (canWin(n, board)) {\ncout << \"HaruHaru\";\n} else {\ncout << \"Hing\";\n}\nreturn 0;\n}"
    },
    {
        "problem_tier": 3,
        "solution_code": "#include <iostream>\nusing namespace std;\nint main() {\nint a[3], sum = 91;\nfor (int i = 0; i < 3; i++) {\ncin >> a[i];\nif (i == 1) {\na[i] = 3 * a[i];\n}\nsum = sum + a[i];\n}\ncout << \"The 1-3-sum is \" << sum;\nreturn 0;\n}"
    },
    {
        "problem_tier": 11,
        "solution_code": "#include <iostream>\n#include <stack>\n#include <string>\nusing namespace std;\nint main() {\nios::sync_with_stdio(0);\ncin.tie(0);\nint caseNum = 1;\nwhile (true) {\nstring line;\ncin >> line;\nint answer = 0;\nstack<char> S;\nif (line[0] == '-') {\nbreak;\n}\nfor (int i = 0; i < line.size(); i++) {\nchar c = line[i];\nif (c == '{') {\nS.push(c);\n} else if (c == '}') {\nif (S.empty() || S.top() != '{') {\nS.push(c);\n} else {\nS.pop();\n}\n}\n}\nwhile (!S.empty()) {\nchar t = S.top();\nS.pop();\nif (S.top() != t) {\nanswer += 2;\n} else if (S.top() == t && t == '{') {\nanswer += 1;\n}\nS.pop();\n}\ncout << caseNum++ << \". \" << answer << '\\n';\n}\nreturn 0;\n}"
    },
    {
        "problem_tier": 12,
        "solution_code": "#include<iostream>\nusing namespace std;\nint main() {\nlong long n;\ncin >> n;\nif (n % 7 == 0 || n % 7 == 2){\ncout << \"CY\" << endl;\n} else{\ncout << \"SK\" << endl;\n}\nreturn 0;\n}"
    },
    {
        "problem_tier": 2,
        "solution_code": "#include <iostream>\nusing namespace std;\nint main() {\nios::sync_with_stdio(false);\ncin.tie(nullptr);\nint a, b, c;\ncin >> a >> b >> c;\nint answer = (b / a) * c * 3;\ncout << answer << \"\\n\";\nreturn 0;\n}"
    },
    {
        "problem_tier": 13,
        "solution_code": "#include <iostream>\n#include <stack>\nusing namespace std;\nint main() {\nios_base::sync_with_stdio(false);\ncin.tie(NULL);\ncout.tie(NULL);\nstring str;\nbool stop = false;\nstack<char> s;\nint ap_cnt = 0, p_cnt = 0;\ncin >> str;\nfor (int i = 0; i < str.size(); i++) {\ns.push(str[i]);\n}\nwhile (!s.empty()) {\nif (s.top() == 'P') {\np_cnt++;\ns.pop();\nif (ap_cnt > 0 && p_cnt >= 2) {\nap_cnt -= 1;\np_cnt -= 2;\ns.push('P');\n}\n}\nelse {\nif (p_cnt < 1) {\nstop = true;\nbreak;\n}\nelse {\nap_cnt++;\np_cnt = 0;\n}\ns.pop();\n}\n}\nif (stop)\ncout << \"NP\" << \"\\n\";\nelse {\nif (p_cnt == 1 && ap_cnt == 0)\ncout << \"PPAP\" << \"\\n\";\nelse\ncout << \"NP\" << \"\\n\";\n}\nreturn 0;\n}"
    },
    {
        "problem_tier": 12,
        "solution_code": "#include <iostream>\n#include <regex>\n#include <string>\nusing namespace std;\nstring str;\nint main() {\ncin >> str;\nstring engine = \"(100+1+|01)+\";\nif (regex_match(str, regex(engine)))\ncout << \"SUBMARINE\\n\";\nelse\ncout << \"NOISE\\n\";\nreturn 0;\n}"
    },
    {
        "problem_tier": 10,
        "solution_code": "#include <iostream>\n#include <string>\n#include <algorithm>\nusing namespace std;\nstring dp[251] = {\"1\", \"1\", \"3\"};\nint largest = 2;\nvoid string_add(int from, int to) {\nfor (int i = from; i <= to; i++) {\nstring a = dp[i - 1], b = dp[i - 2], c = dp[i - 2];\nint sum = 0;\nstring result;\nwhile (!a.empty() || !b.empty() || !c.empty() || sum) {\nif (a != \"\") {\nsum += a.back() - '0';\na.pop_back();\n}\nif (b != \"\") {\nsum += b.back() - '0';\nb.pop_back();\n}\nif (c != \"\") {\nsum += c.back() - '0';\nc.pop_back();\n}\nresult.push_back(sum % 10 + '0');\nsum /= 10;\n}\nreverse(result.begin(), result.end());\ndp[i] = result;\n}\n}\nint main() {\nint N;\nwhile (cin >> N) {\nif (largest < N) {\nstring_add(largest, N);\nlargest = N;\n}\ncout << dp[N] << endl;\n}\nreturn 0;\n}"
    },
    {
        "problem_tier": 4,
        "solution_code": "#include <iostream>\n#include <string>\nusing namespace std;\nint main() {\nint n;\ncin >> n;\nwhile (n--) {\nstring k;\ncin >> k;\nint ksize = k.size();\nstring ans = \"\";\nfor (int i = 0; i < ksize/2; i++) {\nif (k[i] == k[ksize - i - 1]) {\nans = \"Do-it\";\n}\nelse {\nans = \"Do-it-Not\";\n}\n}\ncout << ans << '\\n';\n}\nreturn 0;\n}"
    },
    {
        "problem_tier": 9,
        "solution_code": "#include<iostream>\n#include<queue>\n#include<stack>\nusing namespace std;\nstack<int> st;\nqueue<int> q;\nbool flag[100000];\nint main() {\ncout.tie(NULL);\ncin.tie(NULL);\nios_base::sync_with_stdio(false);\nint n, m, input, x;\ncin >> n;\nfor(int i = 0; i < n; i++) {\ncin >> flag[i];\n}\nfor(int i = 0; i < n; i++) {\ncin >> input;\nif(flag[i] == 0) {\nst.push(input);\n}\n}\nwhile(!st.empty()) {\nq.push(st.top());\nst.pop();\n}\ncin >> m;\nfor(int i = 0; i < m; i++) {\ncin >> input;\nq.push(input);\n}\nfor(int i = 0; i < m; i++) {\ncout << q.front() << \" \";\nq.pop();\n}\nreturn 0;\n}"
    },
    {
        "problem_tier": 5,
        "solution_code": "#include<iostream>\n#include<string>\n#include<cctype>\nusing namespace std;\nint main() {\nchar ch;\nstring str;\nwhile(1){\ncin >> ch;\ngetline(cin, str);\nif(ch == '#'){\nbreak;\n}\nint len = str.length();\nint cnt = 0;\nfor(int i=0; i<len; i++){\nif(str[i] == ch || str[i] == toupper(ch)){\ncnt++;\n}\n}\ncout << ch << \" \" << cnt << \"\\n\";\n}\nreturn 0;\n}"
    },
    {
        "problem_tier": 4,
        "solution_code": "#include <iostream>\nusing namespace std;\nint cnt = 0;\nint check(int N){\ncnt++;\nif(N == 1)\nreturn 0;\nif(N % 2 == 0)\nreturn check(N/2);\nelse\nreturn check(3*N+1);\n}\nint main(){\nios_base::sync_with_stdio(false);\ncin.tie(0);\nint N;\ncin >> N;\ncheck(N);\ncout << cnt;\nreturn 0;\n}"
    },
    {
        "problem_tier": 6,
        "solution_code": "#include<iostream>\n#include<vector>\nusing namespace std;\nvoid check_num(vector<int>* l) {\nint overlap = -1;\nfor(vector<int>::iterator iter = l->begin(); iter != l->end(); ++iter) {\nfor(vector<int>::iterator curr = iter + 1; curr != l->end(); ++curr) {\nif(overlap == -1 && *iter == 0)\nbreak;\nelse if(overlap == -1 && *curr == 0)\ncontinue;\nelse if(overlap == -1 && *iter == *curr) {\n*curr = 0;\noverlap = *iter;\n*iter = 0;\n}\nelse if(overlap == *curr) {\n*curr = 0;\n}\n}\noverlap = -1;\n}\n}\nint main(int argc, const char* argv[]) {\nios::sync_with_stdio();\ncin.tie(NULL);\ncout.tie(NULL);\nunsigned short N = 0;\ncin >> N;\nvector<vector<int>> num(3);\nint temp[3];\nfor(int i = 0; i < N; i++) {\ncin >> temp[0] >> temp[1] >> temp[2];\nfor(int j = 0; j < 3; j++)\nnum[j].push_back(temp[j]);\n}\nfor(int i = 0; i < 3; i++)\ncheck_num(&num[i]);\nfor(int i = 0; i < N; i++)\nprintf(\"%d\\n\", num[0][i] + num[1][i] + num[2][i]);\nreturn 0;\n}"
    },
    {
        "problem_tier": 7,
        "solution_code": "#include <iostream>\nusing namespace std;\nint nCr(int n, int r){\nif(!n)\nreturn 0;\nif(!r)\nreturn 1;\nif(n == r)\nreturn 1;\nreturn nCr(n-1, r-1) + nCr(n-1, r);\n}\nint main() {\nint N;\ncin >> N;\nint spot = nCr(N, 4);\ncout << spot;\nreturn 0;\n}"
    },
    {
        "problem_tier": 9,
        "solution_code": "#include <iostream>\n#include <algorithm>\n#include <vector>\n#include <cstring>\nusing namespace std;\nstruct Card {\nchar color;\nint number;\n};\nbool cmp(Card a, Card b) {\nreturn a.number < b.number;\n}\nint main() {\nvector<Card> cards(5);\nint color[4] = {0};\nint number[10] = {0};\nint maxNum = 0;\nint pair1 = 0, pair2 = 0;\nint triple = 0;\nint quad = 0;\nfor (int i = 0; i < 5; i++) {\ncin >> cards[i].color >> cards[i].number;\ncolor[cards[i].color - 'A']++;\nnumber[cards[i].number]++;\nmaxNum = max(maxNum, cards[i].number);\n}\nsort(cards.begin(), cards.end(), cmp);\nfor (int i = 1; i <= 9; i++) {\nif (number[i] == 2) {\nif (pair1 > 0) {\npair2 = i;\n} else {\npair1 = i;\n}\n} else if (number[i] == 3) {\ntriple = i;\n} else if (number[i] == 4) {\nquad = i;\n}\n}\nbool isFlush = false;\nbool isStraight = false;\nfor (int i = 0; i < 4; i++) {\nif (color[i] == 5) {\nisFlush = true;\nbreak;\n}\n}\nfor (int i = 1; i <= 6; i++) {\nif (number[i] && number[i+1] && number[i+2] && number[i+3] && number[i+4]) {\nisStraight = true;\nbreak;\n}\n}\nif (isFlush && isStraight) {\ncout << 900 + maxNum << endl;\n} else if (isFlush) {\ncout << 600 + maxNum << endl;\n} else if (isStraight) {\ncout << 500 + maxNum << endl;\n} else if (quad != 0) {\ncout << 800 + quad << endl;\n} else if (triple != 0 && pair1 != 0) {\ncout << 700 + triple * 10 + pair1 << endl;\n} else if (triple != 0) {\ncout << 400 + triple << endl;\n} else if (pair1 != 0 && pair2 != 0) {\ncout << 300 + max(pair1, pair2) * 10 + min(pair1, pair2) << endl;\n} else if (pair1 != 0) {\ncout << 200 + pair1 << endl;\n} else {\ncout << 100 + maxNum << endl;\n}\nreturn 0;\n}"
    },
    {
        "problem_tier": 12,
        "solution_code": "#include <iostream>\n#include <vector>\n#include <algorithm>\nusing namespace std;\nstruct Subject {\nint t;\nint s;\n};\nbool compare(Subject a, Subject b) {\nreturn a.t < b.t;\n}\nint main() {\ncin.tie(0);\ncout.tie(0);\nios::sync_with_stdio(false);\nint N, T;\ncin >> N >> T;\nvector<Subject> v(N+1);\nfor (int i = 1; i <= N; i++) {\nint t, s;\ncin >> t >> s;\nv[i] = { t, s };\n}\nsort(v.begin() + 1, v.end(), compare);\nint d[101][10001] = { 0 };\nint ans = 0;\nfor (int k = 1; k <= N; k++) {\nfor (int i = v[1].t; i <= T; i++) {\nif (v[k].t > i)\nd[k][i] = d[k - 1][i];\nelse {\nd[k][i] = max(d[k - 1][i], d[k - 1][i - v[k].t] + v[k].s);\n}\nans = max(ans, d[k][i]);\n}\n}\ncout << ans;\nreturn 0;\n}"
    },
    {
        "problem_tier": 12,
        "solution_code": "#include <iostream>\n#include <vector>\n#include <queue>\nusing namespace std;\nint N;\nint main(void) {\nios::sync_with_stdio(false);\ncin.tie(NULL);\ncout.tie(NULL);\ncin >> N;\nvector<pair<int,int>> v[5000+1];\nfor(int i=0;i<N-1;i++) {\nint a, b, c;\ncin >> a >> b >> c;\nv[a].push_back({b,c});\nv[b].push_back({a,c});\n}\nfor(int i=0;i<Q;i++) {\nvector<bool> visit(5000+1,false);\nint ans=0;\nint k, video;\ncin >> k >> video;\nqueue<int> q;\nvisit[video] = true;\nq.push(video);\nwhile(!q.empty()) {\nint now_idx = q.front();\nq.pop();\nfor(int j=0;j<v[now_idx].size();j++) {\nint next_idx = v[now_idx][j].first;\nif(visit[next_idx]) continue;\nint next_val = v[now_idx][j].second;\nif(next_val >= k) {\nvisit[now_idx] = true;\nans++;\nq.push(next_idx);\n}\n}\n}\ncout << ans << '\\n';\n}\nreturn 0;\n}"
    },
    {
        "problem_tier": 19,
        "solution_code": "#include <iostream>\n#include <vector>\n#include <cmath>\n#define endl \"\\n\"\n#define MAX 100010\nusing namespace std;\nint N, M;\nint Switch[MAX];\nvector<int> SegmentTree;\nvector<int> Lazy;\nvector<pair<int, pair<int, int>>> Cmd;\nvoid Input() {\ncin >> N >> M;\nfor (int i = 0; i < M; i++) {\nint a, b, c;\ncin >> a >> b >> c;\nCmd.push_back(make_pair(a, make_pair(b, c)));\n}\n}\nvoid Lazy_Update(int Node, int Start, int End) {\nif (Lazy[Node] != 0) {\nSegmentTree[Node] = (End - Start + 1) - SegmentTree[Node];\nif (Start != End) {\nLazy[Node * 2] = !Lazy[Node * 2];\nLazy[Node * 2 + 1] = !Lazy[Node * 2 + 1];\n}\nLazy[Node] = 0;\n}\n}\nvoid Update(int Node, int Start, int End, int Left, int Right) {\nLazy_Update(Node, Start, End);\nif (Right < Start || Left > End) return;\nif (Left <= Start && End <= Right) {\nSegmentTree[Node] = (End - Start + 1) - SegmentTree[Node];\nif (Start != End) {\nLazy[Node * 2] = !Lazy[Node * 2];\nLazy[Node * 2 + 1] = !Lazy[Node * 2 + 1];\n}\nreturn;\n}\nint Mid = (Start + End) / 2;\nUpdate(Node * 2, Start, Mid, Left, Right);\nUpdate(Node * 2 + 1, Mid + 1, End, Left, Right);\nSegmentTree[Node] = SegmentTree[Node * 2] + SegmentTree[Node * 2 + 1];\n}\nint Query(int Node, int Start, int End, int Left, int Right) {\nLazy_Update(Node, Start, End);\nif (Right < Start || Left > End) return 0;\nif (Left <= Start && End <= Right) return SegmentTree[Node];\nint Mid = (Start + End) / 2;\nint Left_Result = Query(Node * 2, Start, Mid, Left, Right);\nint Right_Result = Query(Node * 2 + 1, Mid + 1, End, Left, Right);\nreturn Left_Result + Right_Result;\n}\nvoid Solution() {\nint Tree_Height = (int)ceil(log2(N));\nint Tree_Size = 1 << (Tree_Height + 1);\nSegmentTree.resize(Tree_Size, 0);\nLazy.resize(Tree_Size);\nfor (int i = 0; i < M; i++) {\nint Command = Cmd[i].first;\nif (Command == 0) {\nint Index = Cmd[i].second.first - 1;\nint Index2 = Cmd[i].second.second - 1;\nUpdate(1, 0, N - 1, Index, Index2);\ncontinue;\n}\nint Index = Cmd[i].second.first - 1;\nint Index2 = Cmd[i].second.second - 1;\ncout << Query(1, 0, N - 1, Index, Index2) << endl;\n}\n}\nvoid Solve() {\nInput();\nSolution();\n}\nint main(void) {\nios::sync_with_stdio(false);\ncin.tie(NULL);\ncout.tie(NULL);\nSolve();\nreturn 0;\n}"
    },
    {
        "problem_tier": 11,
        "solution_code": "#include <iostream>\n#include <queue>\n#include <vector>\nusing namespace std;\nint R, C;\nvector<vector<char>> field;\nvector<vector<bool>> visited;\nqueue<pair<int, int>> q;\nint dx[] = {0, 0, 1, -1};\nint dy[] = {1, -1, 0, 0};\nint sheepCount = 0;\nint wolfCount = 0;\nvoid bfs(int startX, int startY) {\nint curSheep = 0;\nint curWolf = 0;\nq.push({startX, startY});\nvisited[startX][startY] = true;\nif (field[startX][startY] == 'k') {\ncurSheep++;\n} else if (field[startX][startY] == 'v') {\ncurWolf++;\n}\nwhile (!q.empty()) {\nint x = q.front().first;\nint y = q.front().second;\nq.pop();\nfor (int i = 0; i < 4; i++) {\nint nx = x + dx[i];\nint ny = y + dy[i];\nif (nx >= 0 && ny >= 0 && nx < R && ny < C && field[nx][ny] != '#' && !visited[nx][ny]) {\nif (field[nx][ny] == 'k') {\ncurSheep++;\n} else if (field[nx][ny] == 'v') {\ncurWolf++;\n}\nvisited[nx][ny] = true;\nq.push({nx, ny});\n}\n}\n}\nif (curSheep > curWolf) {\nsheepCount += curSheep;\n} else {\nwolfCount += curWolf;\n}\n}\nint main() {\ncin.tie(NULL);\nios_base::sync_with_stdio(false);\ncin >> R >> C;\nfield = vector<vector<char>>(R, vector<char>(C));\nvisited = vector<vector<bool>>(R, vector<bool>(C, false));\nfor (int i = 0; i < R; i++) {\nfor (int j = 0; j < C; j++) {\ncin >> field[i][j];\n}\n}\nfor (int i = 0; i < R; i++) {\nfor (int j = 0; j < C; j++) {\nif (field[i][j] != '#' && !visited[i][j]) {\nbfs(i, j);\n}\n}\n}\ncout << sheepCount << \" \" << wolfCount << endl;\nreturn 0;\n}"
    },
    {
        "problem_tier": 12,
        "solution_code": "#include <iostream>\n#include <vector>\n#include <algorithm>\nusing namespace std;\nint main(){\nint N, L;\nvector<pair<int, int>> map;\nint ans = 0;\ncin >> N >> L;\nfor(int i=0; i<N; i++){\nint a, b;\ncin >> a >> b;\nmap.push_back({a, b});\n}\nsort(map.begin(), map.end());\nint covered = -1, to = -1;\nfor(int i=0; i<map.size(); i++){\ncovered = max(covered, map[i].first);\nto = map[i].second;\nwhile(covered < to){\ncovered += L;\nans++;\n}\n}\ncout << ans;\nreturn 0;\n}"
    },
    {
        "problem_tier": 17,
        "solution_code": "#include <iostream>\n#include <cstring>\n#include <string>\n#include <algorithm>\nusing namespace std;\nconst int INF = 987654321;\nconst int MAX = 17;\nint N, P, cnt;\nint cost[MAX][MAX];\nint dp[1 << MAX];\nstring s;\nint go(int mask) {\nint& ret = dp[mask];\nif (ret != -1) return ret;\nif (cnt >= P) return ret = 0;\nret = INF;\ncnt++;\nfor (int i = 0; i < N; i++) {\nif (mask & (1 << i)) {\nfor (int j = 0; j < N; j++) {\nif (!(mask & (1 << j))) {\nret = min(ret, go(mask | (1 << j)) + cost[i][j]);\n}\n}\n}\n}\ncnt--;\nreturn ret;\n}\nint main() {\nmemset(dp, -1, sizeof(dp));\ncin >> N;\nfor (int i = 0; i < N; i++) {\nfor (int j = 0; j < N; j++) {\ncin >> cost[i][j];\n}\n}\ncin >> s;\ncin >> P;\nint mask = 0;\nint cnt = 0;\nfor (int i = 0; i < s.size(); i++) {\nif (s[i] == 'Y') {\nmask |= (1 << i);\ncnt++;\n}\n}\nint result = go(mask);\nif (result == INF) {\ncout << -1 << endl;\n} else {\ncout << result << endl;\n}\nreturn 0;\n}"
    },
    {
        "problem_tier": 5,
        "solution_code": "#include <iostream>\nusing namespace std;\nint main() {\nint R, B;\ncin >> R >> B;\nint width = 1;\nwhile (true) {\nint length = (R + B) / width;\nif ((length * 2 + width * 2 - 4 == R) && ((R + B) % width == 0)) {\ncout << length << \" \" << width;\nbreak;\n}\nwidth++;\n}\nreturn 0;\n}"
    },
    {
        "problem_tier": 15,
        "solution_code": "#include<iostream>\n#include<vector>\nusing namespace std;\nint T;\nint N;\nvector<int> v_pre;\nvector<int> v_in;\nvoid post_order(int start, int end, int pos){\nfor(int i=start; i<end; ++i){\nif(v_in[i] == v_pre[pos]){\npost_order(start, i, pos+1);\npost_order(i+1, end, pos+1+i-start);\ncout << v_pre[pos] << ' ';\n}\n}\n}\nvoid solve(){\nint root_idx = 0;\npost_order(root_idx, N, 0);\ncout << endl;\n}\nint main(){\ncin >> T;\nfor(int i=0; i<T; ++i){\ncin >> N;\nv_pre = vector<int>(N);\nv_in = vector<int>(N);\nfor(int j=0; j<N; ++j){\ncin >> v_pre[j];\n}\nfor(int j=0; j<N; ++j){\ncin >> v_in[j];\n}\nsolve();\n}\n}"
    },
    {
        "problem_tier": 13,
        "solution_code": "#include <iostream>\n#include <queue>\n#include <cstring>\n#include <vector>\nusing namespace std;\nvector<int> relation[100];\nint is_visited[100], smaller_child[100], bigger_child[100];\nint main() {\nint N, M;\ncin >> N >> M;\nint mid = (N + 1) / 2;\nfor (int i = 0; i < M; ++i) {\nint big, small;\ncin >> big >> small;\nrelation[big].push_back(small);\n}\nfor (int i = 1; i <= N; ++i) {\nint child_num = 0, start = i;\nmemset(is_visited, -1, sizeof(is_visited));\nqueue<int> que;\nque.push(start);\nwhile (!que.empty()) {\nint now_node = que.front();\nque.pop();\nint small_node_num = relation[now_node].size();\nfor (int j = 0; j < small_node_num; ++j) {\nint child_node = relation[now_node][j];\nif (is_visited[child_node] == -1) {\nbigger_child[child_node]++;\nchild_num++;\nis_visited[child_node] = 1;\nque.push(child_node);\n}\n}\n}\nsmaller_child[i] = child_num;     }\nint ans = 0;\nfor (int i = 1; i <= N; ++i) {\nif (bigger_child[i] >= mid || smaller_child[i] >= mid) {\nans++;\n}\n}\ncout << ans << endl;\nreturn 0;\n}"
    },
    {
        "problem_tier": 14,
        "solution_code": "#include<iostream>\n#include<vector>\n#include<queue>\n#include<cstring>\nusing namespace std;\nconst int INF = 987654321;\nint n;\nint c[52][52]; int f[52][52]; vector<int> graph[52];\nint charToInt(char c) {\nif (c >= 'A' && c <= 'Z')\nreturn c - 'A';\nreturn c - 'a' + 26;\n}\nint maxFlow(int source, int sink) {\nint totalFlow = 0;\nwhile (true) {\nint parent[52];\nmemset(parent, -1, sizeof(parent));\nqueue<int> q;\nq.push(source);         while (!q.empty() && parent[sink] == -1) {\nint cur = q.front();\nq.pop();\nfor (int next : graph[cur]) {\nif (c[cur][next] - f[cur][next] > 0 && parent[next] == -1) {                     q.push(next);\nparent[next] = cur;                     if (next == sink)\nbreak;\n}\n}\n}\nif (parent[sink] == -1)             break;\nint flow = INF;\nfor (int i = sink; i != source; i = parent[i])\nflow = min(flow, c[parent[i]][i] - f[parent[i]][i]);\nfor (int i = sink; i != source; i = parent[i]) {\nf[parent[i]][i] += flow;             f[i][parent[i]] -= flow;         }\ntotalFlow += flow;     }\nreturn totalFlow;\n}\nint main() {\nios_base::sync_with_stdio(false);\ncin.tie(NULL);\ncin >> n;\nfor (int i = 0; i < n; i++) {\nchar u, v;\nint w;\ncin >> u >> v >> w;\nint u_idx = charToInt(u);\nint v_idx = charToInt(v);\nc[u_idx][v_idx] += w;\nc[v_idx][u_idx] += w;\ngraph[u_idx].push_back(v_idx);\ngraph[v_idx].push_back(u_idx);\n}\nint source = charToInt('A');\nint sink = charToInt('Z');\ncout << maxFlow(source, sink) << \"\\n\";\nreturn 0;\n}"
    },
    {
        "problem_tier": 9,
        "solution_code": "#include <iostream>\n#include <vector>\nusing namespace std;\nint r, c;\nvector<string> board;\nvoid input() {\ncin >> r >> c;\nboard.resize(r);\nfor (auto& x : board) {\ncin >> x;\n}\n}\nvoid solution() {\nbool flag = true;\nint nx, ny;\nint dx[4] = {0, 0, -1, 1};     int dy[4] = {1, -1, 0, 0};\nfor (int y = 0; y < r; y++) {\nfor (int x = 0; x < c; x++) {\nif (board[y][x] == 'W') {\nfor (int i = 0; i < 4; i++) {\nnx = x + dx[i];\nny = y + dy[i];\nif (nx >= 0 && nx < c && ny >= 0 && ny < r) {                         if (board[ny][nx] == 'S') {                             flag = false;\ngoto END;                         } else {\nif (board[ny][nx] == '.')                                 board[ny][nx] = 'D';\n}\n}\n}\n}\n}\n}\nEND:\ncout << flag << endl;\nif (flag) {\nfor (const auto& x : board) {\ncout << x << endl;\n}\n}\n}\nint main() {\nios_base::sync_with_stdio(false);\ncin.tie(nullptr);\ninput();\nsolution();\nreturn 0;\n}"
    },
    {
        "problem_tier": 4,
        "solution_code": "#include <iostream>\n#include <iomanip>\nusing namespace std;\nint main() {\ndouble a, n, cnt;\ncin >> n;\ncnt = n;\nwhile (1) {\ncin >> a;\nif (a == 999) break;\ncout << fixed << setprecision(2) << a - cnt << endl;\ncnt = a;\n}\nreturn 0;\n}"
    },
    {
        "problem_tier": 14,
        "solution_code": "#include <iostream>\n#include <vector>\n#include <string>\nusing namespace std;\nchar ec[10][10];\nint N;\nvector<int> v;\nbool check(int idx) {\nint sum = 0;\nfor (int i = idx; i >= 0; i--) {\nsum += v[i];\nif (ec[i][idx] == '+' && sum <= 0) return false;\nif (ec[i][idx] == '-' && sum >= 0) return false;\nif (ec[i][idx] == '0' && sum != 0) return false;\n}\nreturn true;\n}\nvoid dfs(int cnt) {\nif (cnt == N) {\nfor (int x : v) {\ncout << x << \" \";\n}\nexit(0);\n}\nfor (int i = -10; i <= 10; i++) {\nv.push_back(i);\nif (check(cnt)) dfs(cnt + 1);\nv.pop_back();\n}\n}\nint main() {\ncin >> N;\nstring s;\ncin >> s;\nint idx = 0;\nfor (int i = 0; i < N; i++) {\nfor (int j = i; j < N; j++) {\nec[i][j] = s[idx++];\n}\n}\ndfs(0);\nreturn 0;\n}"
    },
    {
        "problem_tier": 12,
        "solution_code": "#include <iostream>\n#include <cstring>\n#define MAX 2020\nusing namespace std;\nint n;\nint Left[MAX];\nint Right[MAX];\nint dp[MAX][MAX];\nint solve(int i, int j){\nif(i>=n || j>=n) return dp[i][j] = 0;\nif(dp[i][j] != -1) return dp[i][j];\nif(Left[i] > Right[j]){\ndp[i][j] = max(dp[i][j], solve(i, j+1) + Right[j]);\n}\ndp[i][j] = max(dp[i][j], solve(i+1, j));\ndp[i][j] = max(dp[i][j], solve(i+1, j+1));\nreturn dp[i][j];\n}\nint main(){\nios_base::sync_with_stdio(0);\ncin.tie(0);\ncin >> n;\nfor(int i=0; i<n; i++){\ncin >> Left[i];\n}\nfor(int j=0; j<n; j++){\ncin >> Right[j];\n}\nmemset(dp, -1, sizeof(dp));\ncout << solve(0, 0);\nreturn 0;\n}"
    },
    {
        "problem_tier": 15,
        "solution_code": "#include <iostream>\n#include <vector>\n#include <queue>\n#include <algorithm>\nusing namespace std;\nbool cmp(pair<int, int> a, pair<int, int> b){\nif(a.second == b.second)\nreturn a.first < b.first;\nelse\nreturn a.second < b.second;\n}\nint main() {\nios_base::sync_with_stdio(0);\ncin.tie(0); cout.tie(0);\nint n, d;\nint answer = 0;\nvector<pair<int, int>> v;\npriority_queue<int> pq;\ncin >> n;\nint s, e;\nfor(int i=0; i<n; i++){\ncin >> s >> e;\nif(s < e) v.push_back({s, e});\nelse v.push_back({e, s});\n}\ncin >> d;\nsort(v.begin(), v.end(), cmp);\nfor(int i=0; i<v.size(); i++){\nint start = v[i].first;\nint end = v[i].second;\nif(end-start <= d) pq.push(-start);\nelse continue;\nwhile(!pq.empty()){\nif(-pq.top() < end-d) pq.pop();\nelse{\nanswer = max(answer, (int)pq.size());\nbreak;\n}\n}\n}\ncout << answer;\nreturn 0;\n}"
    },
    {
        "problem_tier": 11,
        "solution_code": "#include <iostream>\n#include <vector>\n#include <algorithm>\nusing namespace std;\nint fib[46] = {0, 1};\nvoid generateFibonacciArray(){\nfor(int i=2;i<46;i++){\nfib[i] = fib[i-1] + fib[i-2];\n}\n}\nvoid solveProblem(){\nint T;\ncin >> T;\nwhile(T--){\nint n, tmp;\ncin >> n;\nvector<int> v;\nfor(int i=0;i<n;i++){\ncin >> tmp;\nv.push_back(tmp);\n}\nfor(int i=0;i<v.size();i++){\nvector<int> result;\nwhile(v[i]){\nfor(int j=sizeof(fib)/sizeof(*fib)-1;j>=0;j--){\nif(fib[j]>v[i])continue;\nresult.push_back(fib[j]);\nv[i]-=fib[j];\nif(v[i]<=0)break;\n}\n}\nsort(result.begin(), result.end());\nfor(int k=0;k<result.size();k++){\ncout << result[k] << ' ';\n}\ncout << endl;\n}\n}\n}\nint main(){\nios_base::sync_with_stdio(0);\ncin.tie(0);\ncout.tie(0);\ngenerateFibonacciArray();\nsolveProblem();\nreturn 0;\n}"
    },
    {
        "problem_tier": 5,
        "solution_code": "#include<iostream>\n#include<cmath>\nusing namespace std;\nint getIntFront(string front) {\nint sum = 0;\nfor(int i=0; i<front.size(); i++) {\nsum += (front[i]-'A') * pow(26, front.size()-i-1);\n}\nreturn sum;\n}\nint main() {\nint t;\ncin >> t;\nwhile(t--) {\nstring s;\ncin >> s;\nstring front = s.substr(0, 3);\nstring back = s.substr(4, 4);\nif(abs(getIntFront(front) - stoi(back)) <= 100) {\ncout << \"nice\\n\";\n} else {\ncout << \"not nice\\n\";\n}\n}\nreturn 0;\n}"
    },
    {
        "problem_tier": 4,
        "solution_code": "#include <iostream>\nusing namespace std;\nint main() {\nint a, b;\nwhile (1) {\ncin >> a >> b;\nif (a == 0 && b == 0) break;\nelse cout << a / b << \" \" << a % b << \"/\" << b << \"\\n\";\n}\nreturn 0;\n}"
    },
    {
        "problem_tier": 13,
        "solution_code": "#include <iostream>\n#include <vector>\n#include <algorithm>\nusing namespace std;\ntypedef long long ll;\ntypedef pair<int, int> pii;\ntypedef pair<ll, pii> plii;\nint parent[1001];\nint find(int x) {\nif (parent[x] == x)\nreturn x;\nreturn parent[x] = find(parent[x]);\n}\nvoid unionSets(int x, int y) {\nx = find(x);\ny = find(y);\nif (x != y)\nparent[y] = x;\n}\nint main() {\nios_base::sync_with_stdio(false);\ncin.tie(NULL);\nint n;\ncin >> n;\nvector<plii> edges;\nfor (int i = 1; i <= n; i++) {\nfor (int j = 1; j <= n; j++) {\nll cost;\ncin >> cost;\nif (i < j)\nedges.push_back({cost, {i, j}});\n}\n}\nsort(edges.begin(), edges.end());\nfor (int i = 1; i <= n; i++)\nparent[i] = i;\nll totalCost = 0;\nfor (int i = 0; i < edges.size(); i++) {\nint u = edges[i].second.first;\nint v = edges[i].second.second;\nll cost = edges[i].first;\nif (find(u) != find(v)) {\nunionSets(u, v);\ntotalCost += cost;\n}\n}\ncout << totalCost << endl;\nreturn 0;\n}"
    },
    {
        "problem_tier": 14,
        "solution_code": "#include<bits/stdc++.h>\nusing namespace std;\nint dp[1010][1010][2];\nint cost[1010];\nint solve(int i, int j, int flag){\nint& ret = dp[i][j][flag];\nif(ret != -1) return ret;\nif(i >= j){\nif(!flag) return ret = cost[i];\nelse return ret = 0;\n}\nif(!flag){        return ret = max(solve(i+1, j, !flag) + cost[i], solve(i, j-1, !flag) + cost[j]);\n}else{        return ret = min(solve(i+1, j, !flag), solve(i, j-1, !flag));\n}\n}\nvoid f(){\nmemset(dp, -1, sizeof(dp));\nint n;\ncin >> n;\nfor(int i = 1; i <= n; i++){\ncin >> cost[i];\n}\ncout << solve(1, n, 0) << \"\\n\";\n}\nint main(){\nios_base::sync_with_stdio(0);\ncin.tie(0);\nint t;\ncin >> t;\nwhile(t--){\nf();\n}\nreturn 0;\n}"
    },
    {
        "problem_tier": 9,
        "solution_code": "#include <iostream>\n#include <string>\nusing namespace std;\nstring addStrings(string num1, string num2) {\nstring res = \"\";\nint carry = 0;\nint idx1 = num1.size() - 1;\nint idx2 = num2.size() - 1;\nwhile (idx1 >= 0 || idx2 >= 0) {\nint n1 = idx1 >= 0 ? num1[idx1] - '0' : 0;\nint n2 = idx2 >= 0 ? num2[idx2] - '0' : 0;\nint sum = n1 + n2 + carry;\ncarry = sum / 10;\nres += to_string(sum % 10);\nidx1--;\nidx2--;\n}\nif (carry > 0) {\nres += to_string(carry);\n}\nreverse(res.begin(), res.end());\nreturn res;\n}\nint main() {\nstring num1, num2;\ncin >> num1 >> num2;\nstring result = addStrings(num1, num2);\ncout << result << endl;\nreturn 0;\n}"
    },
    {
        "problem_tier": 16,
        "solution_code": "#include <iostream>\n#include <vector>\n#include <tuple>\n#include <queue>\n#include <algorithm>\n#include <limits.h>\nusing namespace std;\nint n, m, k;\nint graph[1001][1001];\nint v[1001][1001][11][2] = {0,};\nint dir[4][2] = {{1,0},{-1,0},{0,-1},{0,1}};\nint ans = INT_MAX;\nvoid funct();\nint main(){\ncin >> n >> m >> k;\nfor(int i=0; i<n; i++){\nfor(int j=0; j<m; j++){\nscanf(\"%1d\", &graph[i][j]);\n}\n}\nv[0][0][0][1] = 1;\nfunct();\nif(ans == INT_MAX)\ncout << -1 << endl;\nelse\ncout << ans << endl;\n}\nvoid funct(){\nqueue<tuple<int, int, int, bool>> q;\nq.push(make_tuple(0, 0, 0, 1));\nwhile(!q.empty()){\nint r, c, wall;\nbool sun;\ntie(r, c, wall, sun) = q.front();\nq.pop();\nif(r == n-1 && c == m-1){\nans = min(ans, v[r][c][wall][sun]);\nreturn;\n}\nfor(int i = 0; i < 4; i++){\nint nr = r + dir[i][0];\nint nc = c + dir[i][1];\nif(nr < 0 || nc < 0 || nr >= n || nc >= m){                 continue;\n}\nif(v[nr][nc][wall][!sun] != 0){                 continue;\n}\nif(graph[nr][nc] == 1 && sun == 1 && wall + 1 <= k && v[nr][nc][wall+1][!sun] == 0){                 v[nr][nc][wall+1][!sun] = v[r][c][wall][sun] + 1;\nq.push(make_tuple(nr, nc, wall+1, !sun));\n}\nif(graph[nr][nc] == 0 && v[nr][nc][wall][!sun] == 0){                 v[nr][nc][wall][!sun] = v[r][c][wall][sun] + 1;\nq.push(make_tuple(nr, nc, wall, !sun));\n}\n}\nif(sun == 0 && v[r][c][wall][!sun] == 0){             v[r][c][wall][!sun] = v[r][c][wall][sun] + 1;\nq.push(make_tuple(r, c, wall, !sun));\n}\n}\n}"
    },
    {
        "problem_tier": 3,
        "solution_code": "#include <iostream>\n#include <limits>\nusing namespace std;\nint main() {\nint t, a, b, ans = numeric_limits<int>::max();\ncin >> t;\nwhile (t--) {\ncin >> a >> b;\nif (a <= b) ans = min(ans, b);\n}\nif (ans == numeric_limits<int>::max()) cout << -1;\nelse cout << ans;\nreturn 0;\n}"
    },
    {
        "problem_tier": 14,
        "solution_code": "#include<iostream>\n#include<algorithm>\n#include<queue>\n#include<vector>\n#include<cstring>\n#define MAX 100\n#define INF 987654321\nusing namespace std;\nint W, H;\nchar MAP[MAX][MAX];\nint visited[MAX][MAX];\nint dx[] = {0, 0, 1, -1};\nint dy[] = {1, -1, 0, 0};\npair<int, int> Start, End;\nvoid Input() {\ncin >> W >> H;\nint C_count = 0;\nfor (int i = 0; i < H; i++) {\nfor (int j = 0; j < W; j++) {\ncin >> MAP[i][j];\nif (MAP[i][j] == 'C') {\nif (C_count == 0) {\nStart.first = i;\nStart.second = j;\nC_count++;\n}\nelse {\nEnd.first = i;\nEnd.second = j;\n}\n}\n}\n}\n}\nint BFS(int a, int b) {\nqueue<pair<pair<int, int>, pair<int, int>>> q;\nfor (int i = 0; i < 4; i++) {\nq.push(make_pair(make_pair(a, b), make_pair(i, 0)));\n}\nvisited[a][b] = 0;\nwhile (!q.empty()) {\nint x = q.front().first.first;\nint y = q.front().first.second;\nint Dir = q.front().second.first;\nint Cnt = q.front().second.second;\nq.pop();\nfor (int i = 0; i < 4; i++) {\nint nx = x + dx[i];\nint ny = y + dy[i];\nint nCnt = Cnt;\nif (nx < 0 || ny < 0 || nx >= H || ny >= W) continue;\nif (MAP[nx][ny] == '*') continue;\nif (Dir != i) nCnt = nCnt + 1;\nif (visited[nx][ny] >= nCnt) {\nvisited[nx][ny] = nCnt;\nq.push(make_pair(make_pair(nx, ny), make_pair(i, nCnt)));\n}\n}\n}\nreturn visited[End.first][End.second];\n}\nvoid Solution() {\nint ans = BFS(Start.first, Start.second);\ncout << ans << endl;\n}\nint main(void) {\nios_base::sync_with_stdio(0);\ncin.tie(0);\ncout.tie(0);\nInput();\nSolution();\nreturn 0;\n}"
    },
    {
        "problem_tier": 11,
        "solution_code": "#include <iostream>\n#include <vector>\n#include <algorithm>\nchar solution(std::vector<std::vector<int>>& list) {\nint maxX, minX, maxY, minY;\nmaxX = std::max(list[0][0], list[1][0]);\nminX = std::min(list[0][2], list[1][2]);\nmaxY = std::max(list[0][1], list[1][1]);\nminY = std::min(list[0][3], list[1][3]);\nint xdif = minX - maxX;\nint ydif = minY - maxY;\nif (xdif > 0 && ydif > 0) return 'a';\nelse if (xdif < 0 || ydif < 0) return 'd';\nelse if (xdif == 0 && ydif == 0) return 'c';\nreturn 'b';\n}\nint main() {\nfor (int i = 0; i < 4; i++) {\nstd::vector<std::vector<int>> list;\nfor (int k = 0; k < 2; k++) {\nstd::vector<int> v;\nfor (int t = 0; t < 4; t++) {\nint n;\nstd::cin >> n;\nv.push_back(n);\n}\nlist.push_back(v);\n}\nstd::cout << solution(list) << std::endl;\n}\nreturn 0;\n}"
    },
    {
        "problem_tier": 9,
        "solution_code": "#include<iostream>\n#include<vector>\nusing namespace std;\nbool visited[9];\nint N, K, ans;\nvector<int> v;\nvoid dfs(int depth, int power) {\nif (depth == N - 1 && power >= 500) {\nans++;\nreturn;\n}\nfor (int i = 0; i < N; i++) {\nif (visited[i]) continue;\nvisited[i] = true;\nif (power - K + v[i] >= 500) dfs(depth + 1, power - K + v[i]);\nvisited[i] = false;\n}\n}\nint main() {\nios_base::sync_with_stdio(false);\ncin.tie(0);\ncin >> N >> K;\nfor (int i = 0; i < N; i++) {\nint inp;\ncin >> inp;\nv.push_back(inp);\n}\ndfs(0, 500);\ncout << ans;\nreturn 0;\n}"
    },
    {
        "problem_tier": 4,
        "solution_code": "#include <iostream>\n#include <string>\nusing namespace std;\nint main() {\nint t;\ncin >> t;\nfor (int i = 1; i <= t; ++i) {\nstring s;\ncin >> s;\ncout << \"String#\" << i << \"\\n\";\nfor (int j = 0; j < s.length(); ++j) {\ncout << (char)((s[j] - 'A' + 1) % 26 + 'A');\n}\ncout << \"\\n\\n\";\n}\nreturn 0;\n}"
    },
    {
        "problem_tier": 13,
        "solution_code": "#include <iostream>\nusing namespace std;\nint GCD(int a, int b){\nint n;\nif(a < b){\nint temp;\ntemp = a;\na = b;\nb = temp;\n}\nwhile(b != 0){\nint r = a % b;\na = b;\nb = r;\n}\nreturn a;\n}\nint main(void){\nint N, M, S;\ncin >> N >> M;\nif(N > M)\nN = N % M;\nS = GCD(N, M);\nM /= S;\ncout << S * (M - 1);\nreturn 0;\n}"
    },
    {
        "problem_tier": 16,
        "solution_code": "#include <iostream>\n#include <vector>\n#include <queue>\n#include <cstring>\n#include <algorithm>\n#define pii pair<int, int>\n#define INF 987654321\nusing namespace std;\nint w, h;\nchar board[21][21];\nint dist[11][11];\nvector<pii> dirty;\npii start;\nint dx[4] = {-1, 0, 1, 0};\nint dy[4] = {0, 1, 0, -1};\nint bfs(int x, int y, int tx, int ty) {\nint visited[21][21];\nmemset(visited, -1, sizeof(visited));\nqueue<pii> q;\nvisited[x][y] = 0;\nq.push({x, y});\nwhile (!q.empty()) {\nint cx = q.front().first;\nint cy = q.front().second;\nq.pop();\nif (cx == tx && cy == ty) {\nreturn visited[cx][cy];\n}\nfor (int i = 0; i < 4; i++) {\nint nx = cx + dx[i];\nint ny = cy + dy[i];\nif (nx < 0 || ny < 0 || nx >= h || ny >= w) continue;\nif (visited[nx][ny] != -1 || board[nx][ny] == 'x') continue;\nvisited[nx][ny] = visited[cx][cy] + 1;\nq.push({nx, ny});\n}\n}\nreturn -1;\n}\nint tsp(int cur, int visited) {\nif (visited == (1 << dirty.size()) - 1) {\nreturn dist[cur][0];\n}\nint &ret = dp[cur][visited];\nif (ret != -1) return ret;\nret = INF;\nfor (int i = 0; i < dirty.size(); i++) {\nif ((visited & (1 << i)) == 0) {\nret = min(ret, dist[cur][i + 1] + tsp(i + 1, visited | (1 << i)));\n}\n}\nreturn ret;\n}\nint main() {\nios_base::sync_with_stdio(false);\ncin.tie(NULL);\ncout.tie(NULL);\nwhile (true) {\ncin >> w >> h;\nif (w == 0 && h == 0) break;\ndirty.clear();\nmemset(dist, 0, sizeof(dist));\nfor (int i = 0; i < h; i++) {\nfor (int j = 0; j < w; j++) {\ncin >> board[i][j];\nif (board[i][j] == 'o') {\nstart = {i, j};\n} else if (board[i][j] == '*') {\ndirty.push_back({i, j});\n}\n}\n}\ndirty.push_back(start);\nbool flag = false;\nfor (int i = 0; i < dirty.size(); i++) {\nfor (int j = i + 1; j < dirty.size(); j++) {\nint d = bfs(dirty[i].first, dirty[i].second, dirty[j].first, dirty[j].second);\nif (d == -1) {\nflag = true;\nbreak;\n}\ndist[i][j] = dist[j][i] = d;\n}\nif (flag) break;\n}\nif (flag) {\ncout << -1 << \"\\n\";\n} else {\nmemset(dp, -1, sizeof(dp));\ncout << tsp(0, 1) << \"\\n\";\n}\n}\nreturn 0;\n}"
    },
    {
        "problem_tier": 13,
        "solution_code": "#include <iostream>\n#include <queue>\n#include <set>\ntypedef long long ll;\nusing namespace std;\nll A, B, C;\nset<pair<pair<ll, ll>, ll>> Visit;\nvoid Input() {\ncin >> A >> B >> C;\n}\nvoid Solution() {\nbool Can_Answer = false;\nqueue<pair<pair<ll, ll>, ll>> Q;\nQ.push(make_pair(make_pair(A, B), C));\nVisit.insert(make_pair(make_pair(A, B), C));\nwhile (!Q.empty()) {\nll a = Q.front().first.first;\nll b = Q.front().first.second;\nll c = Q.front().second;\nQ.pop();\nif (a == b && b == c && a == c) {\nCan_Answer = true;\nbreak;\n}\nll Tmp_A, Tmp_B, Tmp_C;\nif (a < b) {\nTmp_B = b - a;\nTmp_A = a + a;\nTmp_C = c;\nif (Visit.find(make_pair(make_pair(Tmp_A, Tmp_B), Tmp_C)) == Visit.end()) {\nVisit.insert(make_pair(make_pair(Tmp_A, Tmp_B), Tmp_C));\nQ.push(make_pair(make_pair(Tmp_A, Tmp_B), Tmp_C));\n}\n}\nif (a > b) {\nTmp_A = a - b;\nTmp_B = b + b;\nTmp_C = c;\nif (Visit.find(make_pair(make_pair(Tmp_A, Tmp_B), Tmp_C)) == Visit.end()) {\nVisit.insert(make_pair(make_pair(Tmp_A, Tmp_B), Tmp_C));\nQ.push(make_pair(make_pair(Tmp_A, Tmp_B), Tmp_C));\n}\n}\nif (a < c) {\nTmp_C = c - a;\nTmp_A = a + a;\nTmp_B = b;\nif (Visit.find(make_pair(make_pair(Tmp_A, Tmp_B), Tmp_C)) == Visit.end()) {\nVisit.insert(make_pair(make_pair(Tmp_A, Tmp_B), Tmp_C));\nQ.push(make_pair(make_pair(Tmp_A, Tmp_B), Tmp_C));\n}\n}\nif (a > c) {\nTmp_A = a - c;\nTmp_C = c + c;\nTmp_B = b;\nif (Visit.find(make_pair(make_pair(Tmp_A, Tmp_B), Tmp_C)) == Visit.end()) {\nVisit.insert(make_pair(make_pair(Tmp_A, Tmp_B), Tmp_C));\nQ.push(make_pair(make_pair(Tmp_A, Tmp_B), Tmp_C));\n}\n}\nif (b < c) {\nTmp_C = c - b;\nTmp_B = b + b;\nTmp_A = a;\nif (Visit.find(make_pair(make_pair(Tmp_A, Tmp_B), Tmp_C)) == Visit.end()) {\nVisit.insert(make_pair(make_pair(Tmp_A, Tmp_B), Tmp_C));\nQ.push(make_pair(make_pair(Tmp_A, Tmp_B), Tmp_C));\n}\n}\nif (b > c) {\nTmp_B = b - c;\nTmp_C = c + c;\nTmp_A = a;\nif (Visit.find(make_pair(make_pair(Tmp_A, Tmp_B), Tmp_C)) == Visit.end()) {\nVisit.insert(make_pair(make_pair(Tmp_A, Tmp_B), Tmp_C));\nQ.push(make_pair(make_pair(Tmp_A, Tmp_B), Tmp_C));\n}\n}\n}\nif (Can_Answer) cout << 1 << endl;\nelse cout << 0 << endl;\n}\nint main() {\nios::sync_with_stdio(false);\ncin.tie(NULL);\ncout.tie(NULL);\nInput();\nSolution();\nreturn 0;\n}"
    },
    {
        "problem_tier": 10,
        "solution_code": "#include<iostream>\n#include<vector>\n#include<algorithm>\nusing namespace std;\nint main() {\nint M, N;\nvector<int> L;\ncin >> M >> N;\nfor(int i=0;i<N;i++){\nint l;\ncin >> l;\nL.push_back(l);\n}\nint left = 1;\nint right = *max_element(L.begin(), L.end());\nint snack = 0;\nwhile(left <= right) {\nint mid = (left + right) / 2;         int count = 0;\nfor(int i=0;i<N;i++){\ncount += L[i] / mid;         }\nif(count >= M){             left = mid + 1;\nsnack = mid;\n}\nelse if(count < M){             right = mid - 1;\n}\n}\ncout << snack << \"\\n\";\nreturn 0;\n}"
    },
    {
        "problem_tier": 15,
        "solution_code": "#include <iostream>\n#include <vector>\n#include <queue>\n#include <set>\nusing namespace std;\ntypedef pair<int, int> pii;\nconst int MAX = 1001;\nconst int INF = 987654321;\nint N, M, A, B, C;\nvector<pii> adj[MAX];\nset<pii> dijkstra() {\nset<pii> ret;\nvector<int> d(N + 1, INF);\nvector<int> before(N + 1);\npriority_queue<pii, vector<pii>, greater<pii>> pq;\nfor (int i = 0; i <= N; i++)\nbefore[i] = i;\nd[1] = 0;\npq.push({0, 1});\nwhile (!pq.empty()) {\nint currD = pq.top().first;\nint curr = pq.top().second;\npq.pop();\nif (currD > d[curr])\ncontinue;\nfor (auto x : adj[curr]) {\nint next = x.first;\nint w = x.second;\nif (d[curr] + w < d[next]) {\nd[next] = d[curr] + w;\nbefore[next] = curr;\npq.push({d[next], next});\n}\n}\n}\nfor (int i = 1; i <= N; i++) {\nint p = i;\nwhile (p != before[p]) {\nret.insert({min(p, before[p]), max(p, before[p])});\np = before[p];\n}\n}\nreturn ret;\n}\nint main() {\nios_base::sync_with_stdio(false);\ncin.tie(NULL);\ncout.tie(NULL);\ncin >> N >> M;\nfor (int i = 0; i < M; i++) {\ncin >> A >> B >> C;\nadj[A].push_back({B, C});\nadj[B].push_back({A, C});\n}\nset<pii> ans = dijkstra();\ncout << ans.size() << \"\\n\";\nfor (auto edge : ans) {\ncout << edge.first << \" \" << edge.second << \"\\n\";\n}\nreturn 0;\n}"
    },
    {
        "problem_tier": 8,
        "solution_code": "#include<bits/stdc++.h>\nusing namespace std;\nstruct Point{\ndouble x, y;\n};\ndouble getLength(Point a, Point b){\ndouble x = a.x - b.x;\ndouble y = a.y - b.y;\nreturn sqrt(x*x + y*y);\n}\ndouble getInclination(Point a, Point b){\nreturn abs(a.y - b.y) / abs(a.x - b.x);\n}\nint main(){\nPoint a, b, c;\ndouble abLen, acLen, bcLen, len1, len2, len3;\ncin >> a.x >> a.y >> b.x >> b.y >> c.x >> c.y;\nif(getInclination(a, b) == getInclination(b, c)){\ncout << \"-1.0\";\nreturn 0;\n}"
    },
    {
        "problem_tier": 16,
        "solution_code": "#include<bits/stdc++.h>\n#define N 10001\nusing namespace std;\nvector<int> an, Gr[N];\nint n, r, c[N], dp[N][2];\nint f(int p, int q, int o){\nint& t(dp[p][o]);\nif (!~t)\n{\nt = o ? c[p] : 0;\nfor (int i : Gr[p])\nif (i ^ q)\nt += max(f(i, p, 0), o ? 0 : f(i, p, 1));\n}\nreturn t;\n}\nvoid Solve(int p, int q, int o){\nif (o) an.push_back(p);\nfor (int i : Gr[p])\nif (i ^ q)\nSolve(i, p, o ? 0 : dp[i][1] > dp[i][0]);\n}\nint main(){\nios_base::sync_with_stdio(0);\ncin.tie(0);\nmemset(dp, -1, sizeof dp);\ncin >> n;\nfor (int i(1); i <= n; cin >> c[i++]);\nfor (int i, j, o{}; ++o < n;)\ncin >> i >> j, Gr[i].push_back(j), Gr[j].push_back(i);\ncout << max(f(1, 0, 0), f(1, 0, 1)) << '\\n';\nSolve(1, 0, dp[1][1] > dp[1][0]);\nsort(an.begin(), an.end());\nfor (int i : an)\ncout << i << ' ';\nreturn 0;\n}"
    },
    {
        "problem_tier": 5,
        "solution_code": "#include <iostream>\n#include <vector>\nusing namespace std;\nint main() {\nint n;\ncin >> n;\nvector<int> a(n);\nfor (int i = 0; i < n; i++) {\na[i] = i + 1;\n}\nwhile (n > 1) {\nvector<int> b;\nfor (int i = 1; i < n; i += 2) {\nb.push_back(a[i]);\n}\na = b;\nn = b.size();\n}\nfor (int i = 0; i < n; i++) {\ncout << a[i] << \" \";\n}\ncout << endl;\nreturn 0;\n}"
    },
    {
        "problem_tier": 5,
        "solution_code": "#include <iostream>\n#include <vector>\n#include <algorithm>\nusing namespace std;\nint main() {\nint N;\ncin >> N;\nvector<int> v;\nfor (int i = 0; i < N; i++) {\nint temp;\ncin >> temp;\nv.push_back(temp);\n}\nsort(v.begin(), v.end());\nint sum = 0;\nfor (int i = 0; i < v.size() - 1; i++) {\nsum += v[i];\n}\ncout << sum << endl;\nreturn 0;\n}"
    },
    {
        "problem_tier": 3,
        "solution_code": "#include <iostream>\nusing namespace std;\nint main() {\nint n;\ncin >> n;\nfor(int i = 0; i < n; i++) {\nint a, b;\ncin >> a >> b;\nif(a < b) {\ncout << \"NOBRAINS\" << endl;\n} else {\ncout << \"MMMBRAINS\" << endl;\n}\n}\nreturn 0;\n}"
    },
    {
        "problem_tier": 3,
        "solution_code": "#include <iostream>\n#include <string>\nusing namespace std;\nint main() {\nstring equation;\ngetline(cin, equation);\nint num1 = equation[0] - '0';\nint num2 = equation[4] - '0';\nint num3 = equation[8] - '0';\nif (num1 + num2 == num3)\ncout << \"YES\" << endl;\nelse\ncout << \"NO\" << endl;\nreturn 0;\n}"
    },
    {
        "problem_tier": 2,
        "solution_code": "#include <bits/stdc++.h>\nusing namespace std;\nint score[2], info[5];\nint main() {\nfor (int k = 0; k < 2; k++) {\nfor (int i = 0; i < 5; i++)\ncin >> info[i];\nscore[k] = info[0] * 6 + info[1] * 3 + info[2] * 2 + info[3] + info[4] * 2;\n}\nfor (int i = 0; i < 2; i++)\ncout << score[i] << \" \";\nreturn 0;\n}"
    },
    {
        "problem_tier": 8,
        "solution_code": "#include <iostream>\n#include <cmath>\nusing namespace std;\ntypedef long long ll;\nll binarySearch(ll num) {\nll l = 0;\nll r = sqrt(num);\nwhile (l <= r) {\nll mid = (l + r) / 2;\nif (mid < sqrt(num))\nl = mid + 1;\nelse\nr = mid - 1;\n}\nreturn l;\n}\nint main() {\nll n;\ncin >> n;\ncout << binarySearch(n);\nreturn 0;\n}"
    },
    {
        "problem_tier": 5,
        "solution_code": "#include <iostream>\nint main() {\nint N, K, t, Max = 0;\nstd::cin >> N >> K;\nfor (int i = 0; i < K; i++) {\nt = N * (i + 1);\nint temp = 0;\nwhile (t != 0) {\ntemp = temp * 10 + t % 10;\nt /= 10;\n}\nif (temp > Max) Max = temp;\n}\nstd::cout << Max << std::endl;\nreturn 0;\n}"
    },
    {
        "problem_tier": 14,
        "solution_code": "#include <iostream>\n#include <vector>\nusing namespace std;\nint n, m, k;\nint laptop[41][41];\nstruct sticker {\nint r, c;\nvector<vector<int>> sticker;\n};\nvoid rotateSticker(sticker& s) {\nint r = s.r, c = s.c;\nvector<vector<int>> rotated(c, vector<int>(r));\nfor (int i = 0; i < r; i++) {\nfor (int j = 0; j < c; j++) {\nrotated[j][r - 1 - i] = s.sticker[i][j];\n}\n}\ns.sticker = rotated;\nswap(s.r, s.c);\n}\nbool canAttachSticker(sticker& s, int r, int c) {\nint stickerR = s.r, stickerC = s.c;\nif (r + stickerR > n || c + stickerC > m) return false;\nfor (int i = 0; i < stickerR; i++) {\nfor (int j = 0; j < stickerC; j++) {\nif (s.sticker[i][j] == 1 && laptop[r + i][c + j] == 1) return false;\n}\n}\nfor (int i = 0; i < stickerR; i++) {\nfor (int j = 0; j < stickerC; j++) {\nif (s.sticker[i][j] == 1)\nlaptop[r + i][c + j] = 1;\n}\n}\nreturn true;\n}\nint main() {\ncin >> n >> m >> k;\nfor (int i = 0; i < k; i++) {\nint r, c;\ncin >> r >> c;\nvector<vector<int>> s(r, vector<int>(c));\nfor (int j = 0; j < r; j++) {\nfor (int k = 0; k < c; k++) {\ncin >> s[j][k];\n}\n}\nsticker st = { r, c, s };\nbool attached = false;\nfor (int j = 0; j < 4; j++) {\nfor (int x = 0; x <= n - r; x++) {\nif (attached) break;\nfor (int y = 0; y <= m - c; y++) {\nif (canAttachSticker(st, x, y)) {\nattached = true;\nbreak;\n}\n}\n}\nif (attached) break;\nrotateSticker(st);\n}\n}\nint answer = 0;\nfor (int i = 1; i <= n; i++) {\nfor (int j = 1; j <= m; j++) {\nanswer += laptop[i][j];\n}\n}\ncout << answer << endl;\nreturn 0;\n}"
    },
    {
        "problem_tier": 6,
        "solution_code": "#include <iostream>\n#include <cstring>\n#include <cmath>\nusing namespace std;\nint main() {\nint r, c;\nstring message;\ncin >> message;\nint size = message.length();\nfor (int i = sqrt(size); i >= 1; i--) {\nif (size % i == 0) {\nr = i;\nc = size / i;\nbreak;\n}\n}\nchar matrix[101][101];\nint index = 0;\nfor (int j = 0; j < c; j++) {\nfor (int i = 0; i < r; i++) {\nmatrix[i][j] = message[index++];\n}\n}\nfor (int i = 0; i < r; i++) {\nfor (int j = 0; j < c; j++) {\ncout << matrix[i][j];\n}\n}\nreturn 0;\n}"
    },
    {
        "problem_tier": 14,
        "solution_code": "#include <iostream>\n#include <vector>\n#include <string>\nusing namespace std;\nvector<int> getFailFunction(string& a) {\nint num = a.length();\nvector<int> failfunc(num);\nint j = 0;\nfailfunc[0] = 0;\nfor (int i = 1; i < num; i++) {\nwhile (j > 0 && a[i] != a[j])\nj = failfunc[j - 1];\nif (a[i] == a[j]) {\nfailfunc[i] = j + 1;\nj += 1;\n}\nelse\nfailfunc[i] = 0;\n}\nreturn failfunc;\n}\nint main() {\nstring s;\ncin >> s;\nint n = s.length();\nint ans = -1;\nfor (int i = 0; i < n; i++) {\nstring a = s.substr(i, n - i);\nvector<int> failfunc = getFailFunction(a);\nfor (int j = 0; j < n - i; j++) {\nif (ans < failfunc[j])\nans = failfunc[j];\n}\n}\ncout << ans << '\\n';\nreturn 0;\n}"
    },
    {
        "problem_tier": 3,
        "solution_code": "#include <iostream>\nusing namespace std;\nint main() {\nint score_A = 0, score_B = 0;\nfor (int i = 0; i < 3; i++) {\nint value;\ncin >> value;\nscore_A += value * (3 - i);\n}\nfor (int i = 0; i < 3; i++) {\nint value;\ncin >> value;\nscore_B += value * (3 - i);\n}\nif (score_A > score_B) {\ncout << \"A\";\n} else if (score_A < score_B) {\ncout << \"B\";\n} else {\ncout << \"T\";\n}\nreturn 0;\n}"
    },
    {
        "problem_tier": 5,
        "solution_code": "#include <iostream>\nusing namespace std;\nint main() {\nint year;\ncin >> year;\nint gan[10];     char zi[12];\nfor (int i = 0; i < 10; i++)\ngan[i] = i;\nfor (int i = 0; i < 12; i++)\nzi[i] = i + 65;\ncout << zi[((year + 8) % 12)] << gan[(year + 6) % 10];\nreturn 0;\n}"
    },
    {
        "problem_tier": 16,
        "solution_code": "#include <iostream>\n#include <vector>\n#include <algorithm>\nusing namespace std;\ntypedef long long ll;\nvoid makeSums(int start, int end, vector<ll>& arr, vector<ll>& vec, ll sum) {\nif (start > end) {\nvec.push_back(sum);\n}\nelse {\nmakeSums(start + 1, end, arr, vec, sum);\nmakeSums(start + 1, end, arr, vec, sum + arr[start]);\n}\n}\nint main() {\nint N, C;\ncin >> N >> C;\nvector<ll> arr;\narr.resize(N, 0);\nfor (int i = 0; i < N; i++) {\ncin >> arr[i];\n}\nvector<ll> leftSums;\nvector<ll> rightSums;\nmakeSums(0, N / 2 - 1, arr, leftSums, 0);\nmakeSums(N / 2, N - 1, arr, rightSums, 0);\nsort(rightSums.begin(), rightSums.end());\nint leftSumsSize = leftSums.size();\nint sol = 0;\nfor (int i = 0; i < leftSumsSize; i++) {\nll restC = C - leftSums[i];\nsol += upper_bound(rightSums.begin(), rightSums.end(), restC) - rightSums.begin();\n}\ncout << sol;\nreturn 0;\n}"
    },
    {
        "problem_tier": 7,
        "solution_code": "#include <iostream>\n#include <algorithm>\n#include <vector>\n#include <tuple>\nusing namespace std;\nvector<tuple<int, int, int>> v;\nbool compare(tuple<int, int, int> a, tuple<int, int, int> b) {\nreturn get<2>(a) > get<2>(b);\n}\nint main() {\nint n;\ncin >> n;\nfor (int i = 0; i < n; i++) {\nint nationN, stuN, score;\ncin >> nationN >> stuN >> score;\nv.push_back(make_tuple(nationN, stuN, score));\n}\nsort(v.begin(), v.end(), compare);\nfor (int i = 0; i < 2; i++) {\ncout << get<0>(v[i]) << \" \" << get<1>(v[i]) << \"\\n\";\n}\nif (get<0>(v[0]) == get<0>(v[1])) {\nfor (int i = 2; i < n; i++) {\nif (get<0>(v[i]) != get<0>(v[0])) {\ncout << get<0>(v[i]) << \" \" << get<1>(v[i]) << \"\\n\";\nbreak;\n}\n}\n} else {\ncout << get<0>(v[2]) << \" \" << get<1>(v[2]) << \"\\n\";\n}\nreturn 0;\n}"
    },
    {
        "problem_tier": 4,
        "solution_code": "#include<iostream>\n#include<string>\nusing namespace std;\nint digitalRoot(string num) {\nint sum = 0;\nfor (int i = 0; i < num.length(); i++) {\nsum += num[i] - '0';\n}\nif (sum < 10)\nreturn sum;\nelse\nreturn digitalRoot(to_string(sum));\n}\nint main() {\nstring num;\nwhile (1) {\ncin >> num;\nif (num == \"0\")\nbreak;\ncout << digitalRoot(num) << endl;\n}\nreturn 0;\n}"
    },
    {
        "problem_tier": 14,
        "solution_code": "#include <iostream>\n#include <algorithm>\n#include <vector>\n#include <queue>\n#define MAX 201\n#define INF 987654321\nusing namespace std;\nint N, M;\nint graph[MAX][MAX], answer[MAX][MAX];\nint main() {\nios::sync_with_stdio(false);\ncin.tie(0);\ncout.tie(0);\ncin >> N >> M;\nfor (int i = 1; i <= N; i++){\nfor (int j = 1; j <= N; j++){\nif (i == j)\ngraph[i][j] = 0;\nelse\ngraph[i][j] = INF;\n}\n}\nfor (int i = 0; i < M; i++) {\nint from, to, dis;\ncin >> from >> to >> dis;\ngraph[from][to] = dis;\ngraph[to][from] = dis;\nanswer[from][to] = to;\nanswer[to][from] = from;\n}\nfor (int k = 1; k <= N; k++) {\nfor (int i = 1; i <= N; i++) {\nfor (int j = 1; j <= N; j++) {\nif (graph[i][j] > graph[i][k] + graph[k][j]) {\ngraph[i][j] = graph[i][k] + graph[k][j];\nanswer[i][j] = answer[i][k];\n}\n}\n}\n}\nfor (int i = 1; i <= N; i++) {\nfor (int j = 1; j <= N; j++) {\nif (answer[i][j] == 0)\ncout << \"-\";\nelse\ncout << answer[i][j];\ncout << \" \";\n}\ncout << \"\\n\";\n}\nreturn 0;\n}"
    },
    {
        "problem_tier": 4,
        "solution_code": "#include <iostream>\n#include <algorithm>\n#include <cmath>\nusing namespace std;\nint main() {\nint Bx, By, Dx, Dy, Jx, Jy;\ncin >> Bx >> By;\ncin >> Dx >> Dy;\ncin >> Jx >> Jy;\nint B = max(abs(Jx - Bx), abs(Jy - By));\nint D = abs(Jx - Dx) + abs(Jy - Dy);\nif (B < D) {\ncout << \"bessie\" << endl;\n} else if (B > D) {\ncout << \"daisy\" << endl;\n} else {\ncout << \"tie\" << endl;\n}\nreturn 0;\n}"
    },
    {
        "problem_tier": 16,
        "solution_code": "#include <iostream>\n#include <algorithm>\n#include <vector>\nusing namespace std;\nconst int INF = 1e9;\nstruct Node {\nint num = INF, idx = INF;\n};\nint n, q;\nint a[100001];\nvector<Node> tree(400001);\nbool operator<(const Node& a, const Node& b) {\nif (a.num == b.num)\nreturn a.idx < b.idx;\nreturn a.num < b.num;\n}\nNode query(int start, int end, int node, int left, int right) {\nif (left > end || start > right)\nreturn { INF, INF };\nif (left <= start && end <= right)\nreturn tree[node];\nint mid = (start + end) / 2;\nreturn min(query(start, mid, node * 2, left, right), query(mid + 1, end, node * 2 + 1, left, right));\n}\nNode update(int start, int end, int node, int index, int y) {\nif (index < start || index > end)\nreturn tree[node];\nif (start == end)\nreturn tree[node] = { y, index };\nint mid = (start + end) / 2;\nreturn tree[node] = min(update(start, mid, node * 2, index, y), update(mid + 1, end, node * 2 + 1, index, y));\n}\nNode init(int start, int end, int node) {\nif (start == end)\nreturn tree[node] = { a[start], start };\nint mid = (start + end) / 2;\nreturn tree[node] = min(init(start, mid, node * 2), init(mid + 1, end, node * 2 + 1));\n}\nint main() {\nios_base::sync_with_stdio(false);\ncin.tie(0);\ncout.tie(0);\ncin >> n;\nfor (int i = 0; i < n; i++)\ncin >> a[i];\ncin >> q;\ninit(0, n - 1, 1);\nwhile (q--) {\nint op, x, y;\ncin >> op >> x >> y;\nif (op == 1) {\nupdate(0, n - 1, 1, x - 1, y);\n}\nelse {\ncout << query(0, n - 1, 1, x - 1, y - 1).idx + 1 << '\\n';\n}\n}\nreturn 0;\n}"
    },
    {
        "problem_tier": 3,
        "solution_code": "#include <iostream>\nusing namespace std;\nint main() {\nlong long r, c, n;\ncin >> r >> c >> n;\nlong long x = (r % n == 0) ? r / n : (r / n) + 1;\nlong long y = (c % n == 0) ? c / n : (c / n) + 1;\ncout << x * y << endl;\nreturn 0;\n}"
    },
    {
        "problem_tier": 12,
        "solution_code": "#include <iostream>\n#include <vector>\n#include <algorithm>\nusing namespace std;\nint main() {\nios_base::sync_with_stdio(false);\ncin.tie(NULL);\ncout.tie(NULL);\nint n;\ncin >> n;\nunsigned long long ans = 0;\nunsigned long long temp = 0;\nvector<int> v(n + 1, 0);\nfor (int i = 1; i <= n; i++)\ncin >> v[i];\nfor (int i = 3; i <= n; i++)\ntemp += v[i];\nif (temp > ans) {\nans = temp;\ntemp = 0;\n}\nfor (int i = n - 2; i >= 1; i--)\ntemp += v[i];\nif (temp > ans) {\nans = temp;\ntemp = 0;\n}\nint i = 1;\nfor (int j = i + 1; j <= n - 1; j++) {\ntemp = 0;\nfor (int x = j + 1; x <= n; x++)\ntemp += v[x];\nfor (int x = i + 1; x <= n; x++) {\nif (x == j)\ncontinue;\ntemp += v[x];\n}\nif (temp > ans)\nans = temp;\n}\ni = n;\nfor (int j = i - 1; j >= 2; j--) {\ntemp = 0;\nfor (int x = j - 1; x >= 1; x--)\ntemp += v[x];\nfor (int x = i - 1; x >= 1; x--) {\nif (x == j)\ncontinue;\ntemp += v[x];\n}\nif (temp > ans)\nans = temp;\n}\nint pos = 2;\nwhile (pos < n) {\ntemp = 0;\nfor (int i = 2; i <= pos; i++)\ntemp += v[i];\nfor (int j = n - 1; j >= pos; j--)\ntemp += v[j];\nif (temp > ans)\nans = temp;\npos++;\n}\ncout << ans << \"\\n\";\nreturn 0;\n}"
    },
    {
        "problem_tier": 12,
        "solution_code": "#include <iostream>\n#include <algorithm>\nusing namespace std;\nint main() {\nint n;\nlong long dp[101];\ncin >> n;\nfor (int i = 1; i <= n; i++) {\ndp[i] = dp[i - 1] + 1;\nfor (int j = 3; j < i; j++) {\ndp[i] = max(dp[i], dp[i - j] * (j - 1));\n}\n}\ncout << dp[n] << endl;\nreturn 0;\n}"
    },
    {
        "problem_tier": 5,
        "solution_code": "#include <iostream>\nusing namespace std;\nint main() {\nint n, k;\nwhile (scanf(\"%d %d\", &n, &k) != EOF) {\nint ans = 0;\nint coupon = n;\nint stamp = 0;\nwhile (coupon) {\nans += coupon;             stamp += coupon;             coupon = 0;\ncoupon += stamp / k;             stamp %= k;         }\ncout << ans << endl;     }\nreturn 0;\n}"
    },
    {
        "problem_tier": 18,
        "solution_code": "#include<iostream>\n#include<queue>\n#include<vector>\n#include<algorithm>\n#define MAX 1003\nusing namespace std;\nvector<int> adj[MAX];\nbool check[MAX];\nint d[MAX];\nbool dfs(int cur){\nfor(int nxt : adj[cur]){\nif(check[nxt]) continue;\ncheck[nxt] = true;\nif(d[nxt] == 0 || dfs(d[nxt])){\nd[nxt] = cur;\nreturn true;\n}\n}\nreturn false;\n}\nint main(){\nios::sync_with_stdio(0);\ncin.tie(0);\nint N, M, S, num;\nint cnt = 0;\ncin >> N >> M;\nfor(int i=1;i<=N;i++){\ncin >> S;\nwhile(S--){\ncin >> num;\nadj[i].push_back(num);\n}\n}\nfor(int i=1;i<=N;i++){\nfor(int j=1;j<=2;j++){\nfill(check, check+MAX, false);\nif(dfs(i)) cnt++;\n}\n}\ncout << cnt << \"\\n\";\nreturn 0;\n}"
    },
    {
        "problem_tier": 16,
        "solution_code": "#include <iostream>\n#include <vector>\n#include <queue>\n#include <cstring>\nusing namespace std;\nchar cave[101][101];\nint R, C;\nint cluster[101][101];\nvector<int> throwList;\nint dx[] = {-1, 1, 0, 0};\nint dy[] = {0, 0, -1, 1};\nbool isInRange(int x, int y) {\nreturn x >= 0 && x < R && y >= 0 && y < C;\n}\nvoid printCave() {\nfor(int i=0; i<R; i++) {\nfor(int j=0; j<C; j++) {\ncout << cave[i][j];\n}\ncout << endl;\n}\ncout << endl;\n}\nvoid throwSticks(int height, char dir) {\nif(dir == 'L') {\nfor(int i=0; i<C; i++) {\nif(cave[height][i] == 'x') {\ncave[height][i] = '.';\nbreak;\n}\n}\n}\nelse if(dir == 'R') {\nfor(int i=C-1; i>=0; i--) {\nif(cave[height][i] == 'x') {\ncave[height][i] = '.';\nbreak;\n}\n}\n}\n}\nvoid breakCluster(int x, int y) {\nqueue<pair<int, int>> q;\nq.push(make_pair(x, y));\ncluster[x][y] = 0;\nwhile(!q.empty()) {\nint currX = q.front().first;\nint currY = q.front().second;\nq.pop();\nfor(int i=0; i<4; i++) {\nint nx = currX + dx[i];\nint ny = currY + dy[i];\nif(isInRange(nx, ny) && cave[nx][ny] == 'x' && cluster[nx][ny] == -1) {\ncluster[nx][ny] = 0;\nq.push(make_pair(nx, ny));\n}\n}\n}\n}\nbool isFloatingCluster() {\nmemset(cluster, -1, sizeof(cluster));\nfor(int i=0; i<C; i++) {\nif(cave[R-1][i] == 'x' && cluster[R-1][i] == -1) {\nbreakCluster(R-1, i);\n}\n}\nbool floating = true;\nfor(int i=0; i<R; i++) {\nfor(int j=0; j<C; j++) {\nif(cave[i][j] == 'x' && cluster[i][j] == -1) {\nfloating = false;\nbreak;\n}\n}\n}\nreturn floating;\n}\nvoid moveCluster(int height) {\nint lowest = R-1;\nfor(int i=0; i<R; i++) {\nfor(int j=0; j<C; j++) {\nif(cave[i][j] == 'x' && cluster[i][j] != -1) {\ncave[i][j] = '.';\nlowest = min(lowest, i);\n}\n}\n}\nint dropHeight = R-1;\nfor(int i=lowest; i>=0; i--) {\nfor(int j=0; j<C; j++) {\nif(cave[i][j] == 'x' && cluster[i][j] != -1) {\nint ny = j;\nint nx = i+1;\nif(isInRange(nx, ny) && cave[nx][ny] == '.') {\ncave[nx][ny] = 'x';\ncluster[i][j] = -1;\ndropHeight = min(dropHeight, nx);\n}\n}\n}\n}\nif(dropHeight != R-1) {\nfor(int i=0; i<R; i++) {\nfor(int j=0; j<C; j++) {\nif(cave[i][j] == 'x' && cluster[i][j] != -1) {\ncave[i][j] = '.';\n}\n}\n}\nfor(int i=0; i<R; i++) {\nfor(int j=0; j<C; j++) {\nif(cave[i][j] == 'x' && cluster[i][j] != -1) {\ncave[i+dropHeight-R+1][j] = 'x';\n}\n}\n}\n}\n}\nvoid solve() {\nfor(int i=0; i<throwList.size(); i++) {\nint height = R - throwList[i];\nif(i % 2 == 0) {\nfor(int j=0; j<C; j++) {\nif(cave[height][j] == 'x') {\ncave[height][j] = '.';\nbreak;\n}\n}\n}\nelse {\nfor(int j=C-1; j>=0; j--) {\nif(cave[height][j] == 'x') {\ncave[height][j] = '.';\nbreak;\n}\n}\n}\nif(isFloatingCluster()) {\nmoveCluster(height);\n}\n}\n}\nint main() {\ncin.tie(NULL);\ncout.tie(NULL);\nios_base::sync_with_stdio(false);\ncin >> R >> C;\nfor(int i=0; i<R; i++) {\nfor(int j=0; j<C; j++) {\ncin >> cave[i][j];\n}\n}\nint throwCount;\ncin >> throwCount;\nfor(int i=0; i<throwCount; i++) {\nint height;\ncin >> height;\nthrowList.push_back(height);\n}\nsolve();\nfor(int i=0; i<R; i++) {\nfor(int j=0; j<C; j++) {\ncout << cave[i][j];\n}\n"
    },
    {
        "problem_tier": 18,
        "solution_code": "#include <iostream>\n#include <cmath>\n#include <vector>\nusing namespace std;\nvector<int> Tree;\nvector<int> Pos;\nvoid updateTree(vector<int>& Tree, int Node, int Begin, int End, int Index, int Var){\nif (Index < Begin || Index > End) return;\nTree[Node] += Var;\nif (Begin < End){\nint Mid = (Begin + End) / 2;\nupdateTree(Tree, Node*2, Begin, Mid, Index, Var);\nupdateTree(Tree, Node*2+1, Mid+1, End, Index, Var);\nTree[Node] = Tree[Node*2] + Tree[Node*2+1];\n}\n}\nint calcSum(vector<int>& Tree, int Node, int Begin, int End, int Left, int Right){\nif (Left > End || Right < Begin) return 0;\nif (Left <= Begin && Right >= End) return Tree[Node];\nint Mid = (Begin + End) / 2;\nreturn calcSum(Tree, Node*2, Begin, Mid, Left, Right) + calcSum(Tree, Node*2+1, Mid+1, End, Left, Right);\n}\nint main(){\nint T, N, M, DVDNum;\ncin >> T;\nfor (int i = 0; i < T; i++){\ncin >> N >> M;\nTree.resize((N+M)*4+1);\nPos.resize(N+1);\nfor (int j = 1; j <= N; j++){\nPos[j] = M + j;\nupdateTree(Tree, 1, 1, M+N, Pos[j], 1);\n}\nfor (int j = 1; j <= M; j++){\ncin >> DVDNum;\ncout << calcSum(Tree, 1, 1, M+N, 1, Pos[DVDNum]-1) << \" \";\nupdateTree(Tree, 1, 1, M+N, Pos[DVDNum], -1);\nupdateTree(Tree, 1, 1, M+N, M+1-j, 1);\nPos[DVDNum] = M+1-j;\n}\ncout << endl;\n}\n}"
    },
    {
        "problem_tier": 8,
        "solution_code": "#include <iostream>\n#include <vector>\n#include <algorithm>\nusing namespace std;\nint main() {\nint n;\ncin >> n;\nvector<pair<int, int>> v;\nfor (int i = 0; i < n; i++) {\nint a, b;\ncin >> a >> b;\nv.push_back({a, b});\n}\nsort(v.begin(), v.end());\nint time = 0;\nfor (int i = 0; i < n; i++) {\ntime = max(v[i].first, time);\ntime += v[i].second;\n}\ncout << time;\nreturn 0;\n}"
    },
    {
        "problem_tier": 15,
        "solution_code": "#include <iostream>\nusing namespace std;\nconst int MAX = 21;\nconst int INF = 9999999;\nint N;\nint map[MAX][MAX];\nbool road[MAX][MAX];\nbool isImpossible;\nvoid reverse_floyd() {\nfor (int k = 1; k <= N; k++) {\nfor (int i = 1; i <= N; i++) {\nfor (int j = 1; j <= N; j++) {\nif (k == i || i == j || j == k)\ncontinue;\nif (map[i][j] > map[i][k] + map[k][j]) {\nisImpossible = true;\nreturn;\n} else if (map[i][j] == map[i][k] + map[k][j]) {\nroad[i][j] = false;\n}\n}\n}\n}\n}\nint main() {\ncin >> N;\nfor (int i = 1; i <= N; i++) {\nfor (int j = 1; j <= N; j++) {\nroad[i][j] = true;\n}\n}\nfor (int i = 1; i <= N; i++) {\nfor (int j = 1; j <= N; j++) {\ncin >> map[i][j];\n}\n}\nreverse_floyd();\nint ans = 0;\nfor (int i = 1; i <= N; i++) {\nfor (int j = 1; j <= N; j++) {\nif (road[i][j] == true) {\nans += map[i][j];\n}\n}\n}\nans /= 2;\nif (isImpossible)\ncout << -1;\nelse\ncout << ans;\nreturn 0;\n}"
    },
    {
        "problem_tier": 13,
        "solution_code": "#include <iostream>\n#include <queue>\nusing namespace std;\nint main() {\nint t;\ncin >> t;\nwhile(t--) {\nint k;\ncin >> k;\npriority_queue<long long, vector<long long>, greater<long long>> pq;\nwhile(k--) {\nlong long num;\ncin >> num;\npq.push(num);\n}\nlong long ans = 0;\nwhile(!pq.empty()) {\nif(pq.size() == 1)\nbreak;\nlong long first = pq.top();\npq.pop();\nlong long second = pq.top();\npq.pop();\nans += first + second;\npq.push(first + second);\n}\npq.pop();\ncout << ans << '\\n';\n}\nreturn 0;\n}"
    },
    {
        "problem_tier": 4,
        "solution_code": "#include<iostream>\nusing namespace std;\nint main(){\nios::sync_with_stdio(0);\ncin.tie(0);\ncout.tie(0);\nint test;\ncin >> test;\nfor(int i=0; i<test; i++){\ndouble n, m, a;\ncin >> n >> m;\nint cnt = 0;\nfor(int i=0; i<n; i++){\nfor(int j=0; j<n; j++){\nif(i<j){\na = ((i*i+j*j+m)/(i*j));\nif(abs(a - (int)a) < 1e-12){\ncnt++;\n}\n}\n}\n}\ncout << cnt << \"\\n\";\n}\nreturn 0;\n}"
    },
    {
        "problem_tier": 14,
        "solution_code": "#include <iostream>\n#include <vector>\nusing namespace std;\nint parent[1001][1001];\nchar map[1001][1001];\nint find(int y, int x){\nint py = parent[y][x].first, px = parent[y][x].second;\nif(py == y && px == x){\nreturn parent[y][x];\n}else{\nreturn parent[y][x] = find(py, px);\n}\n}\nbool check_range(int y, int x, int n, int m){\nif(y > 0 && x > 0 && y <= n && x <= m)\nreturn true;\nreturn false;\n}\nvoid dfs(int y, int x, int n, int m){\nif(!check_range(y, x, n, m)){\nparent[y][x] = {y, x};\nreturn;\n}\nint ny = y + dir[map[y][x]].first, nx = x + dir[map[y][x]].second;\nif(parent[ny][nx].first == 0 && parent[ny][nx].second == 0){\nparent[ny][nx] = {y, x};\ndfs(ny, nx, n, m);\n}else if(find(y, x) == find(ny, nx)){\nreturn;\n}else if(find(y, x) != find(ny, nx)){\nreturn;\n}\n}\nint main(){\nint n, m;\ncin >> n >> m;\ndir.insert({'R', {0, 1}});\ndir.insert({'L', {0, -1}});\ndir.insert({'U', {-1, 0}});\ndir.insert({'D', {1, 0}});\nfor(int i = 1; i <= n; i++){\nfor(int k = 1; k <= m; k++){\ncin >> map[i][k];\n}\n}\nfor(int i = 1; i <= n; i++){\nfor(int k = 1; k <= m; k++){\nif(parent[i][k].first == 0 && parent[i][k].second == 0){\nparent[i][k] = {i, k};\ndfs(i, k, n, m);\n}\n}\n}\nint result = 0;\nvector<int> sets;\nfor(int i = 1; i <= n; i++){\nfor(int k = 1; k <= m; k++){\nint r = find(i, k);\nif(find(sets.begin(), sets.end(), r) == sets.end()){\nresult++;\nsets.push_back(r);\n}\n}\n}\ncout << result << endl;\nreturn 0;\n}"
    },
    {
        "problem_tier": 15,
        "solution_code": "#include <iostream>\n#include <vector>\n#include <algorithm>\nusing namespace std;\nstruct Info {\nint num, color, size, ans;\n};\nstruct State {\nint pivot, pSize, cSize;\n};\nbool comp1(Info a, Info b) {\nreturn a.size < b.size;\n}\nbool comp2(Info a, Info b) {\nreturn a.num < b.num;\n}\nint main() {\nios::sync_with_stdio(0);\ncin.tie(0);\ncout.tie(0);\nint N, c, s;\ncin >> N;\nvector<Info> v(N);\nvector<State> acc(N);\nfor (int i = 0; i < N; i++) {\ncin >> c >> s;\nv[i] = { i, c-1, s, 0 };\n}\nsort(v.begin(), v.end(), comp1);\nint pivot = v[0].size;\nint pTot = 0;\nint cTot = v[0].size;\nacc[v[0].color].cSize = v[0].size;\nacc[v[0].color].pivot = v[0].size;\nfor (int i = 1; i < N; i++) {\nint idx = v[i].color;\nif (acc[idx].pivot < v[i].size) {\nacc[idx].pivot = v[i].size;\nacc[idx].pSize = acc[idx].cSize;\n}\nif (pivot >= v[i].size) {\nv[i].ans = pTot - acc[idx].pSize;\n} else {\nv[i].ans = cTot - acc[idx].cSize;\npivot = v[i].size;\npTot = cTot;\n}\nacc[idx].cSize += v[i].size;\ncTot += v[i].size;\n}\nsort(v.begin(), v.end(), comp2);\nfor (int i = 0; i < N; i++) {\ncout << v[i].ans << \"\\n\";\n}\nreturn 0;\n}"
    },
    {
        "problem_tier": 8,
        "solution_code": "#include <iostream>\n#include <vector>\nusing namespace std;\nlong long dp[117];\nint main() {\nios_base::sync_with_stdio(false);\ncin.tie(NULL);\ncout.tie(NULL);\nint n;\ncin >> n;\ndp[1] = 1;\ndp[2] = 1;\ndp[3] = 1;\nfor (int i = 4; i <= n; i++) {\ndp[i] = dp[i - 1] + dp[i - 3];\n}\ncout << dp[n] << endl;\nreturn 0;\n}"
    },
    {
        "problem_tier": 4,
        "solution_code": "#include <iostream>\nusing namespace std;\nint main() {\nint t;     cin >> t;\nwhile(t--) {\nint n, k;         cin >> n >> k;\nint ans = 0;         for(int i=0; i<n; ++i) {\nint num;             cin >> num;\nans += num / k;\n}\ncout << ans << '\\n';\n}\nreturn 0;\n}"
    },
    {
        "problem_tier": 7,
        "solution_code": "#include<iostream>\n#include<string>\n#include<vector>\nusing namespace std;\nint main() {\nstring str;\ncin >> str;\nint n;\ncin >> n;\nint cnt = 0;\nfor (int i = 0; i < n; i++) {\nstring input;\ncin >> input;\nint size = str.size();\nint partCnt = 0;\nint idx = 0;\nfor (int j = 0; j < size; j++) {\nif (input.find(str[j], idx) == -1)\nbreak;\nelse {\npartCnt++;\nidx = input.find(str[j], idx) + 1;\nif (idx >= input.size())\nidx = 0;\nif (partCnt == size)\ncnt++;\n}\n}\n}\ncout << cnt;\n}"
    },
    {
        "problem_tier": 4,
        "solution_code": "#include <iostream>\nusing namespace std;\nstring getAns(int waitTime) {\nstring tmp = \"\";\nif (waitTime / 3600 < 10)\ntmp += \"0\";\nif (waitTime / 3600 >= 24) {\nint newTime = waitTime / 3600 - 24;\nif (newTime < 10)\ntmp += \"0\";\ntmp += to_string(newTime) + \":\";\n}\nelse\ntmp += to_string(waitTime / 3600) + \":\";\nwaitTime %= 3600;\nif (waitTime / 60 < 10)\ntmp += \"0\";\ntmp += to_string(waitTime / 60) + \":\";\nwaitTime %= 60;\nif (waitTime < 10)\ntmp += \"0\";\ntmp += to_string(waitTime);\nreturn tmp;\n}\nint main() {\nint nowTime[3], doTime[3];\nint sec1, sec2, waitTime;\nscanf(\"%d:%d:%d\", &nowTime[0], &nowTime[1], &nowTime[2]);\nscanf(\"%d:%d:%d\", &doTime[0], &doTime[1], &doTime[2]);\nsec1 = nowTime[0] * 3600 + nowTime[1] * 60 + nowTime[2];\nsec2 = doTime[0] * 3600 + doTime[1] * 60 + doTime[2];\nif (sec1 == sec2)\ncout << \"24:00:00\\n\";\nelse {\nwaitTime = 24 * 3600 - sec1 + sec2;\ncout << getAns(waitTime);\n}\nreturn 0;\n}"
    },
    {
        "problem_tier": 13,
        "solution_code": "#include <iostream>\n#include <cstring>\nusing namespace std;\n#define MAX 33\ntypedef long long ll;\nll DP[MAX][MAX][3];\nbool Can_Slash(int x, int y) {\nif (MAP[x + 1][y] == 0 && MAP[x][y + 1] == 0 && MAP[x + 1][y + 1] == 0)\nreturn true;\nreturn false;\n}\nll DFS(int x, int y, int Dir) {\nif (x == N - 1 && y == N - 1)\nreturn 1;\nif (DP[x][y][Dir] != -1)\nreturn DP[x][y][Dir];\nDP[x][y][Dir] = 0;\nif (Dir == 0) {\nint nx = x + dx[Dir];\nint ny = y + dy[Dir];\nif (nx >= 0 && ny >= 0 && nx < N && ny < N) {\nif (MAP[nx][ny] == 0) {\nDP[x][y][Dir] = DP[x][y][Dir] + DFS(nx, ny, Dir);\n}\n}\nnx = x + dx[2];\nny = y + dy[2];\nif (nx >= 0 && ny >= 0 && nx < N && ny < N) {\nif (Can_Slash(x, y)) {\nDP[x][y][Dir] = DP[x][y][Dir] + DFS(nx, ny, 2);\n}\n}\n}\nelse if (Dir == 1) {\nint nx = x + dx[Dir];\nint ny = y + dy[Dir];\nif (nx >= 0 && ny >= 0 && nx < N && ny < N) {\nif (MAP[nx][ny] == 0) {\nDP[x][y][Dir] = DP[x][y][Dir] + DFS(nx, ny, Dir);\n}\n}\nnx = x + dx[2];\nny = y + dy[2];\nif (nx >= 0 && ny >= 0 && nx < N && ny < N) {\nif (Can_Slash(x, y)) {\nDP[x][y][Dir] = DP[x][y][Dir] + DFS(nx, ny, 2);\n}\n}\n}\nelse if (Dir == 2) {\nint nx = x + dx[Dir];\nint ny = y + dy[Dir];\nif (nx >= 0 && ny >= 0 && nx < N && ny < N) {\nif (Can_Slash(x, y)) {\nDP[x][y][Dir] = DP[x][y][Dir] + DFS(nx, ny, Dir);\n}\n}\nnx = x + dx[0];\nny = y + dy[0];\nif (nx >= 0 && ny >= 0 && nx < N && ny < N) {\nif (MAP[nx][ny] == 0) {\nDP[x][y][Dir] = DP[x][y][Dir] + DFS(nx, ny, 0);\n}\n}\nnx = x + dx[1];\nny = y + dy[1];\nif (nx >= 0 && ny >= 0 && nx < N && ny < N) {\nif (MAP[nx][ny] == 0) {\nDP[x][y][Dir] = DP[x]["
    },
    {
        "problem_tier": 11,
        "solution_code": "#include<iostream>\n#include<algorithm>\nusing namespace std;\nint main(){\nios::sync_with_stdio(false);\ncin.tie(0);\ncout.tie(0);\nint n, k;\ncin >> n >> k;\nint arr[200000];\nint cnt[200001] = {};\nint answer = 0;\nint start = 0;\nfor(int i=0; i<n; i++){\ncin >> arr[i];\ncnt[arr[i]]++;\nwhile(cnt[arr[i]] > k){\ncnt[arr[start++]]--;\n}\nanswer = max(answer, i-start+1);\n}\ncout << answer;\nreturn 0;\n}"
    },
    {
        "problem_tier": 2,
        "solution_code": "#include <iostream>\n#include <vector>\nusing namespace std;\nint main() {\nios::sync_with_stdio(false);\ncin.tie(nullptr);\nwhile (true) {\nint n;\ncin >> n;\nif (n == 0)\nbreak;\nint totalBlocks = n * (n + 1) / 2;\ncout << totalBlocks << \"\\n\";\n}\nreturn 0;\n}"
    },
    {
        "problem_tier": 16,
        "solution_code": "#include <iostream>\n#include <vector>\n#include <algorithm>\nusing namespace std;\nconst int INF = 1000000001;\nvector<int> Arr;\nvector<int> Tree;\nint initTree(int Begin, int End, int Node) {\nif (Begin == End)\nreturn Tree[Node] = Arr[Begin];\nint Mid = (Begin + End) / 2;\nint leftMin = initTree(Begin, Mid, Node * 2);\nint rightMin = initTree(Mid + 1, End, Node * 2 + 1);\nif (leftMin < rightMin)\nreturn Tree[Node] = leftMin;\nelse\nreturn Tree[Node] = rightMin;\n}\nint updateTree(int Begin, int End, int Node, int Index) {\nif (Index < Begin || Index > End)\nreturn Tree[Node];\nif (Begin == End)\nreturn Tree[Node] = Arr[Index];\nint Mid = (Begin + End) / 2;\nint leftMin = updateTree(Begin, Mid, Node * 2, Index);\nint rightMin = updateTree(Mid + 1, End, Node * 2 + 1, Index);\nreturn Tree[Node] = min(leftMin, rightMin);\n}\nint findMin(int Begin, int End, int Node, int Left, int Right) {\nif (Left > End || Right < Begin)\nreturn INF;\nif (Left <= Begin && Right >= End)\nreturn Tree[Node];\nint Mid = (Begin + End) / 2;\nint leftMin = findMin(Begin, Mid, Node * 2, Left, Right);\nint rightMin = findMin(Mid + 1, End, Node * 2 + 1, Left, Right);\nreturn min(leftMin, rightMin);\n}\nint main() {\nint N, M, Q, Index, Value, Left, Right;\ncin >> N;\nArr.resize(N);\nfor (int i = 0; i < N; i++)\ncin >> Arr[i];\nTree.resize(N * 4);\ninit(0, N - 1, 1);\ncin >> M;\nfor (int i = 0; i < M; i++) {\ncin >> Q;\nif (Q == 1) {\ncin >> Index >> Value;\nArr[Index - 1] = Value;\nupdateTree(0, N - 1, 1, Index - 1);\n} else {\ncin >> Left >> Right;\ncout << findMin(0, N - 1, 1, Left - 1, Right - 1) << endl;\n}\n}\nreturn 0;\n}"
    },
    {
        "problem_tier": 9,
        "solution_code": "#include <iostream>\n#include <algorithm>\n#include <vector>\nusing namespace std;\nint main() {\nios_base::sync_with_stdio(0);\ncin.tie(0);\ncout.tie(0);\nint n, tmp;\ncin >> n;\nvector<int> v;\nfor (int i = 0; i < n; i++) {\ncin >> tmp;\nv.push_back(tmp);\n}\nsort(v.begin(), v.end());\nint a, b, c;\nint result = 0;\nfor (int i = n - 1; i >= 2; i--) {\nc = v[i];\nb = v[i - 1];\na = v[i - 2];\nif (c >= a + b) continue;\nelse {\nresult = a + b + c;\ncout << result << '\\n';\nreturn 0;\n}"
    },
    {
        "problem_tier": 5,
        "solution_code": "#include<iostream>\n#include<string>\n#include<cctype>\nusing namespace std;\nbool isPrime(int num) {\nif(num < 2) return false;\nfor(int i = 2; i * i <= num; i++) {\nif(num % i == 0) return false;\n}\nreturn true;\n}\nint main() {\nstring str;\ncin >> str;\nint sum = 0;\nfor(int i = 0; i < str.length(); i++) {\nchar c = str[i];\nif(isupper(c)) {\nsum += int(c) - 38;\n}\nelse if(islower(c)) {\nsum += int(c) - 96;\n}\n}\nif(isPrime(sum)) {\ncout << \"It is a prime word.\";\n}\nelse {\ncout << \"It is not a prime word.\";\n}\nreturn 0;\n}"
    },
    {
        "problem_tier": 9,
        "solution_code": "#include <iostream>\n#include <vector>\n#include <algorithm>\n#include <cstring>\nusing namespace std;\nbool visited[1000];\nint romanNum[4] = {1, 5, 10, 50};\nint N, answer = 0;\nvoid dfs(int cnt, int idx, int sum) {\nif(cnt == N) {\nif(!visited[sum]) {\nvisited[sum] = true;\nanswer++;\n}\nreturn;\n}\nfor(int i = idx; i < 4; i++) {\ndfs(cnt + 1, i, sum + romanNum[i]);\n}\n}\nint main() {\ncin >> N;\ndfs(0, 0, 0);\ncout << answer << endl;\nreturn 0;\n}"
    },
    {
        "problem_tier": 11,
        "solution_code": "#include<iostream>\n#include<unordered_map>\n#include<vector>\nusing namespace std;\nint main(){\nios_base::sync_with_stdio(false);\ncin.tie(0);\nint N;\ncin >> N;\nunordered_map<string,int> um;\nvector<string> inp;\nfor(int i=0; i<N; i++){\nstring _inp;\ncin >> _inp;\num.insert({_inp,i});\n}\nfor(int i=0; i<N; i++){\nstring _inp;\ncin >> _inp;\ninp.push_back(_inp);\n}\nint cnt = 0;\nfor(int i=0; i<inp.size(); i++){\nfor(int k=i+1; k<inp.size(); k++){\nif(um[inp[i]] > um[inp[k]]){\ncnt++;\nbreak;\n}\n}\n}\ncout << cnt;\nreturn 0;\n}"
    },
    {
        "problem_tier": 8,
        "solution_code": "#include <iostream>\n#include <vector>\n#include <algorithm>\nusing namespace std;\nstruct Point {\nint x;\nint color;\nPoint(int x, int color) : x(x), color(color) {}\n};\nint main() {\nint n;\ncin >> n;\nvector<vector<Point>> points(n + 1);\nfor (int i = 0; i < n; i++) {\nint x, color;\ncin >> x >> color;\npoints[color].push_back(Point(x, color));\n}\nint ans = 0;\nfor (int i = 1; i <= n; i++) {\nsort(points[i].begin(), points[i].end(), [](const Point &a, const Point &b) {\nreturn a.x < b.x;\n});\nint colorSize = points[i].size();\nfor (int j = 0; j < colorSize; j++) {\nint leftDist = (j == 0) ? 1e9 : points[i][j].x - points[i][j - 1].x;\nint rightDist = (j == colorSize - 1) ? 1e9 : points[i][j + 1].x - points[i][j].x;\nans += min(leftDist, rightDist);\n}\n}\ncout << ans << endl;\nreturn 0;\n}"
    },
    {
        "problem_tier": 5,
        "solution_code": "#include <iostream>\n#include <cstdio>\nusing namespace std;\nint main() {\nchar n[50];\nint cnt = 1;\nscanf(\"%s\", n);\nfor (int i = 0; i < 50; i++) {\nif (n[i] == 'A') {\nif (cnt == 1) {\ncnt = 2;\n} else if (cnt == 2) {\ncnt = 1;\n}\n} else if (n[i] == 'B') {\nif (cnt == 2) {\ncnt = 3;\n} else if (cnt == 3) {\ncnt = 2;\n}\n} else if (n[i] == 'C') {\nif (cnt == 1) {\ncnt = 3;\n} else if (cnt == 3) {\ncnt = 1;\n}\n}\n}\nprintf(\"%d\", cnt);\nreturn 0;\n}"
    },
    {
        "problem_tier": 2,
        "solution_code": "#include <iostream>\nusing namespace std;\nint main() {\nint n, m;\ncin >> n >> m;\nlong long int dp[1001][301];\nint arr[1001][301];\nfor (int i = 0; i < n; i++) {\nfor (int j = 0; j < m; j++) {\ncin >> arr[i][j];\n}\n}\nfor (int i = 0; i < m; i++) {\ndp[0][i] = arr[0][i];\n}\nfor (int i = 1; i < n; i++) {\nfor (int j = 0; j < m; j++) {\nlong long int minSum = dp[i - 1][0];\nfor (int k = 1; k <= j; k++) {\nminSum = min(minSum, dp[i - 1][k]);\n}\nfor (int k = j; k < m; k++) {\nminSum = min(minSum, dp[i - 1][k + 1]);\ndp[i][j] = minSum + arr[i][j];\n}\n}\n}\nlong long int answer = dp[n - 1][0];\nfor (int i = 1; i < m; i++) {\nanswer = min(answer, dp[n - 1][i]);\n}\ncout << answer << endl;\nreturn 0;\n}"
    },
    {
        "problem_tier": 14,
        "solution_code": "#include <iostream>\n#include <vector>\nusing namespace std;\nint map[21][21];\nbool visited[21][21];\nint N, M, K;\nint result = 0;\nint x, y;\nint dice[6] = {2, 4, 1, 3, 5, 6};\nint dir[4][2] = {{0, 1}, {1, 0}, {0, -1}, {-1, 0}};\nint moveDir;\nint A, B, C;\nvoid DFS(int x, int y);\nvoid moveDice(int dir);\nvoid reset();\nint main() {\ncin >> N >> M >> K;\nreset();\nfor (int i = 1; i <= N; i++) {\nfor (int j = 1; j <= M; j++) {\ncin >> map[i][j];\n}\n}\nx = 1;\ny = 1;\nmoveDir = 0;\nfor (int i = 0; i < K; i++) {\nif ((x + dir[moveDir][0] > N || x + dir[moveDir][0] < 1) || (y + dir[moveDir][1] > M || y + dir[moveDir][1] < 1)) {\nif (moveDir < 2) moveDir += 2;\nelse moveDir -= 2;\n}\nmoveDice(moveDir);\nx += dir[moveDir][0];\ny += dir[moveDir][1];\nB = map[x][y];\nC = 1;\nreset();\nDFS(x, y);\nresult += B * C;\nA = dice[5];\nif (A > B) {\nif (moveDir != 3) moveDir += 1;\nelse moveDir = 0;\n}\nif (A < B) {\nif (moveDir != 0) moveDir -= 1;\nelse moveDir = 3;\n}\n}\ncout << result << '\\n';\nreturn 0;\n}\nvoid moveDice(int dir) {\nint tmp;\nif (dir == 0) {\ntmp = dice[3];\ndice[3] = dice[2];\ndice[2] = dice[1];\ndice[1] = dice[5];\ndice[5] = tmp;\n} else if (dir == 1) {\ntmp = dice[5];\ndice[5] = dice[4];\ndice[4] = dice[2];\ndice[2] = dice[0];\ndice[0] = tmp;\n} else if (dir == 2) {\ntmp = dice[1];\ndice[1] = dice[2];\ndice[2] = dice[3];\ndice[3] = dice[5];\ndice[5] = tmp;\n} else {\ntmp = dice[0];\ndice[0] = dice[2];\ndice[2] = dice[4];\ndice[4] = dice[5];\ndice[5] = tmp;\n}\n}\nvoid reset() {\nfor (int i = 1; i <= N; i++) {\nfor (int j = 1; j <= M; j++) {\nvisited[i][j] = false;\n}\n}\n}\nvoid DFS(int x, int y) {\nvisited[x][y] = true;\nfor (int i = 0; i < 4; i++) {\nint nx = x + dir[i][0];\nint ny = y + dir[i][1];\nif ((nx <= N && nx > 0) && (ny <= M && ny > 0)) {\nif (map[nx][ny] == B && !visited[nx][ny]) {\nvisited[nx][ny] = true;\nC += 1;\nDFS(nx, ny);\n}\n}\n}\n}"
    },
    {
        "problem_tier": 9,
        "solution_code": "#include <iostream>\n#include <vector>\n#include <cstring>\nusing namespace std;\nbool eratosthenes_sieve[100002];\nvector<int> prime;\nvoid primeFactorization(const int &N) {\nif (eratosthenes_sieve[N]) {\ncout << N << \" 1\\n\";\nreturn;\n}\nint copy_N = N;\nfor (int i = 0; i < prime.size(); i++) {\nif (eratosthenes_sieve[copy_N]) {\nif (copy_N == 1)\nreturn;\ncout << copy_N << \" 1\\n\";\nreturn;\n}\nif (copy_N % prime[i] == 0) {\nint count = 0;\nwhile (copy_N % prime[i] == 0) {\ncount++;\ncopy_N /= prime[i];\n}\ncout << prime[i] << \" \" << count << \"\\n\";\n}\n}\n}\nint main() {\nios_base::sync_with_stdio(0);\ncin.tie(0);\nint N, origin;\ncin >> N;\nmemset(eratosthenes_sieve, true, sizeof(eratosthenes_sieve));\nfor (int i = 2; i <= 100000; i++) {\nif (i * i > 100000)\nbreak;\nif (eratosthenes_sieve[i]) {\nfor (int j = i + i; j <= 100000; j += i)\neratosthenes_sieve[j] = false;\n}\n}\nfor (int i = 2; i <= 100000; i++) {\nif (eratosthenes_sieve[i])\nprime.push_back(i);\n}\nfor (int i = 0; i < N; i++) {\ncin >> origin;\nprimeFactorization(origin);\n}\nreturn 0;\n}"
    },
    {
        "problem_tier": 11,
        "solution_code": "#include <iostream>\n#include <queue>\nusing namespace std;\nint M, N;\nconst int MAX = 251;\nint map[MAX][MAX];\nbool visited[MAX][MAX];\nint dy[] = { 0,0,-1,1,-1,-1,1,1 };\nint dx[] = { 1,-1,0,0,-1,1,-1,1 };\nqueue<pair<int, int>> q;\nvoid BFS(int y, int x) {\nvisited[y][x] = true;\nq.push(make_pair(y, x));\nwhile (!q.empty()) {\ny = q.front().first;\nx = q.front().second;\nq.pop();\nfor (int i = 0; i < 8; i++) {\nint ny = y + dy[i];\nint nx = x + dx[i];\nif (ny<0 || nx<0 || ny>=M || nx>=N)\ncontinue;\nif (map[ny][nx] == 1 && visited[ny][nx] == 0) {\nvisited[ny][nx] = true;\nq.push(make_pair(ny, nx));\n}\n}\n}\n}\nint main() {\ncin >> M >> N;\nfor (int i = 0; i < M; i++) {\nfor (int j = 0; j < N; j++) {\ncin >> map[i][j];\n}\n}\nint ans = 0;\nfor (int i = 0; i < M; i++) {\nfor (int j = 0; j < N; j++) {\nif (map[i][j] == 1 && visited[i][j] == 0) {\nBFS(i, j);\nans++;\n}\n}\n}\ncout << ans;\nreturn 0;\n}"
    },
    {
        "problem_tier": 4,
        "solution_code": "#include <iostream>\n#define ll long long\nusing namespace std;\nint main() {\nll num, ans = 0;\nchar op;\ncin >> ans;\nwhile (1) {\ncin >> op;\nif (op == '=') {\ncout << ans << '\\n';\nbreak;\n}\ncin >> num;\nif (op == '+')\nans += num;\nelse if (op == '-')\nans -= num;\nelse if (op == '*')\nans *= num;\nelse if (op == '/')\nans /= num;\n}\nreturn 0;\n}"
    },
    {
        "problem_tier": 18,
        "solution_code": "#include <iostream>\n#include <vector>\n#include <algorithm>\nusing namespace std;\ntypedef pair<int, int> pii;\nint N;\nvector<int> tree;\nvoid updateTree(int node, int left, int right, int index, int diff){\nif(index < left || right < index) return;\ntree[node] += diff;\nif(left != right){\nint mid = (left + right) / 2;\nupdateTree(node * 2, left, mid, index, diff);\nupdateTree(node * 2 + 1, mid + 1, right, index, diff);\n}\n}\nint queryTree(int node, int left, int right, int start, int end){\nif(end < left || right < start) return 0;\nif(start <= left && right <= end) return tree[node];\nint mid = (left + right) / 2;\nreturn queryTree(node * 2, left, mid, start, end) + queryTree(node * 2 + 1, mid + 1, right, start, end);\n}\nint main(){\nios_base::sync_with_stdio(false);\ncin.tie(nullptr);\ncout.tie(nullptr);\ncin >> N;\nvector<pii> arr(N);\nfor(int i = 0; i < N; ++i){\narr[i].first = i;\ncin >> arr[i].second;\n}\nsort(arr.begin(), arr.end(), [](const auto &a, const auto &b){\nreturn a.second < b.second;\n});\nfor(int i = 0; i < N; ++i){\narr[i].second = i;\n}\nint treeHeight = ceil(log2(N));\nint treeSize = 1 << (treeHeight + 1);\ntree.resize(treeSize, 0);\nvector<pii> result(N);\nfor(int i = N - 1; i >= 0; --i){\nresult[i].first = arr[i].first;\nresult[i].second = queryTree(1, 0, N - 1, 0, arr[i].first - 1) + 1;\nupdateTree(1, 0, N - 1, arr[i].first, 1);\n}\nsort(result.begin(), result.end());\nfor(auto e : result){\ncout << e.second << \"\\n\";\n}\nreturn 0;\n}"
    },
    {
        "problem_tier": 11,
        "solution_code": "#include<iostream>\n#include<string>\n#include<vector>\n#include<algorithm>\nusing namespace std;\nint dist(string a, string b) {\nint ans = 0;\nfor (int i = 0; i < 4; i++) {\nif (a[i] != b[i])\nans++;\n}\nreturn ans;\n}\nint main() {\nios_base::sync_with_stdio(false);\ncin.tie(0);\nint t;\ncin >> t;\nfor (int i = 0; i < t; i++) {\nvector<string> v;\nint n;\ncin >> n;\nfor (int j = 0; j < n; j++) {\nstring str;\ncin >> str;\nv.push_back(str);\n}\nif (n > 32) {             cout << \"0\\n\";\ncontinue;\n}\nint real = 20;         for (int j = 0; j < n - 2; j++) {\nfor (int m = j + 1; m < n - 1; m++) {\nfor (int k = m + 1; k < n; k++) {\nreal = min(real, dist(v[j], v[m]) + dist(v[m], v[k]) + dist(v[j], v[k]));\n}\n}\n}\ncout << real << \"\\n\";\n}\nreturn 0;\n}"
    },
    {
        "problem_tier": 12,
        "solution_code": "#include <iostream>\n#include <vector>\n#include <queue>\nusing namespace std;\nconst int MAX = 1001;\nvector<int> adj[MAX];\nint inDeg[MAX];\nqueue<int> q;\nint result[MAX];\nint main() {\nint N, M;\ncin >> N >> M;\nint a, b;\nfor (int i = 0; i < M; i++) {\ncin >> a >> b;\nadj[a].push_back(b);\ninDeg[b]++;\n}\nfor (int i = 1; i <= N; i++) {\nif (inDeg[i] == 0) {\nq.push(i);\n}\nresult[i] = 1;     }\nwhile (!q.empty()) {\nint cur = q.front();\nq.pop();\nfor (int i = 0; i < adj[cur].size(); i++) {\nint next = adj[cur][i];\ninDeg[next]--;\nif (inDeg[next] == 0) {\nq.push(next);\nresult[next] = max(result[next], result[cur] + 1);\n}\n}\n}\nfor (int i = 1; i <= N; i++) {\ncout << result[i] << \" \";\n}\nreturn 0;\n}"
    },
    {
        "problem_tier": 5,
        "solution_code": "#include <iostream>\n#include <cstring>\nusing namespace std;\nint most_award(int arr[]) {\nint dice[7] = {0};     int count = 0;\nint a = 0;\nfor (int i = 0; i < 4; i++) {\ndice[arr[i]]++;\n}\nint max = arr[0];\nfor (int i = 1; i < 7; i++) {\nif (dice[i] == 4)\nreturn 50000 + (i * 5000);\nelse if (dice[i] == 3)\nreturn 10000 + (i * 1000);\nelse if (dice[i] == 2) {\nif (count == 1) {                 return 2000 + (a * 500) + (i * 500);\n}\na = i;             count++;\n} else {\nif (max < arr[i] && i <= 3)\nmax = arr[i];\n}\n}\nif (count == 1) {         return 1000 + (a * 100);\n} else {         return max * 100;\n}\n}\nint main() {\nint N;\nint result = 0, max = 0;\nint arr[5] = {0};\ncin >> N;\nfor (int i = 0; i < N; i++) {\nfor (int j = 0; j < 4; j++) {\ncin >> arr[j];\n}\nresult = most_award(arr);\nif (result > max)\nmax = result;\n}\ncout << max << '\\n';\nreturn 0;\n}"
    },
    {
        "problem_tier": 13,
        "solution_code": "#include <iostream>\nusing namespace std;\nconst int team1[] = {0,0,0,0,0,1,1,1,1,2,2,2,3,3,4};\nconst int team2[] = {1,2,3,4,5,2,3,4,5,3,4,5,4,5,5};\nint answer[4], match[6][3], result[6][3];\nvoid DFS(int tc, int round){\nif(round == 15){\nif(answer[tc])\nreturn;\nfor(int r=0; r<6; r++){\nfor(int c=0; c<3; c++){\nif(match[r][c] != result[r][c])\nreturn;\n}\n}\nanswer[tc] = 1;\nreturn;\n}\nint t1 = team1[round];\nint t2 = team2[round];\nresult[t1][0]++;\nresult[t2][2]++;\nDFS(tc, round+1);\nresult[t1][0]--;\nresult[t2][2]--;\nresult[t1][1]++;\nresult[t2][1]++;\nDFS(tc, round+1);\nresult[t1][1]--;\nresult[t2][1]--;\nresult[t1][2]++;\nresult[t2][0]++;\nDFS(tc, round+1);\nresult[t1][2]--;\nresult[t2][0]--;\n}\nint main(){\nios_base::sync_with_stdio(false);\ncin.tie(NULL);\ncout.tie(NULL);\nfor(int TC=0; TC<4; ++TC){\nfor(int r=0; r<6; ++r){\nfor(int c=0; c<3; c++){\ncin >> match[r][c];\n}\n}\nDFS(TC, 0);\n}\nfor(int i=0; i<4; i++) {\ncout << answer[i] << \" \";\n}\ncout << \"\\n\";\nreturn 0;\n}"
    },
    {
        "problem_tier": 6,
        "solution_code": "#include <iostream>\n#include <cstring>\nusing namespace std;\nstruct Paper {\nint N, x, y, w, h;\n};\nint arr[101][101] = {0};\nint ans[101];\nPaper one;\nvoid process() {\nint k = 1;\nwhile (k <= one.N) {\ncin >> one.x >> one.y >> one.w >> one.h;\nfor (int i = one.y; i < one.y + one.h; i++) {\nfor (int j = one.x; j < one.x + one.w; j++) {\nif (arr[i][j] == 0) {\nans[k] += 1;\narr[i][j] = k;\n} else {\nans[arr[i][j]] -= 1;\nans[k] += 1;\narr[i][j] = k;\n}\n}\n}\nk += 1;\n}\n}\nvoid outputAns() {\nfor (int i = 1; i <= one.N; i++) {\ncout << ans[i] << endl;\n}\n}\nint main() {\nmemset(ans, 0, sizeof(ans));\ncin >> one.N;\nprocess();\noutputAns();\nreturn 0;\n}"
    },
    {
        "problem_tier": 3,
        "solution_code": "#include <iostream>\nint main() {\nint n;\nstd::cin >> n;\nchar ch = '가' + n - 1;\nstd::cout << ch << std::endl;\nreturn 0;\n}"
    },
    {
        "problem_tier": 8,
        "solution_code": "#include<iostream>\nusing namespace std;\nlong long fibonacci(int n) {\nif (n == 0) return 0;\nif (n == 1) return 1;\nlong long fibo1 = 0;\nlong long fibo2 = 1;\nlong long fibo = 0;\nfor (int i = 2; i <= n; i++) {\nfibo = (fibo1 + fibo2) % 1000000007;\nfibo1 = fibo2;\nfibo2 = fibo;\n}\nreturn fibo;\n}\nint main() {\nint n;\ncin >> n;\ncout << fibonacci(n) << endl;\nreturn 0;\n}"
    },
    {
        "problem_tier": 5,
        "solution_code": "#include <iostream>\n#include <vector>\nusing namespace std;\nint main() {\nint N, C;\nint count = 0;\ncin >> N >> C;\nvector<int> student(N);\nfor (int i = 0; i < N; i++) {\ncin >> student[i];\n}\nvector<bool> time(C + 1);\nfor (int i = 0; i < N; i++) {\nfor (int j = 1; student[i] * j <= C; j++) {\nif (!time[student[i] * j]) {\ntime[student[i] * j] = true;\ncount++;\n}\n}\n}\ncout << count << endl;\nreturn 0;\n}"
    },
    {
        "problem_tier": 14,
        "solution_code": "#include<iostream>\n#include<algorithm>\nusing namespace std;\nint n, k;\nint arr[50001];\nint dp[4][50001];\nint main(){\ncin >> n;\nfor(int i=1; i<=n; i++){\nint tmp;\ncin >> tmp;\narr[i] = arr[i-1] + tmp;\n}\ncin >> k;\nfor(int i=1; i<=3; i++){\nfor(int j=i*k; j<=n; j++){\ndp[i][j] = max(dp[i][j-1], dp[i-1][j-k] + arr[j] - arr[j-k]);\n}\n}\ncout << dp[3][n] << endl;\nreturn 0;\n}"
    },
    {
        "problem_tier": 12,
        "solution_code": "#include <iostream>\n#include <vector>\n#include <algorithm>\nusing namespace std;\nint dice[10001][7];\nint front[7];\nint main() {\nint n, num;\nint ans = 0, sum = 0, maxN = 0, idx, std;\ncin >> n;\nfor (int i = 1; i <= n; i++) {\nfor (int j = 1; j <= 6; j++) {\ncin >> dice[i][j];\n}\n}\nfront[1] = 6;\nfront[2] = 4;\nfront[3] = 5;\nfront[4] = 2;\nfront[5] = 3;\nfront[6] = 1;\nfor (int i = 1; i <= 6; i++) {\nsum = 0;\nmaxN = 0;\nfor (int p = 1; p <= 6; p++) {\nif (p != dice[1][i] && p != dice[1][front[i]]) {\nmaxN = max(maxN, p);\n}\n}\nsum += maxN;\nstd = dice[1][i];\nfor (int j = 2; j <= n; j++) {\nmaxN = 0;\nfor (int x = 1; x <= 6; x++) {\nif (dice[j][x] == std) {\nidx = x;                     break;\n}\n}\nint top = dice[j][front[idx]];             int bottom = std;\nfor (int k = 1; k <= 6; k++) {\nif (k != top && k != bottom) {\nmaxN = max(maxN, k);                 }\n}\nsum += maxN;\nstd = top;\n}\nans = max(ans, sum);\nsum = 0;\n}\ncout << ans;\nreturn 0;\n}"
    },
    {
        "problem_tier": 10,
        "solution_code": "#include <iostream>\nusing namespace std;\nint dp[1005] = {0,};\nint main() {\nios_base::sync_with_stdio(0);\ncin.tie(0);\ncout.tie(0);\nint n;\ncin >> n;\ndp[1] = dp[3] = 0;\ndp[2] = dp[4] = dp[5] = 1;\nfor (int i = 6; i <= n; i++) {\nif (dp[i - 1] == 1 && dp[i - 3] == 1 && dp[i - 4] == 1)\ndp[i] = 0;\nelse\ndp[i] = 1;\n}\nif (dp[n] == 1)\ncout << \"SK\" << endl;\nelse\ncout << \"CY\" << endl;\nreturn 0;\n}"
    },
    {
        "problem_tier": 4,
        "solution_code": "#include<iostream>\n#include<algorithm>\nusing namespace std;\nint main() {\nint a[3], d, d2;\nfor(int i=0; i<3; i++)\ncin >> a[i];\nsort(a, a+3);\nd = a[1] - a[0];\nd2 = a[2] - a[1];\nif(d > d2)\ncout << a[0] + d2;\nelse if(d == d2)\ncout << a[2] + d;\nelse\ncout << a[1] + d;\nreturn 0;\n}"
    },
    {
        "problem_tier": 4,
        "solution_code": "#include <iostream>\n#include <vector>\n#include <algorithm>\nusing namespace std;\nvoid printFunc(vector<string> a) {\nint size = a.size();\nfor (int i = 0; i < size; i++) {\ncout << a[i];\nif (i != size - 1)\ncout << \"\\n\";\n}\n}\nint main() {\ncin.tie(NULL);\nios::sync_with_stdio(false);\nint n;\nint k;\ncin >> n;\nvector<string> mir(n);\nfor (int i = 0; i < n; i++) {\ncin >> mir[i];\n}\ncin >> k;\nif (k == 1) {\nprintFunc(mir);\n}\nelse if (k == 2) {\nfor (int i = 0; i < n; i++) {\nreverse(mir[i].begin(), mir[i].end());\n}\nprintFunc(mir);\n}\nelse {\nint cnt = 0;\nwhile (cnt < n / 2 + n % 2) {\nstring temp = mir[cnt];\nmir[cnt] = mir[n - cnt - 1];\nmir[n - cnt - 1] = temp;\ncnt++;\n}\nprintFunc(mir);\n}\nreturn 0;\n}"
    },
    {
        "problem_tier": 2,
        "solution_code": "#include <iostream>\n#include <algorithm>\n#include <vector>\nusing namespace std;\nint main() {\nios::sync_with_stdio(false);\ncin.tie(nullptr);\nint n;\nvector<int> v;\nfor (int i = 0; i < 3; i++) {\ncin >> n;\nv.push_back(n);\n}\nsort(v.begin(), v.end());\ncout << v[1] << \"\\n\";\nreturn 0;\n}"
    },
    {
        "problem_tier": 16,
        "solution_code": "#include <iostream>\n#include <queue>\n#define endl \"\\n\"\nusing namespace std;\nstruct step {\nint Rx, Ry;     int Bx, By;     int Count; };\nchar map[11][11];\nbool visit[11][11][11][11];\nint N, M;\nint dx[] = {1, -1, 0, 0};\nint dy[] = {0, 0, 1, -1};\nvoid move(int& rx, int& ry, int& distance, int& i) {\nwhile (map[rx + dx[i]][ry + dy[i]] != '#' && map[rx][ry] != 'O') {\nrx += dx[i];         ry += dy[i];         distance += 1;     }\n}\nvoid BFS(int Rx, int Ry, int Bx, int By) {\nqueue<step> q;\nq.push({Rx, Ry, Bx, By, 0});\nvisit[Rx][Ry][Rx][Ry] = true;\nwhile (!q.empty()) {\nint rx = q.front().Rx;\nint ry = q.front().Ry;\nint bx = q.front().Bx;\nint by = q.front().By;\nint count = q.front().Count;\nq.pop();\nif (count >= 10) break;\nfor (int i = 0; i < 4; i++) {\nint nrx = rx, nry = ry, nbx = bx, nby = by;\nint rc = 0, bc = 0, ncount = count + 1;\nmove(nrx, nry"
    },
    {
        "problem_tier": 5,
        "solution_code": "#include <iostream>\n#include <string>\nusing namespace std;\nint main() {\nint test;\ncin >> test;\nstring str;\nfor (int i = 0; i < test; i++) {\ncin >> str;\nint cnt = 0;\nint cnt1 = 0;\nint arr[10] = {0, };\nfor (int i = 0; i < str.length(); i++) {\ncnt = str[i] - '0';\narr[cnt]++;\n}\nfor (int i = 0; i <= 9; i++) {\nif (arr[i] != 0) {\ncnt1++;\n}\n}\ncout << cnt1 << \"\\n\";\n}\nreturn 0;\n}"
    },
    {
        "problem_tier": 6,
        "solution_code": "#include<iostream>\n#include<vector>\n#include<string>\n#include<sstream>\nusing namespace std;\nvector<int> split(string input, char delimiter){\nvector<int> answer;\nstringstream ss(input);\nstring temp;\nwhile(getline(ss, temp, delimiter)){\nanswer.push_back(stoi(temp));\n}\nreturn answer;\n}\nint main(){\nint n, k;\ncin >> n >> k;\nstring s;\ncin >> s;\nvector<int> v = split(s, ',');\nwhile(k--){\nvector<int> v2;\nfor(int i=0; i<v.size()-1; i++){\nv2.push_back(v[i+1] - v[i]);\n}\nv = v2;\n}\nfor(int i=0; i<v.size(); i++){\ncout << v[i];\nif(i != v.size()-1) cout << ',';\n}\nreturn 0;\n}"
    },
    {
        "problem_tier": 8,
        "solution_code": "#include <iostream>\n#include <deque>\nusing namespace std;\ndeque<int> dq;\nint main() {\ncin.tie(0);\ncout.tie(0);\nios::sync_with_stdio(false);\nint N, cmd, x;\ncin >> N;\nwhile (N--) {\ncin >> cmd;\nswitch (cmd) {\ncase 1:\ncin >> x;\ndq.push_front(x);\nbreak;\ncase 2:\ncin >> x;\ndq.push_back(x);\nbreak;\ncase 3:\nif (dq.empty()) {\ncout << -1 << \"\\n\";\n} else {\ncout << dq.front() << \"\\n\";\ndq.pop_front();\n}\nbreak;\ncase 4:\nif (dq.empty()) {\ncout << -1 << \"\\n\";\n} else {\ncout << dq.back() << \"\\n\";\ndq.pop_back();\n}\nbreak;\ncase 5:\ncout << dq.size() << \"\\n\";\nbreak;\ncase 6:\ndq.empty() ? cout << 1 << \"\\n\" : cout << 0 << \"\\n\";\nbreak;\ncase 7:\nif (dq.empty()) {\ncout << -1 << \"\\n\";\n} else {\ncout << dq.front() << \"\\n\";\n}\nbreak;\ncase 8:\nif (dq.empty()) {\ncout << -1 << \"\\n\";\n} else {\ncout << dq.back() << \"\\n\";\n}\nbreak;\n}\n}\nreturn 0;\n}"
    },
    {
        "problem_tier": 5,
        "solution_code": "#include <iostream>\nusing namespace std;\nint calculate(int number, int base) {\nint result = 0;\nwhile (number) {\nresult += number % base;\nnumber /= base;\n}\nreturn result;\n}\nint main() {\nios::sync_with_stdio(false);\ncin.tie(NULL);\ncout.tie(NULL);\nfor (int i = 1000; i < 10000; ++i) {\nint decimal = calculate(i, 10);\nif (decimal == calculate(i, 12) && decimal == calculate(i, 16)) {\ncout << i << '\\n';\n}\n}\nreturn 0;\n}"
    },
    {
        "problem_tier": 8,
        "solution_code": "#include <iostream>\n#include <string>\n#include <vector>\n#include <algorithm>\nusing namespace std;\nbool compare(const string& str1, const string& str2){\nif(str1.size() == str2.size())\nreturn str1 < str2;\nelse\nreturn str1.size() < str2.size();\n}\nint main(){\nios_base::sync_with_stdio(false);\ncin.tie(nullptr);\nint n;\nvector<string> strarr;\ncin >> n;\nfor(int k=0; k<n; k++){\nstring line;\ncin >> line;\nstring temp = \"\";\nbool flag = false;\nfor(int i=0; i<line.length(); i++){\nif(line[i] >= '0' && line[i] <= '9'){\ntemp += line[i];\nflag = true;\n}\nelse{\nif(flag){\nwhile(true){\nif(temp.length() > 1 && temp[0] == '0')\ntemp = temp.substr(1, temp.length() - 1);\nelse\nbreak;\n}\nstrarr.push_back(temp);\n}\nflag = false;\ntemp = \"\";\n}\n}\nif(flag){\nwhile(true){\nif(temp.length() > 1 && temp[0] == '0')\ntemp = temp.substr(1, temp.length() - 1);\nelse\nbreak;\n}\nstrarr.push_back(temp);\n}\n}\nsort(strarr.begin(), strarr.end(), compare);\nfor(int i=0; i<strarr.size(); i++){\ncout << strarr[i] << endl;\n}\nreturn 0;\n}"
    },
    {
        "problem_tier": 15,
        "solution_code": "#include <iostream>\n#include <vector>\n#include <algorithm>\nusing namespace std;\nvector<pair<int, int>> v(1010);\nint work[1010];\nbool finish[1010];\nbool DFS(int x){\nint size = v[x].second - v[x].first + 1;\nfor(int i=0; i<size; ++i){\nint t = v[x].first + i;\nif(finish[t]){\ncontinue;\n}\nfinish[t] = true;\nif(work[t] == 0 || DFS(work[t])){\nwork[t] = x;\nreturn true;\n}\n}\nreturn false;\n}\nint main(int argc, char* argv[]){\nint t;\nint n, m;\nint start, end;\nint count;\ncin >> t;\nwhile(t--){\ncount = 0;\ncin >> n >> m;\nv.clear();\nv.push_back({0,0});\nfor(int i=1; i<=m; ++i){\ncin >> start;\ncin >> end;\nv.push_back({start, end});\n}\nfill(work, work + 1010, 0);\nfor(int i=1; i<=m; ++i){\nfill(finish, finish + 1010, false);\nif(DFS(i)){\n++count;\n}\n}\ncout << count << endl;\n}\nreturn 0;\n}"
    },
    {
        "problem_tier": 4,
        "solution_code": "#include <iostream>\nusing namespace std;\nint main() {\nwhile (true) {\nint a, b, c;\ncin >> a >> b >> c;\nif (a == 0 && b == 0 && c == 0)\nbreak;\nif (b - a == c - b && b - a != 0)\ncout << \"AP \" << c + (b - a) << '\\n';\nelse\ncout << \"GP \" << c * (b / a) << '\\n';\n}\nreturn 0;\n}"
    },
    {
        "problem_tier": 11,
        "solution_code": "#include<iostream>\nusing namespace std;\nint dx[4] = {0, 0, -1, 1};\nint dy[4] = {1, -1, 0, 0};\nint m, n, k;\nint map[5][5];\nint visited[5][5];\nint cnt;\nvoid dfs(int y, int x, int dis) {\nif (x == n-1 && y == 0 && dis == k) {\ncnt++;\nreturn;\n}\nfor (int i = 0; i < 4; i++) {\nint nx = x + dx[i];\nint ny = y + dy[i];\nif (nx < 0 || nx >= n || ny < 0 || ny >= m)\ncontinue;\nif (visited[ny][nx] || map[nx][ny])\ncontinue;\nvisited[ny][nx] = 1;\ndfs(ny, nx, dis+1);\nvisited[ny][nx] = 0;\n}\n}\nint main() {\ncin >> m >> n >> k;\nfor (int i = 0; i < m; i++) {\nstring s;\ncin >> s;\nfor (int j = 0; j < n; j++) {\nif (s[j] == 'T')\nmap[i][j] = 1;\n}\n}\nvisited[m-1][0] = 1;\ndfs(m-1, 0, 1);\ncout << cnt;\nreturn 0;\n}"
    },
    {
        "problem_tier": 6,
        "solution_code": "#include<iostream>\n#include<algorithm>\n#include<cstring>\n#include<string>\nusing namespace std;\nint main(int argc, char* argv[]) {\nint x, y;\nchar map[40][40];\nstring s1, s2;\nmemset(map, '.', sizeof(map));\ncin >> s1;\ncin >> s2;\nfor(int i=0; i<s1.length(); ++i){\nif(s2.find(s1[i]) <= s2.length()){\nx = s2.find(s1[i]);\ny = i;\nbreak;\n}\n}\nfor(int i=0; i<s2.length(); ++i){\nfor(int j=0; j<s1.length(); ++j){\nif(x == i){\nmap[i][j] = s1[j];\n}\nif(y == j){\nmap[i][j] = s2[i];\n}\ncout << map[i][j];\n}\ncout << endl;\n}\nreturn 0;\n}"
    },
    {
        "problem_tier": 17,
        "solution_code": "#include <iostream>\n#include <vector>\n#include <queue>\n#define MAX 10001\nusing namespace std;\nclass Edge{\npublic:\nint node;\nint time;\nEdge(int node, int time){\nthis->node = node;\nthis->time = time;\n}\n};\nint n, start, finish;\nint inDegree[MAX], result[MAX], c[MAX]; vector<Edge> a[MAX];\nvector<Edge> b[MAX];\nvoid topology(){\nqueue<int> q;\nq.push(start);\nwhile(!q.empty()){\nint x = q.front();\nq.pop();\nfor(int i=0;i<a[x].size();i++){\nEdge y = Edge(a[x][i].node, a[x][i].time);\nif(result[y.node] <= y.time + result[x]){\nresult[y.node] = y.time + result[x];\n}\nif(--inDegree[y.node] == 0){\nq.push(y.node);\n}\n}\n}\nint count = 0;\nq.push(finish);\nwhile(!q.empty()){\nint y = q.front();\nq.pop();\nfor(int i=0;i<b[y].size();i++){\nEdge x = Edge(b[y][i].node, b[y][i].time);\nif(result[y] - result[x.node] == x.time){\ncount++;\nif(c[x.node] == 0){\nq.push(x.node);\nc[x.node] = 1;\n}\n}\n}\n}\nprintf(\"%d\\n%d\", result[finish], count);\n}\nint main(){\nint m;\nscanf(\"%d%d\", &n, &m);\nfor(int i=0;i<m;i++){\nint x, node, time;\nscanf(\"%d%d%d\", &x, &node, &time);\na[x].push_back(Edge(node,time));\nb[node].push_back(Edge(x,time));\ninDegree[node]++;\n}\nscanf(\"%d%d\", &start, &finish);\ntopology();\nreturn 0;\n}"
    },
    {
        "problem_tier": 12,
        "solution_code": "#include<iostream>\n#include<algorithm>\nusing namespace std;\nint main(){\nunsigned long long n, m;\nunsigned long long t[100001];\ncin >> n >> m;\nfor (int i = 0; i < n; i++){\ncin >> t[i];\n}\nsort(t, t + n);\nunsigned long long high = m * t[n-1];\nunsigned long long low = 1;\nunsigned long long mid;\nunsigned long long ans = 0;\nunsigned long long people;\nwhile(high >= low){\npeople = 0;\nmid = (high + low) / 2;\nfor (int i = 0; i < n; i++){\npeople += mid / t[i];\n}\nif(people >= m){\nif(ans > mid || ans == 0){\nans = mid;\n}\nhigh = mid - 1;\n}\nelse{\nlow = mid + 1;\n}\n}\ncout << ans;\nreturn 0;\n}"
    },
    {
        "problem_tier": 6,
        "solution_code": "#include <iostream>\n#include <string>\nusing namespace std;\nint main() {\nstring sentence;\ngetline(cin, sentence);\nstring happy = \":-)\";\nstring sad = \":-(\";\nstring temp;\nint happyN = 0, sadN = 0;\nfor (int i = 0; i < sentence.length() - 2; i++) {\ntemp = sentence.substr(i, 3);\nif (temp == happy)\nhappyN++;\nelse if (temp == sad)\nsadN++;\n}\nif (happyN == 0 && sadN == 0)\ncout << \"none\";\nelse if (happyN == sadN)\ncout << \"unsure\";\nelse if (happyN > sadN)\ncout << \"happy\";\nelse\ncout << \"sad\";\nreturn 0;\n}"
    },
    {
        "problem_tier": 16,
        "solution_code": "#include <iostream>\n#include <queue>\n#include <unordered_set>\nusing namespace std;\nusing ll = long long;\npriority_queue<ll> Q;\nunordered_set<ll> S;\nll k, n, m, a[101];\nint main() {\ncin >> k >> n;\nQ.push(-1);\nfor (ll i{}; i < k; cin >> a[i++]);\nwhile (n--) {\nll t(-Q.top());\nQ.pop();\nfor (ll i{}; i < k; i++) {\nll x = t * a[i];\nif (!S.count(x) && (!(Q.size() > n && x >= m))) {\nQ.push(-x);\nS.insert(x);\nm = max(m, x);\n}\n}\n}\ncout << -Q.top();\nreturn 0;\n}"
    },
    {
        "problem_tier": 17,
        "solution_code": "#include <iostream>\n#include <cstring>\n#define MOD 1000000007\nusing namespace std;\nint N, L, R;\nlong long dp[101][101][101];\nlong long solve() {\nmemset(dp, 0, sizeof(dp));\ndp[1][1][1] = 1;\nfor (int n = 2; n <= N; n++) {\nfor (int l = 1; l <= N; l++) {\nfor (int r = 1; r <= N; r++) {\ndp[n][l][r] = (dp[n-1][l-1][r] + dp[n-1][l][r-1] + dp[n-1][l][r] * (n-2)) % MOD;\n}\n}\n}\nreturn dp[N][L][R];\n}\nint main() {\ncin >> N >> L >> R;\ncout << solve() << endl;\nreturn 0;\n}"
    },
    {
        "problem_tier": 4,
        "solution_code": "#include <iostream>\nusing namespace std;\nint main() {\nint t;\ncin >> t;\nwhile (t--) {\nint n;\nint cnt = 0;\ncin >> n;\ncout << \"Pairs for \" << n << \": \";\nfor (int i = 1; i <= 12; i++) {\nfor (int j = 1; j <= 12; j++) {\nif (i + j == n && i < j) {\nif (!cnt) {\ncnt++;\ncout << i << ' ' << j;\n} else {\ncout << \", \" << i << ' ' << j;\n}\n}\n}\n}\ncout << '\\n';\n}\nreturn 0;\n}"
    },
    {
        "problem_tier": 16,
        "solution_code": "#include <iostream>\n#include <vector>\nusing namespace std;\ntypedef long long ll;\nvector<ll> arr;\nvector<ll> tree;\nll init_tree(int node, int start, int end) {\nif (start == end) {\nreturn tree[node] = arr[start];\n}\nint mid = (start + end) / 2;\nll left_sum = init_tree(node * 2, start, mid);\nll right_sum = init_tree(node * 2 + 1, mid + 1, end);\nreturn tree[node] = left_sum + right_sum;\n}\nll query(int node, int start, int end, int left, int right) {\nif (end < left || start > right) {\nreturn 0;\n}\nif (left <= start && end <= right) {\nreturn tree[node];\n}\nint mid = (start + end) / 2;\nll left_sum = query(node * 2, start, mid, left, right);\nll right_sum = query(node * 2 + 1, mid + 1, end, left, right);\nreturn left_sum + right_sum;\n}\nvoid update(int node, int start, int end, int index, ll diff) {\nif (index < start || index > end) {\nreturn;\n}\ntree[node] += diff;\nif (start == end) {\nreturn;\n}\nint mid = (start + end) / 2;\nupdate(node * 2, start, mid, index, diff);\nupdate(node * 2 + 1, mid + 1, end, index, diff);\n}\nint main() {\nint n, m;\ncin >> n >> m;\narr.resize(n);\ntree.resize(n * 4);\nfor (int i = 0; i < n; i++) {\narr[i] = 0;\n}\ninit_tree(1, 0, n - 1);\nfor (int i = 0; i < m; i++) {\nint op, a, b;\ncin >> op >> a >> b;\nif (op == 0) {\nif (a > b) {\nswap(a, b);\n}\ncout << query(1, 0, n - 1, a - 1, b - 1) << '\\n';\n} else {\nll diff = b - arr[a - 1];\narr[a - 1] = b;\nupdate(1, 0, n - 1, a - 1, diff);\n}\n}\nreturn 0;\n}"
    },
    {
        "problem_tier": 5,
        "solution_code": "#include <iostream>\n#include <string>\nusing namespace std;\nint main() {\nint n, m;\ncin >> n >> m;\nstring str = \"\";\nfor(int i=0; i<n; i++) {\nstr = str + to_string(n);\n}\nif(str.length() > m) {\ncout << str.substr(0, m);\n} else {\ncout << str;\n}\nreturn 0;\n}"
    },
    {
        "problem_tier": 12,
        "solution_code": "#include <iostream>\n#include <vector>\n#include <algorithm>\n#include <cstring>\nusing namespace std;\nstruct info {\nint x;     int y;     int num;     char dir; };\nint A, B;\nint N, M;\ninfo robot[101]; int map[101][101]; bool check;\nvoid crash_wall(int num) {\ncout << \"Robot\" << num << \" crashes into the wall\";\nreturn;\n}\nvoid crash_robot(int num1, int num2) {\ncout << \"Robot\" << num1 << \" crashes into robot\" << num2;\nreturn;\n}\nvoid success() {\ncout << \"OK\";\nreturn;\n}\nvoid left(info& r) {\nif (r.dir == 'N') {\nr.dir = 'W';\n}\nelse if (r.dir == 'W') {\nr.dir = 'S';\n}\nelse if (r.dir == 'S') {\nr.dir = 'E';\n}\nelse if (r.dir == 'E') {\nr.dir = 'N';\n}\nreturn;\n}\nvoid right(info& r) {\nif (r.dir == 'N') {\nr.dir = 'E';\n}\nelse if (r.dir == 'W') {\nr.dir = 'N';\n}\nelse if (r.dir == 'S') {\nr.dir = 'W';\n}\nelse if (r.dir == 'E') {\nr.dir = 'S';\n}\nreturn;\n}\nvoid front(info& r) {\nif (r.dir == 'N') {\nr.y += 1;\nif (r.y > B) {\ncrash_wall(r.num);\ncheck = false;\nreturn;\n}\nelse {\nif (map[r.x][r.y] != 0) {\ncrash_robot(r.num, map[r.x][r.y]);\ncheck = false;\nreturn;\n}\nelse {\nmap[r.x][r.y] = r.num;\nmap[r.x][r.y - 1] = 0;\n}\n}\n}\nelse if (r.dir == 'W') {\nr.x -= 1;\nif (r.x < 1) {\ncrash_wall(r.num);\ncheck = false;\nreturn;\n}\nelse {\nif (map[r.x][r.y] != 0) {\ncrash_robot(r.num, map[r.x][r.y]);\ncheck = false;\nreturn;\n}\nelse {\nmap[r.x][r.y] = r.num;\nmap[r.x + 1][r.y] = 0;\n}\n}\n}\nelse if (r.dir == 'S') {\nr.y -= 1;\nif (r.y < 1) {\ncrash_wall(r.num);\ncheck = false;\nreturn;\n}\nelse {\nif (map[r.x][r.y] != 0) {\ncrash_robot(r.num, map[r.x][r.y]);\ncheck = false;\nreturn;\n}\nelse {\nmap[r.x][r.y] = r.num;\nmap[r.x][r.y + 1] = 0;\n}\n}\n}\nelse if (r.dir == 'E') {\nr.x += 1;\nif (r.x > A) {\ncrash_wall(r.num);\ncheck = false;\nreturn;\n}\nelse {\nif (map[r.x][r.y] != 0) {\ncrash_robot(r.num, map[r.x][r.y]);\ncheck = false;\nreturn;\n}\nelse {\nmap[r.x][r.y] = r.num;\nmap[r.x - 1][r.y] = 0;\n}\n}\n}\n}\nint main() {\nios::sync_with_stdio(false);\ncin.tie(NULL);\ncout.tie(NULL);\ncin >> A >> B;\ncin >> N >> M;\nmemset(map, 0, sizeof(map));\nfor (int i = 1; i <= N; i++) {\nint x, y;\nchar dir;\ncin >> x >> y >> dir;\nrobot[i].x = x;\nrobot[i].y = y;\nrobot[i].dir = dir;\nrobot[i].num = i;\nmap[x][y] = i;\n}\ncheck = true;\nfor (int i = 1; i <= M; i++) {\nif (!check)\nbreak;\nint num;\nchar command;\nint repeat;\ncin >> num >> command >> repeat;\nif (command == 'L') {\nwhile (repeat--) {\nif (!check)\nbreak;\nleft(robot[num]);\n}\n}\nelse if (command == 'R') {\nwhile (repeat--) {\nif (!check)\nbreak;\nright(robot[num]);\n}\n}\nelse if (command == 'F') {\nwhile (repeat--) {\nif (!check)\nbreak;\nfront(robot[num]);\n}\n}\n}\nif (check)\nsuccess();\nreturn 0;\n}"
    },
    {
        "problem_tier": 4,
        "solution_code": "#include <iostream>\n#include <algorithm>\nusing namespace std;\nint main() {\ndouble a[5];\ndouble ans[4];\nfor (int i = 1; i <= 4; i++)\ncin >> a[i];\nans[0] = a[1] / a[3] + a[2] / a[4];\nans[1] = a[3] / a[4] + a[1] / a[2];\nans[2] = a[4] / a[2] + a[3] / a[1];\nans[3] = a[2] / a[1] + a[4] / a[3];\ndouble rot = 0;\nint mini = 10;\nfor (int i = 0; i < 4; i++) {\nif (rot < ans[i])\nrot = ans[i];\n}\nfor (int i = 0; i < 4; i++) {\nif (rot == ans[i])\nmini = min(mini, i);\n}\ncout << mini << '\\n';\nreturn 0;\n}"
    },
    {
        "problem_tier": 14,
        "solution_code": "#include<iostream>\n#include<queue>\n#include<vector>\nusing namespace std;\n#define endl \"\\n\"\n#define MAX 8\nchar MAP[MAX][MAX];\nchar Wall_MAP[MAX][MAX][MAX];\nvector<pair<int, int>> Wall_V;\nint dx[] = { -1, -1, -1, 0, 0, 1, 1, 1, 0 };\nint dy[] = { -1, 0, 1, -1, 1, -1, 0, 1, 0 };\nvoid Input() {\nfor (int i = 0; i < MAX; i++) {\nfor (int j = 0; j < MAX; j++) {\ncin >> MAP[i][j];\nif (MAP[i][j] == '#') {\nWall_MAP[0][i][j] = '#';\nWall_V.push_back(make_pair(i, j));\n}\n}\n}\nfor (int t = 0; t < MAX; t++) {\nfor (int i = 0; i < MAX; i++) {\nfor (int j = 0; j < MAX; j++) {\nif (Wall_MAP[t][i][j] == '#') continue;\nWall_MAP[t][i][j] = '.';\n}\n}\n}\n}\nvoid Make_Wall_MAP() {\nfor (int i = 0; i < Wall_V.size(); i++) {\nint x = Wall_V[i].first;\nint y = Wall_V[i].second;\nint Time = 1;\nwhile (1) {\nint nx = x + 1;\nint ny = y;\nif (nx >= MAX) break;\nWall_MAP[Time][nx][ny] = '#';\nTime++;\nx = nx;\ny = ny;\n}\n}\n}\nbool Can_Finish(int x, int T) {\nfor (int i = x - 1; i >= 0; i--) {\nfor (int j = 0; j < MAX; j++) {\nif (Wall_MAP[T][i][j] == '#') return false;\n}\n}\nreturn true;\n}\nint BFS(int a, int b) {\nqueue<pair<pair<int, int>, int>> Q;\nQ.push(make_pair(make_pair(a, b), 0));\nwhile (!Q.empty()) {\nint x = Q.front().first.first;\nint y = Q.front().first.second;\nint t = Q.front().second;\nQ.pop();\nif (x == 0) return 1;\nelse {\nif (Can_Finish(x, t) == true) return 1;\n}\nfor (int i = 0; i < 9; i++) {\nint nx = x + dx[i];\nint ny = y + dy[i];\nint nt = t + 1;\nif (nx >= 0 && ny >= 0 && nx < MAX && ny < MAX) {\nif (Wall_MAP[nt][nx][ny] == '.' && Wall_MAP[t][nx][ny] == '.') {\nQ.push(make_pair(make_pair(nx, ny), nt));\n}\n}\n}\n}\nreturn 0;\n}\nbool Wall_State() {\nfor (int i = 0; i < 7; i++) {\nint Cnt = 0;\nfor (int j = 0; j < MAX; j++) {\nif (MAP[i][j] == '#') Cnt++;\n}\nif (Cnt == 8) return false;\n}\nreturn true;\n}\nvoid Solution() {\nif (Wall_V[0].size() == 0) {\ncout << 1 << endl;\nreturn;\n}\nif (Wall_State() == false) {\ncout << 0 << endl;\nreturn;\n}\nMake_Wall_MAP();\ncout << BFS(7, 0) << endl;\n}\nvoid Solve() {\nInput();\nSolution();\n}\nint main(void) {\nios::sync_with_stdio(false);\ncin.tie(NULL);\ncout.tie(NULL);\nSolve();\nreturn 0;\n}"
    },
    {
        "problem_tier": 4,
        "solution_code": "#include<iostream>\nusing namespace std;\nint main() {\nint t;\ncin >> t;\nwhile (t--) {\nint n;\nint p1cnt = 0;\nint p2cnt = 0;\ncin >> n;\nwhile (n--) {\nchar p1, p2;\ncin >> p1 >> p2;\nif (p1 == 'R') {\nif (p2 == 'R') {\np1cnt++;\np2cnt++;\n}\nelse if (p2 == 'P') {\np2cnt++;\n}\nelse if (p2 == 'S') {\np1cnt++;\n}\n}\nelse if (p1 == 'P') {\nif (p2 == 'R') {\np1cnt++;\n}\nelse if (p2 == 'P') {\np1cnt++;\np2cnt++;\n}\nelse if (p2 == 'S') {\np2cnt++;\n}\n}\nelse if (p1 == 'S') {\nif (p2 == 'R') {\np2cnt++;\n}\nelse if (p2 == 'P') {\np1cnt++;\n}\nelse if (p2 == 'S') {\np1cnt++;\np2cnt++;\n}\n}\n}\nif (p1cnt > p2cnt) {\ncout << \"Player 1\" << '\\n';\n}\nelse if (p1cnt < p2cnt) {\ncout << \"Player 2\" << '\\n';\n}\nelse {\ncout << \"TIE\" << '\\n';\n}\n}\nreturn 0;\n}"
    },
    {
        "problem_tier": 11,
        "solution_code": "#include<iostream>\n#include<string>\nusing namespace std;\nint main(){\nstring L, R;\nint answer = 0;\ncin >> L >> R;\nif(L.size() != R.size()){\nanswer = 0;\n}\nelse{\nstring substr = \"\";\nfor(int i=0; i<L.size(); i++){\nif(L[i] == R[i]){\nsubstr += L[i];\n}\nelse\nbreak;\n}\nfor(int i=0; i<substr.size(); i++){\nif(substr[i] == '8'){\nanswer++;\n}\n}\n}\ncout << answer;\nreturn 0;\n}"
    },
    {
        "problem_tier": 2,
        "solution_code": "#include <iostream>\nusing namespace std;\nint main() {\nint n;\ncin >> n;\ncout << (n + 1) * 2 << \" \" << (n + 1) * 3;\nreturn 0;\n}"
    },
    {
        "problem_tier": 4,
        "solution_code": "#include<iostream>\nusing namespace std;\nint main(){\nint n, a, b, c;\ncin >> n;\nfor(int i=1; i<=n; i++){\ncin >> a >> b >> c;\nint sum = a*a + b*b + c*c;\nint ma = max(a, max(b, c));\nif(sum == 2*ma*ma){\nprintf(\"Scenario #%d:\\n\", i);\nprintf(\"yes\\n\\n\");\n}\nelse{\nprintf(\"Scenario #%d:\\n\", i);\nprintf(\"no\\n\\n\");\n}\n}\nreturn 0;\n}"
    },
    {
        "problem_tier": 3,
        "solution_code": "#include <bits/stdc++.h>\nusing namespace std;\nint main() {\nint n, m;\ncin >> n >> m;\ncout << min(n / 2, m / 2);\nreturn 0;\n}"
    },
    {
        "problem_tier": 4,
        "solution_code": "#include <iostream>\nusing namespace std;\nint main() {\nint c, k, p;\ncin >> c >> k >> p;\nint sum = 0;\nfor (int i = 1; i <= c; i++) {\nsum += (k * i) + (p * i * i);\n}\ncout << sum;\nreturn 0;\n}"
    },
    {
        "problem_tier": 13,
        "solution_code": "#include <iostream>\n#include <algorithm>\n#include <vector>\n#include <limits.h>\nusing namespace std;\nint n;\nvector<vector<vector<int>>> graph;\nvoid attack(int one, int two, int three, int depth);\nint ans = INT_MAX;\nint main() {\ncin >> n;\nint scv[n] = { 0, 0, 0 };\ngraph.resize(61, vector<vector<int>>(61, vector<int>(61, 0)));\nfor (int i = 0; i < n; i++) {\ncin >> scv[i];\n}\nattack(scv[0], scv[1], scv[2], 0);\ncout << ans;\nreturn 0;\n}"
    },
    {
        "problem_tier": 10,
        "solution_code": "#include <iostream>\n#include <queue>\nusing namespace std;\nint N, M;\nconst int MAX = 1001;\nint map[MAX][MAX];\nbool visited[MAX][MAX];\nint dy[] = { 0,0,-1,1 };\nint dx[] = { -1,1,0,0 };\nqueue<pair<int, int>> q;\nvoid BFS(int y, int x) {\nvisited[y][x] = true;\nq.push(make_pair(y, x));\nwhile (!q.empty()) {\ny = q.front().first;\nx = q.front().second;\nq.pop();\nfor (int i = 0; i < 4; i++) {\nint ny = y + dy[i];\nint nx = x + dx[i];\nif (ny < 0 || nx < 0 || ny >= M || nx >= N)\ncontinue;\nif (map[ny][nx] == 0 && !visited[ny][nx]) {\nvisited[ny][nx] = true;\nq.push(make_pair(ny, nx));\n}\n}\n}\n}\nint main() {\ncin >> M >> N;\nfor (int i = 0; i < M; i++) {\nfor (int j = 0; j < N; j++) {\nscanf(\"%1d\", &map[i][j]);\n}\n}\nfor (int j = 0; j < N; j++) {\nif (map[0][j] == 0 && !visited[0][j]) {\nBFS(0, j);\n}\n}\nbool flag = false;\nfor (int j = 0; j < N; j++) {\nif (visited[M - 1][j]) {\nflag = true;\n}\n}\nif (flag == true)\ncout << \"YES\";\nelse\ncout << \"NO\";\nreturn 0;\n}"
    },
    {
        "problem_tier": 3,
        "solution_code": "#include<iostream>\nusing namespace std;\nint main(){\nint a, b;\ncin >> a;\ncin >> b;\nif(a >= 3 && b <= 4){\ncout << \"TroyMartian\\n\";\n}\nif(a <= 6 && b >= 2){\ncout << \"VladSaturnian\\n\";\n}\nif(a <= 2 && b <= 3){\ncout << \"GraemeMercurian\\n\";\n}\nreturn 0;\n}"
    },
    {
        "problem_tier": 4,
        "solution_code": "#include <iostream>\nusing namespace std;\nint main() {\nint n, t, ans = 0;\nint wtime = 0;\ncin >> n >> t;\nwhile (n--) {\nint work;\ncin >> work;\nwtime += work;\nif (wtime <= t) {\nans++;\n}\n}\ncout << ans << '\\n';\nreturn 0;\n}"
    },
    {
        "problem_tier": 8,
        "solution_code": "#include <iostream>\n#include <algorithm>\nusing namespace std;\nint main() {\nint n, x, y;\ncin >> n >> x >> y;\nint ans = 0;\nfor (int i = y + 1; i < n; i += y + 1) {\nint left = max(0, x - (i + 1) / 2);\nint right = min(n - 1, x + (i + 1) / 2);\nans += max(0, right - left + 1);\n}\ncout << ans << endl;\nreturn 0;\n}"
    },
    {
        "problem_tier": 14,
        "solution_code": "#include <iostream>\n#include <vector>\nusing namespace std;\nint N, M;\nint board[4][4];\nbool isHorizontal(int r, int c, int mask) {\nint idx = r * M + c;\nreturn ((1 << idx) & mask) != 0;\n}\nint calcSum(int mask) {\nint ret = 0;\nvector<vector<bool>> visit(N, vector<bool>(M, 0));\nfor (int i = 0; i < N * M; i++) {\nint r = i / M;\nint c = i % M;\nint nr = r;\nint nc = c;\nint sum = 0;\nwhile (nr < N && nc < M && !visit[nr][nc] && isHorizontal(r, c, mask) == isHorizontal(nr, nc, mask)) {\nsum *= 10;\nsum += board[nr][nc];\nvisit[nr][nc] = true;\nif (isHorizontal(r, c, mask))\nnc++;\nelse\nnr++;\n}\nret += sum;\n}\nreturn ret;\n}\nint optimize() {\nint ret = 0;\nfor (int i = 0; i < (1 << N * M); i++) {\nret = max(ret, calcSum(i));\n}\nreturn ret;\n}\nint main() {\nios_base::sync_with_stdio(false);\ncin.tie(NULL);\ncout.tie(NULL);\ncin >> N >> M;\nfor (int i = 0; i < N; i++) {\nstring temp;\ncin >> temp;\nfor (int j = 0; j < M; j++) {\nboard[i][j] = temp[j] - '0';\n}\n}\ncout << optimize();\nreturn 0;\n}"
    },
    {
        "problem_tier": 3,
        "solution_code": "#include <iostream>\nusing namespace std;\nint main() {\nint y1, m1, d1;     int y2, m2, d2;     cin >> y1 >> m1 >> d1;\ncin >> y2 >> m2 >> d2;\nint year1, year2, year3;\nyear1 = y2 - y1;\nif (m2 < m1 || (m2 == m1 && d2 < d1)) {\nyear1 -= 1;     }\nyear2 = year1 + 1;     year3 = year1;\ncout << year1 << '\\n' << year2 << '\\n' << year3 << '\\n';\nreturn 0;\n}"
    },
    {
        "problem_tier": 15,
        "solution_code": "#include <iostream>\n#include <vector>\nusing namespace std;\n#define INF 1e9\n#define MAX 101\nint map[MAX][MAX];\nint nxt[MAX][MAX];\nvoid FloydWarshall(int n) {\nfor (int k = 1; k <= n; k++) {\nfor (int i = 1; i <= n; i++) {\nfor (int j = 1; j <= n; j++) {\nif (map[i][j] > map[i][k] + map[k][j]) {\nmap[i][j] = map[i][k] + map[k][j];\nnxt[i][j] = nxt[i][k];\n}\n}\n}\n}\n}\nvector<int> findPath(int start, int end) {\nvector<int> path;\nint current = start;\nwhile (current != end) {\npath.push_back(current);\ncurrent = nxt[current][end];\n}\npath.push_back(current);\nreturn path;\n}\nint main() {\nios_base::sync_with_stdio(0);\ncin.tie(0);\nint n, m;\ncin >> n >> m;\nfor (int i = 1; i <= n; i++) {\nfor (int j = 1; j <= n; j++) {\nif (i == j) {\nmap[i][j] = 0;\nnxt[i][j] = i;\n}\nelse {\nmap[i][j] = INF;\nnxt[i][j] = 0;\n}\n}\n}\nfor (int i = 0; i < m; i++) {\nint a, b, c;\ncin >> a >> b >> c;\nif (map[a][b] > c) {\nmap[a][b] = c;\nnxt[a][b] = b;\n}\n}\nFloydWarshall(n);\nfor (int i = 1; i <= n; i++) {\nfor (int j = 1; j <= n; j++) {\nif (map[i][j] == INF) {\ncout << \"0 \";\n}\nelse {\ncout << map[i][j] << \" \";\n}\n}\ncout << endl;\n}\nfor (int i = 1; i <= n; i++) {\nfor (int j = 1; j <= n; j++) {\nif (i != j) {\nvector<int> path = findPath(i, j);\ncout << path.size() << \" \";\nfor (int p : path) {\ncout << p << \" \";\n}\n}\nelse {\ncout << \"0\";\n}\ncout << endl;\n}\n}\nreturn 0;\n}"
    },
    {
        "problem_tier": 6,
        "solution_code": "#include <iostream>\n#include <string>\nusing namespace std;\nbool isPossible(string num) {\nfor (int pivot = 1; pivot < num.size(); pivot++) {\nlong long left = 1, right = 1;\nfor (int i = 0; i < pivot; i++) {\nleft *= num[i] - '0';\n}\nfor (int i = pivot; i < num.size(); i++) {\nright *= num[i] - '0';\n}\nif (left == right) {\nreturn true;\n}\n}\nreturn false;\n}\nint main() {\nstring num;\ncin >> num;\nif (isPossible(num)) {\ncout << \"YES\" << endl;\n} else {\ncout << \"NO\" << endl;\n}\nreturn 0;\n}"
    },
    {
        "problem_tier": 12,
        "solution_code": "#include <iostream>\n#include <string>\n#include <vector>\n#include <algorithm>\nusing namespace std;\nint testcase;\nint num;\nvector<string> ans;\nvoid solve(int target, int sum, int sign, int prev, int idx, string expression) {\nif (idx == target) {\nsum += (prev * sign);\nif (sum == 0) {\nans.push_back(expression);\n}\nreturn;\n} else {\nsolve(target, sum + (prev * sign), 1, idx + 1, idx + 1, expression + '+' + to_string(idx + 1));\nsolve(target, sum + (prev * sign), -1, idx + 1, idx + 1, expression + '-' + to_string(idx + 1));\nsolve(target, sum, sign, prev * 10 + (idx + 1), idx + 1, expression + ' ' + to_string(idx + 1));\n}\n}\nint main() {\ncin >> testcase;\nwhile (testcase--) {\ncin >> num;\nsolve(num, 0, 1, 1, 1, \"1\");\nsort(ans.begin(), ans.end());\nfor (int i = 0; i < ans.size(); i++) {\ncout << ans[i] << endl;\n}\ncout << endl;\nans.clear();\n}\nreturn 0;\n}"
    },
    {
        "problem_tier": 3,
        "solution_code": "#include <iostream>\n#include <algorithm>\nusing namespace std;\nint main() {\nint chicken, coke, beer;\ncin >> chicken >> coke >> beer;\ncout << min(chicken, coke / 2 + beer);\nreturn 0;\n}"
    },
    {
        "problem_tier": 11,
        "solution_code": "#include<iostream>\nusing namespace std;\nlong long dp[65][10] = {0};\nint main() {\nint T;\ncin >> T;\nfor(int i=0; i<=9; i++)\ndp[1][i] = 1;\nfor(int i=2; i<=64; i++) {\nfor(int j=0; j<=9; j++) {\nfor(int k=j; k<=9; k++) {\ndp[i][j] += dp[i-1][k];\n}\n}\n}\nwhile(T--) {\nint n;\ncin >> n;\nlong long result = 0;\nfor(int i=0; i<=9; i++) {\nresult += dp[n][i];\n}\ncout << result << '\\n';\n}\nreturn 0;\n}"
    },
    {
        "problem_tier": 18,
        "solution_code": "#include <iostream>\n#include <vector>\n#include <algorithm>\n#include <queue>\n#include <cstring>\nusing namespace std;\nconst int INF = 1e9;\nconst int MAX = 100001;\nint N, K;\nint parent[MAX][17], dist[MAX][17], minDist[MAX][17], maxDist[MAX][17], depth[MAX];\nbool visited[MAX];\nvector<pair<int, int>> graph[MAX];\nvoid DFS(int node, int d) {\nvisited[node] = true;\ndepth[node] = d;\nfor (int i = 0; i < graph[node].size(); i++) {\nint next = graph[node][i].first;\nint cost = graph[node][i].second;\nif (!visited[next]) {\nparent[next][0] = node;\ndist[next][0] = cost;\nminDist[next][0] = cost;\nmaxDist[next][0] = cost;\nDFS(next, d + 1);\n}\n}\n}\nvoid LCA() {\nfor (int j = 1; j < 17; j++) {\nfor (int i = 1; i <= N; i++) {\nparent[i][j] = parent[parent[i][j-1]][j-1];\ndist[i][j] = dist[i][j-1] + dist[parent[i][j-1]][j-1];\nminDist[i][j] = min(minDist[i][j-1], minDist[parent[i][j-1]][j-1]);\nmaxDist[i][j] = max(maxDist[i][j-1], maxDist[parent[i][j-1]][j-1]);\n}\n}\n}\npair<int, int> query(int x, int y) {\nint minD = INF;\nint maxD = 0;\nif (depth[x] > depth[y]) swap(x, y);\nfor (int i = 16; i >= 0; i--) {\nif (depth[y] - depth[x] >= (1 << i)) {\nminD = min(minD, minDist[y][i]);\nmaxD = max(maxD, maxDist[y][i]);\ny = parent[y][i];\n}\n}\nif (x == y) return make_pair(minD, maxD);\nfor (int i = 16; i >= 0; i--) {\nif (parent[x][i] != parent[y][i]) {\nminD = min(minD, min(minDist[x][i], minDist[y][i]));\nmaxD = max(maxD, max(maxDist[x][i], maxDist[y][i]));\nx = parent[x][i];\ny = parent[y][i];\n}\n}\nminD = min(minD, min(minDist[x][0], minDist[y][0]));\nmaxD = max(maxD, max(maxDist[x][0], maxDist[y][0]));\nreturn make_pair(minD, maxD);\n}\nint main() {\nios_base::sync_with_stdio(0);\ncin.tie(0);\ncin >> N;\nfor (int i = 0; i < N - 1; i++) {\nint a, b, c;\ncin >> a >> b >> c;\ngraph[a].push_back({b, c});\ngraph[b].push_back({a, c});\n}\nmemset(parent, 0, sizeof(parent));\nmemset(dist, 0, sizeof(dist));\nmemset(minDist, INF, sizeof(minDist));\nDFS(1, 0);\nLCA();\ncin >> K;\nwhile (K--) {\nint a, b;\ncin >> a >> b;\npair<int, int> result = query(a, b);\ncout << result.first << \" \" << result.second << \"\\n\";\n}\nreturn 0;\n}"
    },
    {
        "problem_tier": 15,
        "solution_code": "#include <iostream>\n#include <vector>\n#include <queue>\nusing namespace std;\nvoid solve() {\nint M = 0, middle, a;\npriority_queue<int, vector<int>, greater<int>> minheap;\npriority_queue<int> maxheap;\nvector<int> ans;\ncin >> M;\ncin >> middle;\nans.push_back(middle);\nfor (int i = 2; i <= M; i++) {\ncin >> a;\nif (a > middle)\nminheap.push(a);\nelse\nmaxheap.push(a);\nif (i % 2 == 0)\ncontinue;\nelse if (minheap.size() < maxheap.size()) {\nminheap.push(middle);\nmiddle = maxheap.top();\nmaxheap.pop();\nans.push_back(middle);\n}\nelse if (maxheap.size() < minheap.size()) {\nmaxheap.push(middle);\nmiddle = minheap.top();\nminheap.pop();\nans.push_back(middle);\n}\nelse\nans.push_back(middle);\n}\ncout << M/2 + 1 << \"\\n\";\nfor (int i = 0; i < ans.size(); i++) {\nif (i % 10 == 0 && i != 0) {\ncout << \"\\n\";\n}\ncout << ans[i] << \" \";\n}\n}\nint main() {\nint T;\ncin >> T;\nwhile (T--) {\nsolve();\ncout << \"\\n\";\n}\nreturn 0;\n}"
    },
    {
        "problem_tier": 12,
        "solution_code": "#include<iostream>\n#include<vector>\n#include<string>\n#include<algorithm>\nusing namespace std;\nint answer = 0;\nvoid recursive(string s, string t){\nif(s.size() > t.size()){\nreturn;\n}\nif(s == t){\nanswer = 1;\nreturn;\n}\nif(t[0] == t[t.size()-1]){\nif(t[0] == 'A'){             t.pop_back();\nrecursive(s, t);\n}\nelse{             reverse(t.begin(), t.end());\nt.pop_back();\nrecursive(s, t);\n}\n}\nelse{\nif(t[t.size()-1] == 'A'){\nif(t[0] == 'B'){                 string temp = t;\ntemp.pop_back();\nrecursive(s, temp);\nreverse(t.begin(), t.end());\nt.pop_back();\nrecursive(s, t);\n}\n}\nelse{             if(t[0] == 'A'){\nreturn;\n}\n}\n}\n}\nint main(){\nios::sync_with_stdio(0);\ncin.tie(0);\nstring S, T;\ncin>>S>>T;\nrecursive(S, T);\ncout<<answer<<\"\\n\";\nreturn 0;\n}"
    },
    {
        "problem_tier": 15,
        "solution_code": "#include<iostream>\n#include<vector>\nusing namespace std;\nint Lower_Bound(vector<int> vt, int num) {\nint low = 0, high = vt.size() - 1;\nwhile (low < high) {\nint mid = (low + high) / 2;\nif (vt[mid] >= num)\nhigh = mid;\nelse\nlow = mid + 1;\n}\nreturn high;\n}\nint main() {\nint n, num;\ncin >> n;\nvector<int> vt;\nvt.push_back(-1);\nfor (int i = 0; i < n; i++) {\ncin >> num;\nif (num > vt[vt.size() - 1])\nvt.push_back(num);\nelse\nvt[Lower_Bound(vt, num)] = num;\n}\ncout << n - vt.size() + 1;\nreturn 0;\n}"
    },
    {
        "problem_tier": 2,
        "solution_code": "#include<iostream>\nusing namespace std;\nint main() {\nchar c;\ncin >> c;\nif(c == 'N' || c == 'n')\ncout << \"NaverD2\";\nelse\ncout << \"NaverWhale\";\nreturn 0;\n}"
    },
    {
        "problem_tier": 5,
        "solution_code": "#include <iostream>\n#include <vector>\nusing namespace std;\nint main() {\nint n, cluster;\nlong long count = 0;\nvector<int> size;\ncin >> n;\nfor (int i = 0; i < n; i++) {\nint s;\ncin >> s;\nsize.push_back(s);\n}\ncin >> cluster;\nfor (int i = 0; i < n; i++) {\nif (size[i] % cluster == 0) {\ncount += size[i] / cluster;\n}\nelse {\ncount += size[i] / cluster + 1;\n}\n}\ncout << count * (long long)cluster << endl;\nreturn 0;\n}"
    },
    {
        "problem_tier": 12,
        "solution_code": "#include <iostream>\n#include <vector>\n#include <queue>\n#define MAX 50001\n#define INF 1e9\nusing namespace std;\nint n, m;\nint dist[MAX+1];\nvector<pair<int,int>> v[MAX+1];\nvoid dijkstra(int start){\nfor(int i=1; i<=n; i++)\ndist[i] = INF;\npriority_queue<pair<int,int>> pq;\npq.push({0, start});\ndist[start] = 0;\nwhile(!pq.empty()){\nint cost = -pq.top().first;\nint cur = pq.top().second;\npq.pop();\nfor(int i=0; i<v[cur].size(); i++){\nint next = v[cur][i].first;\nint newcost = v[cur][i].second + cost;\nif(dist[next] > newcost){\ndist[next] = newcost;\npq.push({-dist[next], next});\n}\n}\n}\n}\nint main(){\nios_base::sync_with_stdio(false);\ncin.tie(NULL);\ncout.tie(NULL);\ncin >> n >> m;\nwhile(m--){\nint a, b, c;\ncin >> a >> b >> c;\nv[a].push_back({b, c});\nv[b].push_back({a, c});\n}\ndijkstra(1);\ncout << dist[n];\nreturn 0;\n}"
    },
    {
        "problem_tier": 6,
        "solution_code": "#include <iostream>\n#include <string>\n#include <algorithm>\n#include <set>\nusing namespace std;\nint main() {\nint N;\ncin >> N;\nset<string> words;\nfor (int i = 0; i < N; i++) {\nstring word;\ncin >> word;\nwords.insert(word);\n}\nfor (auto word : words) {\nstring reversed = word;\nreverse(reversed.begin(), reversed.end());\nif (words.count(reversed) > 0) {\ncout << word.size() << \" \" << word[word.size() / 2];\nreturn 0;\n}"
    },
    {
        "problem_tier": 4,
        "solution_code": "#include<iostream>\nusing namespace std;\nint main() {\nint a, b, c;\ncin >> a >> b >> c;\nif(a + b == c) {\ncout << a << '+' << b << '=' << c;\n} else if(a - b == c) {\ncout << a << '-' << b << '=' << c;\n} else if(a * b == c) {\ncout << a << '*' << b << '=' << c;\n} else if(a / b == c) {\ncout << a << '/' << b << '=' << c;\n} else if(a == b + c) {\ncout << a << '=' << b << '+' << c;\n} else if(a == b - c) {\ncout << a << '=' << b << '-' << c;\n} else if(a == b * c) {\ncout << a << '=' << b << '*' << c;\n} else if(a == b / c) {\ncout << a << '=' << b << '/' << c;\n}\nreturn 0;\n}"
    },
    {
        "problem_tier": 9,
        "solution_code": "#include <iostream>\n#include <unordered_map>\n#include <vector>\n#include <algorithm>\nusing namespace std;\nbool compare(const pair<string, int>& a, const pair<string, int>& b) {\nreturn a.second < b.second;\n}\nint main(void) {\nios::sync_with_stdio(false);\ncin.tie(0);\ncout.tie(0);\nint k, l;\ncin >> k >> l;\nunordered_map<string, int> student;\nfor (int i = 0; i < l; i++) {\nstring number;\ncin >> number;\nstudent[number] = i;\n}\nvector<pair<string, int>> v;\nfor (auto& i : student)\nv.push_back(i);\nsort(v.begin(), v.end(), compare);\nfor (int i = 0; i < min(k, (int)v.size()); i++)\ncout << v[i].first << '\\n';\nreturn 0;\n}"
    },
    {
        "problem_tier": 2,
        "solution_code": "#include <iostream>\n#include <string>\nusing namespace std;\nint main() {\nstring str;\ncin >> str;\nfor (int i = 0; i < str.size(); i++) {\nif (str[i] >= 'a' && str[i] <= 'z') {\nstr[i] = str[i] - 'a' + 'A';\n}\n}\ncout << str;\nreturn 0;\n}"
    },
    {
        "problem_tier": 12,
        "solution_code": "#include<iostream>\n#include<algorithm>\n#include<vector>\nusing namespace std;\nint dp[100001];\nint main() {\nios::sync_with_stdio(false);\ncin.tie(0);\ncout.tie(0);\nfor (int i = 0; i <= 100000; i++) {\ndp[i] = 1000000000;     }\nint c, n;\ncin >> c >> n;\nvector<pair<int, int>> vt(n);\nfor (int i = 0; i < n; i++) {\nint a, b;\ncin >> a >> b;\nvt[i] = { a, b };\n}\ndp[0] = 0;\nfor (int i = 0; i <= 100000; i++) {\nfor (int j = 0; j < n; j++) {\nif (i - vt[j].second >= 0) {\ndp[i] = min(dp[i], dp[i - vt[j].second] + vt[j].first);\n}\n}\n}\nfor (int i = c; i <= 100000; i++) {\nif (dp[i] != 1000000000) {\ncout << i;\nbreak;\n}\n}\nreturn 0;\n}"
    },
    {
        "problem_tier": 12,
        "solution_code": "#include <iostream>\n#include <vector>\n#include <algorithm>\n#include <climits>\n#include <queue>\nusing namespace std;\nint n = 0, m = 0, t = 0, arr[101][101], ny = 0, nx = 0;\nint my[4] = {1, 0, -1, 0}, mx[4] = {0, 1, 0, -1};\nbool ch[101][101][2] = {false,};\nint main(void) {\nios_base::sync_with_stdio(false);\ncin.tie(NULL);\ncout.tie(NULL);\ncin >> n >> m >> t;\nfor(int i = 1; i <= n; i++) {\nfor(int j = 1; j <= m; j++) {\ncin >> arr[i][j];\n}\n}\nqueue<pair<pair<int, int>, pair<int, int>>> q;     q.push(make_pair(make_pair(1, 1), make_pair(0, 0)));\nch[1][1][0] = true;\nwhile(!q.empty()) {\nint y = q.front().first.first;\nint x = q.front().first.second;\nint s = q.front().second.first;         int cnt = q.front().second.second;         q.pop();\nif(cnt > t) continue;\nfor(int i = 0; i < 4; i++) {\nny = y + my[i];\nnx = x + mx[i];\nif(ny == n && nx == m) {\nif(cnt + 1 <= t) {\ncout << cnt + 1 << \"\\n\";\nexit(0);\n}\n} else if(ny > 0 && ny <= n && nx > 0 && nx <= m) {\nif(arr[ny][nx] == 1 && s == 1) {                     ch[ny][nx][s] = true;\nq.push(make_pair(make_pair(ny, nx), make_pair(1, cnt + 1)));\n} else if(arr[ny][nx] == 2 && !ch[ny][nx][s]) {                     ch[ny][nx][s] = true;\nq.push(make_pair(make_pair(ny, nx), make_pair(1, cnt + 1)));\n} else if(arr[ny][nx] == 0 && !ch[ny][nx][s]) {                     ch[ny][nx][s] = true;\nq.push(make_pair(make_pair(ny, nx), make_pair(s, cnt + 1)));\n}\n}\n}\n}\ncout << \"Fail\" << \"\\n\";\nreturn 0;\n}"
    },
    {
        "problem_tier": 7,
        "solution_code": "#include <iostream>\n#include <vector>\n#include <algorithm>\nusing namespace std;\nint getMaxCardNum(int curPeople, int depth, int idx, int cardNum, int cardPerPerson[][5]) {\nif (depth == 3) {\nint sum = 0;\nfor (int i = 0; i < 3; i++) {\nsum += cards[i];\n}\nreturn max(sum % 10, cardNum);\n}\nint maxCardNum = 0;\nfor (int i = idx; i < 5; i++) {\ncards.push_back(cardPerPerson[curPeople][i]);\nmaxCardNum = max(maxCardNum, getMaxCardNum(curPeople, depth + 1, i + 1, cardNum));\ncards.pop_back();\n}\nreturn maxCardNum;\n}\nint main() {\nint cardPerPerson[1000][5], peopleNum;\nvector<pair<int, int>> maxCard;\nvector<int> cards;\ncin >> peopleNum;\nfor (int i = 0; i < peopleNum; i++) {\nfor (int j = 0; j < 5; j++) {\ncin >> cardPerPerson[i][j];\n}\nmaxCard.push_back({ getMaxCardNum(i, 0, 0, 0, cardPerPerson), i + 1 });\n}\nsort(maxCard.rbegin(), maxCard.rend());\ncout << maxCard[0].second;\nreturn 0;\n}"
    },
    {
        "problem_tier": 7,
        "solution_code": "#include<iostream>\nusing namespace std;\nvoid Solve() {\nint A, B;\ncin >> A >> B;\ncout << \"yes\\n\";\n}\nvoid TC() {\nint T;\ncin >> T;\nfor (int i = 0; i < T; i++) {\nSolve();\n}\n}\nint main() {\nTC();\nreturn 0;\n}"
    },
    {
        "problem_tier": 5,
        "solution_code": "#include<iostream>\n#include<algorithm>\nusing namespace std;\nint main(){\nint T;\ncin >> T;\nwhile(T--){\nint numi;\nstring num;\nbool flag;\ncin >> num;\nnumi = stoi(num);\nreverse(num.begin(), num.end());\nnumi += stoi(num);\nnum = to_string(numi);\nflag = true;\nfor(int i = 0; i < num.length()/2; i++){\nif(num[i] != num[num.length()-1-i]){\nflag = false;\n}\n}\nif(flag){\ncout << \"YES\\n\";\n}\nelse{\ncout << \"NO\\n\";\n}\n}\nreturn 0;\n}"
    },
    {
        "problem_tier": 2,
        "solution_code": "#include <bits/stdc++.h>\nusing namespace std;\nint main() {\nint rBox, sBox, ans;\ncin >> rBox >> sBox;\nans = rBox * 8 + sBox * 3 - 28;\nif (ans < 0)\nans = 0;\ncout << ans;\nreturn 0;\n}"
    },
    {
        "problem_tier": 8,
        "solution_code": "#include <iostream>\n#include <algorithm>\n#include <vector>\n#include <map>\nusing namespace std;\nstring getString(int num) {\nstring nums[10] = {\"zero\", \"one\", \"two\", \"three\", \"four\", \"five\", \"six\", \"seven\", \"eight\", \"nine\"};\nstring s;\nif (num >= 10) {\ns = nums[num / 10] + \" \" + nums[num % 10];\n} else {\ns = nums[num];\n}\nreturn s;\n}\nint main() {\nint M, N;\ncin >> M >> N;\nmap<string, int> numMap;\nfor (int i = M; i <= N; i++) {\nstring s = getString(i);\nnumMap[s] = i;\n}\nint cnt = 0;\nfor (auto el : numMap) {\ncout << el.second << \" \";\ncnt++;\nif (cnt % 10 == 0) {\ncout << endl;\n}\n}\nreturn 0;\n}"
    },
    {
        "problem_tier": 13,
        "solution_code": "#include <iostream>\n#include <vector>\n#define MAX 51\nusing namespace std;\nbool ch[MAX][MAX];\nint n, m, sy, sx, my[] = {0,0,1,-1}, mx[] = {1,-1,0,0}, ny, nx;\nvector<vector<char>> v(50, vector<char>(50, 0));\nvoid dfs(int y, int x, int num){\nch[y][x] = true;\nfor(int i=0;i<4;i++){\nny = y + my[i];\nnx = x + mx[i];\nif(ny>=0 && ny<n && nx>=0 && nx<m && v[y][x] == v[ny][nx] && !ch[ny][nx]){\ndfs(ny, nx, num+1);\n}\nelse if(sy == ny && sx == nx && num >= 4){\ncout << \"Yes\" << \"\\n\";\nexit(0);\n}\n}\nch[y][x] = false;\n}\nint main(){\nios_base::sync_with_stdio(false);\ncin.tie(NULL);\ncout.tie(NULL);\ncin >> n >> m;\nfor(int i=0;i<n;i++){\nfor(int j=0;j<m;j++){\ncin >> v[i][j];\nch[i][j] = false;\n}\n}\nfor(int i=0;i<n;i++){\nfor(int j=0;j<m;j++){\nif(!ch[i][j]){\nsy = i, sx = j;\ndfs(i, j, 1);\nch[i][j] = true;\n}\n}\n}\ncout << \"No\" << \"\\n\";\nreturn 0;\n}"
    },
    {
        "problem_tier": 16,
        "solution_code": "#include<iostream>\n#include<algorithm>\nusing namespace std;\nstruct Box {\nint sender;\nint receiver;\nint count;\n};\nbool comp(Box a, Box b) {\nif (a.receiver == b.receiver)\nreturn a.sender < b.sender;\nreturn a.receiver < b.receiver;\n}\nint main() {\nint n, c, m;\ncin >> n >> c >> m;\nBox arr[m];\nfor (int i = 0; i < m; i++) {\ncin >> arr[i].sender >> arr[i].receiver >> arr[i].count;\n}\nsort(arr, arr + m, comp);\nint capacity[2001] = {0};\nint result = 0;\nfor (int i = 0; i < m; i++) {\nint maxCount = 0;\nfor (int j = arr[i].sender; j < arr[i].receiver; j++) {\nmaxCount = max(capacity[j], maxCount);\n}\nint val = min(arr[i].count, c - maxCount);\nresult += val;\nfor (int j = arr[i].sender; j < arr[i].receiver; j++) {\ncapacity[j] += val;\n}\n}\ncout << result << endl;\nreturn 0;\n}"
    },
    {
        "problem_tier": 13,
        "solution_code": "#include <iostream>\n#define MAX_INPUT 1000000\nint main() {\nint T, N;\nlong long sum_of_div[MAX_INPUT + 1] = {0};\nfor (int i = 1; i <= MAX_INPUT; i++) {\nfor (int j = 1; i * j <= MAX_INPUT; j++) {\nsum_of_div[i * j] += i;\n}\nsum_of_div[i] += sum_of_div[i - 1];\n}\nstd::cin >> T;\nwhile (T--) {\nstd::cin >> N;\nstd::cout << sum_of_div[N] << \"\\n\";\n}\nreturn 0;\n}"
    },
    {
        "problem_tier": 15,
        "solution_code": "#include <iostream>\n#include <vector>\n#include <queue>\n#include <cstring>\n#include <algorithm>\nusing namespace std;\n#define MAX 20\nstruct Block {\nint x, y, cnt, rainbowCnt;\nbool operator<(const Block& b) const {\nif (cnt == b.cnt) {\nif (rainbowCnt == b.rainbowCnt) {\nif (x == b.x) return y < b.y;\nreturn x < b.x;\n}\nreturn rainbowCnt < b.rainbowCnt;\n}\nreturn cnt < b.cnt;\n}\n};\nint N, M;\nint board[MAX][MAX];\nint dx[] = { 0, 0, -1, 1 };\nint dy[] = { -1, 1, 0, 0 };\nint score = 0;\nvoid input();\nbool findBlock();\nvoid applyGravity();\nvoid rotateBoard();\nint main() {\ncin.tie(NULL);\ncout.tie(NULL);\nios_base::sync_with_stdio(false);\ninput();\nwhile (true) {\nif (!findBlock()) break;         applyGravity();\nrotateBoard();\napplyGravity();\n}\ncout << score << '\\n';\nreturn 0;\n}\nvoid input() {\ncin >> N >> M;\nfor (int i = 0; i < N; i++) {\nfor (int j = 0; j < N; j++) {\ncin >> board[i][j];\n}\n}\n}\nbool findBlock() {\nbool visit[MAX][MAX] = { false, };\npriority_queue<Block> pQ;\nfor (int i = 0; i < N; i++) {\nfor (int j = 0; j < N; j++) {\nif (board[i][j] > 0 && !visit[i][j]) {\nbool rainbowVisit[MAX][MAX] = { false, };\nqueue<pair<int, int>> Q;\nQ.push({ i, j });\nvisit[i][j] = true;\nint cnt = 1, rainbowCnt = 0;\nwhile (!Q.empty()) {\nint x = Q.front().first;\nint y = Q.front().second;\nQ.pop();\nfor (int d = 0; d < 4; d++) {\nint nx = x + dx[d];\nint ny = y + dy[d];\nif (nx < 0 || nx >= N || ny < 0 || ny >= N || visit[nx][ny] || rainbowVisit[nx][ny]) continue;\nif (board[nx][ny] == 0) {\nrainbowVisit[nx][ny] = true;\nQ.push({ nx, ny });\ncnt++;\nrainbowCnt++;\n}\nelse if (board[i][j] == board[nx][ny]) {\nvisit[nx][ny] = true;\nQ.push({ nx, ny });\ncnt++;\n}\n}\n}\npQ.push({ i, j, cnt, rainbowCnt });\n}\n}\n}\nif (pQ.empty()) return false;\nint x = pQ.top().x;\nint y = pQ.top().y;\nint cnt = pQ.top().cnt;\nif (cnt < 2) return false;\nscore += cnt * cnt;     queue<pair<int, int>> Q;\nQ.push({ x, y });\nint blockId = board[x][y];\nboard[x][y] = -2;\nwhile (!Q.empty()) {\nint x = Q.front().first;\nint y = Q.front().second;\nQ.pop();\nfor (int d = 0; d < 4; d++) {\nint nx = x + dx[d];\nint ny = y + dy[d];\nif (nx < 0 || nx >= N || ny < 0 || ny >= N) continue;\nif (board[nx][ny] == 0 || board[nx][ny] == blockId) {\nQ.push({ nx, ny });\nboard[nx][ny] = -2;\n}\n}\n}\nreturn true;\n}\nvoid applyGravity() {\nfor (int i = 0; i < N; i++) {\nfor (int j = N - 1; j >= 0; j--) {\nif (board[j][i] == -2) {\nint x = j;\nint y = i;\nwhile (x > 0 && board[x][y] == -2) x--;\nif (board[x][y] == -1) continue;\nboard[j][i] = board[x][y];\nboard[x][y] = -2;\n}\n}\n}\n}\nvoid rotateBoard() {\nint tempBoard[MAX][MAX];\nfor (int i = 0; i < N; i++) {\nfor (int j = 0; j < N; j++) {\ntempBoard[i][j] = board[i][j];\n}\n}\nfor (int i = 0; i < N; i++) {\nfor (int j = 0; j < N; j++) {\nboard[i][j] = tempBoard[j][N - 1 - i];\n}\n}\n}"
    },
    {
        "problem_tier": 12,
        "solution_code": "#include <iostream>\n#include <vector>\n#include <algorithm>\ntypedef long long ll;\nusing namespace std;\nvector<ll> ftr;\nvoid factorial() {\nftr.push_back(1);\nfor (int i = 1; i < 21; i++) {\nftr.push_back(i * ftr[i-1]);\n}\n}\nvoid case1(int n, ll k) {\nk--;\nvector<ll> comb;\nset<ll> numSet;\nfor (int i = 1; i <= n; i++) {\nnumSet.insert(i);\n}\nfor (int i = 0; i < n - 1; i++) {\nll index = k / ftr[n-1-i];\nauto it = numSet.begin();\nfor (int j = 0; j < index; j++) {\nit++;\n}\ncomb.push_back(*it);\nnumSet.erase(it);\nk %= ftr[n-1-i];\n}\ncomb.push_back(*numSet.begin());\nfor (int i = 0; i < comb.size(); i++) {\ncout << comb[i] << ' ';\n}\n}\nvoid case2(int n, vector<ll>& comb) {\nset<ll> numSet;\nfor (int i = 1; i <= n; i++) {\nnumSet.insert(i);\n}\nll ans = 0;\nfor (int i = 1; i <= n; i++) {\nauto it = numSet.begin();\nll cnt = 0;\nwhile (*it != comb[i]) {\nit++;\ncnt++;\n}\nans += cnt * ftr[n-i];\nnumSet.erase(it);\n}\nans++;\ncout << ans << '\\n';\n}\nint main() {\nint n, op;\ncin >> n >> op;\nfactorial();\nif (op == 1) {\nll k;\ncin >> k;\ncase1(n, k);\n} else {\nvector<ll> comb(n+1);\nfor (int i = 1; i <= n; i++) {\ncin >> comb[i];\n}\ncase2(n, comb);\n}\nreturn 0;\n}"
    },
    {
        "problem_tier": 4,
        "solution_code": "#include <iostream>\nusing namespace std;\nint main() {\nint t;\ncin >> t;\nwhile (t--) {\nint box;\ncin >> box;\nfor (int i = 0; i < box; i++) {\nfor (int j = 0; j < box; j++) {\nif (i != 0 && i != box - 1 && j != 0 && j != box - 1)\ncout << \"J\";\nelse\ncout << \"#\";\n}\ncout << '\\n';\n}\ncout << '\\n';\n}\nreturn 0;\n}"
    },
    {
        "problem_tier": 13,
        "solution_code": "#include <iostream>\n#include <vector>\n#include <queue>\n#include <algorithm>\nusing namespace std;\nint N, M;\nint map[51][51];\nint dx[] = {0, 0, -1, 1};\nint dy[] = {-1, 1, 0, 0};\nint bfs(vector<pair<int, int>> virus) {\nvector<vector<int>> dist(N, vector<int>(N, -1));\nqueue<pair<int, int>> q;\nfor (auto v : virus) {\nq.push(v);\ndist[v.first][v.second] = 0;\n}\nint max_time = 0;\nwhile (!q.empty()) {\nint x = q.front().first;\nint y = q.front().second;\nq.pop();\nfor (int i = 0; i < 4; i++) {\nint nx = x + dx[i];\nint ny = y + dy[i];\nif (nx < 0 || ny < 0 || nx >= N || ny >= N) continue;\nif (map[nx][ny] == 1) continue;\nif (dist[nx][ny] != -1) continue;\ndist[nx][ny] = dist[x][y] + 1;\nmax_time = max(max_time, dist[nx][ny]);\nq.push({nx, ny});\n}\n}\nfor (int i = 0; i < N; i++) {\nfor (int j = 0; j < N; j++) {\nif (map[i][j] != 1 && dist[i][j] == -1) {\nmax_time = -1;\n}\n}\n}\nreturn max_time;\n}\nint main() {\ncin >> N >> M;\nvector<pair<int, int>> virus;\nfor (int i = 0; i < N; i++) {\nfor (int j = 0; j < N; j++) {\ncin >> map[i][j];\nif (map[i][j] == 2) {\nvirus.push_back({i, j});\n}\n}\n}\nvector<int> combi(virus.size(), 0);\nfill(combi.begin(), combi.begin() + M, 1);\nint min_time = 987654321;\ndo {\nvector<pair<int, int>> selected_virus;\nfor (int i = 0; i < virus.size(); i++) {\nif (combi[i] == 1) {\nselected_virus.push_back(virus[i]);\n}\n}\nint time = bfs(selected_virus);\nif (time != -1) {\nmin_time = min(min_time, time);\n}\n} while (prev_permutation(combi.begin(), combi.end()));\nif (min_time == 987654321) {\nmin_time = -1;\n}\ncout << min_time << endl;\nreturn 0;\n}"
    },
    {
        "problem_tier": 5,
        "solution_code": "#include <iostream>\n#include <vector>\n#include <algorithm>\nusing namespace std;\nint main() {\nint t, n;\ncin >> t;\nwhile (t--) {\ncin >> n;\nvector<int> a(n);\nfor (int i = 0; i < n; i++)\ncin >> a[i];\nsort(a.begin(), a.end());\nint m = 2000000000;\nint tmp = 0;\nint sum = 0;\nfor (int i = 0; i < n - 1; i++)\nsum += abs(a[i + 1] - a[i]);\nwhile (tmp++ < a[n - 1]) {\nsum += abs(a[n - 1] - tmp) + abs(a[0] - tmp);\nif (m > sum)\nm = sum;\nsum -= abs(a[n - 1] - tmp) + abs(a[0] - tmp);\n}\ncout << m << '\\n';\n}\n}"
    },
    {
        "problem_tier": 15,
        "solution_code": "#include <iostream>\n#include <cstring>\n#include <string>\nint nextMaximum[1000001][11];\nint dfs(std::string num, int depth) {\nif (depth == 0)\nreturn std::stoi(num);\nconst int currNum = std::stoi(num);\nint& maximum = nextMaximum[currNum][depth];\nif (maximum >= 0)\nreturn maximum;\nfor (int i = 0; i < num.length(); i++) {\nfor (int j = i + 1; j < num.length(); j++) {\nif (i == 0 && num[j] == '0')\ncontinue;\nstd::swap(num[i], num[j]);\nmaximum = std::max(maximum, dfs(num, depth - 1));\nstd::swap(num[i], num[j]);\n}\n}\nreturn maximum;\n}\nvoid solve() {\nstd::string n;\nint k;\nstd::cin >> n >> k;\nmemset(nextMaximum, -1, sizeof(int) * 1000001 * 11);\nstd::cout << dfs(n, k);\n}\nint main(void) {\nstd::ios::sync_with_stdio(false);\nstd::cin.tie(NULL);\nstd::cout.tie(NULL);\nsolve();\nreturn 0;\n}"
    },
    {
        "problem_tier": 4,
        "solution_code": "#include<bits/stdc++.h>\nusing namespace std;\nint main() {\nint testNum = 0;\nint n[5];\nwhile(1) {\ntestNum++;\nstring evenString = \"odd\";\ncin >> n[0];\nif(!n[0]) break;\nn[1] = 3 * n[0];\nif(n[1] % 2 == 0) {\nevenString = \"even\";\nn[2] = n[1] / 2;\n} else {\nn[2] = (n[1] + 1) / 2;\n}\nn[3] = 3 * n[2];\nn[4] = n[3] / 9;\ncout << testNum << \".\" << evenString << \" \" << n[4] << '\\n';\n}\nreturn 0;\n}"
    },
    {
        "problem_tier": 5,
        "solution_code": "#include <iostream>\n#include <cmath>\nusing namespace std;\nint main() {\nint n;\nint a, b, c, d, e;\nint tot;\ncin >> n;\na = n / 10000;\nb = (n - a * 10000) / 1000;\nc = (n - a * 10000 - b * 1000) / 100;\nd = (n - a * 10000 - b * 1000 - c * 100) / 10;\ne = (n - a * 10000 - b * 1000 - c * 100 - d * 10);\ntot = pow(a, 5) + pow(b, 5) + pow(c, 5) + pow(d, 5) + pow(e, 5);\ncout << tot << endl;\nreturn 0;\n}"
    },
    {
        "problem_tier": 2,
        "solution_code": "#include <iostream>\nusing namespace std;\nint main() {\nint n, s;\nwhile(cin >> n >> s) {\ncout << s / (n + 1) << '\\n';\n}\nreturn 0;\n}"
    },
    {
        "problem_tier": 17,
        "solution_code": "#include <iostream>\n#include <vector>\n#include <algorithm>\nusing namespace std;\nstruct Point {\nint x, y;\n};\nstruct Line {\nPoint p1, p2;\n};\nint ccw(Point a, Point b, Point c) {\nint tmp = a.x * b.y + b.x * c.y + c.x * a.y - (a.y * b.x + b.y * c.x + c.y * a.x);\nif (tmp > 0) return 1;\nif (tmp < 0) return -1;\nreturn 0;\n}\nbool isIntersect(Line l1, Line l2) {\nint ccw1 = ccw(l1.p1, l1.p2, l2.p1);\nint ccw2 = ccw(l1.p1, l1.p2, l2.p2);\nint ccw3 = ccw(l2.p1, l2.p2, l1.p1);\nint ccw4 = ccw(l2.p1, l2.p2, l1.p2);\nif (ccw1 * ccw2 == 0 && ccw3 * ccw4 == 0) {\nif (l1.p1.x == l1.p2.x) {\nint max1 = max(l1.p1.y, l1.p2.y);\nint min1 = min(l1.p1.y, l1.p2.y);\nint max2 = max(l2.p1.y, l2.p2.y);\nint min2 = min(l2.p1.y, l2.p2.y);\nif (max1 >= min2 && max2 >= min1) return true;\nelse return false;\n}\nint max1 = max(l1.p1.x, l1.p2.x);\nint min1 = min(l1.p1.x, l1.p2.x);\nint max2 = max(l2.p1.x, l2.p2.x);\nint min2 = min(l2.p1.x, l2.p2.x);\nif (max1 >= min2 && max2 >= min1) return true;\nreturn false;\n}\nif (ccw1 * ccw2 <= 0 && ccw3 * ccw4 <= 0) return true;\nreturn false;\n}\nint findParent(vector<int>& parent, int x) {\nif (parent[x] == x) return x;\nparent[x] = findParent(parent, parent[x]);\nreturn parent[x];\n}\nvoid unionParent(vector<int>& parent, int x, int y) {\nint px = findParent(parent, x);\nint py = findParent(parent, y);\nif (px <= py) parent[py] = px;\nelse parent[px] = py;\n}\nint main() {\nios_base::sync_with_stdio(false);\ncin.tie(NULL);\ncout.tie(NULL);\nint N;\ncin >> N;\nvector<Line> lines(N);\nvector<int> parent(N);\nfor (int i = 0; i < N; i++) {\ncin >> lines[i].p1.x >> lines[i].p1.y >> lines[i].p2.x >> lines[i].p2.y;\nparent[i] = i;\n}\nfor (int i = 0; i < N - 1; i++) {\nfor (int j = i + 1; j < N; j++) {\nif (isIntersect(lines[i], lines[j])) {\nunionParent(parent, i, j);\n}\n}\n}\nvector<int> group;\nvector<int> count;\nint MAX = 0;\nfor (int i = 0; i < N; i++) {\ngroup.push_back(findParent(parent, i));\ncount.push_back(findParent(parent, i));\n}\nsort(group.begin(), group.end());\nint prev = group[0];\nint cnt = 1;\nfor (int i = 1; i < group.size(); i++) {\nif (group[i] == prev) {\ncnt++;\n}\nelse {\nMAX = max(MAX, cnt);\ncnt = 1;\nprev = group[i];\n}\n}\nMAX = max(MAX, cnt);\ncout << group.size() << '\\n' << MAX << '\\n';\nreturn 0;\n}"
    },
    {
        "problem_tier": 11,
        "solution_code": "#include <iostream>\n#include <vector>\n#include <algorithm>\n#include <queue>\nusing namespace std;\nint N, M;\nint ansNum = 1, ansDist = 0, ansCnt = 0;\nvector<int> graph[50001];\nvector<bool> check(50001);\nvoid bfs() {\nqueue<pair<int, int>> q;\nq.push({1, 0});\nwhile (!q.empty()) {\nint now = q.front().first;\nint dist = q.front().second;\ncheck[now] = true;\nq.pop();\nif (dist > ansDist) {\nansDist = dist;\nansNum = now;\nansCnt = 1;\n}\nelse if (dist == ansDist) {\nansNum = min(ansNum, now);\nansCnt++;\n}\nfor (int i = 0; i < graph[now].size(); i++) {\nint next = graph[now][i];\nif (!check[next]) {\ncheck[next] = true;\nq.push({next, dist + 1});\n}\n}\n}\n}\nint main() {\nios_base::sync_with_stdio(0);\ncin.tie(0);\ncout.tie(0);\ncin >> N >> M;\nfor (int i = 0; i < M; i++) {\nint a, b;\ncin >> a >> b;\ngraph[a].push_back(b);\ngraph[b].push_back(a);\n}\nbfs();\ncout << ansNum << \" \" << ansDist << \" \" << ansCnt << '\\n';\nreturn 0;\n}"
    },
    {
        "problem_tier": 14,
        "solution_code": "#include <iostream>\n#include <vector>\n#include <algorithm>\nusing namespace std;\nstruct Flower {\nint startMonth;\nint startDay;\nint endMonth;\nint endDay;\n};\nbool compare(Flower a, Flower b) {\nif (a.startMonth == b.startMonth) {\nreturn a.startDay < b.startDay;\n}\nreturn a.startMonth < b.startMonth;\n}\nint main() {\nint N;\ncin >> N;\nvector<Flower> flowers(N);\nfor (int i = 0; i < N; i++) {\ncin >> flowers[i].startMonth >> flowers[i].startDay;\ncin >> flowers[i].endMonth >> flowers[i].endDay;\n}\nsort(flowers.begin(), flowers.end(), compare);\nint endMonth = 3;\nint endDay = 1;\nint month = 3;\nint day = 1;\nint count = 0;\nfor (int i = 0; i < N; i++) {\nif (flowers[i].startMonth <= month) {\nif (flowers[i].startMonth != month || flowers[i].startDay <= day) {\nif (flowers[i].endMonth > endMonth) {\nendMonth = flowers[i].endMonth;\nendDay = flowers[i].endDay;\n}\nelse if (flowers[i].endMonth == endMonth && flowers[i].endDay > endDay) {\nendDay = flowers[i].endDay;\n}\n}\n}\nif (month == endMonth && day == endDay) {\ncount = 0;\nbreak;\n}\nmonth = endMonth;\nday = endDay;\ncount++;\n}\ncout << count;\nreturn 0;\n}"
    },
    {
        "problem_tier": 3,
        "solution_code": "#include<iostream>\nusing namespace std;\nint main() {\nint n, cnt=0;\ncin >> n;\nfor(int i=0; i<5; i++) {\nint x;\ncin >> x;\nif(x == n)\ncnt++;\n}\ncout << cnt;\nreturn 0;\n}"
    },
    {
        "problem_tier": 6,
        "solution_code": "#include <iostream>\nusing namespace std;\nbool canTake[1001];\nint main() {\nios_base::sync_with_stdio(false);\ncin.tie(NULL);\ncout.tie(NULL);\nint L, N;\ncin >> L >> N;\nint firstCnt = 0, firstAns, secondCnt = 0, secondAns;\nfor (int idx = 1; idx <= N; idx++) {\nint left, right;\ncin >> left >> right;\nif (firstCnt < right - left + 1) {\nfirstCnt = right - left + 1;\nfirstAns = idx;\n}\nint temp = 0;         for (int i = left; i <= right; i++) {\nif (!canTake[i]) {\ntemp++;\ncanTake[i] = true;\n}\n}\nif (secondCnt < temp) {\nsecondCnt = temp;\nsecondAns = idx;\n}\n}\ncout << firstAns << '\\n' << secondAns;\nreturn 0;\n}"
    },
    {
        "problem_tier": 13,
        "solution_code": "#include<bits/stdc++.h>\nusing namespace std;\ntypedef pair<int,int> p;\nint xpos[100100];\nvector<p> animals;\nint cal(int x, int y, int z) {\nreturn abs(x - z) + y;\n}\nint main() {\nint m, n, l;\ncin >> m >> n >> l;\nfor (int i = 0; i < m; i++)\ncin >> xpos[i];\nfor (int i = 0; i < n; i++) {\nint x, y;\ncin >> x >> y;\nanimals.push_back(make_pair(x, y));\n}\nsort(animals.begin(), animals.end());\nsort(xpos, xpos + m);\nint res = 0;\nint xidx = 0;\nfor (int i = 0; i < n; i++) {\nwhile (xidx != m - 1 && xpos[xidx + 1] < animals[i].first) {\nxidx++;\n}\nif (cal(animals[i].first, animals[i].second, xpos[xidx]) <= l) {\nres++;\ncontinue;\n}\nif (xidx != m - 1) {\nif (cal(animals[i].first, animals[i].second, xpos[xidx + 1]) <= l) {\nres++;\ncontinue;\n}\n}\n}\ncout << res << endl;\nreturn 0;\n}"
    },
    {
        "problem_tier": 3,
        "solution_code": "#include <iostream>\n#include <algorithm>\nusing namespace std;\nint main() {\nint n, m, k;\ncin >> n >> m >> k;\ncout << min(m, k) + min(n - m, n - k) << '\\n';\nreturn 0;\n}"
    },
    {
        "problem_tier": 4,
        "solution_code": "#include <iostream>\n#include <vector>\nusing namespace std;\nint main() {\nint n;\ncin >> n;\nint count = 0;\nvector<int> numbers(n);\nfor (int i = 0; i < n; i++) {\ncin >> numbers[i];\nif (numbers[i] != i+1) {\ncount++;\n}\n}\ncout << count << \"\\n\";\nreturn 0;\n}"
    },
    {
        "problem_tier": 9,
        "solution_code": "#include<iostream>\n#define MOD 1000000000\n#define MAX 1000001\ntypedef long long ll;\nusing namespace std;\nll DP(int num){\nll arr[MAX];\narr[0] = 0;\narr[1] = 1;\nfor(int i=2; i<=num; i++){\narr[i] = (arr[i-1] + arr[i-2]) % MOD;\n}\nreturn arr[num] % MOD;\n}\nint main(void){\nint n, flag = 1;\ncin >> n;\nif(n < 0){\nn *= -1;\nif(n % 2 == 0) flag = -1;\n}\nif(n == 0) flag = 0;\ncout << flag << '\\n' << DP(n) << '\\n';\nreturn 0;\n}"
    },
    {
        "problem_tier": 4,
        "solution_code": "#include <iostream>\nusing namespace std;\nint main() {\nint t, a, b, ac = 0, bc = 0;\ncin >> t;\nwhile (t--) {\ncin >> a >> b;\nif (a > b) {\nac++;\n}\nelse if (a < b) {\nbc++;\n}\n}\ncout << ac << ' ' << bc << '\\n';\nreturn 0;\n}"
    },
    {
        "problem_tier": 5,
        "solution_code": "#include <iostream>\n#include <string>\nusing namespace std;\nint main() {\nstring input;\ncin >> input;\nif (input.substr(0, 2) == \"0x\") {\nint decimal = stoi(input, nullptr, 16);\ncout << decimal << endl;\n}\nelse if (input[0] == '0') {\nint decimal = stoi(input, nullptr, 8);\ncout << decimal << endl;\n}\nelse {\ncout << input << endl;\n}\nreturn 0;\n}"
    },
    {
        "problem_tier": 10,
        "solution_code": "#include <iostream>\n#include <climits>\nusing namespace std;\nconst int MAX = 10;\nint N;\nint cost[MAX][MAX];\nbool visited[MAX][MAX];\nint result = INT_MAX;\nbool check(int y, int x) {\nif (visited[y][x]) return true;\nfor (int i = -1; i <= 1; i++) {\nfor (int j = -1; j <= 1; j++) {\nint ny = y + i;\nint nx = x + j;\nif (visited[ny][nx]) return true;\n}\n}\nreturn false;\n}\nint calculateCost(int y, int x) {\nint cost = 0;\nfor (int i = -1; i <= 1; i++) {\nfor (int j = -1; j <= 1; j++) {\nint ny = y + i;\nint nx = x + j;\nvisited[ny][nx] = true;\ncost += cost[ny][nx];\n}\n}\nreturn cost;\n}\nvoid dfs(int y, int x, int depth, int totalCost) {\nif (depth == 3) {\nresult = min(result, totalCost);\nreturn;\n}\nfor (int i = 1; i < N - 1; i++) {\nfor (int j = 1; j < N - 1; j++) {\nif (check(i, j)) continue;\nint currentCost = calculateCost(i, j);\ndfs(i, j, depth + 1, totalCost + currentCost);\nfor (int k = -1; k <= 1; k++) {\nfor (int l = -1; l <= 1; l++) {\nint ny = i + k;\nint nx = j + l;\nvisited[ny][nx] = false;\n}\n}\n}\n}\n}\nint main() {\ncin >> N;\nfor (int i = 0; i < N; i++) {\nfor (int j = 0; j < N; j++) {\ncin >> cost[i][j];\n}\n}\ndfs(1, 1, 0, 0);\ncout << result << endl;\nreturn 0;\n}"
    },
    {
        "problem_tier": 3,
        "solution_code": "#include <iostream>\nusing namespace std;\nint main() {\nint N, W, H, L;\ncin >> N >> W >> H >> L;\nint room = (W / L) * (H / L);\nif (room > N)\ncout << N << endl;\nelse\ncout << room << endl;\nreturn 0;\n}"
    },
    {
        "problem_tier": 2,
        "solution_code": "#include <iostream>\nusing namespace std;\nint main() {\nios::sync_with_stdio(false);\ncin.tie(NULL);\nint T, S;\ncin >> T >> S;\nif (S == 0 && (12 <= T && T <= 16))\ncout << \"320\";\nelse\ncout << \"280\";\nreturn 0;\n}"
    },
    {
        "problem_tier": 6,
        "solution_code": "#include<iostream>\n#include<vector>\n#include<algorithm>\nusing namespace std;\nint main() {\nint n;\ncin >> n;\nvector<vector<int>> arr(n, vector<int>(5));\nfor(int i=0; i<n; i++){\nfor(int j=0; j<5; j++){\ncin >> arr[i][j];\n}\n}\nvector<int> cnt(n);\nfor(int i=0; i<n; i++){\nfor(int j=0; j<n; j++){\nif(i != j){                 for(int k=0; k<5; k++){                     if(arr[i][k] == arr[j][k]){                         cnt[i]++;\nbreak;\n}\n}\n}\n}\n}\nint max_duplicate = -1;     int answer = -1;\nfor(int i=0; i<n; i++){\nif(cnt[i] > max_duplicate){\nmax_duplicate = cnt[i];\nanswer = i+1;\n}\n}\ncout << answer << endl;\nreturn 0;\n}"
    },
    {
        "problem_tier": 14,
        "solution_code": "#include <iostream>\n#include <cmath>\n#include <vector>\n#include <algorithm>\n#include <string>\nusing namespace std;\nint arr[50][5] = {0};\nvoid makeVortex(int y1, int x1, int y2, int x2) {\nint dx[] = {-1, 0, 1, 0};     int dy[] = {0, -1, 0, 1};\nint offset = 0;     int num = 1;\nint count = 0;\nint x = 0;\nint y = 0;\nwhile (true) {\nif (-offset <= x && x <= offset && -offset <= y && y <= offset) {\nif (y1 <= x && x <= y2 && x1 <= y && y <= x2) {\narr[x - y1][y - x1] = num;\ncount++;\nif (count == (y2 - y1 + 1) * (x2 - x1 + 1)) break;\n}\nnum++;\n}\nint k = 0;         while (k < 4) {\nint nx = x + dx[k];\nint ny = y + dy[k];\nif (-offset <= nx && nx <= offset && -offset <= ny && ny <= offset) {\nif (y1 <= nx && nx <= y2 && x1 <= ny && ny <= x2) {\narr[nx - y1][ny - x1] = num;\ncount++;\nif (count == (y2 - y1 + 1) * (x2 - x1 + 1)) break;\n}\nx = nx;\ny = ny;\nnum++;\n} else {\nk++;\n}\n}\noffset++;\ny += 1;\n}\n}\nint findDigit() {\nint maxNum = -1;\nfor (int i = 0; i <= y2 - y1; i++) {\nfor (int j = 0; j <= x2 - x1; j++) {\nmaxNum = max(maxNum, arr[i][j]);\n}\n}\nreturn to_string(maxNum).length();\n}\nvoid printSolution() {\nint digit = findDigit();\nfor (int i = 0; i <= y2 - y1; i++) {\nfor (int j = 0; j <= x2 - x1; j++) {\nint size = to_string(arr[i][j]).length();\nfor (int k = 0; k < digit - size; k++) cout << \" \";\ncout << arr[i][j] << \" \";\n}\ncout << \"\\n\";\n}\n}\nint main() {\ncin.tie(0);\ncout.tie(0);\nios::sync_with_stdio(false);\nint y1, x1, y2, x2;\ncin >> y1 >> x1 >> y2 >> x2;\nmakeVortex(y1, x1, y2, x2);\nprintSolution();\nreturn 0;\n}"
    },
    {
        "problem_tier": 14,
        "solution_code": "#include <iostream>\nusing namespace std;\ntypedef long long LL;\nstruct coordinate {\nLL x;\nLL y;\nvoid read() {\ncin >> x >> y;\n}\n};\nLL ccw(LL ax, LL ay, LL bx, LL by, LL cx, LL cy){\nLL result = ax*by + bx*cy + cx*ay - bx*ay - cx*by - ax*cy;\nif (result > 0)\nreturn 1;\nelse if (result < 0)\nreturn -1;\nelse\nreturn 0;\n}\nbool isOverlapped(coordinate A, coordinate B, coordinate C, coordinate D) {\nint ans1 = ccw(A.x, A.y, B.x, B.y, C.x, C.y) * ccw(A.x, A.y, B.x, B.y, D.x, D.y);\nint ans2 = ccw(C.x, C.y, D.x, D.y, A.x, A.y) * ccw(C.x, C.y, D.x, D.y, B.x, B.y);\nreturn (ans1 < 0) && (ans2 < 0);\n}\nint main() {\ncoordinate A, B, C, D;\nA.read();\nB.read();\nC.read();\nD.read();\nif (isOverlapped(A, B, C, D))\ncout << \"1\";\nelse\ncout << \"0\";\nreturn 0;\n}"
    },
    {
        "problem_tier": 4,
        "solution_code": "#include <iostream>\nusing namespace std;\nint main() {\ndouble price, quantity;\nint n;\ncin >> price >> quantity;\ncin >> n;\ndouble minPricePerGram = price / quantity * 1000;\nwhile (n--) {\ndouble p, q;\ncin >> p >> q;\ndouble costPerGram = p / q * 1000;\nif (minPricePerGram > costPerGram) {\nminPricePerGram = costPerGram;\n}\n}\nprintf(\"%.2f\\n\", minPricePerGram);\nreturn 0;\n}"
    },
    {
        "problem_tier": 9,
        "solution_code": "#include<iostream>\nusing namespace std;\nint main() {\nios_base::sync_with_stdio(false);\ncin.tie(NULL);\ncout.tie(NULL);\nlong long int n;\ncin >> n;\nif (n % 2 == 1)\ncout << \"SK\";\nelse\ncout << \"CY\";\nreturn 0;\n}"
    },
    {
        "problem_tier": 17,
        "solution_code": "#include<iostream>\n#include<queue>\n#include<algorithm>\n#include<vector>\n#include<string.h>\nusing namespace std;\n#define INF 1000000000\n#define MAX_NODE 501\nint N, M;\nint S, D;\nvector<pair<int,int>> Graph[MAX_NODE];\nint Dist[MAX_NODE];\nint Route[MAX_NODE];\nvoid Dijkstra(int StartNode){\nfill(Dist, Dist+N, INF);\npriority_queue<pair<int,int>, vector<pair<int,int>>, greater<pair<int,int>>> pq;\npq.push({0, StartNode});\nDist[StartNode] = 0;\nwhile(!pq.empty()){\nint CurNode = pq.top().second;\nint CurCost = pq.top().first;\npq.pop();\nif(Dist[CurNode] < CurCost)\ncontinue;\nint Size = static_cast<int>(Graph[CurNode].size());\nfor(int i = 0; i < Size; ++i){\nif(Graph[CurNode][i].second == INF)\ncontinue;\nint NextNode = Graph[CurNode][i].first;\nint NextCost = Graph[CurNode][i].second + CurCost;\nif(Dist[NextNode] > NextCost){\npq.push({NextCost, NextNode});\nDist[NextNode] = NextCost;\nRoute[NextNode] = CurNode;\n}\n}\n}\n}\nvoid RemoveTrace(int StartNode, int EndNode){\nRoute[StartNode] = 0;\nint Index = EndNode;\nwhile(Route[Index] != 0){\nfor(size_t i = 0; i < Graph[Route[Index]].size(); ++i){\nif(Graph[Route[Index]][i].first == Index){\nGraph[Route[Index]][i].second = INF;\n}\n}\nIndex = Route[Index];\n}\nfor(size_t i = 0; i < Graph[StartNode].size(); ++i){\nif(Graph[StartNode][i].first == Index){\nGraph[StartNode][i].second = INF;\nbreak;\n}\n}\n}\nint main(){\nwhile(true){\ncin >> N >> M;\nif(N == 0 && M == 0)\nbreak;\ncin >> S >> D;\nfor(int i = 0; i < MAX_NODE; i++){\nGraph[i].clear();\n}\nint NodeA, NodeB, Cost;\nfor(int i = 0; i < M; ++i){\ncin >> NodeA >> NodeB >> Cost;\nGraph[NodeA].push_back({NodeB, Cost});\n}\nint MinCost = INF;\nint CurrentCost = INF;\nwhile(MinCost == CurrentCost){\nDijkstra(S);\nCurrentCost = Dist[D];\nMinCost = min(MinCost, CurrentCost);\nRemoveTrace(S, D);\n}\nif(INF != CurrentCost)\ncout << CurrentCost << \"\\n\";\nelse\ncout << -1 << \"\\n\";\n}\nreturn 0;\n}"
    },
    {
        "problem_tier": 4,
        "solution_code": "#include <iostream>\nusing namespace std;\nint main() {\ndouble a[5] = {350.34, 230.9, 190.55, 125.3, 180.9};\ndouble sum;\nint n;\ncin >> n;\nwhile(n--) {\nsum = 0;\nfor(int i = 0; i < 5; i++) {\ndouble x;\ncin >> x;\nsum += a[i] * x;\n}\nprintf(\"$%.2f\\n\", sum);\n}\nreturn 0;\n}"
    },
    {
        "problem_tier": 2,
        "solution_code": "#include <iostream>\n#include <string>\nusing namespace std;\nint main(){\nstring s;\ncin >> s;\nfor(int i = s.size() - 1; i >= 0; i--){\ncout << s[i];\n}\nreturn 0;\n}"
    },
    {
        "problem_tier": 4,
        "solution_code": "#include <iostream>\n#include <vector>\n#include <string>\n#define MAX 1000000\nusing namespace std;\nint main(void) {\nstring p;\nint k, size, psize, v[MAX];\nvector<int> prime;\ncin >> p >> k;\npsize = p.size();\nfor (int i = 2; i < MAX; i++) {\nv[i] = i;\n}\nfor (int i = 4; i < MAX; i += 2) {\nv[i] = 0;\n}\nfor (int i = 6; i < MAX; i += 3) {\nv[i] = 0;\n}\nfor (int i = 5; i < MAX; i += 6) {\nfor (int j = i + i; j < MAX; j += i) {\nv[j] = 0;\n}\n}\nfor (int i = 7; i < MAX; i += 6) {\nfor (int j = i + i; j < MAX; j += i) {\nv[j] = 0;\n}\n}\nfor (int i = 2; i < MAX; i++) {\nif (v[i] == i) {\nprime.push_back(i);\n}\n}\nsize = prime.size();\nfor (int i = 0; i < size && prime[i] < k; i++) {\nint pinit = 0;\nfor (int j = 0; j < psize; j++) {\npinit = (pinit * 10 + (p[j] - '0')) % prime[i];\n}\nif (!pinit) {\nprintf(\"BAD%d\", prime[i]);\nreturn 0;\n}"
    },
    {
        "problem_tier": 2,
        "solution_code": "#include <iostream>\nusing namespace std;\nint main() {\nint n;\ncin >> n;\nfor (int i = 0; i < n; i++) {\ncout << \"SciComLove\" << endl;\n}\nreturn 0;\n}"
    },
    {
        "problem_tier": 18,
        "solution_code": "#include <iostream>\n#include <string>\n#include <vector>\nusing namespace std;\nvector<int> getPi(string pattern) {\nint m = pattern.length();\nvector<int> pi(m, 0);\nint j = 0;\nfor (int i = 1; i < m; i++) {\nwhile (j > 0 && pattern[i] != pattern[j]) {\nj = pi[j - 1];\n}\nif (pattern[i] == pattern[j]) {\npi[i] = ++j;\n}\n}\nreturn pi;\n}\nint main() {\nios::sync_with_stdio(false);\ncin.tie(NULL);\ncout.tie(NULL);\nint L;\ncin >> L;\nstring ad;\ncin >> ad;\nvector<int> pi = getPi(ad);\ncout << L - pi[L - 1];\nreturn 0;\n}"
    },
    {
        "problem_tier": 8,
        "solution_code": "#include <iostream>\nusing namespace std;\nint main() {\nint n;\nlong long t[36] = {0,};\ncin >> n;\nt[0] = 1;\nfor (int i = 1; i < n + 1; i++) {\nfor (int j = 0; j < i; j++) {\nt[i] += t[j] * t[i-j-1];\n}\n}\ncout << t[n];\nreturn 0;\n}"
    },
    {
        "problem_tier": 2,
        "solution_code": "#include <iostream>\nusing namespace std;\nint main() {\nint n;\ncin >> n;\ncout << n % 21;\nreturn 0;\n}"
    },
    {
        "problem_tier": 9,
        "solution_code": "#include<iostream>\n#include<vector>\nusing namespace std;\nint main(){\nint N, X;\ncin >> N >> X;\nvector<int> arr(N);\nfor(int i=0; i<N; i++){\ncin >> arr[i];\n}\nint maxSum = 0, maxCount = 0;\nint sum = 0;\nfor(int i=0; i<X; i++){\nsum += arr[i];\n}\nmaxSum = sum;\nmaxCount = 1;\nfor(int i=X; i<N; i++){\nsum = sum - arr[i-X] + arr[i];\nif(sum > maxSum){\nmaxSum = sum;\nmaxCount = 1;\n}\nelse if(sum == maxSum){\nmaxCount++;\n}\n}\nif(maxSum == 0){\ncout << \"SAD\" << endl;\n}\nelse{\ncout << maxSum << endl;\ncout << maxCount << endl;\n}\nreturn 0;\n}"
    },
    {
        "problem_tier": 3,
        "solution_code": "#include<iostream>\nusing namespace std;\nstring fa(string x){\nstring tmp;\ntmp = ((x[0])-'0' * x.size()) + '0';\nreturn tmp;\n}\nint main() {\nstring x;\ncin >> x;\nfor (int i = 0; i < x.size(); i++){\nx = fa(x);\n}\nif (x.size() == 1)\ncout << \"FA\" << '\\n';\nelse\ncout << \"NFA\" << '\\n';\n}"
    },
    {
        "problem_tier": 5,
        "solution_code": "#include <iostream>\n#include <algorithm>\nusing namespace std;\nint main() {\nint N, m, M, T, R;\nint minute = 0;\nint pulse = m;\ncin >> N >> m >> M >> T >> R;\nif (M - m < T) {\ncout << -1;\nreturn 0;\n}"
    },
    {
        "problem_tier": 18,
        "solution_code": "#include <iostream>\n#include <vector>\n#include <cstring>\nusing namespace std;\nint V, E;\nvector<int> adj[10001];\nbool isCutVertex[10001];\nint discovered[10001];\nint cnt = 0;\nvoid input(){\ncin >> V >> E;\nint u, v;\nfor(int i = 0; i < E; i++){\ncin >> u >> v;\nadj[u].push_back(v);\nadj[v].push_back(u);\n}\nmemset(discovered, -1, sizeof(discovered));\n}\nint findCutVertex(int now, bool isroot){\ndiscovered[now] = cnt++;\nint ret = discovered[now];\nint child = 0;\nfor(int i = 0; i < adj[now].size(); i++){\nint next = adj[now][i];\nif(discovered[next] == -1){\nchild++;\nint subtree = findCutVertex(next, false);\nif(!isroot && subtree >= discovered[now]){\nisCutVertex[now] = true;\n}\nret = min(ret, subtree);\n}\nelse{\nret = min(ret, discovered[next]);\n}\n}\nif(isroot && child >= 2) isCutVertex[now] = true;\nreturn ret;\n}\nint main(){\nios_base::sync_with_stdio(false);\ncin.tie(0);\ncout.tie(0);\ninput();\nfor(int i = 1; i <= V; i++){\nif(discovered[i] != -1) continue;\nfindCutVertex(i, true);\n}\nvector<int> res;\nfor(int i = 1; i <= V; i++){\nif(isCutVertex[i]) res.push_back(i);\n}\ncout << res.size() << \"\\n\";\nfor(auto &w : res){\ncout << w << \" \";\n}\nreturn 0;\n}"
    },
    {
        "problem_tier": 2,
        "solution_code": "#include <iostream>\n#include <string>\nint main() {\nint n, m;\nstd::cin >> n >> m;\nstd::string a, b;\nstd::cin >> a >> b;\nint result[100000] = {0};\nfor (int i = 0; i < m; i++) {\nfor (int j = 0; j < n; j++) {\nint temp = (a[n-1-j] - '0') * (b[m-1-i] - '0');\nresult[n + m - 1 - i - j] += temp;\n}\n}\nfor (int i = n + m - 1; i > 0; i--) {\nresult[i-1] += result[i] / 10;\nresult[i] %= 10;\n}\nint flag = 0;\nfor (int i = 0; i < n + m; i++) {\nif (flag == 0) {\nif (result[i] != 0)\nflag = 1;\nelse if (i == n + m - 1)\nstd::cout << \"0\";\n}\nif (flag != 0)\nstd::cout << result[i];\n}\nreturn 0;\n}"
    },
    {
        "problem_tier": 12,
        "solution_code": "#include <iostream>\n#include <cmath>\nusing namespace std;\nlong long int gcd, lcm;\nlong long int resultA = 0, resultB = 0;\nint getGCD(int a, int b) {\nif (b == 0)\nreturn a;\nreturn getGCD(b, a % b);\n}\nvoid solve() {\nlong long int divide = lcm / gcd;\nfor (int i = 1; i <= sqrt(divide); i++) {\nif (divide % i == 0) {\nlong long int a = i, b = divide / i;\nif (getGCD(a, b) == 1) {\nresultA = a;\nresultB = b;\n}\n}\n}\ncout << resultA * gcd << \" \" << resultB * gcd << \"\\n\";\n}\nint main() {\nios::sync_with_stdio(false);\ncin.tie(nullptr);\ncout.tie(nullptr);\ncin >> gcd >> lcm;\nsolve();\nreturn 0;\n}"
    },
    {
        "problem_tier": 15,
        "solution_code": "#include <iostream>\n#include <vector>\n#include <algorithm>\nusing namespace std;\nstruct Village {\nint DP[2];\nvector<int> link;\nint population;\nbool visited;\n};\nint N;\nvector<Village> villages;\nint maxPopulation(int a, int b) {\nif (a > b)\nreturn a;\nelse\nreturn b;\n}\nvoid dfs(int cur) {\nvillages[cur].visited = true;\nvillages[cur].DP[0] = 0;\nvillages[cur].DP[1] = villages[cur].population;\nfor (size_t i = 0; i < villages[cur].link.size(); ++i) {\nint next = villages[cur].link[i];\nif (villages[next].visited)\ncontinue;\ndfs(next);\nvillages[cur].DP[0] += maxPopulation(villages[next].DP[0], villages[next].DP[1]);\nvillages[cur].DP[1] += villages[next].DP[0];\n}\n}\nint main() {\nios::sync_with_stdio(0);\ncin.tie(0);\ncout.tie(0);\ncin >> N;\nVillage dummy;\nvillages.push_back(dummy);\nfor (int i = 1; i <= N; ++i) {\nVillage v;\ncin >> v.population;\nvillages.push_back(v);\n}\nfor (int i = 0; i < N - 1; ++i) {\nint from, to;\ncin >> from >> to;\nvillages[from].link.push_back(to);\nvillages[to].link.push_back(from);\n}\ndfs(1);\ncout << maxPopulation(villages[1].DP[0], villages[1].DP[1]);\nreturn 0;\n}"
    },
    {
        "problem_tier": 2,
        "solution_code": "#include <iostream>\n#include <vector>\nusing namespace std;\nint main() {\nint m, n;\nint dx[] = { -1, -1, -1, 0, 0, 1, 1, 1 };\nint dy[] = { -1, 0, 1, -1, 1, -1, 0, 1 };\nwhile (cin >> m >> n && (m != 0 && n != 0)) {\nvector<vector<char>> board(m, vector<char>(n));\nfor (int i = 0; i < m; i++) {\nfor (int j = 0; j < n; j++) {\ncin >> board[i][j];\n}\n}\nvector<vector<int>> result(m, vector<int>(n, 0));\nfor (int i = 0; i < m; i++) {\nfor (int j = 0; j < n; j++) {\nif (board[i][j] == '*') {\nfor (int k = 0; k < 8; k++) {                         int nx = i + dx[k];\nint ny = j + dy[k];\nif (nx >= 0 && nx < m && ny >= 0 && ny < n && board[nx][ny] != '*') {\nresult[nx][ny] += 1;\n}\n}\n}\n}\n}\nfor (int i = 0; i < m; i++) {\nfor (int j = 0; j < n; j++) {\nif (board[i][j] == '*') {\ncout << \"*\";\n} else {\ncout << result[i][j];\n}\n}\ncout << endl;\n}\ncout << endl;\n}\nreturn 0;\n}"
    },
    {
        "problem_tier": 5,
        "solution_code": "#include<iostream>\n#include<string>\nusing namespace std;\nint main() {\nint s1, s2, s3;\nint countarr[81] = {};\ncin >> s1 >> s2 >> s3;\nint max = 0;\nfor(int i=1; i<=s1; i++) {\nfor(int j=1; j<=s2; j++) {\nfor(int h=1; h<=s3; h++) {\ncountarr[i+j+h]++;\nif(countarr[i+j+h] > max){\nmax = countarr[i+j+h];\n}\n}\n}\n}\nfor(int i=3; i<=s1+s2+s3; i++) {\nif(max == countarr[i]){\ncout << i << endl;\nbreak;\n}\n}\nreturn 0;\n}"
    },
    {
        "problem_tier": 5,
        "solution_code": "#include<iostream>\n#include<vector>\nusing namespace std;\nint main() {\nint n;\ncin >> n;\nvector<int> trophies(n);\nfor (int i = 0; i < n; i++) {\ncin >> trophies[i];\n}\nint leftCnt = 1;\nint rightCnt = 1;\nint leftMax = trophies[0];\nint rightMax = trophies[n-1];\nfor (int i = 1; i < n; i++) {\nif (trophies[i] > leftMax) {\nleftCnt++;\nleftMax = trophies[i];\n}\n}\nfor (int i = n-2; i >= 0; i--) {\nif (trophies[i] > rightMax) {\nrightCnt++;\nrightMax = trophies[i];\n}\n}\ncout << leftCnt << endl;\ncout << rightCnt << endl;\nreturn 0;\n}"
    },
    {
        "problem_tier": 2,
        "solution_code": "#include<iostream>\nusing namespace std;\nint main() {\nint n;\ncin >> n;\ncout << n * n * n;\nreturn 0;\n}"
    },
    {
        "problem_tier": 5,
        "solution_code": "#include <iostream>\n#include <stack>\nusing namespace std;\nvoid printBinary(unsigned long long val) {\nstack<int> s;\nwhile (val > 0) {\ns.push(val % 2);\nval /= 2;\n}\nwhile (!s.empty()) {\ncout << s.top();\ns.pop();\n}\n}\nint main() {\nunsigned long long v;\ncin >> v;\nprintBinary(v);\nreturn 0;\n}"
    },
    {
        "problem_tier": 5,
        "solution_code": "#include <iostream>\nusing namespace std;\nint main() {\nint e, f, c;\ncin >> e >> f >> c;\nint empty_cola = e + f;\nint total = 0;\nwhile (empty_cola >= c) {\ntotal += empty_cola / c;         empty_cola = empty_cola / c + empty_cola % c;     }\ncout << total << '\\n';\nreturn 0;\n}"
    },
    {
        "problem_tier": 12,
        "solution_code": "#include <iostream>\n#include <algorithm>\n#define MAX 987654321\nusing namespace std;\nint n, ans = MAX, cnt = 0;\nstring st, dt, temp;\nvoid input() {\ncin >> n;\ncin >> st;\ncin >> dt;\n}\nvoid lightOn(int idx) {\nif (idx > 0)\ntemp[idx - 1] = (temp[idx - 1] == '0') ? '1' : '0';\ntemp[idx] = (temp[idx] == '0') ? '1' : '0';\nif (idx < n - 1)\ntemp[idx + 1] = (temp[idx + 1] == '0') ? '1' : '0';\n}\nvoid solve(int first) {\ntemp = st;\ncnt = 0;\nif (first == 0) {\ntemp[0] = (temp[0] == '0') ? '1' : '0';\ntemp[1] = (temp[1] == '0') ? '1' : '0';\ncnt++;\n}\nfor (int i = 1; i < n; i++) {\nif (temp[i - 1] != dt[i - 1]) {\nlightOn(i);\ncnt++;\n}\n}\nif (temp == dt)\nans = min(ans, cnt);\n}\nint main() {\nios_base::sync_with_stdio(false);\ncin.tie(NULL);\ncout.tie(NULL);\ninput();\nsolve(0);\nsolve(1);\nif (ans != MAX)\ncout << ans << \"\\n\";\nelse\ncout << -1 << \"\\n\";\nreturn 0;\n}"
    },
    {
        "problem_tier": 13,
        "solution_code": "#include <iostream>\n#include <queue>\n#include <vector>\nusing namespace std;\nint N, M;\nchar board[21][21];\nint dx[4] = { -1, 1, 0, 0 };\nint dy[4] = { 0, 0, -1, 1 };\nvector<pair<int, int>> start;\nbool outRange(int x, int y) {\nif (x < 0 || x >= N || y < 0 || y >= M) return true;\nelse return false;\n}\nint bfs() {\nqueue<pair<pair<int, int>, pair<int, int>>> q;\nq.push({ start[0], start[1] });\nint cnt = 1;\nwhile (!q.empty()) {\nint size = q.size();\nif (cnt > 10) break;\nfor (int i = 0; i < size; i++) {\npair<int, int> coin1 = q.front().first;\npair<int, int> coin2 = q.front().second;\nq.pop();\nfor (int dir = 0; dir < 4; dir++) {\nint nx1 = coin1.first + dx[dir];\nint ny1 = coin1.second + dy[dir];\nint nx2 = coin2.first + dx[dir];\nint ny2 = coin2.second + dy[dir];\nbool coin1OutRange = outRange(nx1, ny1);\nbool coin2OutRange = outRange(nx2, ny2);\nif (coin1OutRange && coin2OutRange) continue;\nelse if (!coin1OutRange && !coin2OutRange) {\nif (board[nx1][ny1] == '#') {\nnx1 = coin1.first;\nny1 = coin1.second;\n}\nif (board[nx2][ny2] == '#') {\nnx2 = coin2.first;\nny2 = coin2.second;\n}\nq.push({ {nx1, ny1}, {nx2, ny2} });\n}\nelse {\nreturn cnt;\n}\n}\n}\ncnt++;     }\nreturn -1; }\nint main() {\nios::sync_with_stdio(0);\ncin.tie(0), cout.tie(0);\ncin >> N >> M;\nfor (int i = 0; i < N; i++) {\nfor (int j = 0; j < M; j++) {\ncin >> board[i][j];\nif (board[i][j] == 'o') {\nstart.push_back({ i, j });\n}\n}\n}\nint result = bfs();\nif (result == -1 || result > 10) cout << -1 << endl;\nelse cout << result << endl;\nreturn 0;\n}"
    },
    {
        "problem_tier": 2,
        "solution_code": "#include <bits/stdc++.h>\nusing namespace std;\nint main() {\nint N, M;\ncin >> N >> M;\nint diff = M - N;\ncout << diff << endl;\nreturn 0;\n}"
    },
    {
        "problem_tier": 5,
        "solution_code": "#include<iostream>\n#include<cmath>\nusing namespace std;\nint cnt(int n){\nint count = 0;\nfor (int i = 1; i <= sqrt(n); i++){\nif (!(n % i)){\ncount++;\n}\n}\nreturn count;\n}\nint main() {\nint n;\ncin >> n;\nint d[n+1];\nd[1] = 1;\nd[2] = 2;\nfor (int i = 3; i <= n; i++){\nd[i] = d[i-1] + cnt(i);\n}\ncout << d[n];\nreturn 0;\n}"
    },
    {
        "problem_tier": 15,
        "solution_code": "#include<iostream>\n#include<vector>\n#include<cmath>\n#include<climits>\n#include<algorithm>\nvoid solve(void);\ndouble get_minimum(const int idx, const int count, std::pair<int,int> current, std::vector<std::pair<int,int>>& points);\nint main(void){\nstd::ios::sync_with_stdio(false);\nstd::cin.tie(NULL);\nint test_case;\nstd::cin >> test_case;\nfor(int t=0; t<test_case; t++)\nsolve();\n}\ndouble get_minimum(const int idx, const int count, std::pair<int,int> current, std::vector<std::pair<int,int>>& points){\nif(points.size() == idx){\nif(count == points.size()/2)\nreturn sqrt(pow(current.first,2) + pow(current.second,2));\nreturn LLONG_MAX;\n}\nstd::pair<int,int>& temp = points[idx];\nif(points.size()/2 == count)\nreturn get_minimum(idx+1, count, std::make_pair(current.first - temp.first, current.second - temp.second), points);\ndouble return_a = get_minimum(idx+1, count, std::make_pair(current.first - temp.first, current.second - temp.second), points);\ndouble return_b = get_minimum(idx+1, count+1, std::make_pair(current.first + temp.first, current.second + temp.second), points);\nreturn return_a < return_b ? return_a : return_b;\n}\nvoid solve(void){\nint n;\nstd::cin >> n;\nstd::vector<std::pair<int,int>> point;\nfor(int i=0; i<n; i++){\nint x, y;\nstd::cin >> x >> y;\npoint.push_back(std::make_pair(x,y));\n}\ndouble minimum = LLONG_MAX;\ndouble m = get_minimum(0, 0, std::make_pair(0,0), point);\nminimum = m < minimum ? m : minimum;\nstd::cout << std::fixed;\nstd::cout.precision(12);\nstd::cout << minimum << '\\n';\n}"
    },
    {
        "problem_tier": 17,
        "solution_code": "#include <iostream>\n#include <vector>\n#include <algorithm>\n#include <stack>\n#define MAX 1000010\nusing namespace std;\nint N;\nint dp[MAX], memo[MAX];\nvector<pair<int, int>> arr;\nstack<int> ans;\nint len = 0, a, b;\nint main() {\nios::sync_with_stdio(0);\ncin.tie(0);\ncout.tie(0);\ncin >> N;\nfor(int i=0; i<N; i++){\ncin >> a >> b;\narr.push_back({a, b});\n}\nsort(arr.begin(), arr.end());\ndp[len++] = arr[0].second;\nmemo[0] = 0;\nfor(int i=1; i<N; i++){\nif(arr[i].second > dp[len-1]){\ndp[len++] = arr[i].second;\nmemo[i] = len-1;\n}\nelse{\nint *iter = lower_bound(dp, dp+len, arr[i].second);\n*iter = arr[i].second;\nmemo[i] = iter - dp;\n}\n}\ncout << N - len << \"\\n\";\nint cnt = len - 1;\nfor(int i=N-1; i>=0; i--){\nif(cnt == memo[i]){\nans.push(i);\ncnt--;\n}\n}\na = ans.top();\nans.pop();\nfor(int i=0; i<N; i++){\nif(a == i){\nif(ans.empty()) continue;\na = ans.top();\nans.pop();\n}\nelse{\ncout << arr[i].first << \"\\n\";\n}\n}\nreturn 0;\n}"
    },
    {
        "problem_tier": 4,
        "solution_code": "#include <iostream>\nusing namespace std;\nint main() {\nint t;\ncin >> t;\nwhile (t--) {\nint hp, mp, attack, defense;\ncin >> hp >> mp >> attack >> defense;\nint bonus_hp, bonus_mp, bonus_attack, bonus_defense;\ncin >> bonus_hp >> bonus_mp >> bonus_attack >> bonus_defense;\nhp += bonus_hp;\nmp += bonus_mp;\nattack += bonus_attack;\ndefense += bonus_defense;\nif (attack < 0)\nattack = 0;\nif (hp < 1)\nhp = 1;\nif (mp < 1)\nmp = 1;\nint power = hp + 5 * mp + 2 * attack + 2 * defense;\ncout << power << '\\n';\n}\nreturn 0;\n}"
    },
    {
        "problem_tier": 4,
        "solution_code": "#include <iostream>\nusing namespace std;\nint main() {\nint t;\ncin >> t;\nfor (int i = 0; i < t; i++) {\nint n, m;\ncin >> n >> m;\nint u = 2 * m - n;\nint v = n - m;\ncout << u << \" \" << v << endl;\n}\nreturn 0;\n}"
    },
    {
        "problem_tier": 10,
        "solution_code": "#include <iostream>\n#include <vector>\n#include <algorithm>\nusing namespace std;\nint main() {\nint N;\ncin >> N;\nvector<int> arr(N);\nfor(int i=0; i<N; i++) {\ncin >> arr[i];\n}\nvector<int> dp(N, 1);\nfor(int i=1; i<N; i++) {\nfor(int j=0; j<i; j++) {\nif(arr[j] > arr[i]) {\ndp[i] = max(dp[i], dp[j]+1);\n}\n}\n}\nint max_num = 0;\nfor(int i=0; i<N; i++) {\nmax_num = max(max_num, dp[i]);\n}\ncout << N - max_num << endl;\nreturn 0;\n}"
    },
    {
        "problem_tier": 4,
        "solution_code": "#include <iostream>\nusing namespace std;\nint main() {\nint n;\ncin >> n;\nfor (int i = 0; i < n; i++) {\ndouble price;\ncin >> price;\nprintf(\"$%.2f\\n\", price * 0.8);\n}\nreturn 0;\n}"
    },
    {
        "problem_tier": 7,
        "solution_code": "#include <iostream>\nusing namespace std;\nlong long GCD(long long a, long long b) {\nif(a < b) {\nreturn GCD(a, b % a);\n}\nif(b == 0) {\nreturn a;\n}\nreturn GCD(b, a % b);\n}\nlong long LCM(long long a, long long b) {\nreturn a * b / GCD(a, b);\n}\nint main() {\nint t;\ncin >> t;\nwhile(t--) {\nlong long a, b;\ncin >> a >> b;\ncout << LCM(a, b) << '\\n';\n}\nreturn 0;\n}"
    },
    {
        "problem_tier": 8,
        "solution_code": "#include<iostream>\n#include<algorithm>\n#include<climits>\nusing namespace std;\nint main() {\nint tc;\ncin >> tc;\nwhile(tc--) {\nint n;\ncin >> n;\nint arr[n];\nfor(int i = 0; i < n; i++) {\ncin >> arr[i];\n}\nint maxSum = INT_MIN;\nint currSum = 0;\nfor(int i = 0; i < n; i++) {\ncurrSum += arr[i];\nmaxSum = max(maxSum, currSum);\nif(currSum < 0) {\ncurrSum = 0;\n}\n}\ncout << maxSum << endl;\n}\nreturn 0;\n}"
    },
    {
        "problem_tier": 14,
        "solution_code": "#include <iostream>\n#include <vector>\n#include <queue>\n#include <cstring>\nusing namespace std;\nint N, M, res = 987654321;\nint sX, sY, sD; int eX, eY, eD; int dx[4] = {1, 0, -1, 0}; int dy[4] = {0, -1, 0, 1};\nint p[110][110]; int visit[110][110][5];\nstruct robot{\nint x;\nint y;\nint dir;\n};\nvoid bfs(){\nvisit[sX][sY][sD] = 0;\nqueue<robot> q;\nq.push({sX, sY, sD});\nwhile(!q.empty()){\nint x = q.front().x;\nint y = q.front().y;\nint dir = q.front().dir;\nq.pop();\nif(x == eX && y == eY && dir == eD){             res = min(res, visit[x][y][dir]);\ncontinue;\n}\nint nD = (dir + 1) % 4;         if(visit[x][y][nD] == -1){\nq.push({x, y, nD});\nvisit[x][y][nD] = visit[x][y][dir] + 1;\n}\nnD = (dir + 3) % 4;         if(visit[x][y][nD] == -1){\nq.push({x, y, nD});\nvisit[x][y][nD] = visit[x][y][dir] + 1;\n}\nfor(int i = 1; i <= 3; i++){\nint nx = x + i * dx[dir];\nint ny = y + i * dy[dir];\nif(nx < 1 || ny < 1 || nx > N || ny > M) continue;\nif(p[nx][ny] == 1) break;\nif(visit[nx][ny][dir] == -1 || visit[nx][ny][dir] > visit[x][y][dir] + 1){\nq.push({nx, ny, dir});\nvisit[nx][ny][dir] = visit[x][y][dir] + 1;\n}\n}\n}\n}\nint main(){\ncin >> N >> M;\nfor(int i = 1; i <= N; i++)\nfor(int j = 1; j <= M; j++)\ncin >> p[i][j];\ncin >> sX >> sY >> sD >> eX >> eY >> eD;     if(sD == 1) sD = 3;\nelse if(sD == 2) sD = 1;\nelse if(sD == 3) sD = 0;\nelse sD = 2;\nif(eD == 1) eD = 3;\nelse if(eD == 2) eD = 1;\nelse if(eD == 3) eD = 0;\nelse eD = 2;\nmemset(visit, -1, sizeof(visit));\nbfs();\ncout << res;\nreturn 0;\n}"
    },
    {
        "problem_tier": 6,
        "solution_code": "#include<iostream>\n#include<algorithm>\n#include<string>\nusing namespace std;\nint main() {\nios_base::sync_with_stdio(0);\ncin.tie(0);\ncout.tie(0);\nint test;\ncin >> test;\nfor(int i = 0; i < test; i++) {\nstring a1, a2, tmp1, tmp2;\ncin >> a1 >> a2;\ntmp1 = a1;\ntmp2 = a2;\nsort(a1.begin(), a1.end());\nsort(a2.begin(), a2.end());\nif(a1 == a2)\ncout << tmp1 << \"&\" << tmp2 << \" are anagrams.\\n\";\nelse\ncout << tmp1 << \"&\" << tmp2 << \" are NOT anagrams.\\n\";\n}\nreturn 0;\n}"
    },
    {
        "problem_tier": 1,
        "solution_code": "#include <iostream>\n#include <cstdlib>\n#include <ctime>\nusing namespace std;\nint main() {\nsrand(time(NULL));\nint num = rand() % 10 + 1;\ncout << num;\nreturn 0;\n}"
    },
    {
        "problem_tier": 16,
        "solution_code": "#include <bits/stdc++.h>\nusing namespace std;\ntypedef long long ll;\nmap<ll, ll> prime;\nvoid prime_factorization(ll n) {\nll k = 2;\nwhile(k*k <= n){\nif(n % k == 0){\nprime[k]++;\nn /= k;\ncontinue;\n}\nk++;\n}\nprime[n]++;\n}\nint main() {\nll n;\nll ans = 1;\nscanf(\"%lld\", &n);\nif(n == 1){\nprintf(\"1\");\nreturn 0;\n}"
    },
    {
        "problem_tier": 11,
        "solution_code": "#include<iostream>\n#include<vector>\n#include<algorithm>\nusing namespace std;\nint N, maxEnergy = 0;\nvector<int> balls;\nvoid energy(vector<int>& v, int ans) {\nif (v.size() == 3) {\nans += v[0] * v[2];\nmaxEnergy = max(maxEnergy, ans);\nreturn;\n}\nfor (int i = 0; i < v.size() - 2; i++) {\nvector<int> vCopy = v;\nvCopy.erase(vCopy.begin() + i + 1);\nenergy(vCopy, ans + (v[i] * v[i + 2]));\n}\n}\nint main() {\nios_base::sync_with_stdio(false);\ncin.tie(NULL);\ncout.tie(NULL);\ncin >> N;\nfor (int i = 0; i < N; i++) {\nint num;\ncin >> num;\nballs.push_back(num);\n}\nenergy(balls, 0);\ncout << maxEnergy << \"\\n\";\nreturn 0;\n}"
    },
    {
        "problem_tier": 10,
        "solution_code": "#include <iostream>\n#include <vector>\nusing namespace std;\nbool isSimilar(int* a, int* b) {\nint s = 0, first = -1;\nfor (int i = 0; i < 26; ++i) {\nif (a[i] != b[i]) {\nif (first == -1) first = i;\nif (a[i] - b[i] > 1 || a[i] - b[i] < -1) return false;\nelse {\n++s;\nif (s == 2)\nif ((a[first] + a[i]) != (b[first] + b[i])) return false;\nif (s >= 3) return false;\n}\n}\n}\nreturn true;\n}\nint main() {\nint n, i, count = 0;\nchar ori[15];\nchar buf[15];\nint c1[26] = {0};\nscanf(\"%d\", &n);\nscanf(\"%s\", ori);\ni = 0;\nwhile (ori[i]) ++c1[ori[i++] - 'A'];\nfor (int j = 1; j < n; ++j) {\nscanf(\"%s\", buf);\nint c2[26] = {0};\ni = 0;\nwhile (buf[i]) ++c2[buf[i++] - 'A'];\nif (isSimilar(c1, c2)) count++;\n}\nprintf(\"%d\\n\", count);\nreturn 0;\n}"
    },
    {
        "problem_tier": 8,
        "solution_code": "#include<iostream>\nusing namespace std;\nint main() {\nint n, k;\ncin >> n >> k;\nint sum = 0;\nfor (int i = 1; i <= k; i++) {\nsum += i;\n}\nn -= sum;\nif (n < 0) {\ncout << -1;\n}\nelse {\nif (n % k == 0) {\ncout << k - 1;\n}\nelse {\ncout << k;\n}\n}\nreturn 0;\n}"
    },
    {
        "problem_tier": 15,
        "solution_code": "#include <iostream>\n#include <cstring>\nusing namespace std;\nconst int MAX = 50;\nint N, M;\nint Answer;\nint MAP[MAX][MAX];\nint DP[MAX][MAX];\nbool Visit[MAX][MAX];\nint dx[] = {0, 0, 1, -1};\nint dy[] = {1, -1, 0, 0};\nint Bigger(int A, int B)\n{\nif (A > B)\nreturn A;\nreturn B;\n}\nvoid Input()\n{\ncin >> N >> M;\nfor (int i = 0; i < N; i++)\n{\nstring S;\ncin >> S;\nfor (int j = 0; j < S.length(); j++)\n{\nif (S[j] == 'H')\nMAP[i][j] = 0;\nelse\nMAP[i][j] = S[j] - '0';\n}\n}\n}\nint DFS(int x, int y)\n{\nif (x < 0 || y < 0 || x >= N || y >= M || MAP[x][y] == 0)\nreturn 0;\nif (Visit[x][y] == true)\n{\ncout << -1 << endl;\nexit(0);\n}\nif (DP[x][y] != -1)\nreturn DP[x][y];\nVisit[x][y] = true;\nDP[x][y] = 0;\nfor (int i = 0; i < 4; i++)\n{\nint nx = x + (MAP[x][y] * dx[i]);\nint ny = y + (MAP[x][y] * dy[i]);\nDP[x][y] = Bigger(DP[x][y], DFS(nx, ny) + 1);\n}\nVisit[x][y] = false;\nreturn DP[x][y];\n}\nvoid Solution()\n{\nmemset(DP, -1, sizeof(DP));\nAnswer = DFS(0, 0);\ncout << Answer << endl;\n}\nvoid Solve()\n{\nInput();\nSolution();\n}\nint main(void)\n{\nios::sync_with_stdio(false);\ncin.tie(NULL);\ncout.tie(NULL);\nSolve();\nreturn 0;\n}"
    },
    {
        "problem_tier": 12,
        "solution_code": "#include <iostream>\nusing namespace std;\nstruct Egg {\nint durability;\nint weight;\n};\nint N;\nEgg eggs[10];\nint answer;\nvoid backTracking(int x) {\nif (x > N + 1)\nreturn;\nfor (int i = 1; i <= N; i++) {\nif (eggs[x].durability <= 0)\nbackTracking(x + 1);\nelse if (x == i || eggs[i].durability <= 0)\ncontinue;\nelse {\neggs[x].durability -= eggs[i].weight;\neggs[i].durability -= eggs[x].weight;\nbackTracking(x + 1);\neggs[i].durability += eggs[x].weight;\neggs[x].durability += eggs[i].weight;\n}\n}\nint tmp = 0;\nfor (int i = 1; i <= N; i++) {\nif (eggs[i].durability <= 0)\ntmp++;\n}\nanswer = max(answer, tmp);\n}\nint main() {\ncin >> N;\nfor (int i = 1; i <= N; i++) {\nint v1, v2;\ncin >> v1 >> v2;\neggs[i] = {v1, v2};\n}\nbackTracking(1);\ncout << answer;\nreturn 0;\n}"
    },
    {
        "problem_tier": 4,
        "solution_code": "#include <iostream>\n#include <string>\nusing namespace std;\nint main() {\nstring s;\ncin >> s;\nstring shifted = s + \"0000\";     string res = shifted;\nint resPos = res.size();\nfor (int i = s.size() - 1; i >= 0; i--) {\nresPos--;\nif (s[i] == '0') continue;\nres[resPos]++;\n}\nfor (int i = res.size() - 1; i > 0; i--) {\nif (res[i] >= '2') {\nres[i - 1] += (res[i] - '0') / 2;\nres[i] = ((res[i] - '0') % 2) + '0';\n}\n}\nif (res[0] == '2') {\nres[0] = '0';\ncout << \"1\";\n}\nelse if (res[0] == '3') {\nres[0] = '1';\ncout << \"1\";\n}\nelse if (res[0] == '4') {\nres[0] = '0';\ncout << \"10\";\n}\ncout << res;\nreturn 0;\n}"
    },
    {
        "problem_tier": 8,
        "solution_code": "#include <iostream>\n#include <vector>\n#include <algorithm>\nusing namespace std;\nint n, m, cnt = 0;\nvector<int> graph[201], combCk;\nbool isValid(int s, int e) {\nfor(auto next : graph[s]) {\nif(next == e)\nreturn false;\n}\nreturn true;\n}\nint main() {\ncin >> n >> m;\nfor(int i=0, a, b; i<m; i++) {\ncin >> a >> b;\ngraph[a].push_back(b);\ngraph[b].push_back(a);\n}\ncombCk.resize(n, 1);\nfor(int i=0; i<3; i++)\ncombCk[i] = 0;\ndo {\nint can = 1;\nvector<int> tmp;\nfor(int i=0; i<n; i++) {\nif(!combCk[i])\ntmp.push_back(i+1);\n}\nfor(int i=0; i<3; i++) {\nfor(int j=i+1; j<3; j++) {\nif(!isValid(tmp[i], tmp[j])) {\ncan = 0;\nbreak;\n}\n}\n}\nif(can)\ncnt++;\n} while(next_permutation(combCk.begin(), combCk.end()));\ncout << cnt;\nreturn 0;\n}"
    },
    {
        "problem_tier": 17,
        "solution_code": "#include <iostream>\n#include <vector>\n#include <map>\n#define MAX 500000\nusing namespace std;\nlong long tree[MAX * 4];\nmap<int, int> m;\nint arr2[MAX + 1];\nlong long sum(int node, int start, int end, int left, int right) {\nif (left > end || right < start) return 0;\nelse if (left <= start && end <= right) return tree[node];\nint mid = (start + end) / 2;\nreturn sum(node * 2, start, mid, left, right) + sum(node * 2 + 1, mid + 1, end, left, right);\n}\nvoid update(int node, int start, int end, int diff, int index) {\nif (index < start || index > end) return;\ntree[node] += diff;\nif (start != end) {\nint mid = (start + end) / 2;\nupdate(node * 2, start, mid, diff, index);\nupdate(node * 2 + 1, mid + 1, end, diff, index);\n}\n}\nint main(void) {\nios_base::sync_with_stdio(false);\ncin.tie(NULL);\nint N;\ncin >> N;\nfor (int i = 0; i < N; i++) {\nint x;\ncin >> x;\nm[x] = i;\n}\nfor (int i = 0; i < N; i++) {\nint x;\ncin >> x;\narr2[i] = m[x];\n}\nlong long ans = 0;\nfor (int i = 0; i < N; i++) {\nans += sum(1, 0, N - 1, arr2[i] + 1, N - 1);\nupdate(1, 0, N - 1, 1, arr2[i]);\n}\ncout << ans;\nreturn 0;\n}"
    },
    {
        "problem_tier": 14,
        "solution_code": "#include <iostream>\nusing namespace std;\nconst int MOD = 1'000'000'003;\nint dp[1001][1001] = {0};\nint main() {\nios_base::sync_with_stdio(false);\ncin.tie(0);\nint n, k;\ncin >> n >> k;\nfor (int i = 1; i <= n; i++) {\ndp[i][1] = i;\nfor (int j = 2; j <= i / 2; j++) {\ndp[i][j] = (dp[i - 1][j] + dp[i - 2][j - 1]) % MOD;\n}\n}\nint result = dp[n][k];\ncout << result << endl;\nreturn 0;\n}"
    },
    {
        "problem_tier": 4,
        "solution_code": "#include <iostream>\nusing namespace std;\nint getClapNum(int num) {\nint cnt = 0;\nint tmp = num;\nwhile (tmp) {\nif (tmp % 10 == 3 || tmp % 10 == 6 || tmp % 10 == 9)\ncnt++;\ntmp /= 10;\n}\nreturn cnt;\n}\nint main() {\nint n, ans = 0;\ncin >> n;\nfor (int i = 1; i <= n; i++)\nans += getClapNum(i);\ncout << ans;\nreturn 0;\n}"
    },
    {
        "problem_tier": 12,
        "solution_code": "#include <iostream>\n#include <map>\nusing namespace std;\ntypedef long long ll;\nmap<ll, ll> M;\nll ans(ll value, ll div1, ll div2) {\nif (value == 0) {\nreturn 1;\n}\nauto VdivP = M.find(value / div1);\nll sum = 0;\nif (VdivP == M.end()) {\nll temp = ans(value / div1, div1, div2);\nM.insert({ value / div1, temp });\nsum += temp;\n} else {\nsum += (VdivP->second);\n}\nauto VdivQ = M.find(value / div2);\nif (VdivQ == M.end()) {\nll temp = ans(value / div2, div1, div2);\nM.insert({ value / div2, temp });\nsum += temp;\n} else {\nsum += (VdivQ->second);\n}\nreturn sum;\n}\nint main() {\nios_base::sync_with_stdio(false);\ncin.tie(NULL);\ncout.tie(NULL);\nll N, P, Q;\ncin >> N >> P >> Q;\ncout << ans(N, P, Q) << \"\\n\";\nreturn 0;\n}"
    },
    {
        "problem_tier": 18,
        "solution_code": "#include <iostream>\n#include <vector>\n#include <queue>\n#include <functional>\nusing namespace std;\n#define INF 1000000000\nint N, M, K;\nvector<pair<int, int>> line[1001];\npriority_queue<int> kthShortestPaths[1001];\nvoid Dijkstra() {\npriority_queue<pair<int, int>, vector<pair<int, int>>, greater<pair<int, int>>> pq;\npq.push(make_pair(0, 1));\nkthShortestPaths[1].push(0);\nwhile (!pq.empty()) {\nint cur = pq.top().second;\nint dist = pq.top().first;\npq.pop();\nfor (int i = 0; i < line[cur].size(); i++) {\nint next = line[cur][i].first;\nint cost = line[cur][i].second;\nif (kthShortestPaths[next].size() < K) {\nkthShortestPaths[next].push(dist + cost);\npq.push(make_pair(dist + cost, next));\n} else if (kthShortestPaths[next].top() > dist + cost) {\nkthShortestPaths[next].pop();\nkthShortestPaths[next].push(dist + cost);\npq.push(make_pair(dist + cost, next));\n}\n}\n}\n}\nint main() {\nios_base::sync_with_stdio(false);\ncin.tie(NULL);\ncout.tie(NULL);\ncin >> N >> M >> K;\nfor (int i = 0; i < M; i++) {\nint x, y, cost;\ncin >> x >> y >> cost;\nline[x].push_back(make_pair(y, cost));\n}\nDijkstra();\nfor (int i = 1; i <= N; i++) {\nif (kthShortestPaths[i].size() == K) {\ncout << kthShortestPaths[i].top() << \"\\n\";\n} else {\ncout << -1 << \"\\n\";\n}\n}\nreturn 0;\n}"
    },
    {
        "problem_tier": 5,
        "solution_code": "#include<iostream>\n#include<vector>\n#include<sstream>\n#include<algorithm>\nusing namespace std;\nvector<string> tokenize(const string& sentence, const char delimiter = ' '){\nvector<string> result;\nstring token;\nstringstream ss(sentence);\nwhile(getline(ss, token, delimiter)){\nresult.push_back(token);\n}\nreturn result;\n}\nstring getOppositeSentence(string sentence){\nvector<string> tokens = tokenize(sentence);\nreverse(tokens.begin(), tokens.end());\nstring opposite = \"\";\nfor(int i=0; i<tokens.size(); i++){\nopposite += tokens[i];\nif(i != tokens.size()-1){\nopposite += \" \";\n}\n}\nreturn opposite;\n}\nint main(){\nint t;\ncin >> t;\ncin.ignore();\nfor(int i=1; i<=t; i++){\nstring sentence;\ngetline(cin, sentence);\nstring opposite = getOppositeSentence(sentence);\ncout << \"Case #\" << i << \": \" << opposite << '\\n';\n}\nreturn 0;\n}"
    },
    {
        "problem_tier": 5,
        "solution_code": "#include <iostream>\nusing namespace std;\nint main() {\nint n, b[101], a[101];\ncin >> n;\nfor (int i = 0; i < n; i++) {\ncin >> b[i];\na[i] = b[i] * (i + 1);\n}\ncout << a[0] << \" \";\nfor (int i = 1; i < n; i++) {\ncout << a[i] - a[i - 1] << \" \";\n}\nreturn 0;\n}"
    },
    {
        "problem_tier": 14,
        "solution_code": "#include <iostream>\n#include <map>\n#include <vector>\nusing namespace std;\nstruct Trie {\nmap<string, Trie*> m;\nvoid insert(vector<string>& v, int idx) {\nif (idx == v.size()) return;\nif (m.find(v[idx]) == m.end()) {\nTrie* trie = new Trie;\nm.insert({v[idx], trie});\n}\nm[v[idx]]->insert(v, idx + 1);\n}\nvoid dfs(int d) {\nfor (auto& i : m) {\nfor (int j = 0; j < d; j++) {\ncout << \"--\";\n}\ncout << i.first << '\\n';\ni.second->dfs(d + 1);\ndelete i.second;\n}\n}\n};\nint main() {\nios::sync_with_stdio(false);\ncin.tie(0);\ncout.tie(0);\nint n;\ncin >> n;\nTrie* root = new Trie;\nfor (int i = 0; i < n; i++) {\nint num;\ncin >> num;\nvector<string> v(num);\nfor (int j = 0; j < num; j++) {\ncin >> v[j];\n}\nroot->insert(v, 0);\n}\nroot->dfs(0);\ndelete root;\nreturn 0;\n}"
    },
    {
        "problem_tier": 6,
        "solution_code": "#include <iostream>\n#include <vector>\nusing namespace std;\nint main() {\nint n, p, cnt = 1;\nvector<int> nums(1001);\ncin >> n >> p;\nint ne = n;\nwhile (!nums[ne]) {\nnums[ne] = cnt++;\nne = (ne * n) % p;\n}\ncout << cnt - nums[ne] << '\\n';\nreturn 0;\n}"
    },
    {
        "problem_tier": 3,
        "solution_code": "#include<iostream>\nusing namespace std;\nint main() {\nunsigned long long n, m;\ncin >> n >> m;\ncout << n * m / 2 << '\\n';\nreturn 0;\n}"
    },
    {
        "problem_tier": 12,
        "solution_code": "#include <iostream>\n#include <vector>\n#include <algorithm>\n#include <cmath>\nusing namespace std;\nint n, ans = 987654321;\nint graph[20][20];\nbool visited[20];\nint pairs[2];\nint calculate() {\nint cnt1 = 0;\nint cnt2 = 0;\nfor (int i = 0; i < n - 1; i++) {\nfor (int j = i + 1; j < n; j++) {\nif (visited[i] && visited[j]) {\ncnt1 += graph[i][j] + graph[j][i];\n}\nelse if (!visited[i] && !visited[j]) {\ncnt2 += graph[i][j] + graph[j][i];\n}\n}\n}\nreturn abs(cnt1 - cnt2);\n}\nvoid combination(int cnt) {\nif (cnt == n) {\nans = min(ans, calculate());\nreturn;\n}\nvisited[cnt] = true;\ncombination(cnt + 1);\nvisited[cnt] = false;\ncombination(cnt + 1);\n}\nint main() {\nios::sync_with_stdio(false);\ncin.tie(0);\ncout.tie(0);\ncin >> n;\nfor (int i = 0; i < n; i++) {\nfor (int j = 0; j < n; j++) {\ncin >> graph[i][j];\n}\n}\ncombination(0);\ncout << ans;\nreturn 0;\n}"
    },
    {
        "problem_tier": 17,
        "solution_code": "#include <iostream>\n#include <vector>\n#define MAX 40001\nusing namespace std;\nint N, M, max_height;\nint depth[MAX];\nvector<pair<int,int>> graph[MAX];\nbool visited[MAX];\nint parent[MAX][30];\nint dist[MAX][30];\nvoid dfs(int node, int _depth) {\nvisited[node] = 1;\ndepth[node] = _depth;\nfor (auto next : graph[node]) {\nif (visited[next.first]) continue;\nparent[next.first][0] = node;\ndist[next.first][0] = next.second;\ndfs(next.first, _depth + 1);\n}\n}\nvoid set_parent() {\nfor (int i = 1; i < max_height; i++) {\nfor (int k = 1; k <= N; k++) {\nint prev_parent = parent[k][i - 1];\nparent[k][i] = parent[prev_parent][i - 1];\nif (parent[prev_parent][i - 1] == 0) continue;\ndist[k][i] = dist[k][i - 1] + dist[prev_parent][i - 1];\n}\n}\n}\nint lca(int a, int b) {\nint _dist = 0;\nif (depth[a] > depth[b]) swap(a, b);\nfor (int i = max_height; i >= 0; i--) {         int diff = depth[b] - depth[a];\nint jump = 1 << i;\nif (jump <= diff) {\n_dist += dist[b][i];\nb = parent[b][i];\n}\n}\nif (a == b) return _dist;\nfor (int i = max_height; i >= 0; i--) {         if (parent[a][i] != parent[b][i]) {\n_dist += dist[a][i];\na = parent[a][i];\n_dist += dist[b][i];\nb = parent[b][i];\n}\n}\n_dist += dist[a][0] + dist[b][0];     return _dist;\n}\nint main() {\nios_base::sync_with_stdio(false);\ncin.tie(0);\ncin >> N;\nint temp = N;\nwhile (temp > 0) {\nmax_height++;\ntemp = temp >> 1;\n}\nfor (int i = 0; i < N - 1; i++) {\nint a, b, c;\ncin >> a >> b >> c;\ngraph[a].push_back({b, c});         graph[b].push_back({a, c});     }\ndfs(1, 0);\nset_parent();\ncin >> M;\nfor (int i = 0; i < M; i++) {\nint a, b;\ncin >> a >> b;\ncout << lca(a, b) << '\\n';\n}\nreturn 0;\n}"
    },
    {
        "problem_tier": 15,
        "solution_code": "#include <bits/stdc++.h>\nusing namespace std;\ntypedef long long ll;\nint ccw(pair<ll,ll> p1, pair<ll,ll> p2, pair<ll,ll> p3){\nll temp = p1.first * p2.second + p2.first * p3.second + p3.first * p1.second;\ntemp = temp - p1.second * p2.first - p2.second * p3.first - p3.second * p1.first;\nif(temp > 0) return 1;\nelse if(temp == 0) return 0;\nelse if(temp < 0) return -1;\n}\nbool isOverlapped(pair<ll,ll> A, pair<ll,ll> B, pair<ll,ll> C, pair<ll,ll> D){\nint ans1 = ccw(A,B,C) * ccw(A,B,D);\nint ans2 = ccw(C,D,A) * ccw(C,D,B);\nif(ans1 == 0 && ans2 == 0){\nif(A > B) swap(A,B);\nif(C > D) swap(C,D);\nif(A <= D && C <= B){\nreturn true;\n}\nelse{\nreturn false;\n}\n}\nelse if(ans1 <= 0 && ans2 <= 0){\nreturn true;\n}\nelse{\nreturn false;\n}\n}\nint main(){\nios_base::sync_with_stdio(0);\ncin.tie(0);\npair<ll,ll> A;\npair<ll,ll> B;\npair<ll,ll> C;\npair<ll,ll> D;\ncin >> A.first >> A.second;\ncin >> B.first >> B.second;\ncin >> C.first >> C.second;\ncin >> D.first >> D.second;\nif(isOverlapped(A,B,C,D)){\ncout << 1;\n}\nelse{\ncout << 0;\n}\nreturn 0;\n}"
    },
    {
        "problem_tier": 9,
        "solution_code": "#include <iostream>\n#include <string>\n#include <unordered_map>\n#include <algorithm>\n#include <vector>\nusing namespace std;\nint main() {\nint n;\ncin >> n;\nunordered_map<string, int> file;\nfor (int i = 0; i < n; i++) {\nstring input;\ncin >> input;\nstring extension = input.substr(input.find('.') + 1);\nfile[extension]++;\n}\nvector<pair<string, int>> sortedFile;\nfor (auto it = file.begin(); it != file.end(); it++) {\nsortedFile.push_back({it->first, it->second});\n}\nsort(sortedFile.begin(), sortedFile.end());\nfor (auto p : sortedFile) {\ncout << p.first << \" \" << p.second << \"\\n\";\n}\nreturn 0;\n}"
    },
    {
        "problem_tier": 8,
        "solution_code": "#include <iostream>\nusing namespace std;\nint main() {\nint board[102][102] = { 0, };\nint N, row, col;\nint dx[4] = { 0, 1, 0, -1 };\nint dy[4] = { 1, 0, -1, 0 };\nint answer = 0;\ncin >> N;\nfor (int i = 0; i < N; i++) {\ncin >> row >> col;\nfor (int r = row; r < row + 10; r++) {\nfor (int c = col; c < col + 10; c++) {\nboard[r][c] = 1;\n}\n}\n}\nfor (int r = 1; r < 101; r++) {\nfor (int c = 1; c < 101; c++) {\nif (board[r][c] == 1) {\nfor (int i = 0; i < 4; i++) {\nif (board[r + dy[i]][c + dx[i]] == 0) {\nanswer++;\n}\n}\n}\n}\n}\ncout << answer;\nreturn 0;\n}"
    },
    {
        "problem_tier": 14,
        "solution_code": "#include <iostream>\n#include <cstring>\n#include <algorithm>\nusing namespace std;\nint dp[100001][5][5];\nint moves[100001];\nint scores[5][5] = {\n{0, 2, 2, 2, 2},\n{0, 1, 3, 4, 3},\n{0, 3, 1, 3, 4},\n{0, 4, 3, 1, 3},\n{0, 3, 4, 3, 1}\n};\nint main(){\nint n = 1;\nwhile(1){\ncin >> moves[n];\nif(moves[n++] == 0){\nbreak;\n}\n}\ndp[1][0][moves[1]] = 2;\ndp[1][moves[1]][0] = 2;\nfor(int x = 2; x <= n; x++){\nfor(int i = 0; i < 5; i++){\nfor(int j = 0; j < 5; j++){\nif(dp[x-1][i][j] != 0){\nif(moves[x] != j)\nif(dp[x][moves[x]][j] == 0)\ndp[x][moves[x]][j] = dp[x-1][i][j] + scores[i][moves[x]];\nelse\ndp[x][moves[x]][j] = min(dp[x][moves[x]][j], dp[x-1][i][j] + scores[i][moves[x]]);\nif(moves[x] != i)\nif(dp[x][i][moves[x]] == 0)\ndp[x][i][moves[x]] = dp[x-1][i][j] + scores[j][moves[x]];\nelse\ndp[x][i][moves[x]] = min(dp[x][i][moves[x]], dp[x-1][i][j] + scores[j][moves[x]]);\n}\n}\n}\n}\nint res = 400001;\nfor(int i = 0; i < 5; i++){\nfor(int j = 0; j < 5; j++){\nif(dp[n][i][j] != 0)\nres = min(res, dp[n][i][j]);\n}\n}\nif(res == 400001)\nres = 0;\ncout << res;\nreturn 0;\n}"
    },
    {
        "problem_tier": 13,
        "solution_code": "#include <iostream>\n#include <iomanip>\nusing namespace std;\nint N;\ndouble Percent[4];\nbool Visit[30][30];\nint dx[] = {0, 0, 1, -1};\nint dy[] = {1, -1, 0, 0};\ndouble DFS(int x, int y, int Cnt) {\nif (Cnt == N) return 1.0;\nVisit[x][y] = true;\ndouble Result = 0.0;\nfor (int i = 0; i < 4; i++) {\nint nx = x + dx[i];\nint ny = y + dy[i];\nif (Visit[nx][ny]) continue;\nResult += Percent[i] * DFS(nx, ny, Cnt + 1);\n}\nVisit[x][y] = false;\nreturn Result;\n}\nint main(void) {\nios::sync_with_stdio(false);\ncin.tie(NULL);\ncout.tie(NULL);\ncin >> N;\nfor (int i = 0; i < 4; i++) {\nint a;\ncin >> a;\nPercent[i] = a / 100.0;\n}\ndouble R = DFS(14, 14, 0);\ncout.precision(10);\ncout << fixed << R << endl;\nreturn 0;\n}"
    },
    {
        "problem_tier": 7,
        "solution_code": "#include <iostream>\n#include <cstring>\nusing namespace std;\nchar c[101][101];\nint ans[101][101];\nvoid solve(int h) {\nint st;\nfor (int i = W - 1; i >= 0; i--) {\nif (c[h][i] == 'c') {\nst = 1;\nwhile (c[h][i + st] != 'c' && i + st < W) {\nans[h][i + st] = st;\nst++;\n}\n}\n}\n}\nint main() {\ncin >> H >> W;\nfor (int i = 0; i < H; i++) {\nfor (int j = 0; j < W; j++) {\ncin >> c[i][j];\nif (c[i][j] == 'c') {\nans[i][j] = 0;\n} else {\nans[i][j] = -1;\n}\n}\n}\nfor (int i = 0; i < H; i++) {\nsolve(i);\n}\nfor (int i = 0; i < H; i++) {\nfor (int j = 0; j < W; j++) {\ncout << ans[i][j];\n}\ncout << \"\\n\";\n}\nreturn 0;\n}"
    },
    {
        "problem_tier": 12,
        "solution_code": "#include<iostream>\n#include<vector>\n#include<queue>\n#include<cstring>\nusing namespace std;\nstruct Node{\nint v, cost;\n};\nint n, m, dist[1001];\nvector<Node> graph[1001];\nint bfs(int start, int end){\nqueue<int> q;\nq.push(start);\ndist[start] = 0;\nwhile(!q.empty()){\nint x = q.front();\nq.pop();\nfor(auto next : graph[x]){\nif(dist[next.v] >= 0)\ncontinue;\ndist[next.v] = dist[x] + next.cost;\nq.push(next.v);\n}\n}\nreturn dist[end];\n}\nint main(){\ncin >> n >> m;\nfor(int i = 0; i < n-1; i++){\nint u, v, cost;\ncin >> u >> v >> cost;\ngraph[u].push_back({v, cost});\ngraph[v].push_back({u, cost});\n}\nwhile(m--){\nint start, end;\ncin >> start >> end;\nmemset(dist, -1, sizeof(dist));\ncout << bfs(start, end) << '\\n';\n}\n}\n"
    },
    {
        "problem_tier": 13,
        "solution_code": "#include <iostream>\n#include <vector>\n#include <algorithm>\nusing namespace std;\nvoid solve() {\nint n;\ncin >> n;\nvector<int> buildings;\nfor(int i=0;i<n;i++) {\nint temp;\ncin >> temp;\nbuildings.push_back(temp);\n}\nvector<int> count(n);\nfor(int i=0;i<n;i++) {\ndouble maxGradient = -1000000000;\nfor(int j=i+1;j<n;j++) {\nint h = buildings[j] - buildings[i];\nint w = j-i;\ndouble g = h*1.0/w;\nif(g <= maxGradient)\ncontinue;\nmaxGradient = g;\ncount[i]++;\ncount[j]++;\n}\n}\ncout << *max_element(count.begin(), count.end());\n}\nint main(void) {\nios::sync_with_stdio(false);\ncin.tie(NULL);\ncout.tie(NULL);\nsolve();\nreturn 0;\n}"
    },
    {
        "problem_tier": 6,
        "solution_code": "#include <iostream>\n#include <cstring>\nusing namespace std;\nint cow[11];\nint n, ans;\nint main() {\nmemset(cow, -1, sizeof(cow));\ncin >> n;\nwhile (n--) {\nint a, b;\ncin >> a >> b;\nif (cow[a] != -1 && cow[a] != b) {\nans++;\n}\ncow[a] = b;\n}\ncout << ans;\nreturn 0;\n}"
    },
    {
        "problem_tier": 18,
        "solution_code": "#include <iostream>\n#include <vector>\n#include <cmath>\nusing namespace std;\ntypedef long long ll;\nstruct Segment {\nvector<ll> tree;\nvector<ll> seq;\nvector<ll> lazy;\nSegment(ll n){\nseq.resize(n+1);\nll log = ceil(log2(n));\nll t = (1LL << (log + 1));\ntree.resize(t);\nlazy.resize(t);\n}\nvoid init(ll node, ll start, ll end){\nll mid = (start + end) / 2;\nif (start == end)\ntree[node] = seq[start];\nelse {\ninit(node * 2, start, mid);\ninit(node * 2 + 1, mid + 1, end);\ntree[node] = tree[node * 2] + tree[node * 2 + 1];\n}\n}\nll query(ll node, ll start, ll end, ll i, ll j){\nll mid = (start + end) / 2;\nif (lazy[node] != 0){\ntree[node] += (end - start + 1) * lazy[node];\nif (start != end){\nlazy[node * 2] += lazy[node];\nlazy[node * 2 + 1] += lazy[node];\n}\nlazy[node] = 0;\n}\nif (i > end || j < start)\nreturn 0;\nif (i <= start && end <= j)\nreturn tree[node];\nreturn query(node * 2, start, mid, i, j) + query(node * 2 + 1, mid + 1, end, i, j);\n}\nvoid update(ll node, ll start, ll end, ll i, ll j, ll diff){\nll mid = (start + end) / 2;\nif (lazy[node] != 0){\ntree[node] += (end - start + 1) * lazy[node];\nif (start != end){\nlazy[node * 2] += lazy[node];\nlazy[node * 2 + 1] += lazy[node];\n}\nlazy[node] = 0;\n}\nif (j < start || i > end)\nreturn;\nif (i <= start && end <= j){\ntree[node] += (end - start + 1) * diff;\nif (start != end){\nlazy[node * 2] += diff;\nlazy[node * 2 + 1] += diff;\n}\nreturn;\n}\nupdate(node * 2, start, mid, i, j, diff);\nupdate(node * 2 + 1, mid + 1, end, i, j, diff);\ntree[node] = tree[node * 2] + tree[node * 2 + 1];\n}\n};\nint main(){\nios_base::sync_with_stdio(false);\ncin.tie(nullptr);\ncout.tie(nullptr);\nll N, M, K;\nll a, b, c, d;\ncin >> N >> M >> K;\nSegment seg(N);\nfor(int i = 1; i <= N; i++)\ncin >> seg.seq[i];\nseg.init(1, 1, N);\nll cnt = M + K;\nwhile(cnt--){\ncin >> a;\nif(a == 1){\ncin >> b >> c >> d;\nseg.update(1, 1, N, b, c, d);\n}\nelse{\ncin >> b >> c;\ncout << seg.query(1, 1, N, b, c) << \"\\n\";\n}\n}\nreturn 0;\n}"
    },
    {
        "problem_tier": 5,
        "solution_code": "#include <iostream>\n#include <vector>\nusing namespace std;\nint GCD(int a, int b){\nif(b == 0){\nreturn a;\n}\nreturn GCD(b, a % b);\n}\nint main(){\nint n;\ncin >> n;\nif(n == 2){\nint a, b, g;\ncin >> a >> b;\ng = GCD(a, b);\nfor(int i = 1; i <= g; i++){\nif(g % i == 0){\ncout << i << '\\n';\n}\n}\n}\nelse{\nint a, b, c, g;\ncin >> a >> b >> c;\ng = GCD(a, GCD(b, c));\nfor(int i = 1; i <= g; i++){\nif(g % i == 0){\ncout << i << '\\n';\n}\n}\n}\nreturn 0;\n}"
    },
    {
        "problem_tier": 12,
        "solution_code": "#include <iostream>\n#include <vector>\n#include <algorithm>\nusing namespace std;\nint main() {\nios_base::sync_with_stdio(false);\ncin.tie(0);\nint N, K;\ncin >> N >> K;\nvector<long long int> v(N), cost(N-1);\nfor (int i = 0; i < N; i++) {\ncin >> v[i];\n}\nsort(v.begin(), v.end());\nfor (int i = 1; i < N; i++) {\ncost[i-1] = v[i] - v[i-1];\n}\nsort(cost.begin(), cost.end());\nlong long int ans = 0;\nfor (int i = 0; i < N-K; i++) {\nans += cost[i];\n}\ncout << ans;\nreturn 0;\n}"
    },
    {
        "problem_tier": 16,
        "solution_code": "#include <iostream>\n#include <vector>\n#include <queue>\n#include <cstring>\nusing namespace std;\nint main() {\nint t;\ncin >> t;\nwhile (t--) {\nint n;\ncin >> n;\nvector<int> pre;\nfor (int i = 0; i < n; i++) {\nint tmp;\ncin >> tmp;\npre.push_back(tmp);\n}\nvector<vector<int>> adj(n + 1, vector<int>(n + 1, 0));\nvector<int> degree(n + 1, 0);\nfor (int i = 0; i < pre.size(); i++) {\nfor (int j = i + 1; j < pre.size(); j++) {\nadj[pre[i]][pre[j]] = 1;\ndegree[pre[j]]++;\n}\n}\nint m;\ncin >> m;\nfor (int i = 0; i < m; i++) {\nint a, b;\ncin >> a >> b;\nif (adj[a][b] == 1) {\nadj[a][b] = 0;\ndegree[b]--;\nadj[b][a] = 1;\ndegree[a]++;\n}\nelse {\ndegree[a]--;\nadj[b][a] = 0;\nadj[a][b] = 1;\ndegree[b]++;\n}\n}\nqueue<int> Q;\nfor (int i = 1; i <= n; i++) {\nif (degree[i] == 0) {\nQ.push(i);\n}\n}\nvector<int> ans;\nbool cantKnow = false;\nwhile (!Q.empty()) {\nif (Q.size() >= 2) {\ncantKnow = true;\nbreak;\n}\nint x = Q.front();\nQ.pop();\nans.push_back(x);\nfor (int i = 1; i <= n; i++) {\nif (adj[x][i] == 1) {\nint nx = i;\nif (--degree[nx] == 0) {\nQ.push(nx);\n}\n}\n}\n}\nif (cantKnow) {\ncout << \"?\\n\";\ncontinue;\n}\nif (ans.size() != n) {\ncout << \"IMPOSSIBLE\\n\";\ncontinue;\n}\nelse {\nfor (auto x : ans) {\ncout << x << ' ';\n}\n}\ncout << '\\n';\n}\nreturn 0;\n}"
    },
    {
        "problem_tier": 5,
        "solution_code": "#include <iostream>\nusing namespace std;\nint main() {\nint n, m, l;\nint throwCnt = 0, cur = 0;\nint ballCnt[1001];\ncin >> n >> m >> l;\nballCnt[cur] = 1;\nwhile (ballCnt[cur] != m) {\nif (ballCnt[cur] % 2)\ncur = (cur + l) % n;\nelse\ncur = (n + (cur - l)) % n;\nballCnt[cur]++;\nthrowCnt++;\n}\ncout << throwCnt << '\\n';\nreturn 0;\n}"
    },
    {
        "problem_tier": 8,
        "solution_code": "#include <iostream>\n#include <vector>\n#include <algorithm>\n#include <set>\nusing namespace std;\nint main() {\nios_base::sync_with_stdio(0);\ncin.tie(0);\nint n1, n2;\ncin >> n1 >> n2;\nvector<int> a(n1);\nset<int> b;\nfor (int i = 0; i < n1; i++) {\ncin >> a[i];\n}\nfor (int i = 0; i < n2; i++) {\nint tmp;\ncin >> tmp;\nb.insert(tmp);\n}\nvector<int> answer;\nfor (int num : a) {\nif (b.find(num) == b.end()) {\nanswer.push_back(num);\n}\n}\nsort(answer.begin(), answer.end());\ncout << answer.size() << '\\n';\nfor (int i : answer) {\ncout << i << ' ';\n}\nreturn 0;\n}"
    },
    {
        "problem_tier": 13,
        "solution_code": "#include <iostream>\n#include <vector>\n#include <queue>\nusing namespace std;\nint N, M, k; vector<int> parent(10001); vector<int> cost(10001);\nint find(int x){\nif(parent[x] == x) return x;\nreturn parent[x] = find(parent[x]);\n}\nvoid merge_parent(int a, int b){\na = find(a);\nb = find(b);\nif(a != b){\nif(cost[a] > cost[b]) parent[a] = b;\nelse parent[b] = a;\n}\n}\nint main(){\ncin.tie(0);\ncout.tie(0);\nios::sync_with_stdio(false);\ncin >> N >> M >> k;\nfor(int i = 0; i <= 10000; i++) parent[i] = i;\nfor(int i = 1; i <= N; i++) cin >> cost[i];\nfor(int i = 0; i < M; i++){\nint v, w;\ncin >> v >> w;\nmerge_parent(v, w);\n}\nunordered_set<int> s;     for(int i = 1; i <= N; i++){\ns.insert(find(i));\n}\nint ans = 0;     for(auto it : s){\nans += cost[it];\nk -= cost[it];\n}\nif(k >= 0) cout << ans;\nelse cout << \"Ohno\";\nreturn 0;\n}"
    },
    {
        "problem_tier": 10,
        "solution_code": "#include <iostream>\n#include <vector>\nusing namespace std;\nint n, m;\nvector<int> money;\nbool check(int mid) {\nint cnt = 1;\nint curMoney = mid;\nfor(int i=0; i<n; i++) {\nif(money[i] > mid) return false;\nif(curMoney - money[i] < 0) {\ncurMoney = mid;\ncnt++;\n}\ncurMoney -= money[i];\n}\nreturn cnt <= m;\n}\nint binarySearch() {\nint l = 0;\nint r = 1000000000;\nint ans = 1000000000;\nwhile(l <= r) {\nint mid = (l + r) / 2;\nif(check(mid)) {\nans = mid;\nr = mid - 1;\n} else {\nl = mid + 1;\n}\n}\nreturn ans;\n}\nint main() {\ncin >> n >> m;\nmoney.resize(n);\nfor(int i=0; i<n; i++) {\ncin >> money[i];\n}\ncout << binarySearch() << endl;\nreturn 0;\n}"
    },
    {
        "problem_tier": 15,
        "solution_code": "#include <iostream>\n#include <vector>\n#include <queue>\n#include <algorithm>\nusing namespace std;\ntypedef pair<int,int> P;\nint main() {\nios::sync_with_stdio(false);\ncin.tie(NULL);\ncout.tie(NULL);\nint n;\ncin >> n;\nvector<P> arr(n);\nfor(int i=0; i<n; i++) {\ncin >> arr[i].first >> arr[i].second;\n}\nsort(arr.begin(), arr.end());\npriority_queue<int, vector<int>, greater<int>> pq;\nfor(int i=0; i<n; i++) {\nif(pq.size() < arr[i].first) {\npq.push(arr[i].second);\n}\nelse {\nif(pq.top() < arr[i].second) {\npq.pop();\npq.push(arr[i].second);\n}\n}\n}\nint sum = 0;\nwhile(!pq.empty()) {\nsum += pq.top();\npq.pop();\n}\ncout << sum;\nreturn 0;\n}"
    },
    {
        "problem_tier": 12,
        "solution_code": "#include <iostream>\n#include <vector>\n#include <cstring>\nusing namespace std;\nint N;\nchar map[7][7];\nint dx[4] = {-1, 0, 1, 0};\nint dy[4] = {0, -1, 0, 1};\nbool flag;\nvector<pair<int, int>> teacher, blank;\nbool canWatch(int nx, int ny, int dir) {\nwhile (1) {\nnx += dx[dir];\nny += dy[dir];\nif (map[nx][ny] == 'O' || nx < 0 || nx >= N || ny < 0 || ny >= N)\nbreak;\nif (map[nx][ny] == 'S')\nreturn true;\n}\nreturn false;\n}\nbool isPossible() {\nfor (int i = 0; i < teacher.size(); i++) {\nint x = teacher[i].first;\nint y = teacher[i].second;\nfor (int j = 0; j < 4; j++) {\nif (canWatch(x, y, j))\nreturn false;\n}\n}\nreturn true;\n}\nvoid DFS(int cnt) {\nif (cnt == 3) {\nif (isPossible())\nflag = true;\nreturn;\n}\nfor (int i = 0; i < blank.size(); i++) {\nint x = blank[i].first;\nint y = blank[i].second;\nif (map[x][y] == 'X') {\nmap[x][y] = 'O';\nDFS(cnt + 1);\nmap[x][y] = 'X';\n}\n}\n}\nint main(void) {\nios_base::sync_with_stdio(false);\ncin.tie(0);\ncin >> N;\nfor (int i = 0; i < N; i++) {\nfor (int j = 0; j < N; j++) {\ncin >> map[i][j];\nif (map[i][j] == 'T')\nteacher.push_back({i, j});\nelse if (map[i][j] == 'X')\nblank.push_back({i, j});\n}\n}\nDFS(0);\nif (flag)\ncout << \"YES\";\nelse\ncout << \"NO\";\nreturn 0;\n}"
    },
    {
        "problem_tier": 8,
        "solution_code": "#include <iostream>\n#include <vector>\n#include <algorithm>\nusing namespace std;\nint main() {\nint N;\nvector<int> products;\ncin >> N;\nfor (int i = 0; i < N; i++) {\nint num;\ncin >> num;\nproducts.push_back(num);\n}\nsort(products.begin(), products.end(), greater<int>());\nint sum = 0;\nfor (int i = 0; i < products.size(); i++) {\nif ((i + 1) % 3 == 0) {\ncontinue;\n} else {\nsum += products[i];\n}\n}\ncout << sum << endl;\nreturn 0;\n}"
    },
    {
        "problem_tier": 7,
        "solution_code": "#include <iostream>\n#include <algorithm>\n#include <string>\nusing namespace std;\nint gcd(int a, int b) {\nif (b == 0) return a;\nelse return gcd(b, a % b);\n}\nint main() {\nios_base::sync_with_stdio(false);\ncin.tie(0);\nstring s, a, b;\ncin >> s;\nbool flag = false;\nfor (int i = 0; i < s.length(); i++) {\nif (s[i] == ':') {\nflag = true;\ncontinue;\n} else if (!flag) {\na += s[i];\n} else {\nb += s[i];\n}\n}\nint x = stoi(a);\nint y = stoi(b);\nint mod = gcd(x, y);\ncout << x / mod << ':' << y / mod;\nreturn 0;\n}"
    },
    {
        "problem_tier": 5,
        "solution_code": "#include <iostream>\n#include <string>\nusing namespace std;\nint main() {\nstring str;\nint arr[3];\nfor(int i = 0; i < 3; i++) {\ncin >> str;\nint count = 1;\nint max = 1;\nfor(int j = 0; j < str.length() - 1; j++) {\nif(str[j] == str[j + 1]) {\ncount++;\nif(count > max) {\nmax = count;\n}\n} else {\ncount = 1;\n}\n}\narr[i] = max;\n}\nfor(int i = 0; i < 3; i++) {\ncout << arr[i] << \"\\n\";\n}\nreturn 0;\n}"
    },
    {
        "problem_tier": 4,
        "solution_code": "#include<iostream>\n#include<string>\nusing namespace std;\nint main() {\nint test;\ncin >> test;\nfor(int i=0; i<test; i++) {\nstring str;\ncin >> str;\nint len = str.length();\nint arr[26] = {0};\nint sum = 0;\nfor(int j=0; j<len; j++) {\narr[str[j] - 'A'] = 1;\n}\nfor(int j=0; j<26; j++) {\nif(arr[j] != 1) {\nsum += j + 'A';\n}\n}\ncout << sum << \"\\n\";\n}\nreturn 0;\n}"
    },
    {
        "problem_tier": 6,
        "solution_code": "#include <iostream>\n#include <vector>\n#include <algorithm>\nusing namespace std;\nint main() {\nint N;\ncin >> N;\nint arr[30001] = {0,};\nvector<int> v;\nfor (int i = 0; i < N; i++) {\nint x;\ncin >> x;\nv.push_back(x);\n}\nint result = -1;\nfor (int i = 0; i < N - 1; i++) {\nfor (int j = i + 1; j < N; j++) {\nif (v[i] > v[j])\narr[i]++;\nelse\nbreak;\n}\nresult = max(arr[i], result);\n}\ncout << result << endl;\nreturn 0;\n}"
    },
    {
        "problem_tier": 4,
        "solution_code": "#include<iostream>\nusing namespace std;\nint main() {\nint n, ans = 0;\nwhile (cin >> n) {\nans += n;\n}\ncout << ans << '\\n';\nreturn 0;\n}"
    },
    {
        "problem_tier": 2,
        "solution_code": "#include <iostream>\nusing namespace std;\nint main() {\nint a, b, c, d, e, f;\ncin >> a >> b >> c >> d >> e >> f;\ncout << (a + b + c + d + e + f) * 5;\nreturn 0;\n}"
    },
    {
        "problem_tier": 11,
        "solution_code": "#include <iostream>\n#include <vector>\n#include <queue>\nusing namespace std;\nint R, C, N;\nchar MAP[201][201];\nint dx[4] = {-1, 1, 0, 0};\nint dy[4] = {0, 0, -1, 1};\nvoid print() {\nfor(int i=0;i<R;i++) {\nfor(int j=0;j<C;j++) {\ncout << MAP[i][j];\n}\ncout << endl;\n}\n}\nint main() {\ncin >> R >> C >> N;\nfor(int i=0;i<R;i++) {\nfor(int j=0;j<C;j++) {\ncin >> MAP[i][j];\n}\n}\nif(N % 2 == 0) {\nfor(int i=0;i<R;i++) {\nfor(int j=0;j<C;j++) {\ncout << \"O\";\n}\ncout << endl;\n}\n}\nelse {\nif(N == 1) {\nfor(int i=0;i<R;i++) {\nfor(int j=0;j<C;j++) {\ncout << MAP[i][j];\n}\ncout << endl;\n}\n}\nelse {\nqueue<pair<int, int>> q;\nvector<pair<int, int>> bomb;\nfor(int i=0;i<R;i++) {\nfor(int j=0;j<C;j++) {\nif(MAP[i][j] == 'O') {\nbomb.push_back(make_pair(i, j));\nq.push(make_pair(i, j));\n}\n}\n}\nwhile(N > 2) {\nmemset(MAP, 'O', sizeof(MAP));                 while(!q.empty()) {\nint x = q.front().first;\nint y = q.front().second;\nq.pop();\nfor(int i=0;i<4;i++) {\nint nx = x + dx[i];\nint ny = y + dy[i];\nif(nx >= 0 && ny >= 0 && nx < R && ny < C) {\nMAP[nx][ny] = '.';                         }\n}\n}\nfor(int i=0;i<bomb.size();i++) {\nint x = bomb[i].first;\nint y = bomb[i].second;\nfor(int j=0;j<4;j++) {\nint nx = x + dx[j];\nint ny = y + dy[j];\nif(nx >= 0 && ny >= 0 && nx < R && ny < C) {\nif(MAP[nx][ny] == 'O') {\nq.push(make_pair(nx, ny));\n}\n}\n}\n}\nN--;\n}\nfor(int i=0;i<R;i++) {\nfor(int j=0;j<C;j++) {\ncout << MAP[i][j];\n}\ncout << endl;\n}\n}\n}\nreturn 0;\n}"
    },
    {
        "problem_tier": 5,
        "solution_code": "#include <iostream>\n#include <string>\nusing namespace std;\nint main() {\nstring str;\nint jcnt = 0, icnt = 0;\ncin >> str;\nfor (int i = 0; i < str.size() - 2; i++) {\nif (str[i] == 'J' && str[i + 1] == 'O' && str[i + 2] == 'I') {\njcnt++;\n}\nif (str[i] == 'I' && str[i + 1] == 'O' && str[i + 2] == 'I') {\nicnt++;\n}\n}\ncout << jcnt << '\\n' << icnt << '\\n';\nreturn 0;\n}"
    },
    {
        "problem_tier": 8,
        "solution_code": "#include <iostream>\n#include <vector>\n#include <string>\n#include <algorithm>\n#include <queue>\nusing namespace std;\nconst int MAX = 101;\nint n, m;\nchar badak[MAX][MAX];\nint visited[MAX][MAX];\nint cnt;\nchar now = '-';\nvoid dfs(int i, int j) {\nif (badak[i][j] != now)\nreturn;\nvisited[i][j] = 1;\nif (badak[i][j] == '-') {\nif (j+1 < m) {\nif (!visited[i][j+1]) {\ndfs(i, j+1);\n}\n}\n}\nelse if (badak[i][j] == '|') {\nif (i+1 < n) {\nif (!visited[i+1][j]) {\ndfs(i+1, j);\n}\n}\n}\n}\nint main(void) {\ncin >> n >> m;\nfor (int i=0; i<n; i++) {\nfor (int j=0; j<m; j++) {\ncin >> badak[i][j];\n}\n}\nfor (int i=0; i<n; i++) {\nfor (int j=0; j<m; j++) {\nif (!visited[i][j]) {\nvisited[i][j] = 1;\ncnt++;\nif (badak[i][j] == '-') {\nif (j+1 < m) {\nif (!visited[i][j+1]) {\nnow = '-';\ndfs(i, j+1);\n}\n}\n}\nelse if (badak[i][j] == '|') {\nif (i+1 < n) {\nif (!visited[i+1][j]) {\nnow = '|';\ndfs(i+1, j);\n}\n}\n}\n}\n}\n}\ncout << cnt << \"\\n\";\nreturn 0;\n}"
    },
    {
        "problem_tier": 3,
        "solution_code": "#include<iostream>\nint main() {\nchar c;\nstd::cin >> c;\nint unicode = c - '가' + 1;\nstd::cout << unicode;\nreturn 0;\n}"
    },
    {
        "problem_tier": 4,
        "solution_code": "#include <iostream>\nusing namespace std;\nint main() {\nint n;\ncin >> n;\nif (n == 1) {\ncout << 1 << '\\n';\nreturn 0;\n}"
    },
    {
        "problem_tier": 5,
        "solution_code": "#include <iostream>\n#include <string>\n#include <vector>\nusing namespace std;\nvector<int> makeTable(string p) {\nvector<int> table(p.length());\nint j = 0;\nfor (int i = 1; i < p.length(); i++) {\nwhile (p[i] != p[j] && j > 0) {\nj = table[--j];\n}\nif (p[i] == p[j]) {\ntable[i] = ++j;\n}\n}\nreturn table;\n}\nint kmp(string s, string p, vector<int>& table) {\nint j = 0;\nfor (int i = 0; i < s.length(); i++) {\nwhile (s[i] != p[j] && j > 0) {\nj = table[--j];\n}\nif (s[i] == p[j]) {\nif (++j == p.length()) {\nreturn 1;\n}\n}\n}\nreturn 0;\n}\nint main() {\nios::sync_with_stdio(false);\ncin.tie(0);\ncout.tie(0);\nstring s, p;\ncin >> s >> p;\nvector<int> table = makeTable(p);\ncout << kmp(s, p, table);\nreturn 0;\n}"
    },
    {
        "problem_tier": 4,
        "solution_code": "#include<iostream>\n#include<algorithm>\nusing namespace std;\nint main() {\nint N;\ncin >> N;\nint milk[N];\nfor (int i = 0; i < N; i++) {\ncin >> milk[i];\n}\nint cnt = 0;\nint currentMilk = 0;\nfor (int i = 0; i < N; i++) {\nif (milk[i] == currentMilk) {\ncnt++;\ncurrentMilk = (currentMilk + 1) % 3;\n}\n}\ncout << cnt;\nreturn 0;\n}"
    },
    {
        "problem_tier": 10,
        "solution_code": "#include <iostream>\nusing namespace std;\nint main() {\nios_base::sync_with_stdio(false);\ncin.tie(NULL);\ncout.tie(NULL);\nint n;\nlong long ans = 0;\ncin >> n;\nfor (int i = 1; i <= n; i++) {\nint temp = n / i;\ntemp *= i;\nans += temp;\n}\ncout << ans;\nreturn 0;\n}"
    },
    {
        "problem_tier": 2,
        "solution_code": "#include<iostream>\nusing namespace std;\nint main(){\ncout << \"1\";\nreturn 0;\n}"
    },
    {
        "problem_tier": 18,
        "solution_code": "#include <bits/stdc++.h>\nusing namespace std;\nconst int MAX = 1001;\nint N, M;\nvector<int> works[MAX];\nint owner[MAX];\nbool visit[MAX];\nbool DFS(int curr) {\nif (visit[curr]) return false;\nvisit[curr] = true;\nfor (auto work : works[curr]) {\nif (!owner[work] || DFS(owner[work])) {\nowner[work] = curr;\nreturn true;\n}\n}\nreturn false;\n}\nint bipartite_match() {\nint ret = 0;\nfor (int i = 1; i <= N; i++) {\nmemset(visit, 0, sizeof(visit));\nif (DFS(i)) ret++;\n}\nreturn ret;\n}\nint main() {\nios_base::sync_with_stdio(false);\ncin.tie(NULL);\ncout.tie(NULL);\ncin >> N >> M;\nint k, w;\nfor (int i = 1; i <= N; i++) {\ncin >> k;\nfor (int j = 0; j < k; j++) {\ncin >> w;\nworks[i].push_back(w);\n}\n}\ncout << bipartite_match();\nreturn 0;\n}"
    },
    {
        "problem_tier": 5,
        "solution_code": "#include<iostream>\n#include<string>\n#include<bits/stdc++.h>\nusing namespace std;\nint main() {\nstring s1, s2, result;\ncin >> s1 >> s2;\nint start1, start2;\nfor(int i=0; i<s1.length(); i++) {\nif(s1[i] == '1') {\nstart1 = i;\nbreak;\n}\n}\nfor(int i=0; i<s2.length(); i++) {\nif(s2[i] == '1') {\nstart2 = i;\nbreak;\n}\n}\nint end1 = s1.length() - 1;\nint end2 = s2.length() - 1;\nint carry = 0;\nwhile(true) {\nint tmp = (s1[end1] - '0') + (s2[end2] - '0') + carry;\ncarry = tmp / 2;\nresult += (tmp % 2) + '0';\nend1--;\nend2--;\nif(end1 + 1 == start1)\nbreak;\nif(end2 + 1 == start2)\nbreak;\n}\nfor(; (start1 != end1 + 1); end1--) {\nint tmp = (s1[end1] - '0') + carry;\ncarry = tmp / 2;\nresult += (tmp % 2) + '0';\n}\nfor(; (start2 != end2 + 1); end2--) {\nint tmp = (s2[end2] - '0') + carry;\ncarry = tmp / 2;\nresult += (tmp % 2) + '0';\n}\nif(carry == 1) {\nresult += (carry + '0');\n}\nreverse(result.begin(), result.end());\ncout << result;\nreturn 0;\n}"
    },
    {
        "problem_tier": 17,
        "solution_code": "#include <iostream>\n#include <vector>\n#include <cmath>\nusing namespace std;\nint n;\nvector<int> candies;\nvector<int> tree;\nint query(int node, int start, int end, int k) {\nif (start == end) return start;\nint mid = (start + end) / 2;\nif (tree[node * 2] >= k)\nreturn query(node * 2, start, mid, k);\nelse\nreturn query(node * 2 + 1, mid + 1, end, k - tree[node * 2]);\n}\nvoid update(int node, int start, int end, int idx, int value) {\nif (idx < start || idx > end) return;\nif (start == end) {\ntree[node] = value;\nreturn;\n}\nint mid = (start + end) / 2;\nupdate(node * 2, start, mid, idx, value);\nupdate(node * 2 + 1, mid + 1, end, idx, value);\ntree[node] = tree[node * 2] + tree[node * 2 + 1];\n}\nint main() {\nios_base::sync_with_stdio(false);\ncin.tie(NULL);\ncout.tie(NULL);\ncin >> n;\ncandies.resize(MAX+5);\ntree.resize(MAX * 4);\nfor (int i = 0; i < n; i++) {\nint a, b, c;\ncin >> a;\nif (a == 1) {\ncin >> b;\nint k = query(1, 1, MAX, b);\ncout << k << endl;\nupdate(1, 1, MAX, k, candies[k] - 1);\ncandies[k]--;\n}\nelse {\ncin >> b >> c;\nupdate(1, 1, MAX, b, candies[b] + c);\ncandies[b] += c;\n}\n}\nreturn 0;\n}"
    },
    {
        "problem_tier": 12,
        "solution_code": "#include<bits/stdc++.h>\nusing namespace std;\nint n, m;\nvoid calculateOne(vector<vector<int>>& arr) {\nreverse(arr.begin(), arr.end());\n}\nvoid calculateTwo(vector<vector<int>>& arr) {\nfor (int i = 0; i < n; i++) {\nreverse(arr[i].begin(), arr[i].end());\n}\n}\nvoid calculateThree(vector<vector<int>>& arr) {\nvector<vector<int>> tmp(m, vector<int>(n));\nfor (int i = 0; i < m; i++) {\nfor (int j = 0; j < n; j++) {\ntmp[i][j] = arr[n - j - 1][i];\n}\n}\nswap(n, m);\narr = tmp;\n}\nvoid calculateFour(vector<vector<int>>& arr) {\nvector<vector<int>> tmp(m, vector<int>(n));\nfor (int i = 0; i < m; i++) {\nfor (int j = 0; j < n; j++) {\ntmp[i][j] = arr[j][m - i - 1];\n}\n}\nswap(n, m);\narr = tmp;\n}\nvoid calculateFive(vector<vector<int>>& arr) {\nvector<vector<int>> tmp = arr;\nfor (int i = 0; i < n / 2; i++) {\nfor (int j = 0; j < m / 2; j++) {\narr[i][j + m / 2] = tmp[i][j];\n}\n}\nfor (int i = 0; i < n / 2; i++) {\nfor (int j = m / 2; j < m; j++) {\narr[i + n / 2][j] = tmp[i][j];\n}\n}\nfor (int i = n / 2; i < n; i++) {\nfor (int j = m / 2; j < m; j++) {\narr[i][j - m / 2] = tmp[i][j];\n}\n}\nfor (int i = n / 2; i < n; i++) {\nfor (int j = 0; j < m / 2; j++) {\narr[i - n / 2][j] = tmp[i][j];\n}\n}\n}\nvoid calculateSix(vector<vector<int>>& arr) {\nvector<vector<int>> tmp = arr;\nfor (int i = 0; i < n / 2; i++) {\nfor (int j = 0; j < m / 2; j++) {\narr[i + n / 2][j] = tmp[i][j];\n}\n}\nfor (int i = 0; i < n / 2; i++) {\nfor (int j = m / 2; j < m; j++) {\narr[i][j - m / 2] = tmp[i][j];\n}\n}\nfor (int i = n / 2; i < n; i++) {\nfor (int j = m / 2; j < m; j++) {\narr[i - n / 2][j] = tmp[i][j];\n}\n}\nfor (int i = n / 2; i < n; i++)"
    },
    {
        "problem_tier": 10,
        "solution_code": "#include <iostream>\n#include <vector>\n#include <algorithm>\nusing namespace std;\nint N;\nvector<int> A(11); int op[4]; vector<int> v; int Min = 10e10;\nint Max = -10e10;\nint Calc() {\nint res = A[0];\nfor (int i = 0; i < N-1; i++) {\nif (v[i] == 0) {\nres += A[i+1];\n}\nelse if (v[i] == 1) {\nres -= A[i+1];\n}\nelse if (v[i] == 2) {\nres *= A[i+1];\n}\nelse if (v[i] == 3) {\nres /= A[i+1];\n}\n}\nreturn res;\n}\nvoid getSet(int cnt) {\nif (cnt == N-1) {\nint res = Calc();\nMin = min(Min, res);\nMax = max(Max, res);\nreturn;\n}\nif (op[0] > 0) {\nop[0]--;\nv.push_back(0);\ngetSet(cnt+1);\nv.pop_back();\nop[0]++;\n}\nif (op[1] > 0) {\nop[1]--;\nv.push_back(1);\ngetSet(cnt+1);\nv.pop_back();\nop[1]++;\n}\nif (op[2] > 0) {\nop[2]--;\nv.push_back(2);\ngetSet(cnt+1);\nv.pop_back();\nop[2]++;\n}\nif (op[3] > 0) {\nop[3]--;\nv.push_back(3);\ngetSet(cnt+1);\nv.pop_back();\nop[3]++;\n}\n}\nvoid solution() {\ncin >> N;\nfor (int i=0; i<N; i++) {\ncin >> A[i];\n}\nfor (int i=0; i<4; i++) {\ncin >> op[i];\n}\ngetSet(0);\ncout << Max << '\\n';\ncout << Min << '\\n';\n}\nint main() {\nsolution();\nreturn 0;\n}"
    },
    {
        "problem_tier": 8,
        "solution_code": "#include <iostream>\n#include <unordered_set>\nusing namespace std;\nint main() {\nunordered_set<string> arr{\"ChongChong\"};\nint n;\ncin >> n;\nwhile (n--) {\nstring a, b;\ncin >> a >> b;\nif (arr.count(a) > 0 || arr.count(b) > 0) {\narr.insert(a);\narr.insert(b);\n}\n}\ncout << arr.size();\nreturn 0;\n}"
    },
    {
        "problem_tier": 18,
        "solution_code": "#include<iostream>\n#include<vector>\n#define MAX 201\nusing namespace std;\nint n, m;\nvector<int> cow[MAX];\nint assignCow[MAX];\nbool check[MAX];\nbool dfs(int x){\nfor(int i=0;i<cow[x].size();i++){\nint t = cow[x][i];         if(check[t]) continue;         check[t] = true;         if(assignCow[t] == 0 || dfs(assignCow[t])){\nassignCow[t] = x;\nreturn true;\n}\n}\nreturn false;\n}\nint main(){\nscanf(\"%d%d\",&n,&m);\nfor(int i=1;i<=n;i++){\nint houseNum;\nscanf(\"%d\",&houseNum);\nfor(int j=0;j<houseNum;j++){\nscanf(\"%d\",&houseNum);\ncow[i].push_back(houseNum);\n}\n}\nint count = 0;\nfor(int i=1;i<=n;i++){\nfill(check, check+MAX,false);\nif(dfs(i)) count++;\n}\ncout<<count<<endl;\n}"
    },
    {
        "problem_tier": 8,
        "solution_code": "#include <iostream>\nusing namespace std;\nint main() {\nint n;\ncin >> n;\nint len = 4 * n - 3;\nchar star[len][len];\nfor (int i = 0; i < len; i++) {\nfor (int j = 0; j < len; j++) {\nstar[i][j] = ' ';\n}\n}\nint start = 0;\nint end = len - 1;\nfor (int q = 0; q < n; q++) {\nfor (int i = start; i <= end; i++) {\nstar[start][i] = '*';\nstar[i][start] = '*';\nstar[i][end] = '*';\nstar[end][i] = '*';\n}\nstart += 2;\nend -= 2;\n}\nfor (int i = 0; i < len; i++) {\nfor (int j = 0; j < len; j++) {\ncout << star[i][j];\n}\ncout << endl;\n}\nreturn 0;\n}"
    },
    {
        "problem_tier": 15,
        "solution_code": "#include<iostream>\n#include<algorithm>\n#define MAX 1000\n#define R_INF -987654321\nusing namespace std;\nint N, M;\nint MAP[MAX][MAX];\nint Cost[MAX][MAX][3];\nbool Visit[MAX][MAX];\nint dx[] = { 0, 0, 1 };\nint dy[] = { 1, -1, 0 };\nint Bigger(int A, int B) {\nif (A > B) return A;\nreturn B;\n}\nvoid Input() {\ncin >> N >> M;\nfor (int i = 0; i < N; i++) {\nfor (int j = 0; j < M; j++) {\ncin >> MAP[i][j];\n}\n}\n}\nint DFS(int x, int y, int Dir) {\nif (x == N - 1 && y == M - 1) return MAP[x][y];\nif (Cost[x][y][Dir] != R_INF) return Cost[x][y][Dir];\nVisit[x][y] = true;\nint Biggest_Value = R_INF;\nfor (int i = 0; i < 3; i++) {\nint nx = x + dx[i];\nint ny = y + dy[i];\nif (nx >= 0 && ny >= 0 && nx < N && ny < M) {\nif (Visit[nx][ny] == false) {\nBiggest_Value = Bigger(Biggest_Value, DFS(nx, ny, i));\n}\n}\n}\nVisit[x][y] = false;\nCost[x][y][Dir] = MAP[x][y] + Biggest_Value;\nreturn Cost[x][y][Dir];\n}\nvoid Solution() {\nfor (int i = 0; i < N; i++) {\nfor (int j = 0; j < M; j++) {\nCost[i][j][0] = R_INF;\nCost[i][j][1] = R_INF;\nCost[i][j][2] = R_INF;\n}\n}\nint Answer = DFS(0, 0, 0);\ncout << Answer << endl;\n}\nvoid Solve() {\nInput();\nSolution();\n}\nint main(void) {\nios::sync_with_stdio(false);\ncin.tie(NULL);\ncout.tie(NULL);\nSolve();\nreturn 0;\n}"
    },
    {
        "problem_tier": 12,
        "solution_code": "#include <iostream>\n#include <cstring>\nusing namespace std;\nlong long dp[31][31];\nlong long solved(int whole, int half) {\nif (whole == 0)\nreturn 1;\nlong long& ret = dp[whole][half];\nif (ret != -1)\nreturn ret;\nret = solved(whole - 1, half + 1);\nif (half > 0)\nret += solved(whole, half - 1);\nreturn ret;\n}\nint main() {\nios_base::sync_with_stdio(0);\ncin.tie(0), cout.tie(0);\nfor (int i = 1; i <= 1001; i++) {\nmemset(dp, -1, sizeof(dp));\nint temp;\ncin >> temp;\nif (temp == 0)\nbreak;\ncout << solved(temp, 0) << \"\\n\";\n}\nreturn 0;\n}"
    },
    {
        "problem_tier": 14,
        "solution_code": "#include <iostream>\n#include <vector>\nusing namespace std;\nint n, k, s;\nint history[401][401];\nvector<pair<int, int>> sol;\nvoid History() {\nfor (int v = 1; v <= n; v++) {\nfor (int f = 1; f <= n; f++) {\nfor (int t = 1; t <= n; t++) {\nif (!history[f][t]) {\nif (history[f][v] == 1 && history[v][t] == 1)\nhistory[f][t] = 1;\nelse if (history[f][v] == -1 && history[v][t] == -1)\nhistory[f][t] = -1;\n}\n}\n}\n}\n}\nint main() {\nscanf(\"%d%d\", &n, &k);\nwhile(k--) {\nint pre, aft;\nscanf(\"%d%d\", &pre, &aft);\nhistory[pre][aft] = -1;\nhistory[aft][pre] = 1;\n}\nscanf(\"%d\", &s);\nwhile(s--) {\nint from, to;\nscanf(\"%d%d\", &from, &to);\nsol.push_back(make_pair(from, to));\n}\nHistory();\nfor (int i = 0; i < sol.size(); i++)\nprintf(\"%d\\n\", history[sol[i].first][sol[i].second]);\nreturn 0;\n}"
    },
    {
        "problem_tier": 7,
        "solution_code": "#include <iostream>\n#include <vector>\nusing namespace std;\nint main() {\nint n;\ncin >> n;\nvector<int> nums;\nint maxLength = 0;\nfor (int i = 1; i <= n; i++) {\nint secondNum = i;\nint nextNum = n - secondNum;\nint length = 3;\nvector<int> v = { n, secondNum, nextNum };\nwhile (1) {\nint tmp = nextNum;\nnextNum = secondNum - nextNum;\nif (nextNum < 0)\nbreak;\nsecondNum = tmp;\nlength++;\nv.push_back(nextNum);\n}\nif (maxLength < length) {\nnums = v;\nmaxLength = length;\n}\n}\ncout << maxLength << '\\n';\nfor (auto e : nums)\ncout << e << ' ';\nreturn 0;\n}"
    },
    {
        "problem_tier": 8,
        "solution_code": "#include <iostream>\n#include <algorithm>\nusing namespace std;\nbool cmp(long long a, long long b){\nreturn a > b;\n}\nint main(){\nlong long tips[100001];\nint n;\ncin >> n;\nfor (int i = 0; i < n; i++){\ncin >> tips[i];\n}\nsort(tips, tips + n, cmp);\nlong long sum = 0;\nfor (int i = 0; i < n; i++){\nif (tips[i] - i > 0){\nsum += tips[i] - i;\n}\n}\ncout << sum;\nreturn 0;\n}"
    },
    {
        "problem_tier": 14,
        "solution_code": "#include <iostream>\n#include <vector>\n#include <algorithm>\n#include <queue>\nusing namespace std;\ntypedef pair<int, int> lecture;\nbool cmp(const lecture& a, const lecture& b) {\nif (a.second == b.second) {\nreturn a.first < b.first;\n}\nelse {\nreturn a.second < b.second;\n}\n}\nint main() {\nint n, p, d, ans = 0, cur = 0, idx;\ncin >> n;\nvector<lecture> day;\npriority_queue<int> pq;\nfor (int i = 0; i < n; i++) {\nscanf(\"%d %d\", &p, &d);\nday.push_back(make_pair(p, d));\ncur = max(cur, d);\n}\nsort(day.begin(), day.end(), cmp);\nidx = n - 1;\nwhile (cur) {\nwhile (idx < n && day[idx].second == cur) {\npq.push(day[idx--].first);\n}\nif (!pq.empty()) {\nans += pq.top();\npq.pop();\n}\ncur -= 1;\n}\ncout << ans;\nreturn 0;\n}"
    },
    {
        "problem_tier": 10,
        "solution_code": "#include<iostream>\n#include<queue>\nusing namespace std;\nint N, M;\nint res = 0;\nchar map[601][601]; int visited[601][601]; pair<int, int> I_pos;\nint dy[] = {-1, 0, 1, 0};\nint dx[] = {0, -1, 0, 1};\nvoid bfs() {\nqueue<pair<int, int>> q;\nq.push(I_pos);\nvisited[I_pos.first][I_pos.second] = 1;\nwhile (!q.empty()) {\npair<int, int> cur = q.front();\nq.pop();\nfor (int i = 0; i < 4; i++) {\npair<int, int> next = {cur.first + dy[i], cur.second + dx[i]};\nif (next.first < 0 || next.first >= N || next.second < 0 || next.second >= M) continue;             if (map[next.first][next.second] == 'X') continue;             if (visited[next.first][next.second] == 1) continue;             if (map[next.first][next.second] == 'P') res++;\nq.push(next);\nvisited[next.first][next.second] = 1;\n}\n}\n}\nint main() {\nios_base::sync_with_stdio(false);\ncin.tie(NULL);\ncout.tie(NULL);\ncin >> N >> M;\nfor (int y = 0; y < N; y++) {\nfor (int x = 0; x < M; x++) {\ncin >> map[y][x];\nif (map[y][x] == 'I') {\nI_pos.first = y;\nI_pos.second = x;\n}\n}\n}\nbfs();\nif (res == 0)\ncout << \"TT\";\nelse\ncout << res;\nreturn 0;\n}"
    },
    {
        "problem_tier": 15,
        "solution_code": "#include <iostream>\n#include <algorithm>\n#include <cstring>\nusing namespace std;\nint n, m, k;\nint dp[101][101];\nstring findKthString(int a_cnt, int z_cnt, int k) {\nif (a_cnt == 0) {\nstring s(z_cnt, 'z');\nreturn s;\n}\nif (z_cnt == 0) {\nstring s(a_cnt, 'a');\nreturn s;\n}\nint a_start = dp[a_cnt-1][z_cnt];\nif (k <= a_start) {\nreturn \"a\" + findKthString(a_cnt-1, z_cnt, k);\n} else {\nreturn \"z\" + findKthString(a_cnt, z_cnt-1, k-a_start);\n}\n}\nint main() {\nios::sync_with_stdio(0);\ncin.tie(0);\ncout.tie(0);\ncin >> n >> m >> k;\nmemset(dp, 0, sizeof(dp));\nfor (int i = 0; i <= 100; i++) {\ndp[i][0] = 1;\ndp[0][i] = 1;\n}\nfor (int i = 1; i <= 100; i++) {\nfor (int j = 1; j <= 100; j++) {\ndp[i][j] = min(dp[i-1][j] + dp[i][j-1], 1000000000);\n}\n}\nif (dp[n][m] < k) {\ncout << -1 << endl;\nreturn 0;\n}"
    },
    {
        "problem_tier": 7,
        "solution_code": "#include<iostream>\n#include<algorithm>\n#include<vector>\nusing namespace std;\nint main() {\nios_base::sync_with_stdio(false);\ncin.tie(0);\nint N;\ncin >> N;\nvector<int> v;\nfor(int i=0; i<N; ++i) {\nint number;\ncin >> number;\nv.push_back(number);\n}\nsort(v.begin(), v.end());\nfor(int i=0; i<N; ++i) {\ncout << v[i] << '\\n';\n}\nreturn 0;\n}"
    },
    {
        "problem_tier": 14,
        "solution_code": "#include<iostream>\n#include<queue>\n#include<algorithm>\n#include<cstring>\nusing namespace std;\nint n, m;\nint wall[51][51];\nint ck[51][51];\nint roomCnt, biggestRoomSize, biggestRoomSize2;\nint dr[] = {0, -1, 0, 1};\nint dc[] = {-1, 0, 1, 0};\nint bfs(int i, int j){\nint roomSize = 1;\nck[i][j] = 1;\nqueue<pair<int, int>> q;\nq.push({i, j});\nwhile(!q.empty()){\nint r = q.front().first;\nint c = q.front().second;\nq.pop();\nint wallInfo = wall[r][c];\nfor(int dir=0; dir<4; dir++){\nint nr = r + dr[dir];\nint nc = c + dc[dir];\nif(0 > nr || nr >= n || 0 > nc || nc >= m) continue;             if((wallInfo & (1 << dir)) || ck[nr][nc]) continue;\nroomSize++;\nq.push({nr, nc});\nck[nr][nc] = 1;\n}\n}\nreturn roomSize;\n}\nint main(){\ncin >> m >> n;\nfor(int i=0; i<n; i++){\nfor(int j=0; j<m; j++){\ncin >> wall[i][j];\n}\n}\nfor(int i=0; i<n; i++){\nfor(int j=0; j<m; j++){\nif(!ck[i][j]){\nbiggestRoomSize = max(biggestRoomSize, bfs(i, j));\nroomCnt++;\n}\n}\n}\nfor(int i=0; i<n; i++){\nfor(int j=0; j<m; j++){\nfor(int dir=1; dir<=8; dir <<= 1){\nif(wall[i][j] & dir){\nmemset(ck, 0, sizeof(ck));\nwall[i][j] -= dir;\nbiggestRoomSize2 = max(biggestRoomSize2, bfs(i, j));\nwall[i][j] += dir;\n}\n}\n}\n}\ncout << roomCnt << '\\n' << biggestRoomSize << '\\n' << biggestRoomSize2 << '\\n';\nreturn 0;\n}"
    },
    {
        "problem_tier": 4,
        "solution_code": "#include<iostream>\nusing namespace std;\nint main(){\nint n;\ncin >> n;\ncout << ((n / 2) + 1) * ((n - n / 2) + 1) << '\\n';\n}\n// 주어진 수 n에 대해서, ((n / 2) + 1) * ((n - n / 2) + 1)을 계산하여 출력합니다."
    },
    {
        "problem_tier": 13,
        "solution_code": "#include <iostream>\n#include <algorithm>\n#include <string>\n#include <cstring>\n#define MAX 101\nusing namespace std;\nint LCS[MAX][MAX][MAX] = {0,};\nint main() {\nios::sync_with_stdio(false);\ncin.tie(NULL);\nstring a, b, c;\ncin >> a >> b >> c;\nint save = 0;\nint alen = a.length();\nint blen = b.length();\nint clen = c.length();\nLCS[0][0][0] = 0;\nfor (int i = 1; i <= alen; i++) {\nfor (int j = 1; j <= blen; j++) {\nfor (int k = 1; k <= clen; k++) {\nif (a[i-1] == b[j-1] && b[j-1] == c[k-1]) {\nLCS[i][j][k] = LCS[i-1][j-1][k-1] + 1;\n} else {\nLCS[i][j][k] = max(max(LCS[i-1][j][k], LCS[i][j-1][k]), LCS[i][j][k-1]);\n}\nsave = max(save, LCS[i][j][k]);\n}\n}\n}\ncout << save;\nreturn 0;\n}"
    },
    {
        "problem_tier": 11,
        "solution_code": "#include<iostream>\n#include<bitset>\nusing namespace std;\nint main() {\nint n;\ncin >> n;\nbitset<20*100000+1> num;\nfor(int i=0; i<n; i++) {\nint x;\ncin >> x;\nnum |= num << x;\nnum.set(x);\n}\nint ans = 1;\nwhile(num[ans]) {\nans++;\n}\ncout << ans << endl;\nreturn 0;\n}"
    },
    {
        "problem_tier": 11,
        "solution_code": "#include <iostream>\n#include <stack>\nint main(){\nstd::ios_base::sync_with_stdio(0);\nstd::cin.tie(0);\nint N, P, result = 0;\nstd::cin >> N >> P;\nint* pitch = new int[N];      int* fret = new int[N];\nfor (int i = 0; i < N; i++){\nint p, f;\nstd::cin >> p >> f;\npitch[i] = p;          fret[i] = f;\n}\nfor (int num = 1; num <= 6; num++)      {\nstd::stack<int> st;\nfor (int i = 0; i < N; i++)\n{\nif (pitch[i] == num)              {\nif (!st.empty() && fret[i] > st.top())\n{\nst.push(fret[i]);\nresult++;\n}\nelse if (!st.empty() && fret[i] <= st.top())\n{\nwhile (fret[i] < st.top())\n{\nst.pop();\nresult++;\nif (st.empty()) break;\n}\nif (!st.empty() && fret[i] > st.top())\n{\nst.push(fret[i]);\nresult++;\n}\nelse if (st.empty())\n{\nst.push(fret[i]);\nresult++;\n}\n}\nelse if (st.empty())\n{\nst.push(fret[i]);\nresult++;\n}\n}\n}\n}\nstd::cout << result;\nreturn 0;\n}"
    },
    {
        "problem_tier": 11,
        "solution_code": "#include <iostream>\n#include <vector>\n#include <algorithm>\nusing namespace std;\nint main() {\nint width, height, store_num, temp1, temp2, sum = 0;\nint dong[2];\nvector<pair<int,int>> store;\ncin >> width >> height >> store_num;\nfor (int i = 0; i < store_num; i++) {\ncin >> temp1 >> temp2;\nstore.push_back(make_pair(temp1, temp2));\n}\ncin >> dong[0] >> dong[1];\nfor (int i = 0; i < store_num; i++) {\nif (dong[0] == store[i].first) {\nsum += abs(dong[1] - store[i].second);\n} else if (dong[0] == 1 || dong[0] == 2) {\nif (store[i].first == 3 || store[i].first == 4) {\nif (store[i].first == 3) {\nsum += dong[1];\n} else {\nsum += width - dong[1];\n}\nif (dong[0] == 1) {\nsum += store[i].second;\n} else {\nsum += height - store[i].second;\n}\n} else {\nif (height + store[i].second + dong[1] > height + width) {\nsum += 2 * (width + height) - (height + store[i].second + dong[1]);\n} else {\nsum += height + store[i].second + dong[1];\n}\n}\n} else {\nif (store[i].first == 1 || store[i].first == 2) {\nif (store[i].first == 1) {\nsum += dong[1];\n} else {\nsum += height - dong[1];\n}\nif (dong[0] == 3) {\nsum += store[i].second;\n} else {\nsum += width - store[i].second;\n}\n} else {\nif (width + store[i].second + dong[1] > height + width) {\nsum += 2 * (width + height) - (width + store[i].second + dong[1]);\n} else {\nsum += width + store[i].second + dong[1];\n}\n}\n}\n}\ncout << sum;\nreturn 0;\n}"
    },
    {
        "problem_tier": 4,
        "solution_code": "#include <iostream>\n#include <algorithm>\nusing namespace std;\nint main() {\nint arr[4];\nfor (int i = 0; i < 4; i++) {\ncin >> arr[i];\n}\nsort(arr, arr + 4);\ncout << arr[0] * arr[2] << endl;\nreturn 0;\n}"
    },
    {
        "problem_tier": 18,
        "solution_code": "#include<bits/stdc++.h>\n#define p pair<int, int>\nusing namespace std;\nint n, w, dp[1001][1001], cache[1001][1001];\nvector<p> v;\nint d(int a, int b) {\nreturn abs(v[a].first - v[b].first) + abs(v[a].second - v[b].second);\n}\nint getSum(int a, int b) {\nif (a == w + 1 || b == w + 1)\nreturn 0;\nif (dp[a][b] != 0)\nreturn dp[a][b];\nint nextCase = max(a, b) + 1;\nint g = getSum(a, nextCase) + d(b, nextCase);\nint h = getSum(nextCase, b) + d(a, nextCase);\nif (g < h) {\ncache[a][b] = 2;\n}\nelse {\ncache[a][b] = 1;\n}\ndp[a][b] = min(g, h);\nreturn dp[a][b];\n}\nvoid solve() {\nint a = 0, b = 1;\nfor (int i = 2; i < w + 2; i++) {\nint nextCase = max(a, b) + 1;\nif (cache[a][b] == 1) {\ncout << \"1\" << endl;\na = i;\n}\nelse {\ncout << \"2\" << endl;\nb = i;\n}\n}\n}\nint main() {\ncin >> n >> w;\nv.push_back({ 1, 1 });\nv.push_back({ n, n });\nfor (int i = 0; i < w; i++) {\nint a, b;\ncin >> a >> b;\nv.push_back({ a, b });\n}\ncout << getSum(0, 1) << endl;\nsolve();\n}"
    },
    {
        "problem_tier": 3,
        "solution_code": "#include <iostream>\nusing namespace std;\nint main() {\nint a, b, c, d, e;\ncin >> a >> b >> c >> d >> e;\nif (a < 0)\ncout << -a * c + d + e * b << '\\n';\nelse if (a > 0)\ncout << e * (b - a) << '\\n';\nelse\ncout << d + e * b << '\\n';\nreturn 0;\n}"
    },
    {
        "problem_tier": 11,
        "solution_code": "#include <iostream>\n#include <vector>\n#include <algorithm>\n#define INF 1e9\nusing namespace std;\nint main() {\nios_base::sync_with_stdio(false);\ncin.tie(NULL);\ncout.tie(NULL);\nint N, D;\ncin >> N >> D;\nvector<int> dp(D + 1, INF);\nvector<pair<int, int>> shortcuts[10001];\nfor (int i = 0; i < N; i++) {\nint from, to, cost;\ncin >> from >> to >> cost;\nif (to > D || to - from < cost)\ncontinue;\nshortcuts[to].push_back({from, cost});\n}\ndp[0] = 0;\nfor (int i = 1; i <= D; i++) {\ndp[i] = dp[i - 1] + 1;\nfor (int j = 0; j < shortcuts[i].size(); j++) {\ndp[i] = min(dp[i], dp[shortcuts[i][j].first] + shortcuts[i][j].second);\n}\n}\ncout << dp[D];\nreturn 0;\n}"
    },
    {
        "problem_tier": 5,
        "solution_code": "#include <iostream>\n#include <string>\nusing namespace std;\nint main(void) {\nios::sync_with_stdio(0);\ncin.tie(0);\nint test;\ncin >> test;\nwhile (test--) {\nstring s1, s2;\nint sa1[26], sa2[26];\nfor (int i = 0; i < 26; i++) {\nsa1[i] = 0;\nsa2[i] = 0;\n}\ncin >> s1 >> s2;\nbool isPossible = true;\nif (s1.length() != s2.length()) {\nisPossible = false;\n} else {\nfor (int i = 0; i < s1.length(); i++) {\nsa1[s1[i] - 'a']++;\nsa2[s2[i] - 'a']++;\n}\nfor (int i = 0; i < 26; i++) {\nif (sa1[i] != sa2[i]) {\nisPossible = false;\nbreak;\n}\n}\n}\nif (isPossible) {\ncout << \"Possible\" << '\\n';\n} else {\ncout << \"Impossible\" << '\\n';\n}\n}\nreturn 0;\n}"
    },
    {
        "problem_tier": 1,
        "solution_code": "#include <iostream>\nusing namespace std;\nint main(int argc, char* argv[]) {\ncout << \"02-521-0487\" << endl;\nreturn 0;\n}"
    },
    {
        "problem_tier": 2,
        "solution_code": "#include <iostream>\n#include <vector>\n#include <algorithm>\nusing namespace std;\nint main() {\nint n;\ncin >> n;\nvector<int> nums(n);\nfor (int i = 0; i < n; i++) {\ncin >> nums[i];\n}\nsort(nums.begin(), nums.end());\nfor (int i = 0; i < n; i++) {\ncout << nums[i] << '\\n';\n}\nreturn 0;\n}"
    },
    {
        "problem_tier": 15,
        "solution_code": "#include <iostream>\n#include <vector>\n#include <algorithm>\n#include <cstring>\n#define MAX 25\nusing namespace std;\nint N, M, K;\nstruct Shark{\nint x, y;\nint Dir;\nbool Live;\nvector<int> Priority[5];\n};\nstruct Map_Info{\nvector<int> V;\nint Smell_Time;\nint Smell_Host;\n};\nShark Shark[410];\nMap_Info Map[MAX][MAX];\nint dx[] = { 0, -1, 1, 0, 0 };\nint dy[] = { 0, 0, 0, -1, 1 };\nvoid Input(){\ncin >> N >> M >> K;\nfor (int i = 0; i < N; i++)\n{\nfor (int j = 0; j < N; j++)\n{\nint a; cin >> a;\nif (a != 0)\n{\nMap[i][j].V.push_back(a);\nShark[a].x = i;\nShark[a].y = j;\n}\nMap[i][j].Smell_Time = 0;\nMap[i][j].Smell_Host = 0;\n}\n}\nfor (int i = 1; i <= M; i++)\n{\nint Dir; cin >> Dir;\nShark[i].Dir = Dir;\nShark[i].Live = true;\n}\nfor (int i = 1; i <= M; i++)\n{\nfor (int j = 1; j <= 4; j++)\n{\nint Arr[4];\ncin >> Arr[0] >> Arr[1] >> Arr[2] >> Arr[3];\nfor (int k = 0; k < 4; k++)\n{\nShark[i].Priority[j].push_back(Arr[k]);\n}\n}\n}\n}\nbool Check(){\nfor (int i = 2; i <= M; i++)\n{\nif (Shark[i].Live == true) return false;\n}\nreturn true;\n}\nvoid Setting_Smell(int Time){\nfor (int i = 1; i <= M; i++)\n{\nif (Shark[i].Live == false) continue;\nint x = Shark[i].x;\nint y = Shark[i].y;\nMap[x][y].Smell_Time = Time + K;\nMap[x][y].Smell_Host = i;\n}\n}\nvoid Move_Shark(int Time){\nfor (int i = 1; i <= M; i++)\n{\nif (Shark[i].Live == false) continue;\nint x = Shark[i].x;\nint y = Shark[i].y;\nint Dir = Shark[i].Dir;\nint Self_x, Self_y, Self_Dir;\nSelf_x = Self_y = Self_Dir = -1;\nbool Flag = false;\nfor (int j = 0; j < Shark[i].Priority[Dir].size(); j++)\n{\nint nDir = Shark[i].Priority[Dir][j];\nint nx = x + dx[nDir];\nint ny = y + dy[nDir];\nif (nx >= 0 && ny >= 0 && nx < N && ny < N)\n{\nif (Map[nx][ny].Smell_Time <= Time)\n{\nFlag = true;\nMap[nx][ny].V.push_back(i);\nShark[i].x = nx;\nShark[i].y = ny;\nShark[i].Dir = nDir;\nbreak;\n}\nelse\n{\nif (Map[nx][ny].Smell_Host == i)\n{\nif (Self_x == -1)\n{\nSelf_x = nx;\nSelf_y = ny;\nSelf_Dir = nDir;\n}\n}\n}\n}\n}\nif (Flag == false)\n{\nMap[Self_x][Self_y].V.push_back(i);\nShark[i].x = Self_x;\nShark[i].y = Self_y;\nShark[i].Dir = Self_Dir;\n}\n}\n}\nvoid Killing_Shark(){\nfor (int"
    },
    {
        "problem_tier": 10,
        "solution_code": "#include<bits/stdc++.h>\nusing namespace std;\nstring s;\nint maxPalinLen;\nbool isPalindrome(string str){\nfor(int i=0;i<str.size()/2;i++){\nif(str[i]!=str[str.size()-1-i]){\nreturn false;\n}\n}\nreturn true;\n}\nint main(){\ncin>>s;\nfor(int i=0;i<s.size();i++){\nif(isPalindrome(s.substr(i))){\nmaxPalinLen=max(maxPalinLen,(int)s.size()-i);\n}\n}\ncout<<(s.size()-maxPalinLen)*2+maxPalinLen;\nreturn 0;\n}"
    },
    {
        "problem_tier": 6,
        "solution_code": "#include <iostream>\n#include <string>\nusing namespace std;\nint countZeros(int n, int m) {\nint cnt = 0;\nfor(int i = n; i <= m; i++){\nstring str = to_string(i);\nfor(int j = 0; j < str.length(); j++){\nif(str[j] == '0'){\ncnt++;\n}\n}\n}\nreturn cnt;\n}\nint main() {\nint T, N, M;\ncin >> T;\nfor(int i = 0; i < T; i++){\ncin >> N >> M;\ncout << countZeros(N, M) << \"\\n\";\n}\nreturn 0;\n}"
    },
    {
        "problem_tier": 13,
        "solution_code": "#include <iostream>\n#include <algorithm>\n#include <cmath>\nusing namespace std;\nint book[10001];\nint main() {\nint n,m,count=0;\nint answer=0;\ncin >> n >> m;\nfor (int i = 0; i < n; i++) {\ncin >> book[i];\nif (book[i] < 0)\ncount++;\n}\nsort(book,book+n);\nfor (int i = 0; i < count; i += m)\nanswer += abs(book[i] * 2);\nfor (int i = n-1; i >= count; i -= m)\nanswer += book[i] * 2;\nanswer -= max(abs(book[0]),abs(book[n-1]));\ncout << answer << '\\n';\nreturn 0;\n}"
    },
    {
        "problem_tier": 4,
        "solution_code": "#include <iostream>\nusing namespace std;\nint main() {\nint N, T, C, P;\ncin >> N >> T >> C >> P;\nint ans = ((N - 1) / T) * C * P;\ncout << ans;\nreturn 0;\n}"
    },
    {
        "problem_tier": 20,
        "solution_code": "#include <iostream>\n#include <vector>\n#include <algorithm>\n#include <set>\n#include <cmath>\nusing namespace std;\nclass Point {\npublic:\nint x, y;\nPoint(int _x, int _y) : x(_x), y(_y) {}\nbool operator<(const Point& v) const {\nif (y == v.y) {\nreturn x < v.x;\n} else {\nreturn y < v.y;\n}\n}\n};\nint dist(Point p1, Point p2) {\nreturn (p1.x - p2.x) * (p1.x - p2.x) + (p1.y - p2.y) * (p1.y - p2.y);\n}\nbool cmp(const Point& u, const Point& v) {\nreturn u.x < v.x;\n}\nint main() {\nios_base::sync_with_stdio(0);\ncin.tie(0);\nint N;\ncin >> N;\nvector<Point> vec;\nint a, b;\nfor (int i = 0; i < N; i++) {\ncin >> a >> b;\nvec.push_back(Point(a, b));\n}\nsort(vec.begin(), vec.end(), cmp);\nint minDist = dist(vec[0], vec[1]);\nset<Point> s;\ns.insert(vec[0]);\ns.insert(vec[1]);\nint start = 0;\nfor (int i = 2; i < N; i++) {\nPoint nowP = vec[i];\nwhile (start < i) {\nPoint p = vec[start];\nint gap = nowP.x - p.x;\nif (gap * gap > minDist) {\ns.erase(p);\nstart++;\n} else {\nbreak;\n}\n}\nint sqrtMinDist = (int)(sqrt((double)minDist) + 1);\nauto up = s.upper_bound(Point(100000, nowP.y + sqrtMinDist));\nauto low = s.lower_bound(Point(-100000, nowP.y - sqrtMinDist));\nwhile (low != up) {\nint tmpDist = dist(nowP, *low);\nif (tmpDist < minDist) {\nminDist = tmpDist;\n}\nlow++;\n}\ns.insert(nowP);\n}\ncout << minDist << \"\\n\";\nreturn 0;\n}"
    },
    {
        "problem_tier": 11,
        "solution_code": "#include<iostream>\nusing namespace std;\nint main() {\nint D, K;\ncin >> D >> K;\nint A[31], B[31];\nA[1] = 1;\nA[2] = 0;\nB[1] = 0;\nB[2] = 1;\nfor (int i = 3; i <= D; i++) {\nA[i] = A[i - 1] + A[i - 2];\nB[i] = B[i - 1] + B[i - 2];\n}\nint answerA, answerB;\nfor (int i = 1; i <= K; i++) {\nint spare = K - (A[D] * i);\nif (spare % B[D] == 0) {\nanswerA = i;\nanswerB = spare / B[D];\nbreak;\n}\n}\ncout << answerA << endl;\ncout << answerB << endl;\nreturn 0;\n}"
    },
    {
        "problem_tier": 17,
        "solution_code": "#include <iostream>\n#include <vector>\n#include <algorithm>\n#include <stack>\nusing namespace std;\nstruct pos {\nlong long x, y;\n};\nbool comp_y(pos a, pos b){\nif(a.y != b.y)\nreturn a.y < b.y;\nelse\nreturn a.x < b.x;\n}\nlong long ccw(pos a, pos b, pos c){\nreturn a.x*b.y + b.x*c.y + c.x*a.y - (b.x*a.y + c.x*b.y + a.x*c.y);\n}\nbool comp_c(pos a, pos b){\nlong long cc = ccw(v[0], a, b);\nif(cc != 0)\nreturn cc > 0;\nelse\nreturn (a.x + a.y) < (b.x + b.y);\n}\nint main(void){\nios_base::sync_with_stdio(false);\ncin.tie(NULL);\nstack<pos> s;\nint N;\ncin >> N;\nvector<pos> v(N);\nfor(int i=0; i<N; i++){\ncin >> v[i].x >> v[i].y;\n}\nsort(v.begin(), v.end(), comp_y);\nsort(v.begin()+1, v.end(), comp_c);\ns.push(v[0]);\ns.push(v[1]);\npos first, second;\nfor(int i=2; i<N; i++){\nwhile(s.size() >= 2){\nsecond = s.top();\ns.pop();\nfirst = s.top();\nif(ccw(first, second, v[i]) > 0){\ns.push(second);\nbreak;\n}\n}\ns.push(v[i]);\n}\ncout << s.size();\nreturn 0;\n}"
    },
    {
        "problem_tier": 8,
        "solution_code": "#include<iostream>\n#include<string>\n#include<unordered_set>\n#include<vector>\n#include<algorithm>\nusing namespace std;\nint n, k;\nunordered_set<string> resultSet;\nvector<int> resultVt;\nbool visited[10];\nvoid permutation(vector<int> input, int end) {\nif (resultVt.size() == end) {\nstring result = \"\";\nfor (int i = 0; i < resultVt.size(); i++) {\nresult += to_string(resultVt[i]);\n}\nresultSet.insert(result);\nreturn;\n}\nfor (int i = 0; i < n; i++) {\nif (visited[i]) continue;\nvisited[i] = true;\nresultVt.push_back(input[i]);\npermutation(input, end);\nresultVt.pop_back();\nvisited[i] = false;\n}\n}\nint main() {\nios::sync_with_stdio(false);\ncin.tie(0);\ncout.tie(0);\ncin >> n >> k;\nvector<int> input(n);\nfor (int i = 0; i < n; i++) {\ncin >> input[i];\n}\npermutation(input, k);\ncout << resultSet.size();\nreturn 0;\n}"
    },
    {
        "problem_tier": 9,
        "solution_code": "#include <iostream>\n#include <vector>\n#include <map>\n#include <algorithm>\nusing namespace std;\nstruct bindo{\nint num;\nint cnt;\nint idx;\n};\nvector<bindo> vec;\nbool cmp(const bindo& b1, const bindo& b2){\nif(b1.cnt == b2.cnt){\nreturn b1.idx < b2.idx;\n}\nelse{\nreturn b1.cnt > b2.cnt;\n}\n}\nint main(void){\nint n, c;\ncin >> n >> c;\nvector<int> rem;\nfor(int i=0; i<n; i++){\nint tmp;\ncin >> tmp;\nrem.push_back(tmp);\n}\nfor(int i=n-1; i>=0; i--){\nbool c = true;\nfor(int j=0; j<vec.size(); j++){\nif(vec[j].num == rem[i]){\nc = false;\nvec[j].cnt += 1;\nvec[j].idx = i;\nbreak;\n}\n}\nif(c){\nvec.push_back({rem[i], 1, i});\n}\n}\nsort(vec.begin(), vec.end(), cmp);\nfor(int i=0; i<vec.size(); i++){\nfor(int j=0; j<vec[i].cnt; j++){\ncout << vec[i].num << \" \";\n}\n}\nreturn 0;\n}"
    },
    {
        "problem_tier": 13,
        "solution_code": "#include<iostream>\n#include<algorithm>\n#include<set>\n#include<vector>\n#include<map>\nusing namespace std;\nint sushi_belt[3000000];\nvector<set<int>> sushi_set;\nint main(){\nint n, d, k, c;\ncin >> n >> d >> k >> c;\nfor(int i=0; i<n; i++)\ncin >> sushi_belt[i];\nint index = 0;\nfor(int i=0; i<n; i++){\nfor(int j=0; j<k; j++){\nsushi_set.push_back(set<int>());\nint tmp = (i+j > n-1) ? i+j-n : i+j;             sushi_set[index].insert(sushi_belt[tmp]);\n}\nsushi_set[index++].insert(c);\n}\nint max_count = 0;\nfor(int i=0; i<n; i++){\nsushi_set[i].size() > max_count ? max_count = sushi_set[i].size() : max_count;\n}\ncout << max_count;\nreturn 0;\n}"
    },
    {
        "problem_tier": 6,
        "solution_code": "#include <iostream>\nusing namespace std;\nbool isLucky(int num) {\nwhile (num != 0) {\nint digit = num % 10;\nif (digit != 4 && digit != 7) {\nreturn false;\n}\nnum /= 10;\n}\nreturn true;\n}\nint main() {\nint n;\ncin >> n;\nfor (int i = n; i >= 4; i--) {\nif (isLucky(i)) {\ncout << i << endl;\nbreak;\n}\n}\nreturn 0;\n}"
    },
    {
        "problem_tier": 10,
        "solution_code": "#include<bits/stdc++.h>\nusing namespace std;\n#define MAX 50\nint board[MAX][MAX];\nint xlen, ylen; int dx[8] = {-1, -1, -1, 0, 1, 1, 1, 0};\nint dy[8] = {-1, 0, 1, 1, 1, 0, -1, -1};\nvoid input() {\ncin >> ylen >> xlen;\nfor (int y = 0; y < ylen; y++) {\nfor (int x = 0; x < xlen; x++) {\ncin >> board[y][x];\n}\n}\n}\nint bfs(int x, int y) {     bool visit[MAX][MAX] = {false, };\nqueue<tuple<int, int, int>> q;     q.push(make_tuple(x, y, 0));\nvisit[y][x] = true;\nwhile (!q.empty()) {\nint orix = get<0>(q.front());         int oriy = get<1>(q.front());\nint dist = get<2>(q.front());\nq.pop();\nif (board[oriy][orix] == 1) {\nreturn dist;\n}\nfor (int i = 0; i < 8; i++) {\nint nx = orix + dx[i];             int ny = oriy + dy[i];\nif (nx < 0 || nx >= xlen) continue;             if (ny < 0 || ny >= ylen) continue;\nif (visit[ny][nx]) continue;\nvisit[ny][nx] = true;\nq.push(make_tuple(nx, ny, dist + 1));\n}\n}\n}\nvoid solution() {\nint max_dist = -1;\nfor (int y = 0; y < ylen; y++) {\nfor (int x = 0; x < xlen; x++) {\nif (board[y][x] != 1) {                 max_dist = max(max_dist, bfs(x, y));             }\n}\n}\ncout << max_dist;\n}\nint main() {\nios_base::sync_with_stdio(false);\ncin.tie(nullptr);\ninput();\nsolution();\n}"
    },
    {
        "problem_tier": 3,
        "solution_code": "#include <iostream>\nusing namespace std;\nint main() {\ndouble a, b;\ncin >> a >> b;\nif (a * (100 - b) / 100 >= 100)\ncout << 0;\nelse\ncout << 1;\nreturn 0;\n}"
    },
    {
        "problem_tier": 13,
        "solution_code": "#include <iostream>\n#include <vector>\n#include <cstring>\nusing namespace std;\nvector<int> adj[503];\nbool visited[503];\nbool DFS(int index, int parentIndex) {\nvisited[index] = true;\nfor(auto head : adj[index]) {\nif (!visited[head]) {\nif (DFS(head, index)) return true;\n}\nelse if (parentIndex != head) return true;\n}\nreturn false;\n}\nint main() {\nios::sync_with_stdio(false);\ncin.tie(0);\ncout.tie(0);\nint N, M, answer;\nint count = 0;\nwhile (1) {\nanswer = 0;\ncin >> N >> M;\nif (N == 0 && M == 0) break;\nfor (int i = 1; i <= 500; i++) adj[i].clear();\nwhile (M--) {\nint from, to;\ncin >> from >> to;\nadj[from].push_back(to);\nadj[to].push_back(from);\n}\nmemset(visited, false, sizeof(visited));\nfor (int i = 1; i <= N; i++) {\nif (!visited[i]) {\nif (!DFS(i, -1)) answer++;\n}\n}\ncout << \"Case \" << ++count;\nif (answer == 0) cout << \": No trees.\" << endl;\nelse if (answer == 1) cout << \": There is one tree.\" << endl;\nelse cout << \": A forest of \" << answer << \" trees.\" << endl;\n}\nreturn 0;\n}"
    },
    {
        "problem_tier": 11,
        "solution_code": "#include <iostream>\n#include <queue>\nusing namespace std;\nconst int MAX = 200;\nint N, R1, R2, C1, C2;\nbool Visit[MAX][MAX];\nint dx[] = { -2, -2, 0, 0, 2, 2 };\nint dy[] = { -1, 1, -2, 2, -1, 1 };\nvoid Input(){\ncin >> N;\ncin >> R1 >> C1 >> R2 >> C2;\n}\nvoid BFS(int a, int b){\nqueue<pair<pair<int, int>, int>> Q;\nQ.push(make_pair(make_pair(a, b), 0));\nVisit[a][b] = true;\nwhile (Q.empty() == 0)\n{\nint x = Q.front().first.first;\nint y = Q.front().first.second;\nint Cnt = Q.front().second;\nQ.pop();\nif (x == R2 && y == C2)\n{\ncout << Cnt << endl;\nreturn;\n}\nfor (int i = 0; i < 6; i++)\n{\nint nx = x + dx[i];\nint ny = y + dy[i];\nif (nx >= 0 && ny >= 0 && nx < N && ny < N)\n{\nif (Visit[nx][ny] == false)\n{\nVisit[nx][ny] = true;\nQ.push(make_pair(make_pair(nx, ny), Cnt + 1));\n}\n}\n}\n}\ncout << -1 << endl;\n}\nvoid Solution(){\nBFS(R1, C1);\n}\nvoid Solve(){\nInput();\nSolution();\n}\nint main(void){\nios::sync_with_stdio(false);\ncin.tie(NULL);\ncout.tie(NULL);\nSolve();\nreturn 0;\n}"
    },
    {
        "problem_tier": 16,
        "solution_code": "#include <iostream>\n#include <cstring>\n#define MAX 2501\nusing namespace std;\nbool dp[MAX][MAX];\nstring str;\nint N, res[MAX];\nbool is_palin(int st, int ed){\nif(ed > N) return false;\nif(str[st] == str[ed]){\nif(dp[st+1][ed-1] || ed-st == 1){\nreturn true;\n}\n}\nreturn false;\n}\nvoid fill_dptable(){\nfor(int d = 0; d < N; d++){\nfor(int i = 1; i+d <= N; i++){\nif(d == 0){\ndp[i][i] = true;\ncontinue;\n}\nif(is_palin(i, i+d)){\ndp[i][i+d] = true;\n}\n}\n}\n}\nvoid solve(){\nfill_dptable();\nres[0] = 0;\nfor (int i = 1; i <= N; i++) {\nres[i] = INF;\nfor (int j = 1; j <= i; j++) {\nif (dp[j][i]) {\nif (res[i] > res[j-1]+1) {\nres[i] = res[j-1]+1;\n}\n}\n}\n}\ncout << res[N];\n}\nint main(){\ncin >> str;\nN = str.size();\nstr = \" \" + str;\nsolve();\nreturn 0;\n}"
    },
    {
        "problem_tier": 2,
        "solution_code": "#include <iostream>\n#include <cstring>\nusing namespace std;\nchar* maxchk(char*a,char*b){\nif(strlen(a)>strlen(b)){         return a;     }\nelse if(strlen(a)<strlen(b)){         return b;     }\nelse{\nfor(int i=0;i<strlen(a);i++){\nif(a[i]<b[i]){                 return b;             }\nif(a[i]>b[i]){                 return a;             }\n}\nreturn a;     }\n}\nchar* minchk(char*a,char*b){\nif(strlen(a)>strlen(b)){         return b;     }\nelse if(strlen(a)<strlen(b)){         return a;     }\nelse{\nfor(int i=0;i<strlen(a);i++){\nif(a[i]<b[i]){                 return a;             }\nif(a[i]>b[i]){                 return b;             }\n}\nreturn a;     }\n}\nvoid add(char*a,char*b,char*c){\nint r[1010]={0};     int i=strlen(a)-1;     for(int j=strlen(b)-1;j>=0;j--){         if(i>=0){\nr[i]=(a[i]-'0')+(b[j]-'0');         }\ni--;     }\nfor(;i>=0;i--)         r[i]=a[i]-'0';\nfor(int i=strlen(a)-1;i>0;i--){         if(r[i]>9){             r[i]-=10;             r[i-1]++;         }\n}\nfor(int i=0;i<strlen(a);i++){         if(r[0]>9){\nc[0]='1';\nc[i+1]=r[i]+'0';\n}\nelse{\nc[i]=r[i]+'0';\n}\n}\nif(r[0]>9){         c[1]=c[1]-10;\nc[strlen(a)+1]='\\0';\n}\nelse\nc[strlen(a)]='\\0';\n}\nvoid sub(char*a,char*b,char*c){\nint r[1010]={0};     int i=strlen(a)-1;     bool chk=false;     int k=0;\nfor(int j=strlen(b)-1;j>=0;j--){         if(i>=0){\nr[i]=(a[i]-'0')-(b[j]-'0');         }\ni--;     }\nfor(;i>=0;i--)         r[i]=a[i]-'0';\nfor(i=strlen(a)-1;i>0;i--){         if(r[i]<0){             r[i]+=10;             r[i-1]--;         }\n}\nfor(i=0;i<strlen(a);i++){         if(r[i]!=0)\nchk=true;\n}\nif(!chk){         c[0]=0;\nc[1]='\\0';\n}\nelse{         for(i=0;r[i]==0;i++);         for(;i<strlen(a);i++,k++){             c[k]=r[i]+'0';\n}\nc[k]='\\0';\n}\n}\nchar* max(char*a,char*b){\nfor(int i=0;i<strlen(a);i++){\nif(a[i]<b[i])             return b;         if(a[i]>b[i])             return a;     }\nreturn a; }\nvoid subtract(char*a,char*b){     for(int i=0;i<strlen(b);i++){         a[i]=a[i]-b[i]+'0';         if(a[i]<'0'){             a[i]+=10;             a[i-1]--;         }\n}\nfor(int i=strlen(b)-1;i>=0;i--){         if(a[i]<'0'){             a[i]+=10;             a[i-1]--;         }\n}\n}"
    },
    {
        "problem_tier": 16,
        "solution_code": "#include <iostream>\n#include <vector>\n#include <queue>\n#include <cstring>\nusing namespace std;\nint dx[] = {0, 0, 1, -1};\nint dy[] = {1, -1, 0, 0};\nint main() {\nint t;\ncin >> t;\nwhile (t--) {\nint h, w;\ncin >> h >> w;\nvector<string> building(h+2, string(w+2, '.'));\nvector<vector<bool>> visited(h+2, vector<bool>(w+2, false));\nvector<bool> keys(26, false);\nqueue<pair<int, int>> q;\nfor (int i = 1; i <= h; i++) {\nstring row;\ncin >> row;\nfor (int j = 1; j <= w; j++) {\nbuilding[i][j] = row[j-1];\n}\n}\nstring keyInPossession;\ncin >> keyInPossession;\nfor (char key : keyInPossession) {\nkeys[key - 'a'] = true;\n}\nfor (int i = 0; i <= h+1; i++) {\nif (building[i][0] != '*') {\nq.push({i, 0});\nvisited[i][0] = true;\n}\nif (building[i][w+1] != '*') {\nq.push({i, w+1});\nvisited[i][w+1] = true;\n}\n}\nfor (int j = 0; j <= w+1; j++) {\nif (building[0][j] != '*') {\nq.push({0, j});\nvisited[0][j] = true;\n}\nif (building[h+1][j] != '*') {\nq.push({h+1, j});\nvisited[h+1][j] = true;\n}\n}\nint countDoc = 0;\nwhile (!q.empty()) {\nint x = q.front().first;\nint y = q.front().second;\nq.pop();\nif ('A' <= building[x][y] && building[x][y] <= 'Z') {\nint keyIndex = building[x][y] - 'A';\nif (keys[keyIndex]) {\nbuilding[x][y] = '.';\n} else {\ncontinue;\n}\n}\nif ('a' <= building[x][y] && building[x][y] <= 'z') {\nint keyIndex = building[x][y] - 'a';\nkeys[keyIndex] = true;\nwhile (!q.empty()) q.pop();\nmemset(visited, false, sizeof(visited));\n}\nif (building[x][y] == '$') {\ncountDoc++;\nbuilding[x][y] = '.';\n}\nfor (int i = 0; i < 4; i++) {\nint nx = x + dx[i];\nint ny = y + dy[i];\nif (nx >= 0 && nx <= h+1 && ny >= 0 && ny <= w+1) {\nif (building[nx][ny] == '*' || visited[nx][ny]) continue;\nvisited[nx][ny] = true;\nq.push({nx, ny});\n}\n}\n}\ncout << countDoc << endl;\n}\nreturn 0;\n}"
    },
    {
        "problem_tier": 7,
        "solution_code": "#include <iostream>\n#include <vector>\n#include <algorithm>\nusing namespace std;\nint solution(vector<int> arr)\n{\nint cnt = -1, day = 1;\nsort(arr.begin(), arr.end(), greater<>());\nfor (auto now : arr)\n{\ncnt = max(cnt, day + now);\nday++;\n}\ncnt++;     return cnt;\n}\nint main()\n{\nios::sync_with_stdio(0);\nvector<int> arr;\nint n;\ncin >> n;\nwhile (n--)\n{\nint temp;\ncin >> temp;\narr.push_back(temp);\n}\ncout << solution(arr) << endl;\nreturn 0;\n}"
    },
    {
        "problem_tier": 12,
        "solution_code": "#include <iostream>\n#define Max 10001\nusing namespace std;\nint DP[Max][4] = {0,};\nint curN = 0;\nint T;\nvoid solution(){\nDP[0][1] = 1;\nDP[1][1] = 1;\nfor(int i=2; i<=10000; i++){\nDP[i][1] = DP[i-1][1];\nDP[i][2] = DP[i-2][1] + DP[i-2][2];\nif(i >= 3)\nDP[i][3] = DP[i-3][1] + DP[i-3][2] + DP[i-3][3];\n}\n}\nint main(){\nint n;\ncin >> T;\nsolution();\ncurN = 3;\nwhile(T--){\ncin >> n;\ncout << DP[n][1] + DP[n][2] + DP[n][3] << '\\n';\n}\nreturn 0;\n}"
    },
    {
        "problem_tier": 10,
        "solution_code": "#include <iostream>\n#include <cmath>\nusing namespace std;\nint gcd(int a, int b) {\nif(b == 0)\nreturn a;\nelse{\nreturn gcd(b, a%b);\n}\n}\nint main() {\nint n, s, temp, totGCD;\ncin >> n >> s;\ntotGCD = abs(s);\nfor(int i = 0; i < n; ++i) {\ncin >> temp;\ntemp = abs(temp - s);\nif(i == 0) {\ntotGCD = temp;\n} else {\ntotGCD = gcd(totGCD, temp);\n}\n}\ncout << totGCD << \"\\n\";\nreturn 0;\n}"
    },
    {
        "problem_tier": 11,
        "solution_code": "#include <iostream>\n#include <vector>\n#include <cmath>\nusing namespace std;\nvoid findCenter(int* arr, int left, int right){\nint center = (left + right) / 2;\nif(left == right){\ncout << arr[center];\nreturn;\n}\ncout << arr[center];\nfindCenter(arr, left, center-1);\nfindCenter(arr, center+1, right);\n}\nint main(){\nint k;\ncin >> k;\nint size_k = pow(2,k)-1;\nint* arr = new int[size_k];\nfor(int i=0; i<size_k; i++){\ncin >> arr[i];\n}\nfindCenter(arr, 0, size_k-1);\nreturn 0;\n}"
    },
    {
        "problem_tier": 3,
        "solution_code": "#include<iostream>\nusing namespace std;\nint main() {\nint S, T, D;\ncin >> S >> T >> D;\ncout << (D / (2 * S)) * T << endl;\nreturn 0;\n}"
    },
    {
        "problem_tier": 10,
        "solution_code": "#include <iostream>\n#include <vector>\n#include <algorithm>\nusing namespace std;\nint n;\nvector<int> strength;\nvector<int> happy;\nint max_pleasure = 0;\nvoid solve(int idx, int strong, int pleasure) {\nif (strong <= 0 || idx >= n) {\nif (max_pleasure < pleasure) {\nmax_pleasure = pleasure;\n}\nreturn;\n}\nsolve(idx+1, strong-strength[idx], pleasure+happy[idx]);\nsolve(idx+1, strong, pleasure);\n}\nint main() {\ncin >> n;\nfor (int i = 0; i < n; i++) {\nint x;\ncin >> x;\nstrength.push_back(x);\n}\nfor (int i = 0; i < n; i++) {\nint x;\ncin >> x;\nhappy.push_back(x);\n}\nsolve(0, 100, 0);\ncout << max_pleasure << endl;\n}"
    },
    {
        "problem_tier": 2,
        "solution_code": "#include <iostream>\nusing namespace std;\nint main() {\nint t;\ncin >> t;\nwhile (t--) {\nint a, b;\ncin >> a >> b;\ncout << a + b << '\\n';\n}\nreturn 0;\n}"
    },
    {
        "problem_tier": 11,
        "solution_code": "#include <iostream>\n#include <algorithm>\n#include <vector>\nusing namespace std;\nstruct Candidate {\nint id;\nint count;\nint order;\n};\nbool comp1(const Candidate& a, const Candidate& b) {\nif (a.count == b.count)\nreturn a.order < b.order;\nelse\nreturn a.count < b.count;\n}\nbool comp2(const Candidate& a, const Candidate& b) {\nreturn a.id < b.id;\n}\nint main() {\nint n, m;\ncin >> n >> m;\nvector<Candidate> candidates;\nint votes[101] = {0};\nint order = 1;\nfor (int i = 0; i < m; i++) {\nint id;\ncin >> id;\nvotes[id]++;\nif (candidates.size() < n) {\nif (votes[id] == 1)\ncandidates.push_back({id, 1, order});\nelse {\nfor (int j = 0; j < candidates.size(); j++) {\nif (candidates[j].id == id) {\ncandidates[j].count++;\nbreak;\n}\n}\n}\n}\nelse {\nif (votes[id] == 1) {\nvotes[candidates[0].id] = 0;\ncandidates[0] = {id, 1, order};\n}\nelse {\nfor (int j = 0; j < candidates.size(); j++) {\nif (candidates[j].id == id) {\ncandidates[j].count++;\nbreak;\n}\n}\n}\n}\norder++;\nsort(candidates.begin(), candidates.end(), comp1);\n}\nsort(candidates.begin(), candidates.end(), comp2);\nfor (int i = 0; i < candidates.size(); i++)\ncout << candidates[i].id << \" \";\nreturn 0;\n}"
    },
    {
        "problem_tier": 3,
        "solution_code": "#include<iostream>\n#include<algorithm>\nusing namespace std;\nint main() {\ndouble A, B, C;\ncin >> A >> B >> C;\ndouble result1 = A * B / C;\ndouble result2 = A / B * C;\ncout << max(result1, result2) << endl;\nreturn 0;\n}"
    },
    {
        "problem_tier": 7,
        "solution_code": "#include <iostream>\nusing namespace std;\nint main() {\nint a, b, n;\ncin >> a >> b >> n;\nif (a % b == 0) {\ncout << 0;\nreturn 0;\n}"
    },
    {
        "problem_tier": 15,
        "solution_code": "#include <iostream>\n#include <vector>\n#include <algorithm>\nusing namespace std;\nint main() {\nint n;\ncin >> n;\nvector<pair<int, int>> v(n);\nfor (int i = 0; i < n; i++) {\ncin >> v[i].first;\nv[i].second = i;\n}\nsort(v.begin(), v.end());\nint ans = -1;\nfor (int i = 0; i < n; i++) {\nif (ans < v[i].second-i) {\nans = v[i].second - i;\n}\n}\ncout << ans + 1;\nreturn 0;\n}"
    },
    {
        "problem_tier": 8,
        "solution_code": "#include <iostream>\n#include <vector>\n#include <algorithm>\nusing namespace std;\nint main() {\nint L;\ncin >> L;\nvector<int> S(L);\nfor (int i = 0; i < L; i++) {\ncin >> S[i];\n}\nsort(S.begin(), S.end());\nint n;\ncin >> n;\nbool b = true;\nfor (int i = 1; i < L; i++) {\nif (n == S[i]) {\nb = false;\nbreak;\n} else if (n < S[i]) {\nint start = S[i-1] + 1;\nint end = S[i] - 1;\ncout << (n - start) * (end - n + 1) + (end - n) << endl;\nreturn 0;\n}"
    },
    {
        "problem_tier": 9,
        "solution_code": "#include<iostream>\nusing namespace std;\nvoid answer() {\nint N, K, answer = 0;\nstring burgar;\ncin >> N >> K;\ncin >> burgar;\nfor (int i = 0; i < N; i++) {\nif (burgar[i] != 'H') continue;\nfor (int j = i - K; j <= i + K; j++) {\nif (j < 0 || j >= N) continue;\nif (burgar[j] == 'P') {\nburgar[j] = '_';\nburgar[i] = '_';\nanswer++;\nbreak;\n}\n}\n}\ncout << answer;\n}\nint main() {\nios_base::sync_with_stdio(false);\ncin.tie(NULL);\ncout.tie(NULL);\nanswer();\nreturn 0;\n}"
    },
    {
        "problem_tier": 14,
        "solution_code": "#include <iostream>\n#include <vector>\n#include <algorithm>\n#include <cstring>\nusing namespace std;\nint arr[1001];\nvector<pair<int,int>> v;\nbool cmp(pair<int,int> a, pair<int,int> b){\nif(a.second > b.second)\nreturn true;\nreturn false;\n}\nint main(void){\nint N;\ncin >> N;\nmemset(arr, 0, sizeof(arr));\nfor(int i=0; i<N; i++){\nint d, w;\ncin >> d >> w;\nv.push_back(make_pair(d, w));\n}\nsort(v.begin(), v.end(), cmp);\nfor(int i=0; i<N; i++){\nfor(int j=v[i].first; j>0; j--){\nif(arr[j] == 0){\narr[j] = v[i].second;\nbreak;\n}\n}\n}\nint res = 0;\nfor(int i=1; i<=1000; i++)\nres += arr[i];\ncout << res;\nreturn 0;\n}"
    },
    {
        "problem_tier": 5,
        "solution_code": "#include <iostream>\nusing namespace std;\nint main() {\nint a[10], b[10], c[2];\nfor (int i = 0; i < 10; i++)\ncin >> a[i];\nfor (int i = 0; i < 10; i++) {\ncin >> b[i];\nif (a[i] > b[i])\nc[0]++;\nelse if (a[i] < b[i])\nc[1]++;\nelse {\nc[0]++;\nc[1]++;\n}\n}\nif (c[0] > c[1])\ncout << \"A\" << '\\n';\nelse if (c[0] == c[1])\ncout << \"D\" << '\\n';\nelse\ncout << \"B\" << '\\n';\nreturn 0;\n}"
    },
    {
        "problem_tier": 7,
        "solution_code": "#include<iostream>\nusing namespace std;\nint main(){\nint n, k;\ncin >> n >> k;\nint pascal_arr[n][k];\nfor(int i=0; i<n; i++)\npascal_arr[i][0] = 1;\nfor(int i=1; i<n; i++){\nfor(int j=1; j<=i; j++){\nif(j >= k)\ncontinue;\npascal_arr[i][j] = pascal_arr[i-1][j-1];                                     if(i-1 >= j)\npascal_arr[i][j] += pascal_arr[i-1][j];\n}\n}\ncout << pascal_arr[n-1][k-1];\nreturn 0;\n}"
    },
    {
        "problem_tier": 17,
        "solution_code": "#include <iostream>\n#include <vector>\n#include <string>\n#include <queue>\nusing namespace std;\ntypedef struct {\nint y, x;\n} dir;\ndir ar[4] = {{1,0},{0,1},{-1,0},{0,-1}};\nint r, c;\nstring arr[1500];\nvector<dir> swan;\nqueue<dir> vec;\nqueue<dir> q;\nbool visited[1500][1500] = {0,};\nint main() {\nios_base::sync_with_stdio(0);\ncin.tie(0);\ncout.tie(0);\ncin >> r >> c;\nfor(int i=0; i<r; i++){\ncin >> arr[i];\nfor(int j=0; j<c; j++){\nif(arr[i][j] == 'L'){\narr[i][j] = '.';\nswan.push_back({i, j});\n}\nif(arr[i][j] == '.')\nvec.push({i, j});\n}\n}\nq.push({swan[0].y, swan[0].x});\nvisited[swan[0].y][swan[0].x] = 1;\nfor(int cnt = 0;; cnt++){\nqueue<dir> nq;         bool flag = 0;\nwhile(!q.empty()){\nint y = q.front().y;\nint x = q.front().x;\nq.pop();\nif(y == swan[1].y && x == swan[1].x){\nflag = 1;\nbreak;\n}\nfor(int i=0; i<4; i++){\nint ny = y + ar[i].y;\nint nx = x + ar[i].x;\nif(ny < 0 || ny >= r || nx < 0 || nx >= c || visited[ny][nx])\ncontinue;\nvisited[ny][nx] = 1;\nif(arr[ny][nx] == 'X')\nnq.push({ny, nx});\nelse if(arr[ny][nx] == '.'){\nq.push({ny, nx});\n}\n}\n}\nif(flag){\ncout << cnt << endl;\nreturn 0;\n}"
    },
    {
        "problem_tier": 4,
        "solution_code": "#include <iostream>\n#include <algorithm> #include <functional>\n#include <math.h>\n#include <string>\n#include <string.h>\n#include <vector>\n#include <map>\n#include <sstream>\n#include <queue>\nusing namespace std;\nstruct Coord {\nint r, c;\n};\nCoord getCoord(int num) {\nint r, c;\nr = num % 4;\nif (!r) r = 4;\nc = num / 4;\nif (num % 4 == 0) c--;\nreturn { r, c };\n}\nint main() {\nint n1, n2;\nCoord x, y;\ncin >> n1 >> n2;\nx = getCoord(n1);\ny = getCoord(n2);\ncout << abs(x.r - y.r) + abs(x.c - y.c);\nreturn 0;\n}"
    },
    {
        "problem_tier": 6,
        "solution_code": "#include <iostream>\nusing namespace std;\nint main(void){\nint N;\ncin >> N;\nwhile(N--){\nint aN, bN;\nint a, b;\nint A[5] = {0}, B[5] = {0};\nint count = 0;\ncin >> aN;\nfor(int i=0; i<aN; i++){\ncin >> a;\nA[a]++;\n}\ncin >> bN;\nfor(int i=0; i<bN; i++){\ncin >> b;\nB[b]++;\n}\nfor(int i=4; i>0; i--){\nif(A[i] > B[i]){\ncout << \"A\\n\";\nbreak;\n}\nelse if(A[i] < B[i]){\ncout << \"B\\n\";\nbreak;\n}\nelse count++;\n}\nif(count == 4)\ncout << \"D\\n\";\n}\n}"
    },
    {
        "problem_tier": 1,
        "solution_code": "#include <iostream>\nusing namespace std;\nint main() {\ncout << \"\\uFFFD\" << endl;\nreturn 0;\n}"
    },
    {
        "problem_tier": 17,
        "solution_code": "#include<iostream>\n#include<vector>\n#include<stack>\n#include<algorithm>\n#define MAX 10001\nusing namespace std;\nint id, d[MAX];\nbool finished[MAX];\nvector<int> graph[MAX];\nvector<vector<int>> SCC;\nstack<int> s;\nint v, e;\nint dfs(int x){\nd[x] = ++id;\ns.push(x);\nint parent = d[x];\nfor(int i=0; i<graph[x].size(); i++){\nint y = graph[x][i];\nif(d[y] == 0)\nparent = min(parent, dfs(y));\nelse if(!finished[y])\nparent = min(parent, d[y]);\n}\nif(parent == d[x]){\nvector<int> scc;\nwhile(1){\nint t = s.top();\ns.pop();\nscc.push_back(t);\nfinished[t] = true;\nif(t == x)\nbreak;\n}\nsort(scc.begin(), scc.end());\nSCC.push_back(scc);\n}\nreturn parent;\n}\nbool compare(vector<int> a, vector<int> b){\nreturn a[0] < b[0];\n}\nint main(){\ncin >> v >> e;\nfor(int i=0; i<e; i++){\nint a, b;\nscanf(\"%d%d\", &a, &b);\ngraph[a].push_back(b);\n}\nfor(int i=1; i<=v; i++){\nif(d[i] == 0)\ndfs(i);\n}\ncout << SCC.size() << endl;\nsort(SCC.begin(), SCC.end(), compare);\nfor(int i=0; i<SCC.size(); i++){\nfor(int j=0; j<SCC[i].size(); j++){\nprintf(\"%d\", SCC[i][j]);\n}\nprintf(\"-1\\n\");\n}\n}"
    },
    {
        "problem_tier": 13,
        "solution_code": "#include <iostream>\n#include <vector>\n#include <memory.h>\nusing namespace std;\nbool visited[10001];\nint main(){\nios_base::sync_with_stdio(false);\ncin.tie(0);\nint T;\ncin >> T;\nwhile(T--){\nint N;\ncin >> N;\nvector<int> graph(N+1);\nfor(int i=1; i<=N-1; i++){\nint a, b;\ncin >> a >> b;\ngraph[b] = a;\n}\nint a, b;\ncin >> a >> b;\nvisited[a] = true;\nwhile(a != graph[a]){\nvisited[a] = true;\na = graph[a];\n}\nwhile(true){\nif(visited[b] == true){\ncout << b << '\\n';\nbreak;\n}\nb = graph[b];\n}\nmemset(visited, 0, sizeof(visited));\n}\n}"
    },
    {
        "problem_tier": 5,
        "solution_code": "#include<iostream>\n#include<string>\nusing namespace std;\nint main(){\nstring s;\nstring t;\nint sum = 0;\ncin >> s;\nfor(int i=0; i<s.size(); i++){\nif(s[i] == ','){\nsum += stoi(t);\nt = \"\";\n}\nelse{\nt += s[i];\n}\n}\ncout << sum + stoi(t) << endl;\nreturn 0;\n}"
    },
    {
        "problem_tier": 10,
        "solution_code": "#include <iostream>\n#include <vector>\n#include <algorithm>\nusing namespace std;\nint main() {\nint n;\ncin >> n;\nvector<vector<int>> graph(n, vector<int>(n, 0));\nfor (int i = 0; i < n; i++) {\nstring s;\ncin >> s;\nfor (int j = 0; j < n; j++) {\nif (s[j] == 'Y') {\ngraph[i][j] = 1;\n}\n}\n}\nint ans = 0;\nfor (int i = 0; i < n; i++) {\nint cnt = 0;\nfor (int j = 0; j < n; j++) {\nif (i == j) continue;\nif (graph[i][j] == 1) {\ncnt++;\n}\nelse {\nfor (int k = 0; k < n; k++) {\nif (graph[i][k] == 1 && graph[k][j] == 1) {\ncnt++;\nbreak;\n}\n}\n}\n}\nans = max(ans, cnt);\n}\ncout << ans << '\\n';\nreturn 0;\n}"
    },
    {
        "problem_tier": 5,
        "solution_code": "#include <iostream>\n#include <vector>\n#include <algorithm>\nusing namespace std;\nint main() {\nint t;\ncin >> t;\nvector<int> grades(5);\nint* result = new int[t];\nfor (int i = 0; i < t; i++) {\nfor (int j = 0; j < 5; j++) {\ncin >> grades[j];\n}\nsort(grades.begin(), grades.end());\nif (grades[3] - grades[1] >= 4) {\nresult[i] = -1;\n}\nelse {\nresult[i] = grades[1] + grades[2] + grades[3];\n}\n}\nfor (int i = 0; i < t; i++) {\nif (result[i] != -1) cout << result[i];\nelse cout << \"KIN\";\ncout << \"\\n\";\n}\nreturn 0;\n}"
    },
    {
        "problem_tier": 8,
        "solution_code": "#include <iostream>\n#include <vector>\n#include <algorithm>\nusing namespace std;\nint main() {\nios_base::sync_with_stdio(false);\ncin.tie(NULL);\nint N, score, P;\nvector<int> rank;\ncin >> N >> score >> P;\nfor(int i = 0; i < N; i++){\nint x;\ncin >> x;\nrank.push_back(x);\n}\nint cnt = 0;\nint my_rank = 1;\nfor(int i = 0; i < N; i++){\nif(score < rank[i])\nmy_rank += 1;\nelse if(score == rank[i])\nmy_rank = my_rank;\nelse\nbreak;\ncnt++;\n}\nif(cnt == P)\nmy_rank = -1;\nif(N == 0)\nmy_rank = 1;\ncout << my_rank << '\\n';\nreturn 0;\n}"
    },
    {
        "problem_tier": 5,
        "solution_code": "#include<iostream>\nusing namespace std;\nint main(){\nint A[10];\nint B[10];\nint scoreA = 0;\nint scoreB = 0;\nchar lastWin = 'D';\nfor (int i = 0; i < 10; i++) {\ncin >> A[i];\n}\nfor (int i = 0; i < 10; i++) {\ncin >> B[i];\n}\nfor (int i = 0; i < 10; i++) {\nif (A[i] > B[i]) {\nscoreA += 3;\nlastWin = 'A';\n}\nelse if (A[i] < B[i]) {\nscoreB += 3;\nlastWin = 'B';\n}\nelse {\nscoreA++;\nscoreB++;\n}\n}\ncout << scoreA << \" \" << scoreB << \"\\n\";\nif (scoreA > scoreB) {\ncout << 'A';\n}\nelse if (scoreA < scoreB) {\ncout << 'B';\n}\nelse {\ncout << lastWin;\n}\nreturn 0;\n}"
    },
    {
        "problem_tier": 11,
        "solution_code": "#include <iostream>\nusing namespace std;\nint main() {\nios_base::sync_with_stdio(false);\ncin.tie(0);\nint N, K;\ncin >> N >> K;\nint ans = 0;\nfor(ans;; ans++) {\nint cnt = 0;\nint temp_N = N;\nwhile(temp_N != 0) {\nif(temp_N % 2)\ncnt++;\ntemp_N /= 2;\n}\nif(cnt <= K)\nbreak;\nN++;\n}\ncout << ans;\nreturn 0;\n}"
    },
    {
        "problem_tier": 15,
        "solution_code": "#include <iostream>\n#include <vector>\n#include <queue>\n#include <algorithm>\nusing namespace std;\nstruct Node {\nint val;\nint left;\nint right;\nint height;\nint col;\n};\nvector<Node> node_vec;\nvector<int> node_parent_vec;\nint col_idx = 1;\nvoid inorder(int this_node_idx) {\nNode* this_node = &node_vec.at(this_node_idx);\nif (this_node->left != -1) inorder(this_node->left);\nthis_node->col = col_idx++;\nif (this_node->right != -1) inorder(this_node->right);\n}\nvoid bfs(int start_node) {\nqueue<int> bfs_queue;\nbfs_queue.push(start_node);\nint bfs_size = bfs_queue.size();\nint height = 1;\nwhile (bfs_size) {\nint this_node_idx = bfs_queue.front();\nbfs_queue.pop();\nbfs_size--;\nNode* this_node = &node_vec.at(this_node_idx);\nthis_node->height = height;\nif (this_node->left != -1) bfs_queue.push(this_node->left);\nif (this_node->right != -1) bfs_queue.push(this_node->right);\nif (bfs_size == 0) {\nheight++;\nbfs_size = bfs_queue.size();\n}\n}\n}\nbool sort_node(const Node& node_1, const Node& node_2) {\nif (node_1.height != node_2.height)\nreturn node_1.height < node_2.height;\nelse\nreturn node_1.col < node_2.col;\n}\nint find_root() {\nint root = 1;\nwhile (node_parent_vec.at(root) != -1)\nroot = node_parent_vec.at(root);\nreturn root;\n}\nint main() {\nios::sync_with_stdio(false);\nint N;\ncin >> N;\nnode_vec.resize(N+1);\nnode_parent_vec.resize(N+1, -1);\nfor (int n_idx = 1; n_idx <= N; n_idx++){\nint this_node, left, right;\ncin >> this_node >> left >> right;\nnode_vec.at(this_node).left = left;\nnode_vec.at(this_node).right = right;\nnode_vec.at(this_node).height = node_vec.at(this_node).col = -1;\nif (left != -1)  node_parent_vec.at(left) = this_node;\nif (right != -1)  node_parent_vec.at(right) = this_node;\n}\nint root = find_root();\ninorder(root);\nbfs(root);\nsort(node_vec.begin()+1, node_vec.end(), sort_node);\nint answer_width = 1;\nint answer_height = 1;\nint height = 1;\nint row_first = -1;\nfor (int n_idx = 2; n_idx <= N; n_idx++) {\nif (height < node_vec.at(n_idx).height) {\nheight++;\nrow_first = n_idx;\n}\nelse if (height == node_vec.at(n_idx).height) {\nif (answer_width < node_vec.at(n_idx).col - node_vec.at(row_first).col + 1) {\nanswer_width = node_vec.at(n_idx).col - node_vec.at(row_first).col + 1;\nanswer_height = height;\n}\n}\n}\ncout << answer_height << \" \" << answer_width;\nreturn 0;\n}"
    },
    {
        "problem_tier": 5,
        "solution_code": "#include <iostream>\nusing namespace std;\nint gcd(int a, int b) {\nint r;\nwhile (b != 0) {\nr = a % b;\na = b;\nb = r;\n}\nreturn a;\n}\nint lcm(int a, int b) {\nreturn a * b / gcd(a, b);\n}\nint main() {\nint n;\ncin >> n;\nfor (int i = 0; i < n; i++) {\nint a, b;\ncin >> a >> b;\ncout << lcm(a, b) << \" \" << gcd(a, b) << \"\\n\";\n}\nreturn 0;\n}"
    },
    {
        "problem_tier": 8,
        "solution_code": "#include <iostream>\n#include <vector>\n#include <algorithm>\nusing namespace std;\nint main() {\nios_base::sync_with_stdio(false);\ncin.tie(NULL);\ncout.tie(NULL);\nint N;\ncin >> N;\nvector<double> v;\nfor (int i = 0; i < N; i++) {\ndouble num;\ncin >> num;\nv.push_back(num);\n}\ndouble dp[10001] = {0.0,};\ndouble M = 0.0;\ndp[0] = v[0];\nfor (int i = 1; i < N; i++) {\ndp[i] = max(v[i], v[i] * dp[i-1]);\nM = max(M, dp[i]);\n}\nprintf(\"%.3f\", M);\nreturn 0;\n}"
    },
    {
        "problem_tier": 2,
        "solution_code": "#include <iostream>\nusing namespace std;\nint main() {\nios_base::sync_with_stdio(0);\ncin.tie(0);\ncout.tie(0);\nint Ur, Tr, Uo, To;\ncin >> Ur >> Tr >> Uo >> To;\ncout << 56 * Ur + 24 * Tr + 14 * Uo + 6 * To;\nreturn 0;\n}"
    },
    {
        "problem_tier": 5,
        "solution_code": "#include <iostream>\n#include <string>\n#include <vector>\nusing namespace std;\nint main(void) {\nint n;\ncin >> n;\nfor (int i = 0; i < n; i++) {\nstring str1, str2;\nvector<int> dist;\nint distNum;\ncin >> str1 >> str2;\nfor (int i = 0; i < str1.size(); i++) {\ndistNum = str2[i] - str1[i];\nif (distNum < 0)\ndistNum += 26;\ndist.push_back(distNum);\n}\ncout << \"Distances:\";\nfor (auto c : dist) {\ncout << c << \" \";\n}\ncout << \"\\n\";\ndist.clear();\n}\nreturn 0;\n}"
    },
    {
        "problem_tier": 15,
        "solution_code": "#include <iostream>\n#include <vector>\n#include <queue>\n#include <cstring>\nusing namespace std;\nint n, m;\nint map[1001][1001];\nint result[1001][1001];\nint visit[1001][1001];\nint group[1000001];\nint dy[] = { -1,1,0,0 };\nint dx[] = { 0,0,-1,1 };\nint bfs(int y, int x, int groupNum) {\nint cnt = 1;\nqueue<pair<int, int>> q;\nq.push(make_pair(y, x));\nvisit[y][x] = groupNum;\nwhile (!q.empty()) {\nint cy = q.front().first;\nint cx = q.front().second;\nq.pop();\nfor (int i = 0; i < 4; i++) {\nint ny = cy + dy[i];\nint nx = cx + dx[i];\nif (ny < 0 || ny >= n || nx < 0 || nx >= m) continue;\nif (map[ny][nx] || visit[ny][nx]) continue;\ncnt++;\nvisit[ny][nx] = groupNum;\nq.push(make_pair(ny, nx));\n}\n}\nreturn cnt;\n}\nint main() {\nios_base::sync_with_stdio(0);\ncin.tie(0);\ncin >> n >> m;\nfor (int i = 0; i < n; i++) {\nstring s;\ncin >> s;\nfor (int j = 0; j < m; j++) {\nmap[i][j] = s[j] - '0';\n}\n}\nint groupNum = 1;\nfor (int i = 0; i < n; i++) {\nfor (int j = 0; j < m; j++) {\nif (map[i][j] == 0 && visit[i][j] == 0) {\ngroup[groupNum] = bfs(i, j, groupNum);\ngroupNum++;\n}\n}\n}\nfor (int i = 0; i < n; i++) {\nfor (int j = 0; j < m; j++) {\nif (map[i][j] == 0) {\ncout << \"0\";\n} else {\nint cnt = 1;\nvector<int> check;\nfor (int k = 0; k < 4; k++) {\nint ny = i + dy[k];\nint nx = j + dx[k];\nint num = visit[ny][nx];\nif (ny < 0 || ny >= n || nx < 0 || nx >= m) continue;\nif (visit[ny][nx] && find(check.begin(), check.end(), num) == check.end()) {\ncnt += group[num];\ncheck.push_back(num);\n}\n}\ncout << cnt % 10;\n}\n}\ncout << \"\\n\";\n}\nreturn 0;\n}"
    },
    {
        "problem_tier": 5,
        "solution_code": "#include <iostream>\n#include <vector>\nusing namespace std;\nint main() {\nchar c;\nvector<int> cnt_alphabet(26);\nwhile(cin >> c) {\nif('a' <= c && c <= 'z') {\ncnt_alphabet[c-'a']++;\n}\n}\nint max_element = 0;\nvector<int> max_index;\nfor(int i=0; i<26; i++) {\nif(max_element < cnt_alphabet[i]) {\nmax_element = cnt_alphabet[i];\nif(max_index.size() != 0) {\nmax_index.resize(0);\n}\nmax_index.push_back(i);\n}\nelse if(max_element == cnt_alphabet[i]) {\nmax_index.push_back(i);\n}\n}\nfor(int i=0; i<max_index.size(); i++) {\ncout << char(max_index[i]+'a');\n}\ncout << '\\n';\nreturn 0;\n}"
    },
    {
        "problem_tier": 14,
        "solution_code": "#include<bits/stdc++.h>\nusing namespace std;\nint result;\nint dx[] = {0, 0, 1, -1};\nint dy[] = {1, -1, 0, 0};\nbool Select[25];\nbool MoreThanFour(vector<string>& arr) {\nint Cnt = 0;\nfor (int i = 0; i < 25; i++) {\nif (Select[i] == true) {\nint x = i / 5;\nint y = i % 5;\nif (arr[x][y] == 'S') Cnt++;\n}\n}\nif (Cnt >= 4) return true;\nelse return false;\n}\nbool Adjacency(vector<string>& arr) {\nqueue<pair<int, int>> Q;\nbool Check_Select[5][5];\nbool Queue_Select[5][5];\nbool Check_Answer = false;\nmemset(Queue_Select, false, sizeof(Queue_Select));\nmemset(Check_Select, false, sizeof(Check_Select));\nint Tmp = 0;\nfor (int i = 0; i < 25; i++) {\nif (Select[i] == true) {\nint x = i / 5;\nint y = i % 5;\nCheck_Select[x][y] = true;\nif (Tmp == 0) {\nQ.push(make_pair(x, y));\nQueue_Select[x][y] = true;\nTmp++;\n}\n}\n}\nint Cnt = 1;\nwhile (!Q.empty()) {\nint x = Q.front().first;\nint y = Q.front().second;\nQ.pop();\nif (Cnt == 7) {\nCheck_Answer = true;\nbreak;\n}\nfor (int i = 0; i < 4; i++) {\nint nx = x + dx[i];\nint ny = y + dy[i];\nif (nx >= 0 && ny >= 0 && nx < 5 && ny < 5) {\nif (Check_Select[nx][ny] == true && Queue_Select[nx][ny] == false) {\nQueue_Select[nx][ny] = true;\nQ.push(make_pair(nx, ny));\nCnt++;\n}\n}\n}\n}\nif (Check_Answer == true) return true;\nreturn false;\n}\nvoid DFS(int Idx, int Cnt, vector<string>& arr) {\nif (Cnt == 7) {\nif (MoreThanFour(arr) == true) {\nif (Adjacency(arr) == true) result++;\n}\nreturn;\n}\nfor (int i = Idx; i < 25; i++) {\nif (Select[i] == true) continue;\nSelect[i] = true;\nDFS(i, Cnt + 1, arr);\nSelect[i] = false;\n}\n}\nint main() {\nios_base::sync_with_stdio(0);\ncin.tie(0), cout.tie(0);\nvector<string> arr(5);\nfor (int i = 0; i < 5; i++) {\ncin >> arr[i];\n}\nDFS(0, 0, arr);\ncout << result << endl;\nreturn 0;\n}"
    },
    {
        "problem_tier": 9,
        "solution_code": "#include <iostream>\n#include <string>\nusing namespace std;\nint main() {\nint n;\ncin >> n;\nstring s;\ncin >> s;\nint index = s.find('*');\nstring part1 = s.substr(0, index);\nstring part2 = s.substr(index + 1);\nwhile (n--) {\nstring cmp;\ncin >> cmp;\nif (part1.size() + part2.size() > cmp.size())\ncout << \"NE\\n\";\nelse if (cmp.find(part1) == 0) {\nstring ex = cmp.substr(cmp.size() - part2.size());\nif (ex == part2)\ncout << \"DA\\n\";\nelse\ncout << \"NE\\n\";\n}\nelse\ncout << \"NE\\n\";\n}\nreturn 0;\n}"
    },
    {
        "problem_tier": 12,
        "solution_code": "#include <iostream>\n#include <vector>\nusing namespace std;\nint N, R, Q;\nvector<int> graph[100001];\nint subnode_cnt[100001];\nint dfs(int node, int before){\nfor(auto next : graph[node]){\nif(next != before){\nsubnode_cnt[node] += dfs(next, node) + 1;\n}\n}\nreturn subnode_cnt[node];\n}\nint main(){\nios_base::sync_with_stdio(false);\ncin.tie(0);\ncin >> N >> R >> Q;\nfor(int i=0; i<N-1; i++){\nint a, b;\ncin >> a >> b;\ngraph[a].push_back(b);\ngraph[b].push_back(a);\n}\ndfs(R, 0);\nfor(int i=0; i<Q; i++){\nint q;\ncin >> q;\ncout << subnode_cnt[q] + 1 << '\\n';\n}\nreturn 0;\n}"
    },
    {
        "problem_tier": 7,
        "solution_code": "#include <iostream>\n#include <string>\n#include <algorithm>\nusing namespace std;\nint main() {\nstring input;\ncin >> input;\nstring answer = \"\";\nfor (int i = 0; i < input.size() - 2; i++) {\nfor (int j = i + 1; j < input.size() - 1; j++) {\nstring val;\nfor (int u = i; u >= 0; u--)\nval += input[u];\nfor (int u = j; u > i; u--)\nval += input[u];\nfor (int u = input.size() - 1; u > j; u--)\nval += input[u];\nif (answer == \"\" || answer > val)\nanswer = val;\n}\n}\ncout << answer << endl;\nreturn 0;\n}"
    },
    {
        "problem_tier": 14,
        "solution_code": "#include<iostream>\n#include<vector>\n#include<cmath>\n#include<algorithm>\n#define endl \"\\n\"\n#define MAX 1010\nusing namespace std;\nint N, M;\nint Parent[MAX];\ndouble Answer;\nvector<pair<int, int>> Coord;\nvector<pair<int, int>> Connect;\nvector<pair<double, pair<int, int>>> Edge;\nvoid Input(){\ncin >> N >> M;\nfor (int i = 1; i <= N; i++) Parent[i] = i;\nfor (int i = 0; i < N; i++)\n{\nint a, b; cin >> a >> b;\nCoord.push_back(make_pair(a, b));\n}\nfor (int i = 0; i < M; i++)\n{\nint a, b; cin >> a >> b;\nConnect.push_back(make_pair(a, b));\n}\n}\nint Find_Parent(int A){\nif (A == Parent[A]) return A;\nreturn Parent[A] = Find_Parent(Parent[A]);\n}\nbool Same_Parent(int A, int B){\nA = Find_Parent(A);\nB = Find_Parent(B);\nif (A == B) return true;\nreturn false;\n}\nvoid Union(int A, int B){\nA = Find_Parent(A);\nB = Find_Parent(B);\nParent[B] = A;\n}\ndouble Find_Distance(int x, int y, int xx, int yy){\ndouble dx = pow(x - xx, 2);\ndouble dy = pow(y - yy, 2);\ndouble Dist = sqrt(dx + dy);\nreturn Dist;\n}\nvoid Solution(){\nfor (int i = 0; i < M; i++)\n{\nint N1 = Connect[i].first;\nint N2 = Connect[i].second;\nif (Same_Parent(N1, N2) == false) Union(N1, N2);\n}\nfor (int i = 0; i < N - 1; i++)\n{\nint x = Coord[i].first;\nint y = Coord[i].second;\nfor (int j = i + 1; j < N; j++)\n{\nint xx = Coord[j].first;\nint yy = Coord[j].second;\ndouble Dist = Find_Distance(x, y, xx, yy);\nEdge.push_back(make_pair(Dist, make_pair(i + 1, j + 1)));\n}\n}\nsort(Edge.begin(), Edge.end());\nfor (int i = 0; i < Edge.size(); i++)\n{\nint N1 = Edge[i].second.first;\nint N2 = Edge[i].second.second;\ndouble Dist = Edge[i].first;\nif (Same_Parent(N1, N2) == false)\n{\nUnion(N1, N2);\nAnswer = Answer + Dist;\n}\n}\ncout << Answer << endl;\n}\nvoid Solve(){\nInput();\nSolution();\n}\nint main(void){\nios::sync_with_stdio(false);\ncin.tie(NULL);\ncout.tie(NULL);\ncout << fixed;\ncout.precision(2);\nSolve();\nreturn 0;\n}"
    },
    {
        "problem_tier": 15,
        "solution_code": "#include <iostream>\n#include <vector>\n#include <cstring>\n#include <algorithm>\n#define MAX 12\n#define INF 1e9\nusing namespace std;\nint N, K, Answer;\nvector<int> board[MAX][MAX];\nint map[MAX][MAX];\nvector<vector<int>> pieces;\nint dx[] = {0, 0, 0, -1, 1};\nint dy[] = {0, 1, -1, 0, 0};\npair<int, int> white(int& r, int& c, int& d, int seq) {\nint nr, nc;\nnr = r + dx[d];\nnc = c + dy[d];\nvector<int>& v = board[r][c];\nauto it = find(v.begin(), v.end(), seq);\nint idx = it - v.begin();\nvector<int> moving;\nint size = v.size();\nfor (int i = idx; i < size; ++i) {\nint s = v[i];\npieces[s-1][0] = nr;\npieces[s-1][1] = nc;\nmoving.push_back(s);\n}\nfor (int i = size-1; i >= idx; --i) {\nv.pop_back();\n}\nv.resize(idx);\nfor (int i = 0; i < moving.size(); ++i) {\nboard[nr][nc].push_back(moving[i]);\n}\nreturn make_pair(nr, nc);\n}\npair<int, int> red(int& r, int& c, int& d, int seq) {\nint nr = r + dx[d];\nint nc = c + dy[d];\nwhite(r, c, d, seq);\nvector<int>& v = board[nr][nc];\nauto it = find(v.begin(), v.end(), seq);\nint idx = it - v.begin();\nreverse(v.begin()+idx, v.end());\nreturn make_pair(nr, nc);\n}\npair<int, int> blue(int& r, int& c, int& d, int seq) {\nif (d == 1) {\nd = 2;\n}\nelse if (d == 2) {\nd = 1;\n}\nelse if (d == 3) {\nd = 4;\n}\nelse if (d == 4) {\nd = 3;\n}\nint nr = r + dx[d];\nint nc = c + dy[d];\nif (!(1 <= nr && nr <= N && 1 <= nc && nc <= N) || (map[nr][nc] == 2)) {\nreturn make_pair(0, 0);\n}\nelse {\nif (map[nr][nc] == 0) {\nwhite(r, c, d, seq);\n}\nelse if (map[nr][nc] == 1) {\nred(r, c, d, seq);\n}\n}\nreturn make_pair(nr, nc);\n}\nvoid solve() {\nAnswer++;\nfor (int k = 0; k < pieces.size(); ++k) {\nint seq = k + 1;\nint& r = pieces[k][0];\nint& c = pieces[k][1];\nint& d = pieces[k][2];\nint nr, nc;\nnr = r + dx[d];\nnc = c + dy[d];\npair<int, int> p;\nif (!(1 <= nr && nr <= N && 1 <= nc && nc <= N)) {\np = blue(r, c, d, seq);\n}\nelse if (map[nr][nc] == 0) {\np = white(r, c, d, seq);\n}\nelse if (map[nr][nc] == 1) {\np = red(r, c, d, seq);\n}\nelse if (map[nr][nc] == 2) {\np = blue(r, c, d, seq);\n}\nint a, b;\na = p.first;\nb = p.second;\nif (a == 0 && b == 0) {\ncontinue;\n}\nelse {\nif (board[a][b].size() >= 4) {\nreturn;\n}\n}\n}\nreturn;\n}\nint main(void) {\ncin.tie(NULL);\ncout.tie(NULL);\nios_base::sync_with_stdio(false);\ncin >> N >> K;\nfor (int i = 1; i <= N; ++i) {\nfor (int j = 1; j <= N; ++j) {\ncin >> map[i][j];\n}\n}\nfor (int i = 0; i < K; ++i) {\nint r, c, d;\ncin >> r >> c >> d;\nvector<int> v;\nv.push_back(r);\nv.push_back(c);\nv.push_back(d);\npieces.push_back(v);\nboard[r][c].push_back(i+1);\n}\nwhile"
    },
    {
        "problem_tier": 2,
        "solution_code": "#include<iostream>\n#include<cmath>\nusing namespace std;\nint main(){\ndouble n, m, k;\ncin >> n >> m >> k;\ndouble result = floor(((n+1)*(m+1))/(k+1) - 1);\ncout << result;\nreturn 0;\n}"
    },
    {
        "problem_tier": 12,
        "solution_code": "#include <iostream>\n#include <algorithm>\n#include <vector>\nusing namespace std;\n#define MAX_T 1000 + 1\n#define MAX_W 30 + 1\nvector<int> jadoo_time;\nint dp[MAX_T][MAX_W][3] = {0};\nint main() {\nios::sync_with_stdio(false);\ncin.tie(NULL);\nint T, W;\ncin >> T >> W;\njadoo_time.resize(T + 1, 0);\nfor (int i = 1; i <= T; i++)\ncin >> jadoo_time[i];\nif (jadoo_time[1] == 1)\ndp[1][0][1] = 1;\nelse\ndp[1][1][2] = 1;\nfor (int t = 2; t <= T; t++) {\nfor (int w = 0; w <= W && w < t; w++) {\nif (jadoo_time[t] == 1) {\ndp[t][w][1] = max(dp[t][w][1], dp[t - 1][w][1] + 1);\nif (w < W && w < t - 1)\ndp[t][w + 1][1] = max(dp[t][w + 1][1], dp[t - 1][w][2] + 1);\ndp[t][w][2] = max(dp[t][w][2], dp[t - 1][w][2]);\n} else {\ndp[t][w][2] = max(dp[t][w][2], dp[t - 1][w][2] + 1);\nif (w < W && w < t - 1)\ndp[t][w + 1][2] = max(dp[t][w + 1][2], dp[t - 1][w][1] + 1);\ndp[t][w][1] = max(dp[t][w][1], dp[t - 1][w][1]);\n}\n}\n}\nint answer = 0;\nfor (int w = 0; w <= W; w++)\nanswer = max({ dp[T][w][1], dp[T][w][2], answer });\ncout << answer;\nreturn 0;\n}"
    },
    {
        "problem_tier": 9,
        "solution_code": "#include <iostream>\nusing namespace std;\nint main() {\nint n;\ncin >> n;\nint dp[1001] = {0, 0, 1, 0, 0, 1};\nfor (int i = 6; i <= n; i++) {\nif (dp[i - 1] + dp[i - 3] + dp[i - 4] == 0) {             dp[i] = 1;\n} else {\ndp[i] = 0;\n}\n}\nif (dp[n] == 1) {\ncout << \"SK\";\n} else {\ncout << \"CY\";\n}\nreturn 0;\n}"
    },
    {
        "problem_tier": 16,
        "solution_code": "#include <iostream>\n#include <vector>\nvoid solve(int n, std::vector<int>& count) {\nint start = 1;\nint tenPower = 1;\nwhile (start <= n) {\nwhile (start % 10 != 0 && start <= n) {\nfor (int i = start; i > 0; i /= 10) {\ncount[i % 10] += tenPower;\n}\nstart++;\n}\nif (n < start) {\nreturn;\n}\nwhile (n % 10 != 9 && start <= n) {\nfor (int i = n; i > 0; i /= 10) {\ncount[i % 10] += tenPower;\n}\nn--;\n}\nstart /= 10;\nn /= 10;\nfor (int i = 0; i < 10; i++) {\ncount[i] += (n - start + 1) * tenPower;\n}\ntenPower *= 10;\n}\n}\nint main() {\nstd::ios::sync_with_stdio(false);\nstd::cin.tie(NULL);\nstd::cout.tie(NULL);\nint n;\nstd::cin >> n;\nstd::vector<int> count(10);\nsolve(n, count);\nfor (int i = 0; i < 10; i++) {\nstd::cout << count[i] << \" \";\n}\nreturn 0;\n}"
    },
    {
        "problem_tier": 7,
        "solution_code": "#include <iostream>\n#include <string>\nusing namespace std;\nbool isVowel(char c) {\nreturn (c == 'a' || c == 'e' || c == 'i' || c == 'o' || c == 'u');\n}\nbool isValid(string s) {\nint flag = 0;     int v_cnt = 1;\nint a_cnt = 1;\nfor (int i = 0; i < s.size(); i++) {\nif (isVowel(s[i]))\nflag = 1;\nif (i >= 1 && s[i] == s[i-1]){\nif (s[i] == 'e' || s[i] == 'o')\ncontinue;\nelse\nreturn false;\n}\nif (i >= 1 && isVowel(s[i]) == isVowel(s[i - 1])) {\nif (isVowel(s[i]))\nv_cnt++;\nelse\na_cnt++;\n}\nelse {\nv_cnt = 1;\na_cnt = 1;\n}\nif (v_cnt == 3 || a_cnt == 3) {\nreturn false;\n}\n}\nif (flag == 0)\nreturn false;\nreturn true;\n}\nint main() {\nstring s;\nbool ret;\nwhile (true) {\ncin >> s;\nif (s == \"end\")\nbreak;\nret = isValid(s);\nif (ret)\nprintf(\"<%s> is acceptable.\\n\", s.c_str());\nelse\nprintf(\"<%s> is not acceptable.\\n\", s.c_str());\n}\nreturn 0;\n}"
    },
    {
        "problem_tier": 9,
        "solution_code": "#include <iostream>\n#include <cmath>\nusing namespace std;\nvoid cantor(int n) {\nint size = pow(3, n - 1);\nif (n == 0) {\ncout << \"-\";\nreturn;\n}\ncantor(n - 1);\nfor (int i = 0; i < size; i++) {\ncout << \" \";\n}\ncantor(n - 1);\n}\nint main() {\nint N;\nwhile (cin >> N) {\ncantor(N);\ncout << \"\\n\";\n}\nreturn 0;\n}"
    },
    {
        "problem_tier": 9,
        "solution_code": "#include <iostream>\n#include <vector>\n#include <algorithm>\nusing namespace std;\nint main() {\nint N;\ncin >> N;\nvector<int> v;\nfor (int i = 0; i < N; i++) {\nint x;\ncin >> x;\nv.push_back(x);\n}\nsort(v.begin(), v.end());\nlong long total = 0;\nfor (int i = 0; i < N; i++)\ntotal += abs((i + 1) - v[i]);\ncout << total;\nreturn 0;\n}"
    },
    {
        "problem_tier": 7,
        "solution_code": "#include <iostream>\n#include <string>\nusing namespace std;\nint main() {\nstring s;\ngetline(cin, s);\nstring result = \"\";\nfor (int i = 0; i < s.length(); i++) {\nif (s[i] == 'U' && result.empty()) {\nresult += 'U';\n} else if (s[i] == 'C' && result == \"U\") {\nresult += 'C';\n} else if (s[i] == 'P' && result == \"UC\") {\nresult += 'P';\n} else if (s[i] == 'C' && result == \"UCP\") {\nresult += 'C';\n}\n}\nif (result == \"UCPC\") {\ncout << \"IloveUCPC\" << '\\n';\n} else {\ncout << \"IhateUCPC\" << '\\n';\n}\nreturn 0;\n}"
    },
    {
        "problem_tier": 7,
        "solution_code": "#include <iostream>\nusing namespace std;\nint main() {\nint N, M, J;\ncin >> N >> M >> J;\nint cnt = 0;\nint start = 1, end = M;\nwhile (J--) {\nint x;\ncin >> x;\nbool flag = true;\nwhile (flag) {\nif (start <= x && x <= end) {\nflag = false;\n} else if (start > x) {\nstart--;\nend--;\ncnt++;\n} else {\nstart++;\nend++;\ncnt++;\n}\n}\n}\ncout << cnt;\nreturn 0;\n}"
    },
    {
        "problem_tier": 3,
        "solution_code": "#include <iostream>\nusing namespace std;\nint main() {\nint n, m;\ncin >> n >> m;\nif (m == 1 || m == 2) {\ncout << \"NEWBIE!\" << endl;\n} else if (m <= n) {\ncout << \"OLDBIE!\" << endl;\n} else {\ncout << \"TLE!\" << endl;\n}\nreturn 0;\n}"
    },
    {
        "problem_tier": 10,
        "solution_code": "#include <iostream>\n#include <string>\nusing namespace std;\nint main() {\nint n;\ncin >> n;\nif (n == 0) {\ncout << \"0\\n\";\nreturn 0;\n}"
    },
    {
        "problem_tier": 15,
        "solution_code": "#include <bits/stdc++.h>\n#define INF 0x3f3f3f3f;\nusing namespace std;\nusing pii = pair<int,int>;\nint n, m, fuel, ans;\nint board[21][21], ck[21][21];\nint dx[] = {0,0,1,-1};\nint dy[] = {1,-1,0,0};\nint taxiRow, taxiCol;\nstruct Customer { int startRow, startCol, endRow, endCol, distance; };\nvector <Customer> customerInfo;\nint dist[21][21];\nbool cmp(Customer a, Customer b){\nif(a.distance == b.distance){\nif(a.startRow == b.startRow)\nreturn a.startCol < b.startCol;\nreturn a.startRow < b.startRow;\n}\nreturn a.distance < b.distance;\n}\nvoid updateDistance(){\nmemset(ck,0,sizeof(ck));\nmemset(dist,0,sizeof(dist));\nqueue <pii> q;\nq.push({taxiRow,taxiCol});\nck[taxiRow][taxiCol] = 1;\nwhile(!q.empty()){\nint x = q.front().first;\nint y = q.front().second;\nq.pop();\nfor(int i = 0; i < 4; i++){\nint nx = x + dx[i];\nint ny = y + dy[i];\nif(1 > nx || nx > n || 1 > ny || ny > n) continue;\nif(board[nx][ny] == 1 || ck[nx][ny]) continue;\nck[nx][ny] = 1;\ndist[nx][ny] = dist[x][y] + 1;\nq.push({nx,ny});\n}\n}\n}\nvoid updateCustomerInfo(int option = 0){\nif(!option){\nfor(int i = 0; i < customerInfo.size(); i++)\ncustomerInfo[i].distance = dist[customerInfo[i].startRow][customerInfo[i].startCol];\nsort(customerInfo.begin(),customerInfo.end(),cmp);\n}\nelse{\nfor(int i = 0; i < customerInfo.size(); i++)\ncustomerInfo[i].distance = dist[customerInfo[i].endRow][customerInfo[i].endCol];\n}\n}\nint goToDestination(int option = 0){\nupdateDistance();\nif(!option) updateCustomerInfo();\nelse updateCustomerInfo(1);\nif(!customerInfo[0].distance) {\nif(taxiRow != customerInfo[0].startRow || taxiCol != customerInfo[0].startCol)\nreturn -1;\n}\nif(customerInfo[0].distance > fuel) return -1;\nif(!option){\ntaxiRow = customerInfo[0].startRow;\ntaxiCol = customerInfo[0].startCol;\n}\nelse{\ntaxiRow = customerInfo[0].endRow;\ntaxiCol = customerInfo[0].endCol;\n}\nfuel -= customerInfo[0].distance;\nif(option == 1){\nfuel += customerInfo[0].distance * 2;\n}\nreturn 1;\n}\nint main(){\ncin >> n >> m >> fuel;\nfor(int i = 1; i <= n; i++){\nfor(int j = 1; j <= n; j++){\ncin >> board[i][j];\n}\n}\ncin >> taxiRow >> taxiCol;\nfor(int i = 1; i <= m; i++){\nCustomer customer;\ncin >> customer.startRow >> customer.startCol >> customer.endRow >> customer.endCol;\ncustomerInfo.push_back(customer);\n}\nwhile(customerInfo.size()){\nif(goToDestination() == -1){ cout << -1; return 0; }\nif(goToDestination(1) == -1){ cout << -1; return 0; };\ncustomerInfo.erase(customerInfo.begin());\n}\ncout << fuel;\n}"
    },
    {
        "problem_tier": 16,
        "solution_code": "#include <iostream>\n#include <vector>\nusing namespace std;\ntypedef long long ll;\nvector<ll> arr;\nvector<ll> tree;\nll initTree(int node, int start, int end) {\nif (start == end) {\nreturn tree[node] = arr[start];\n}\nint mid = (start + end) / 2;\nreturn tree[node] = initTree(node * 2, start, mid) + initTree(node * 2 + 1, mid + 1, end);\n}\nll calcSum(int node, int start, int end, int left, int right) {\nif (left > end || right < start) {\nreturn 0;\n}\nif (left <= start && right >= end) {\nreturn tree[node];\n}\nint mid = (start + end) / 2;\nreturn calcSum(node * 2, start, mid, left, right) + calcSum(node * 2 + 1, mid + 1, end, left, right);\n}\nvoid updateTree(int node, int start, int end, int index, ll diff) {\nif (index < start || index > end) {\nreturn;\n}\ntree[node] += diff;\nif (start != end) {\nint mid = (start + end) / 2;\nupdateTree(node * 2, start, mid, index, diff);\nupdateTree(node * 2 + 1, mid + 1, end, index, diff);\n}\n}\nint main() {\nios_base::sync_with_stdio(false);\ncin.tie(0);\nint N, Q;\ncin >> N >> Q;\narr.resize(N);\nfor (int i = 0; i < N; i++) {\ncin >> arr[i];\n}\ntree.resize(4 * N);\ninitTree(1, 0, N - 1);\nfor (int i = 0; i < Q; i++) {\nint x, y, a, b;\ncin >> x >> y >> a >> b;\nif (x > y) {\nswap(x, y);\n}\ncout << calcSum(1, 0, N - 1, x - 1, y - 1) << \"\\n\";\nll diff = b - arr[a - 1];\narr[a - 1] = b;\nupdateTree(1, 0, N - 1, a - 1, diff);\n}\nreturn 0;\n}"
    },
    {
        "problem_tier": 10,
        "solution_code": "#include <iostream>\n#include <vector>\n#include <algorithm>\n#include <queue>\n#include <cstring>\nusing namespace std;\nvector<int> adj[100001];\nint visited[100001];\nint visCount = 1;\nbool cmp(int a, int b) {\nreturn a > b;\n}\nint main() {\nios::sync_with_stdio(false);\ncin.tie(NULL);\ncout.tie(NULL);\nint N, M, R;\ncin >> N >> M >> R;\nfor (int i = 0; i < M; i++) {\nint a, b;\ncin >> a >> b;\nadj[a].push_back(b);\nadj[b].push_back(a);\n}\nfor (int i = 0; i <= N; i++) {\nsort(adj[i].begin(), adj[i].end(), cmp);\n}\nqueue<int> q;\nq.push(R);\nvisited[R] = visCount++;\nwhile (!q.empty()) {\nint curr = q.front();\nq.pop();\nfor (auto now : adj[curr]) {\nif (visited[now] != 0) continue;\nvisited[now] = visCount++;\nq.push(now);\n}\n}\nfor (int i = 1; i <= N; i++) {\ncout << visited[i] << '\\n';\n}\nreturn 0;\n}"
    },
    {
        "problem_tier": 8,
        "solution_code": "#include <iostream>\n#include <cstring>\ntypedef long long ll;\n#define endl \"\\n\"\n#define MAX 68\nusing namespace std;\nll DP[MAX];\nvoid Initialize() {\nmemset(DP, 0, sizeof(DP));\n}\nvoid Input() {\ncin >> N;\n}\nvoid Solution() {\nDP[0] = 1;\nDP[1] = 1;\nDP[2] = 2;\nDP[3] = 4;\nfor (int i = 4; i <= N; i++) {\nDP[i] = DP[i - 1] + DP[i - 2] + DP[i - 3] + DP[i - 4];\n}\ncout << DP[N] << endl;\n}\nvoid Solve() {\nint Tc;\ncin >> Tc;\nfor (int T = 1; T <= Tc; T++) {\nInitialize();\nInput();\nSolution();\n}\n}\nint main(void) {\nios::sync_with_stdio(false);\ncin.tie(NULL);\ncout.tie(NULL);\nSolve();\nreturn 0;\n}"
    },
    {
        "problem_tier": 3,
        "solution_code": "#include <iostream>\n#include <string>\nusing namespace std;\nint main() {\nstring n;\ncin >> n;\nint ans = 0;\nif (n.size() == 4) {\nans = 20;\n} else if (n[1] == '0') {\nans = 10 + (n[2] - '0');\n} else if (n[2] == '0') {\nans = 10 + (n[0] - '0');\n} else {\nans = (n[0] - '0') + (n[1] - '0');\n}\ncout << ans << '\\n';\nreturn 0;\n}"
    },
    {
        "problem_tier": 4,
        "solution_code": "#include <iostream>\nusing namespace std;\nint main() {\nint n;\ncin >> n;\nint sum = 0;\nfor (int i = 0; i <= n; i++) {\nfor (int j = 0; j <= i; j++) {\nsum += j + i;\n}\n}\ncout << sum << '\\n';\nreturn 0;\n}"
    },
    {
        "problem_tier": 16,
        "solution_code": "#include <iostream>\n#include <vector>\n#include <cstring>\n#define MAX 10\nusing namespace std;\nint N, Answer[2];\nint MAP[MAX][MAX], MAP_Color[MAX][MAX];\nbool Select[MAX][MAX];\nint Bishop_PosNum;\nint dx[] = { -1, -1, 1, 1 };\nint dy[] = { -1, 1, -1, 1 };\nvoid Input(){\nmemset(MAP_Color, 0, sizeof(MAP_Color));\ncin >> N;\nfor (int i = 0; i < N; i++){\nfor (int j = 0; j < N; j++){\ncin >> MAP[i][j];\nif (i % 2 == 0){\nif (j % 2 == 0) MAP_Color[i][j] = 1;\n}\nelse{\nif (j % 2 == 1) MAP_Color[i][j] = 1;\n}\n}\n}\n}\nvoid Check_MAP(int x, int y, bool C){\nif (C == true){\nMAP[x][y] = 2;\nfor (int i = 0; i < 4; i++){\nint nx = x + dx[i];\nint ny = y + dy[i];\nwhile (1){\nif (nx < 0 || ny < 0 || nx >= N || ny >= N) break;\nif (MAP[nx][ny] == 1) MAP[nx][ny] = 2;\nnx = nx + dx[i];\nny = ny + dy[i];\n}\n}\n}\nelse{\nMAP[x][y] = 1;\nfor (int i = 0; i < 4; i++){\nint nx = x + dx[i];\nint ny = y + dy[i];\nwhile (1){\nif (nx < 0 || ny < 0 || nx >= N || ny >= N) break;\nif (MAP[nx][ny] == 2) MAP[nx][ny] = 1;\nnx = nx + dx[i];\nny = ny + dy[i];\n}\n}\n}\n}\nbool Can_Position(int x, int y){\nfor (int i = 0; i < 2; i++){\nint nx = x;\nint ny = y;\nwhile (1){\nif (nx < 0 || ny < 0 || nx >= N || ny >= N) break;\nif (Select[nx][ny] == true) return false;\nnx = nx + dx[i];\nny = ny + dy[i];\n}\n}\nreturn true;\n}\nvoid DFS(int Idx, int Cnt, int Color){\nif (Answer[Color] < Cnt) Answer[Color] = Cnt;\nfor (int i = Idx + 1; i < N * N; i++){\nint x = i / N;\nint y = i % N;\nif (MAP_Color[x][y] != Color || MAP[x][y] == 0 || Can_Position(x,y) == false) continue;\nSelect[x][y] = true;\nDFS(i, Cnt + 1, Color);\nSelect[x][y] = false;\n}\n}\nvoid Solution(){\nDFS(-1, 0, 0);\nDFS(-1, 0, 1);\ncout << Answer[0] + Answer[1] << endl;\n}\nvoid Solve(){\nInput();\nSolution();\n}\nint main(void){\nios::sync_with_stdio(false);\ncin.tie(NULL);\ncout.tie(NULL);\nSolve();\nreturn 0;\n}"
    },
    {
        "problem_tier": 7,
        "solution_code": "#include <iostream>\nusing namespace std;\nint main() {\nint n, count = 0;\ncin >> n;\nfor (int i = 1; i * i <= n; ++i) {\ncount++;\n}\ncout << count;\nreturn 0;\n}"
    },
    {
        "problem_tier": 8,
        "solution_code": "#include <iostream>\nusing namespace std;\nint dx[] = { 1, 0, -1, 0 };\nint dy[] = { 0, 1, 0, -1 };\nint main() {\nint n, m, c;\ncin >> n >> m >> c;\nif (c > n * m) {\ncout << \"0\" << endl;\nreturn 0;\n}"
    },
    {
        "problem_tier": 11,
        "solution_code": "#include <iostream>\n#include <vector>\n#include <algorithm>\nusing namespace std;\nint main(){\nint T;\ncin >> T;\nwhile(T--){\nint N;\ncin >> N;\nvector<int> v(N);\nfor(int i=0; i<N; i++)\ncin >> v[i];\nsort(v.begin(), v.end());\nint result = 0;\nresult = max(result, v[1]-v[0]);\nresult = max(result, v[N-1]-v[N-2]);\nfor(int i=0; i<N-2; i++){\nresult = max(result, v[i+2]-v[i]);\n}\ncout << result << '\\n';\n}\nreturn 0;\n}"
    },
    {
        "problem_tier": 15,
        "solution_code": "#include <iostream>\n#include <algorithm>\nusing namespace std;\nconst int MAX = 40001;\nint n;\nint port[MAX];\nint dp[MAX];\nint findMaxLines() {\ndp[0] = port[1];\nint size = 0;\nfor (int i = 2; i <= n; i++) {\nif (dp[size] < port[i])\ndp[++size] = port[i];\nelse {\nint index = lower_bound(dp, dp + size, port[i]) - dp;\ndp[index] = port[i];\n}\n}\nreturn size + 1;\n}\nint main() {\ncin >> n;\nfor (int i = 1; i <= n; i++)\ncin >> port[i];\ncout << findMaxLines() << endl;\nreturn 0;\n}"
    },
    {
        "problem_tier": 3,
        "solution_code": "#include <iostream>\n#include <algorithm>\nusing namespace std;\nint main() {\nint arr[4];\nfor (int i = 0; i < 4; i++)\ncin >> arr[i];\nsort(arr, arr+4);\ncout << abs(arr[3] + arr[0] - arr[2] - arr[1]) << endl;\nreturn 0;\n}"
    },
    {
        "problem_tier": 13,
        "solution_code": "#include<iostream>\n#include<vector>\n#include<cstring>\n#define MAX 101\nusing namespace std;\nint N, M, cnt;\nvector<int> up[MAX];\nvector<int> down[MAX];\nint check[MAX];\nvoid dfs(vector<int> v[], int start){\ncheck[start]=1;\nfor(int i=0;i<v[start].size();i++){\nint x=v[start][i];\nif(check[x]==0){\ncnt++;\ndfs(v,x);\n}\n}\n}\nvoid solve(){\nfor(int i=1;i<=N;i++){\ncnt=0;\nmemset(check,0,sizeof(check));\ndfs(up,i);\nmemset(check,0,sizeof(check));\ndfs(down,i);\ncout<<N-cnt-1<<\"\\n\";\n}\n}\nint main(){\ncin.tie(0);\ncout.tie(0);\ncin>>N>>M;\nfor(int i=1;i<=M;i++){\nint x,y;\ncin>>x>>y;\nup[x].push_back(y);\ndown[y].push_back(x);\n}\nsolve();\nreturn 0;\n}"
    },
    {
        "problem_tier": 13,
        "solution_code": "#include <iostream>\n#include <vector>\n#include <queue>\n#include <utility>\n#include <cstring>\n#define INF 987654321\n#define MAX 10001\nusing namespace std;\nint infect; int infect_sec;\nvoid dijkstra(vector<vector<pair<int,int>>> graph, int start, int n){\npriority_queue<pair<int,int>> pq;\nvector<int> dist(n+1, INF);\npq.emplace(0, start);     dist[start] = 0;\nwhile(!pq.empty()){\nint cur_dist = -pq.top().first;         int cur = pq.top().second;         pq.pop();\nfor(auto& p : graph[cur]){\nint next = p.first;             int next_dist = p.second + cur_dist;\nif(dist[next] > next_dist){\ndist[next] = next_dist;\npq.emplace(-dist[next], next);\n}\n}\n}\nfor(int i=1;i<=n;i++){\nif(dist[i] != INF){             infect += 1;\nif(dist[i] > infect_sec)\ninfect_sec = dist[i];\n}\n}\n}\nint main(){\nint T;\nscanf(\"%d\", &T);\nfor(int tc=0; tc<T; tc++){\nint n, d, c;\nscanf(\"%d%d%d\", &n, &d, &c);\nvector<vector<pair<int,int>>> hack(n+1);\nfor(int i=0; i<d; i++){\nint a, b, s;\nscanf(\"%d%d%d\", &a, &b, &s);\nhack[b].emplace_back(a, s);\n}\ninfect = 0;\ninfect_sec = 0;\ndijkstra(hack, c, n);\nprintf(\"%d %d\\n\", infect, infect_sec);\n}\nreturn 0;\n}"
    },
    {
        "problem_tier": 12,
        "solution_code": "#include<iostream>\n#include<algorithm>\n#include<vector>\nusing namespace std;\nvector<long long> v; long long N; long long minsum[6]; bool visit[6];\nvoid solve(int idx, int cnt, long long sum){\nif(cnt < 6) {\nif((visit[0]==true && visit[5]==true) || (visit[1]==true && visit[4]==true) || (visit[2]==true && visit[3]==true)) {\nif(N != 1)\nreturn;\n}\nminsum[cnt] = min(minsum[cnt], sum);\n} else\nreturn;\nfor(int i=idx; i<6; i++) {\nif(visit[i] == false) {\nvisit[i] = true;\nsolve(i+1, cnt+1, sum + v[i]);\nvisit[i] = false;\n}\n}\n}\nint main(void) {\nfill(minsum, minsum+6, 250000000000001);\ncin >> N;\nfor(int i=0; i<6; i++) {\nint num;\ncin >> num;\nv.push_back(num);\n}\nsolve(0, 0, 0);\nif(N==1) {\ncout << minsum[5];\nreturn 0;\n}"
    },
    {
        "problem_tier": 5,
        "solution_code": "#include <iostream>\n#include <vector>\nusing namespace std;\nint main() {\nint A, B, C, N;\nvector<int> dp(301, 0);\ncin >> A >> B >> C >> N;\ndp[A] = dp[B] = dp[C] = 1;\nfor (int i = 1; i <= N; i++) {\nif (dp[i] || (i >= A && dp[i - A]) || (i >= B && dp[i - B]) || (i >= C && dp[i - C])) {\ndp[i] = 1;\n}\n}\nif (dp[N]) {\ncout << 1 << endl;\n} else {\ncout << 0 << endl;\n}\nreturn 0;\n}"
    },
    {
        "problem_tier": 13,
        "solution_code": "#include<iostream>\n#include<algorithm>\n#include<vector>\n#include<cstring>\n#define endl \"\\n\"\n#define MAX 200010\nusing namespace std;\nint M, N, Total, Result, Answer;\nint Parent[MAX];\nbool Inp_Flag;\nvector<pair<int, pair<int, int>>> Edge;\nvoid Initialize(){\nEdge.clear();\nTotal = Result = 0;\nfor (int i = 0; i < MAX; i++) Parent[i] = i;\n}\nvoid Input(){\ncin >> M >> N;\nif (M == 0 && N == 0){\nInp_Flag = true;\nreturn;\n}\nfor (int i = 0; i < N; i++){\nint a, b, c; cin >> a >> b >> c;\nEdge.push_back(make_pair(c, make_pair(a, b)));\nTotal = Total + c;\n}\n}\nint Find_Parent(int A){\nif (A == Parent[A]) return A;\nelse return Parent[A] = Find_Parent(Parent[A]);\n}\nbool SameParent(int A, int B){\nA = Find_Parent(A);\nB = Find_Parent(B);\nif (A == B) return true;\nreturn false;\n}\nvoid Union(int A, int B){\nA = Find_Parent(A);\nB = Find_Parent(B);\nParent[B] = A;\n}\nvoid Solution(){\nsort(Edge.begin(), Edge.end());\nfor (int i = 0; i < Edge.size(); i++){\nint Cost = Edge[i].first;\nint Node1 = Edge[i].second.first;\nint Node2 = Edge[i].second.second;\nif (SameParent(Node1, Node2) == false){\nUnion(Node1, Node2);\nResult = Result + Cost;\n}\n}\nAnswer = Total - Result;\n}\nvoid Solve(){\nwhile (1){\nInitialize();\nInput();\nif (Inp_Flag == true) return;\nSolution();\ncout << Answer << endl;\n}\n}\nint main(void){\nios::sync_with_stdio(false);\ncin.tie(NULL);\ncout.tie(NULL);\nSolve();\nreturn 0;\n}"
    },
    {
        "problem_tier": 17,
        "solution_code": "#include <iostream>\n#include <stack>\nusing namespace std;\nint main() {\nios_base::sync_with_stdio(false);\ncin.tie(0);\ncout.tie(0);\nint n;\ncin >> n;\nlong long pairCnt = 0;\nstack<pair<int, int>> sta;\nfor (int i = 0; i < n; i++) {\nint height;\ncin >> height;\nint sameHeightCnt = 1;\nwhile (!sta.empty() && sta.top().first < height) {\npairCnt += sta.top().second;\nsta.pop();\n}\nif (!sta.empty()) {\nif (sta.top().first == height) {\npairCnt += sta.top().second;\nsameHeightCnt += sta.top().second;\nif (sta.size() > 1) {\npairCnt++;\n}\nsta.pop();\n}\nelse {\npairCnt++;\n}\n}\nsta.push({height, sameHeightCnt});\n}\ncout << pairCnt;\nreturn 0;\n}"
    },
    {
        "problem_tier": 11,
        "solution_code": "#include <iostream>\n#include <string>\nusing namespace std;\nint main() {\nios_base::sync_with_stdio(false);\ncin.tie(NULL);\ncout.tie(NULL);\nstring S;\nint Q, L, R;\nchar Al;\nint Sum[26][200001];\ncin >> S;\nfor (int i = 0; i < 26; i++) {\nchar Alpha = (char) (i + 97);\nfor (int j = 0; j < S.size(); j++) {\nSum[i][j] = Sum[i][j - 1] + ((S[j] == Alpha) ? 1 : 0);\n}\n}\ncin >> Q;\nwhile (Q--) {\ncin >> Al >> L >> R;\ncout << Sum[Al - 'a'][R] - Sum[Al - 'a'][L - 1] << \"\\n\";\n}\nreturn 0;\n}"
    },
    {
        "problem_tier": 2,
        "solution_code": "#include <iostream>\n#include <string>\nusing namespace std;\nint main() {\nint n;\ncin >> n;\nwhile (n--) {\nstring s;\ncin >> s;\nint sz = s.size();\nif (6 <= sz && sz <= 9)\ncout << \"yes\" << endl;\nelse\ncout << \"no\" << endl;\n}\nreturn 0;\n}"
    },
    {
        "problem_tier": 2,
        "solution_code": "#include <iostream>\nusing namespace std;\nint main() {\ncout << \"The world says hello!\";\nreturn 0;\n}"
    },
    {
        "problem_tier": 11,
        "solution_code": "#include<iostream>\n#include<vector>\nusing namespace std;\nint map[19][19];\nvector<int> dx = {0, 1, 1, 1};\nvector<int> dy = {1, 0, 1, -1};\nint search(int x, int y, int dir1, int dir2, int count) {\nif (count > 5) return 999;\nint nx = x + dx[dir1];\nint ny = y + dy[dir1];\nif (nx < 0 || ny < 0 || nx >= 19 || ny >= 19) return count;\nif (map[nx][ny] == map[x][y])\ncount = search(nx, ny, dir1, dir2, count + 1);\nreturn count;\n}\nint startSetting(int x, int y) {\nint ans = 0;\nfor (int i = 0; i < 4; i++) {\nint val = 1;\nfor (int j = 0; j < 2; j++) {\nint nx = x + dx[i];\nint ny = y + dy[i];\nif (nx < 0 || ny < 0 || nx >= 19 || ny >= 19) continue;\nif (map[x][y] == map[nx][ny]) val += search(nx, ny, i, j, 1);\n}\nif (val == 5) {\nans = map[x][y];\nbreak;\n}\n}\nreturn ans;\n}\nint main() {\ncin.tie(0);\ncout.tie(0);\nios::sync_with_stdio(false);\nint ans, ansX, ansY;\nans = 0;\nansX = ansY = 99;\nfor (int i = 0; i < 19; i++) {\nfor (int j = 0; j < 19; j++) {\ncin >> map[i][j];\n}\n}\nfor (int i = 0; i < 19; i++) {\nfor (int j = 0; j < 19; j++) {\nif (map[i][j] != 0) {\nint val = startSetting(i, j);\nif (val != 0) {\nif (j < ansY) {\nans = val;\nansX = i;\nansY = j;\n}\n}\n}\n}\n}\nif (ans) {\ncout << ans << \"\\n\";\ncout << ansX + 1 << \" \" << ansY + 1;\n} else {\ncout << \"0\";\n}\nreturn 0;\n}"
    },
    {
        "problem_tier": 9,
        "solution_code": "#include <iostream>\nusing namespace std;\nint main() {\nint w, h, p, q, t;\ncin >> w >> h >> p >> q >> t;\nif ((p + t) / w % 2 == 0) {\ncout << (p + t) % w << \" \";\n} else {\ncout << w - (p + t) % w << \" \";\n}\nif ((q + t) / h % 2 == 0) {\ncout << (q + t) % h;\n} else {\ncout << h - (q + t) % h;\n}\nreturn 0;\n}"
    },
    {
        "problem_tier": 10,
        "solution_code": "#include<bits/stdc++.h>\nusing namespace std;\nbool isSuccess(map<char,int> t) {\nfor(auto iter = info.begin(); iter != info.end(); ++iter) {\nif(iter->second != 0) {\nif(t.find(iter->first) != t.end()) {\nif((iter->second) <= t[iter->first])\ncontinue;\nelse return false;\n} else return false;\n}\n}\nreturn true;\n}\nint main(void) {\nios_base::sync_with_stdio(false);\ncin.tie(nullptr);\nint ans = 0;\nint S, P;\ncin >> S >> P;\nstring str;\ncin >> str;\nchar alpha[4] = {'A', 'C', 'G', 'T'};\nmap<char, int> info;\nfor(int i = 0; i < 4; ++i) {\nint n;\ncin >> n;\ninfo[alpha[i]] = n;\n}\nmap<char, int> m;\nfor(int i = 0; i < P; ++i) {\nm[str[i]] += 1;\n}\nif(isSuccess(m)) ans += 1;\nfor(int i = P; i < S; ++i) {\nm[str[i - P]] -= 1;\nm[str[i]] += 1;\nif(isSuccess(m)) ans += 1;\n}\ncout << ans;\nreturn 0;\n}"
    },
    {
        "problem_tier": 1,
        "solution_code": "#include <iostream>\nusing namespace std;\nint main(int argc, char* argv[]) {\nint a, b;\ncin >> a >> b;\ncout << a + b << endl;\nreturn 0;\n}"
    },
    {
        "problem_tier": 3,
        "solution_code": "#include <iostream>\nusing namespace std;\nint main() {\nint n;\ncin >> n;\nn %= 8;\nif (n > 5 || n == 0) {\ncout << (10 - n) % 8 << '\\n';\n} else {\ncout << n << '\\n';\n}\nreturn 0;\n}"
    },
    {
        "problem_tier": 12,
        "solution_code": "#include <iostream>\n#include <regex>\n#include <cstring>\nusing namespace std;\nint N;\nint main() {\ncin >> N;\nregex origin(\"((100+1+)|(01))+\");\nwhile (N--) {\nstring str;\ncin >> str;\nif (regex_match(str, origin))\ncout << \"YES\\n\";\nelse\ncout << \"NO\\n\";\n}\nreturn 0;\n}"
    },
    {
        "problem_tier": 12,
        "solution_code": "#include<bits/stdc++.h>\nusing namespace std;\nint INF = 100;\nint arr[51][51];\nint N, a, b;\nint main() {\ncin >> N;\nfor(int i=1; i<=N; i++){\nfor(int j=1; j<=N; j++){\narr[i][j] = INF;\n}\narr[i][i] = 0;\n}\nwhile(1){\ncin >> a >> b;\nif(a == -1 && b == -1) break;\narr[a][b] = 1;\narr[b][a] = 1;\n}\nfor(int k=1; k<=N; k++){\nfor(int i=1; i<=N; i++){\nfor(int j=1; j<=N; j++){\narr[i][j] = min(arr[i][j], arr[i][k] + arr[k][j]);\n}\n}\n}\nvector<int> ans;\nint ans_dist = INF;\nfor(int i=1; i<=N; i++){\nint row = 0;\nfor(int j=1; j<=N; j++){\nrow = max(row, arr[i][j]);\n}\nif(row < ans_dist){\nans_dist = row;\nans.clear();\nans.push_back(i);\n}\nelse if(row == ans_dist){\nans.push_back(i);\n}\n}\ncout << ans_dist << \" \" << ans.size() << \"\\n\";\nfor(int i=0; i<ans.size(); i++){\ncout << ans[i] << \" \";\n}\nreturn 0;\n}"
    },
    {
        "problem_tier": 16,
        "solution_code": "#include <iostream>\n#define MOD 1000000000\n#define LL long long\nusing namespace std;\nLL arr[1026][11][102];\nint N;\nint main() {\nios_base::sync_with_stdio(false);\ncin.tie(NULL);\ncout.tie(NULL);\ncin >> N;\nfor(int i=1; i<10; i++){\narr[1<<i][i][1] = 1;\n}\nfor(int i=1; i<N; i++){\nfor(int j=0; j<10; j++){\nfor(int k=1; k<1024; k++){\nint idx = 1<<j;\nif(arr[k][j][i] != 0){\nif(j == 0){\narr[k|1<<1][j+1][i+1] = (arr[k|1<<1][j+1][i+1] + arr[k][j][i]) % MOD;\n}\nelse if(j == 9){\narr[k|1<<8][j-1][i+1] = (arr[k|1<<8][j-1][i+1] + arr[k][j][i]) % MOD;\n}\nelse{\narr[k|1<<(j-1)][j-1][i+1] = (arr[k|1<<(j-1)][j-1][i+1] + arr[k][j][i]) % MOD;\narr[k|1<<(j+1)][j+1][i+1] = (arr[k|1<<(j+1)][j+1][i+1] + arr[k][j][i]) % MOD;\n}\n}\n}\n}\n}\nLL sum = 0;\nfor(int i=0; i<10; i++){\nint idx = (1<<10) - 1;\nsum += arr[idx][i][N];\n}\ncout << sum % MOD << \"\\n\";\nreturn 0;\n}"
    },
    {
        "problem_tier": 3,
        "solution_code": "#include<iostream>\nusing namespace std;\nint main() {\nlong long a, b, c;\ncin >> a >> b >> c;\nif (a + b >= 2 * c)\ncout << a + b - 2 * c << endl;\nelse\ncout << a + b << endl;\nreturn 0;\n}"
    },
    {
        "problem_tier": 7,
        "solution_code": "#include <iostream>\n#include <string>\nusing namespace std;\nint main() {\nstring num;\ncin >> num;\nint cnt = 0;\nint sum;\nwhile (num.length() > 1) {\nsum = 0;\nfor (int i = 0; i < num.length(); i++) {\nsum += num[i] - '0';\n}\nnum = to_string(sum);\ncnt++;\n}\ncout << cnt << '\\n';\nif (stoi(num) != 3 && stoi(num) != 6 && stoi(num) != 9)\ncout << \"NO\";\nelse\ncout << \"YES\";\nreturn 0;\n}"
    },
    {
        "problem_tier": 9,
        "solution_code": "#include <iostream>\n#include <vector>\nusing namespace std;\nint main() {\nios_base::sync_with_stdio(false);\ncin.tie(0);\nint n;\ncin >> n;\nvector<int> sum(n + 1);\nfor (int i = 0; i < n; i++) {\nint num;\ncin >> num;\nsum[i + 1] = sum[i] + num;\n}\nint m;\ncin >> m;\nwhile (m--) {\nint s, e;\ncin >> s >> e;\ncout << sum[e] - sum[s - 1] << \"\\n\";\n}\nreturn 0;\n}"
    },
    {
        "problem_tier": 12,
        "solution_code": "#include <iostream>\n#include <stack>\nusing namespace std;\nint main() {\nios::sync_with_stdio(0);\ncin.tie(0);\ncout.tie(0);\nint n;\ncin >> n;\nstack<int> s;\nlong long answer = 0;\nfor (int i = 0; i < n; i++) {\nint height;\ncin >> height;\nwhile (!s.empty() && s.top() <= height) {\ns.pop();\n}\nanswer += s.size();\ns.push(height);\n}\ncout << answer << endl;\nreturn 0;\n}"
    },
    {
        "problem_tier": 4,
        "solution_code": "#include <iostream>\n#include <climits>\nusing namespace std;\nint main(void){\nint n;\nfor(int test_case = 0; test_case < 3; test_case++){\ncin >> n;\nlong long result = 0, overflow = 0;\nfor(int i = 0; i < n; i++){\nlong long tmp;\ncin >> tmp;\nif(result > 0 && tmp > 0 && tmp > LLONG_MAX - result){\noverflow += 1;\n}\nif(result < 0 && tmp < 0 && tmp < LONG_MIN - result){\noverflow -= 1;\n}\nresult += tmp;\n}\nif(overflow < 0){\ncout << \"-\\n\";\n}\nelse if(overflow > 0){\ncout << \"+\\n\";\n}\nelse if(result == 0){\ncout << \"0\\n\";\n}\nelse if(result < 0){\ncout << \"-\\n\";\n}\nelse if(result > 0){\ncout << \"+\\n\";\n}\n}\nreturn 0;\n}"
    },
    {
        "problem_tier": 12,
        "solution_code": "#include<iostream>\n#include<algorithm>\n#define INF 2000000000\nusing namespace std;\nint n, target;\nint arr[100000];\nint main() {\ncin.tie(NULL);\nios_base::sync_with_stdio(false);\ncin >> n >> target;\nfor(int i=0; i<n; i++) {\ncin >> arr[i];\n}\nsort(arr, arr+n);\nint start = 0, end = 0;\nint answer = INF;\nwhile(start < n && end < n) {\nint result = arr[end] - arr[start];\nif(result < target) {\nend++;\n} else {\nanswer = min(answer, result);\nstart++;\n}\n}\ncout << answer;\nreturn 0;\n}"
    },
    {
        "problem_tier": 15,
        "solution_code": "#include<iostream>\n#include<vector>\n#include<queue>\n#include<algorithm>\n#define endl \"\\n\"\n#define MAX 2010\n#define INF 987654321\nusing namespace std;\nint N, M, T, S, G, H, Dist_GH;\nint Dist_S[MAX];\nint Dist_G[MAX];\nint Dist_H[MAX];\nvector<pair<int,int>> V[MAX];\nvector<int> Candidate;\nvoid Initialize(){\nfor (int i = 0; i < MAX; i++){\nV[i].clear();\nDist_S[i] = INF;\nDist_G[i] = INF;\nDist_H[i] = INF;\n}\nCandidate.clear();\n}\nvoid Input(){\ncin >> N >> M >> T;\ncin >> S >> G >> H;\nfor (int i = 0; i < M; i++){\nint a, b, c; cin >> a >> b >> c;\nV[a].push_back(make_pair(b, c));\nV[b].push_back(make_pair(a, c));\n}\nfor (int i = 0; i < T; i++){\nint a; cin >> a;\nCandidate.push_back(a);\n}\n}\nvoid Dijkstra(int Start, int A[MAX]){\npriority_queue<pair<int, int>> PQ;\nPQ.push(make_pair(0, Start));\nA[Start] = 0;\nwhile (PQ.empty() == 0){\nint Cost = -PQ.top().first;\nint Cur = PQ.top().second;\nPQ.pop();\nfor (int i = 0; i < V[Cur].size(); i++){\nint Next = V[Cur][i].first;\nint nCost = V[Cur][i].second;\nif (A[Next] > Cost + nCost){\nA[Next] = Cost + nCost;\nPQ.push(make_pair(-A[Next], Next));\n}\n}\n}\n}\nvoid Solution(){\nDijkstra(S, Dist_S);\nDijkstra(G, Dist_G);\nDist_GH = Dist_G[H];\nDijkstra(H, Dist_H);\nsort(Candidate.begin(), Candidate.end());\nfor (int i = 0; i < Candidate.size(); i++){\nint Dest = Candidate[i];\nif (Dist_S[Dest] == Dist_S[G] + Dist_GH + Dist_H[Dest])\ncout << Dest << \" \";\nelse if (Dist_S[Dest] == Dist_S[H] + Dist_GH + Dist_G[Dest])\ncout << Dest << \" \";\n}\ncout << endl;\n}\nvoid Solve(){\nint Tc; cin >> Tc;\nfor (int T = 1; T <= Tc; T++){\nInitialize();\nInput();\nSolution();\n}\n}\nint main(void){\nios::sync_with_stdio(false);\ncin.tie(NULL);\ncout.tie(NULL);\nSolve();\nreturn 0;\n}"
    },
    {
        "problem_tier": 10,
        "solution_code": "#include <iostream>\n#include <map>\n#include <string>\nusing namespace std;\nint main() {\nmap<string, int> m;\nstring wood;\nint cnt = 0;\nwhile (getline(cin, wood)) {\nm[wood]++;\ncnt++;\n}\ncout << fixed;\ncout.precision(4);\nfor (auto i = m.begin(); i != m.end(); i++) {\ncout << i->first << \" \" << i->second * 100 / (double)cnt << endl;\n}\nreturn 0;\n}"
    },
    {
        "problem_tier": 7,
        "solution_code": "#include <iostream>\n#include <algorithm>\n#include <vector>\nusing namespace std;\nint main() {\nint width, height;\ncin >> width >> height;\nint n;\ncin >> n;\nvector<int> vertical;\nvector<int> horizontal;\nfor (int i = 0; i < n; i++) {\nint dir, len;\ncin >> dir >> len;\nif (dir == 0) {             vertical.push_back(len);\n}\nelse {             horizontal.push_back(len);\n}\n}\nvertical.push_back(height);\nhorizontal.push_back(width);\nsort(vertical.begin(), vertical.end());\nsort(horizontal.begin(), horizontal.end());\nint maxArea = 0;\nfor (int i = 1; i < vertical.size(); i++) {\nfor (int j = 1; j < horizontal.size(); j++) {\nint area = (vertical[i] - vertical[i-1]) * (horizontal[j] - horizontal[j-1]);\nmaxArea = max(maxArea, area);\n}\n}\ncout << maxArea << endl;\nreturn 0;\n}"
    },
    {
        "problem_tier": 14,
        "solution_code": "#include <iostream>\n#include <vector>\nusing namespace std;\nint N;\nvector<vector<int>> board;\nint dy[] = {0, 1, 0, -1};\nint dx[] = {-1, 0, 1, 0};\ndouble p[9] = {0.05, 0.1, 0.1, 0.02, 0.02, 0.07, 0.07, 0.01, 0.01};\nint m_dy[4][10] = {{0, -1, 1, -2, 2, -1, 1, -1, 1, 0}, {2, 1, 1, 0, 0, 0, 0, -1, -1, 1},\n{0, -1, 1, -2, 2, -1, 1, -1, 1, 0}, {-2, -1, -1, 0, 0, 0, 0, 1, 1, -1}};\nint m_dx[4][10] = {{-2, -1, -1, 0, 0, 0, 0, 1, 1, -1}, {0, -1, 1, -2, 2, -1, 1, -1, 1, 0},\n{2, 1, 1, 0, 0, 0, 0, -1, -1, 1}, {0, -1, 1, -2, 2, -1, 1, -1, 1, 0}};\nint result = 0;\nint cnt = 0;\nvoid check() {\nint y = N / 2, x = N / 2;     int a;\nint dist = 1;\nint d = 0;     int cnt = 0;\nwhile (1) {\ncnt++;\nfor (int m = 0; m < dist; m++) {\nint ny = y + dy[d];             int nx = x + dx[d];\ny = ny;\nx = nx;\na = board[ny][nx];\nfor (int k = 0; k < 9; k++) {\nint m_ny = ny + m"
    },
    {
        "problem_tier": 3,
        "solution_code": "#include<iostream>\nusing namespace std;\nint main(){\nint a, b;\ncin >> a >> b;\nif((a+b)%2==1 || a<b)\ncout << -1;\nelse{\nint n = (a+b)/2;\nint m = a - n;\ncout << n << \" \" << m;\n}\nreturn 0;\n}"
    },
    {
        "problem_tier": 5,
        "solution_code": "#include <iostream>\nusing namespace std;\nint main() {\nint n;\nint sum = 5;\nint num = 7;\ncin >> n;\nfor(int i = 2; i <= n; ++i) {\nsum += num;\nnum += 3;\nsum %= 45678;\nnum %= 45678;\n}\ncout << sum << endl;\nreturn 0;\n}"
    },
    {
        "problem_tier": 16,
        "solution_code": "#include <iostream>\n#include <queue>\n#include <algorithm>\n#include <string>\nusing namespace std;\nstruct Point {\nint x;\nint y;\nint z;\n};\nstring arr[51];\nint N, K;\nqueue<Point> Q;\nqueue<int> T;\nbool is_visit[64][51][51];\nint dx[4] = {0, 1, 0, -1};\nint dy[4] = {1, 0, -1, 0};\nint main() {\nios_base::sync_with_stdio(false);\ncin.tie(NULL);\ncout.tie(NULL);\ncin >> N >> K;\nfor (int i = 0; i < N; i++) {\ncin >> arr[i];\nfor (int j = 0; j < K; j++) {\nif (arr[i][j] == '0') {\nis_visit[0][i][j] = true;\nQ.push({i, j, 0});\nT.push(0);\n}\n}\n}\nwhile (!Q.empty()) {\nint x = Q.front().x;\nint y = Q.front().y;\nint z = Q.front().z;\nint time = T.front();\nQ.pop();\nT.pop();\nif (arr[x][y] == '1') {\ncout << time << \"\\n\";\nreturn 0;\n}"
    },
    {
        "problem_tier": 13,
        "solution_code": "#include <iostream>\n#include <vector>\n#include <algorithm>\nusing namespace std;\nint N, Answer;\nint Player[51][10];\nint Order[10];\nbool Select[10];\nvoid Game()\n{\nint Score = 0;\nint Start_Player = 1;\nint Base[4];\nfor (int i = 1; i <= N; i++)\n{\nint Out_Cnt = 0;\nbool Next_Ining = false;\nmemset(Base, 0, sizeof(Base));\nwhile (true)\n{\nfor (int j = Start_Player; j <= 9; j++)\n{\nint Player = Player[i][Order[j]];\nif (Player == 0)\nOut_Cnt++;\nelse if (Player == 1)\n{\nfor (int k = 3; k >= 1; k--)\n{\nif (Base[k] == 1)\n{\nif (k == 3)\n{\nBase[k] = 0;\nScore++;\n}\nelse\n{\nBase[k + 1] = 1;\nBase[k] = 0;\n}\n}\n}\nBase[1] = 1;\n}\nelse if (Player == 2)\n{\nfor (int k = 3; k >= 1; k--)\n{\nif (Base[k] == 1)\n{\nif (k == 3 || k == 2)\n{\nBase[k] = 0;\nScore++;\n}\nelse\n{\nBase[k + 2] = 1"
    },
    {
        "problem_tier": 3,
        "solution_code": "#include <iostream>\n#define PI 3.141592\nusing namespace std;\nint main() {\ndouble d1, d2;\ncin >> d1 >> d2;\nprintf(\"%.6f\\n\", d1 * 2 + 2 * PI * d2);\n}"
    },
    {
        "problem_tier": 4,
        "solution_code": "#include <iostream>\nusing namespace std;\nint main() {\nint n;\ncin >> n;\nwhile (n--) {\nint c, v;\ncin >> c >> v;\ncout << \"You get \" << c / v << \" piece(s) and your dad gets \" << c % v << \" piece(s).\" << endl;\n}\nreturn 0;\n}"
    },
    {
        "problem_tier": 15,
        "solution_code": "#include <iostream>\n#include <algorithm>\n#include <queue>\n#include <set>\n#include <string>\nusing namespace std;\nstring Start, End;\nset<string> Visit;\nint dx[] = { 0, 0, 1, -1 };\nint dy[] = { 1, -1, 0, 0 };\nvoid Input(){\nEnd = \"123456780\";\nfor (int i = 0; i < 3; i++){\nfor (int j = 0; j < 3; j++){\nint a;\ncin >> a;\nchar Tmp = a + '0';\nStart = Start + Tmp;\n}\n}\n}\nint BFS(){\nqueue<pair<string, int>> Q;\nQ.push(make_pair(Start, 0));\nVisit.insert(Start);\nwhile (Q.empty() == 0){\nstring Cur = Q.front().first;\nint Cnt = Q.front().second;\nQ.pop();\nif (Cur == End)\nreturn Cnt;\nint Zero = Cur.find('0');\nint x = Zero / 3;\nint y = Zero % 3;\nfor (int i = 0; i < 4; i++){\nint nx = x + dx[i];\nint ny = y + dy[i];\nif (nx >= 0 && ny >= 0 && nx < 3 && ny < 3){\nstring Next = Cur;\nswap(Next[x * 3 + y], Next[nx * 3 + ny]);\nif (Visit.find(Next) == Visit.end()){\nVisit.insert(Next);\nQ.push(make_pair(Next, Cnt + 1));\n}\n}\n}\n}\nreturn -1;\n}\nvoid Solution(){\ncout << BFS() << endl;\n}\nvoid Solve(){\nInput();\nSolution();\n}\nint main(void){\nios::sync_with_stdio(false);\ncin.tie(NULL);\ncout.tie(NULL);\nSolve();\nreturn 0;\n}"
    },
    {
        "problem_tier": 7,
        "solution_code": "#include <iostream>\n#include <queue>\nusing namespace std;\nint main() {\nint N;\ncin >> N;\nint dasom;\ncin >> dasom;\npriority_queue<int> pq;\nfor (int i = 0; i < N - 1; i++) {\nint vote;\ncin >> vote;\npq.push(vote);\n}\nint answer = 0;\nwhile (!pq.empty() && pq.top() >= dasom) {\nint t = pq.top();\npq.pop();\nt--;\nanswer++;\ndasom++;\npq.push(t);\n}\ncout << answer << \"\\n\";\nreturn 0;\n}"
    },
    {
        "problem_tier": 8,
        "solution_code": "#include<iostream>\n#include<string>\n#include<set>\nusing namespace std;\nint main() {\nint n, ans = 0;\ncin >> n;\nstring str;\nset<string> gomgom;\nfor (int i = 0; i < n; i++) {\ncin >> str;\nif (str == \"ENTER\") {\nans += gomgom.size();\ngomgom.clear();\n}\nelse\ngomgom.insert(str);\n}\nans += gomgom.size();\ncout << ans;\nreturn 0;\n}"
    },
    {
        "problem_tier": 16,
        "solution_code": "#include <iostream>\n#include <map>\nusing namespace std;\nint N, S;\nint arr[41];\nmap<int, int> subsum;\nlong long cnt;\nvoid rightSeq(int mid, int sum){\nif(mid == N){\nsubsum[sum]++;\nreturn;\n}\nrightSeq(mid+1, sum+arr[mid]);\nrightSeq(mid+1, sum);\n}\nvoid leftSeq(int st, int sum){\nif(st == N/2){\ncnt += subsum[S-sum];\nreturn;\n}\nleftSeq(st+1, sum+arr[st]);\nleftSeq(st+1, sum);\n}\nint main(){\ncin >> N >> S;\nfor(int i = 0; i < N; i++){\ncin >> arr[i];\n}\nrightSeq(N/2, 0);\nleftSeq(0, 0);\nif(!S) cout << cnt-1;\nelse cout << cnt;\nreturn 0;\n}"
    },
    {
        "problem_tier": 9,
        "solution_code": "#include <iostream>\n#include <string>\n#include <vector>\nusing namespace std;\nint map[8][8];\nint dx[8] = {0, 0, 1, -1, -1, -1, 1, 1};\nint dy[8] = {1, -1, 0, 0, 1, -1, 1, -1};\nvoid moveKing(char direction, int& x, int& y) {\nint nx = x + dx[direction];\nint ny = y + dy[direction];\nif (nx < 0 || nx >= 8 || ny < 0 || ny >= 8) return;\nif (map[nx][ny] == 1) {\nint nnx = nx + dx[direction];\nint nny = ny + dy[direction];\nif (nnx < 0 || nnx >= 8 || nny < 0 || nny >= 8) return;\nmap[nx][ny] = 0;\nmap[nnx][nny] = 1;\n}\nx = nx;\ny = ny;\n}\nint main() {\nchar kingX, stoneX;\nint kingY, stoneY, n;\ncin >> kingX >> kingY >> stoneX >> stoneY >> n;\nint kingCurrX = kingY - 1;\nint kingCurrY = kingX - 'A';\nint stoneCurrX = stoneY - 1;\nint stoneCurrY = stoneX - 'A';\nmap[kingCurrX][kingCurrY] = 1;\nmap[stoneCurrX][stoneCurrY] = 2;\nfor (int i = 0; i < n; i++) {\nstring move;\ncin >> move;\nif (move == \"R\") moveKing(0, kingCurrX, kingCurrY);\nelse if (move == \"L\") moveKing(1, kingCurrX, kingCurrY);\nelse if (move == \"B\") moveKing(2, kingCurrX, kingCurrY);\nelse if (move == \"T\") moveKing(3, kingCurrX, kingCurrY);\nelse if (move == \"RT\") moveKing(4, kingCurrX, kingCurrY);\nelse if (move == \"LT\") moveKing(5, kingCurrX, kingCurrY);\nelse if (move == \"RB\") moveKing(6, kingCurrX, kingCurrY);\nelse if (move == \"LB\") moveKing(7, kingCurrX, kingCurrY);\nmap[kingCurrX][kingCurrY] = 1;\n}\ncout << static_cast<char>(kingCurrY + 'A') << kingCurrX + 1 << endl;\ncout << static_cast<char>(stoneCurrY + 'A') << stoneCurrX + 1 << endl;\nreturn 0;\n}"
    },
    {
        "problem_tier": 14,
        "solution_code": "#include <iostream>\n#include <algorithm>\n#define MAX 20\nusing namespace std;\nstruct COORD{\nint x;\nint y;\n};\nint N, Answer = 987654321;\nint MAP[MAX][MAX];\nint Label[MAX][MAX];\nCOORD Pos[4];\nint Min(int A, int B) {\nif (A < B) return A;\nreturn B;\n}\nvoid Input(){\ncin >> N;\nfor (int i = 0; i < N; i++)\n{\nfor (int j = 0; j < N; j++)\n{\ncin >> MAP[i][j];\n}\n}\n}\nbool CanMakeLine(int x, int y, int d1, int d2){\nif (x + d1 >= N || y - d1 < 0) return false;\nif (x + d2 >= N || y + d2 >= N) return false;\nif (x + d1 + d2 >= N || y - d1 + d2 >= N) return false;\nif (x + d2 + d1 >= N || y + d2 - d1 < 0) return false;\nreturn true;\n}\nvoid Calculate(){\nint Sum[6] = { 0, 0, 0, 0, 0, 0 };\nfor (int i = 0; i < N; i++)\n{\nfor (int j = 0; j < N; j++)\n{\nSum[Label[i][j]] = Sum[Label[i][j]] + MAP[i][j];\n}\n}\nsort(Sum, Sum + 6);\nint Diff = Sum[5] - Sum[1];\nAnswer = Min(Answer, Diff);\n}\nvoid Labeling(int a, int b, int c, int d){\nfor (int i = 0; i < N; i++)\n{\nfor (int j = 0; j < N; j++)\n{\nLabel[i][j] = 5;\n}\n}\nint SubArea = 0;\nfor (int i = 0; i < Pos[1].x; i++)\n{\nif (i >= Pos[0].x) SubArea++;\nfor (int j = 0; j <= Pos[0].y - SubArea; j++)\n{\nLabel[i][j] = 1;\n}\n"
    },
    {
        "problem_tier": 9,
        "solution_code": "#include<iostream>\n#include<cstdio>\nconst int LM = 1000;\nint st[LM], top = -1, N, n, order = 1;\nint main() {\nscanf(\"%d\", &N);\nfor (int i = 0; i < N; ++i) {\nscanf(\"%d\", &n);\nif (n == order)\n++order;\nelse\nst[++top] = n;\nwhile (top >= 0 && st[top] == order) {\n++order;\n--top;\n}\n}\nif (order - 1 == N)\nprintf(\"Nice\\n\");\nelse\nprintf(\"Sad\\n\");\nreturn 0;\n}"
    },
    {
        "problem_tier": 4,
        "solution_code": "#include <iostream>\nusing namespace std;\nint main() {\nint n;\ncin >> n;\nwhile (true) {\nint target;\ncin >> target;\nif (target == 0) break;\nif (target % n == 0) {\ncout << target << \" is a multiple of \" << n << \".\\n\";\n} else {\ncout << target << \" is NOT a multiple of \" << n << \".\\n\";\n}\n}\nreturn 0;\n}"
    },
    {
        "problem_tier": 8,
        "solution_code": "#include <iostream>\n#include <cmath>\nusing namespace std;\nbool isPrime(long long num){\nif(num < 2){\nreturn false;\n}\nfor(long long i=2; i<=sqrt(num); i++){\nif(num % i == 0){\nreturn false;\n}\n}\nreturn true;\n}\nint main(){\nint tc;\ncin >> tc;\nfor(int t=0; t<tc; t++){\nlong long n, ans;\ncin >> n;\nbool p = (n < 3) ? true : false;\nans = (n < 3) ? 2 : n;\nwhile(!p){\nn++;\nif(isPrime(n)){\nans = n;\np = true;\n}\n}\ncout << ans << endl;\n}\nreturn 0;\n}"
    },
    {
        "problem_tier": 9,
        "solution_code": "#include <iostream>\n#include <string>\n#include <algorithm>\n#include <vector>\n#include <map>\nusing namespace std;\nbool comp(pair<int, string> a, pair<int, string> b) {\nif (a.first == b.first) {\nif (a.second.length() == b.second.length())\nreturn a.second < b.second;         return a.second.length() > b.second.length();     }\nreturn a.first > b.first; }\nint main() {\nios::sync_with_stdio(false);\ncin.tie(0);\ncout.tie(0);\nmap<string, int> checklist;\nint n, m;\ncin >> n >> m;\nwhile (n--) {\nstring str;\ncin >> str;\nif (str.length() < m)\ncontinue;\nchecklist[str]++;\n}\nvector<pair<int, string>> wordbook;\nfor (auto w : checklist)\nwordbook.push_back({ w.second, w.first });\nsort(wordbook.begin(), wordbook.end(), comp);\nfor (auto s : wordbook)\ncout << s.second << '\\n';\nreturn 0;\n}"
    },
    {
        "problem_tier": 8,
        "solution_code": "#include<iostream>\n#include<stack>\nusing namespace std;\nint main() {\nint n, m, num;\nstack<int> stack;\ncin >> n;\nfor (int i = 0; i < n; i++) {\ncin >> m;\nswitch (m) {\ncase 1:\ncin >> num;\nstack.push(num);\nbreak;\ncase 2:\nif (!stack.empty()) {\ncout << stack.top() << \"\\n\";\nstack.pop();\n}\nelse\ncout << \"-1\\n\";\nbreak;\ncase 3:\ncout << stack.size() << \"\\n\";\nbreak;\ncase 4:\nif (stack.empty())\ncout << \"1\\n\";\nelse\ncout << \"0\\n\";\nbreak;\ncase 5:\nif (!stack.empty())\ncout << stack.top() << \"\\n\";\nelse\ncout << \"-1\\n\";\nbreak;\n}\n}\nreturn 0;\n}"
    },
    {
        "problem_tier": 7,
        "solution_code": "#include <iostream>\n#include <algorithm>\nusing namespace std;\nint main() {\nint k;\ncin >> k;\nfor (int c = 1; c <= k; c++) {\nint n;\ncin >> n;\nint* a = new int[n];\nfor (int i = 0; i < n; i++)\ncin >> a[i];\nsort(a, a + n, greater<int>());\ncout << \"Class \" << c << '\\n';\ncout << \"Max \" << a[0] << \", \";\ncout << \"Min \" << a[n-1] << \", \";\nint lg = 0;\nfor (int i = 0; i < n - 1; i++) {\nif (lg < a[i] - a[i+1])\nlg = a[i] - a[i+1];\n}\ncout << \"Largest gap \" << lg << '\\n';\ndelete[] a;\n}\nreturn 0;\n}"
    },
    {
        "problem_tier": 13,
        "solution_code": "#include<iostream>\n#include<vector>\n#include<queue>\n#include<algorithm>\nusing namespace std;\nint main() {\nint N;\ncin >> N;\nvector<int> adj[10002];\nint inDeg[10002] = { 0, };\nqueue<int> q;\nint time[10002];\nint result[10002];\nfor (int i = 1; i <= N; i++) {\ncin >> time[i];\nint preNum;\ncin >> preNum;\nfor (int j = 0; j < preNum; j++) {\nint preBuild;\ncin >> preBuild;\nadj[preBuild].push_back(i);\ninDeg[i]++;\n}\n}\nfor (int i = 1; i <= N; i++) {\nif (inDeg[i] == 0) {\nq.push(i);\n}\nresult[i] = time[i];\n}\nwhile (!q.empty()) {\nint cur = q.front();\nq.pop();\nfor (int i = 0; i < adj[cur].size(); i++) {\nint next = adj[cur][i];\ninDeg[next]--;\nresult[next] = max(result[next], result[cur] + time[next]);\nif (inDeg[next] == 0) {\nq.push(next);\n}\n}\n}\nint ans = -1;\nfor (int i = 1; i <= N; i++) {\nans = max(ans, result[i]);\n}\ncout << ans;\nreturn 0;\n}"
    },
    {
        "problem_tier": 5,
        "solution_code": "#include <iostream>\nusing namespace std;\nstruct Time {\nint h;\nint m;\nint s;\n};\nint findSum(Time t) {\nint sum = t.h * 3600 + t.m * 60 + t.s;\nreturn sum;\n}\nint main() {\nTime now, mission;\nscanf(\"%d:%d:%d\", &now.h, &now.m, &now.s);\nscanf(\"%d:%d:%d\", &mission.h, &mission.m, &mission.s);\nint nowSum = findSum(now);\nint misSum = findSum(mission);\nint temp = misSum - nowSum;\nif (nowSum < misSum) {\nprintf(\"%02d:%02d:%02d\", temp / 3600, temp % 3600 / 60, temp % 60);\n} else {\ntemp = 24 * 3600 - nowSum + misSum;\nprintf(\"%02d:%02d:%02d\", (temp) / 3600, (temp) % 3600 / 60, (temp) % 60);\n}\nreturn 0;\n}"
    },
    {
        "problem_tier": 5,
        "solution_code": "#include <iostream>\n#include <string>\nusing namespace std;\nbool isLucky(string scores) {\nint sum1 = 0;\nint sum2 = 0;\nif (scores.size() % 2 == 0) {\nfor (int i = 0; i < scores.size() / 2; i++) {\nsum1 += scores[i] - '0';\n}\nfor (int i = scores.size() / 2; i < scores.size(); i++) {\nsum2 += scores[i] - '0';\n}\nif (sum1 == sum2) {\nreturn true;\n} else {\nreturn false;\n}\n} else {\nreturn false;\n}\n}\nint main() {\nstring scores;\ncin >> scores;\nif (isLucky(scores)) {\ncout << \"LUCKY\\n\";\n} else {\ncout << \"READY\\n\";\n}\nreturn 0;\n}"
    },
    {
        "problem_tier": 3,
        "solution_code": "#include<iostream>\n#include<string>\nusing namespace std;\nint main() {\nint n;\ncin >> n;\nwhile (n--) {\nstring s;\ncin >> s;\nfor (int i = 0; i < s.length(); i++) {\nif (s[i] >= 'A' && s[i] <= 'Z')\ncout << (char)(s[i] + 32);\nelse\ncout << s[i];\n}\ncout << \"\\n\";\n}\nreturn 0;\n}"
    },
    {
        "problem_tier": 11,
        "solution_code": "#include <iostream>\n#include <queue>\nusing namespace std;\nint N, M;\nconst int MAX = 101;\nchar input[MAX][MAX];\nint map[MAX][MAX] = { 0, };\nbool visited[MAX][MAX] = { 0, };\nint dy[] = { 1,-1,0,0 };\nint dx[] = { 0,0,-1,1 };\nint wSum = 0; int bSum = 0; int s = 1;\nqueue<pair<int, int>> q;\nvoid BFS(int y, int x) {\nvisited[y][x] = true;\nq.push(make_pair(y, x));\nwhile (!q.empty()) {\ny = q.front().first;\nx = q.front().second;\nq.pop();\nfor (int i = 0; i < 4; i++) {\nint ny = y + dy[i];\nint nx = x + dx[i];\nif (ny < 0 || nx < 0 || ny >= M || nx >= N)\ncontinue;\nif (map[ny][nx] == 1 && visited[ny][nx] == 0) {\nvisited[ny][nx] = true;\ns++;\nq.push(make_pair(ny, nx));\n}\n}\n}\n}\nvoid reset() {\nfor (int i = 0; i < M; i++) {\nfor (int j = 0; j < N; j++) {\nvisited[i][j] = 0;\nmap[i][j] = 0;\n}\n}\n}\nint main() {\ncin >> N >> M;\nfor (int i = 0; i < M; i++) {\nfor (int j = 0; j < N; j++) {\nscanf(\"%1s\", &input[i][j]);\n}\n}\nfor (int i = 0; i < M; i++) {\nfor (int j = 0; j < N; j++) {\nif (input[i][j] == 'W') {\nmap[i][j] = 1;\n}\n}\n}\nfor (int i = 0; i < M; i++) {\nfor (int j = 0; j < N; j++) {\nif (map[i][j] == 1 && visited[i][j] == 0) {\nBFS(i, j);\nwSum += s * s;\ns = 1;\n}\n}\n}\nreset();\nfor (int i = 0; i < M; i++) {\nfor (int j = 0; j < N; j++) {\nif (input[i][j] == 'B') {\nmap[i][j] = 1;\n}\n}\n}\nfor (int i = 0; i < M; i++) {\nfor (int j = 0; j < N; j++) {\nif (map[i][j] == 1 && visited[i][j] == 0) {\nBFS(i, j);\nbSum += s * s;\ns = 1;\n}\n}\n}\ncout << wSum << \" \" << bSum;\nreturn 0;\n}"
    },
    {
        "problem_tier": 15,
        "solution_code": "#include <iostream>\n#include <cstring>\n#include <queue>\n#include <cmath>\nusing namespace std;\nint n, m, t;\nint arr[51][51] = { 0, };\nint result = 0;\nint temp[51] = { 0, };\nint visited[51][51];\nint y_ar[4] = { 1,-1,0,0 };\nint x_ar[4] = { 0,0,1,-1 };\nbool bfs(int y, int x) {\nmemset(visited, 0, sizeof(visited));\nqueue <pair<int, int>> que;\nque.push(make_pair(y, x));\nvisited[y][x] = 1;\nwhile (!que.empty()) {\nint cy = que.front().first;\nint cx = que.front().second;\nque.pop();\nfor (int i = 0; i < 4; i++) {\nint ny = cy + y_ar[i];\nint nx = cx + x_ar[i];\nif (ny < 0 || ny == n) continue;\nif (nx == m) nx = 0;\nelse if (nx == -1) nx = m - 1;\nif (visited[ny][nx] == 0 && arr[ny][nx] == arr[cy][cx]) {\nque.push(make_pair(ny, nx));\nvisited[ny][nx] = visited[cy][cx] + 1;\n}\n}\n}\nbool jud = false;\nfor (int i = 0; i < n; i++)\nfor (int j = 0; j < m; j++)\nif (visited[i][j] > 1)\njud = true;\nif (jud == true) {\nfor (int i = 0; i < n; i++)\nfor (int j = 0; j < m; j++)\nif (visited[i][j] != 0)\narr[i][j] = 0;\n}\nreturn jud;\n}\nint main() {\nios_base::sync_with_stdio(0);\ncin.tie(0), cout.tie(0);\ncin >> n >> m >> t;\nfor (int i = 0; i < n; i++)\nfor (int j = 0; j < m; j++)\ncin >> arr[i][j];\nwhile (t--) {\nint x, d, k;\ncin >> x >> d >> k;\nif (d == 1)\nk = m - k;\nfor (int i = x - 1; i < n; i += x) {\nfor (int l = 0; l < k; l++) {\nfor (int j = 0; j < m; j++)\ntemp[j] = arr[i][j];\nfor (int j = 1; j < m; j++)\narr[i][j] = temp[j - 1];\narr[i][0] = temp[m - 1];\n}\n}\nbool jud = false;\nfor (int i = 0; i < n; i++)\nfor (int j = 0; j < m; j++) {\nif (visited[i][j] == 0 && arr[i][j] != 0) {\nbool temp = bfs(i, j);\nif (temp == true)\njud = true;\n}\n}\nif (jud == false) {\ndouble sum = 0;\ndouble cnt = 0;\nfor (int i = 0; i < n; i++)\nfor (int j = 0; j < m; j++)\nif (arr[i][j] != 0 ) {\nsum += arr[i][j];\ncnt += 1;\n}\nif (cnt > 0) {\nsum = sum / cnt;\nfor (int i = 0; i < n; i++)\nfor (int j = 0; j < m; j++)\nif (arr[i][j] != 0) {\nif (sum > arr[i][j])\narr[i][j] ++;\nelse if (sum < arr[i][j])\narr[i][j] --;\n}\n}\n}\n}\nfor (int i = 0; i < n; i++)\nfor (int j = 0; j < m; j++)\nresult += arr[i][j];\ncout << result << endl;\n}"
    },
    {
        "problem_tier": 12,
        "solution_code": "#include <iostream>\n#include <algorithm>\n#include <vector>\nusing namespace std;\nint main() {\nint N, M;\nvector<int> crane;\nvector<int> box;\ncin >> N;\nfor (int i = 0; i < N; i++) {\nint n;\ncin >> n;\ncrane.push_back(n);\n}\ncin >> M;\nfor (int i = 0; i < M; i++) {\nint m;\ncin >> m;\nbox.push_back(m);\n}\nsort(crane.begin(), crane.end(), greater<int>());\nsort(box.begin(), box.end(), greater<int>());\nint cnt = 0;\nif (box[0] > crane[0]) {\ncout << -1;\nreturn 0;\n}"
    },
    {
        "problem_tier": 12,
        "solution_code": "#include<iostream>\n#include<string>\n#include<algorithm>\nusing namespace std;\nint palindrome(string s, int check){\nint left, right;\nleft = 0;\nright = s.size() - 1;\nwhile (left < right){\nif (s[left] != s[right]){\nif (check == 0){\nint len = right - left;\nif (palindrome(s.substr(left + 1, len), 1) == 0 || palindrome(s.substr(left, len), 1) == 0)\nreturn 1;                 else\nreturn 2;             }\nelse\nreturn 2;\n}\nleft++;\nright--;\n}\nreturn 0;\n}\nint main(){\nios_base::sync_with_stdio(false);\ncin.tie(NULL);\ncout.tie(NULL);\nint T;\ncin >> T;\nfor (int i = 0; i < T; i++){\nstring s;\ncin >> s;\ncout << palindrome(s, 0) << \"\\n\";\n}\nreturn 0;\n}"
    },
    {
        "problem_tier": 3,
        "solution_code": "#include <cstdio>\nusing namespace std;\nint main() {\nint K, D, A;\nscanf(\"%d/%d/%d\", &K, &D, &A);\nif(K + A < D || !D)\nprintf(\"hasu\");\nelse\nprintf(\"gosu\");\nreturn 0;\n}"
    },
    {
        "problem_tier": 8,
        "solution_code": "#include <iostream>\n#include <vector>\n#include <cstring>\nusing namespace std;\nint N, M;\nchar c[1000][50];\nchar dna[4] = {'A', 'C', 'G', 'T'};\nint tt[4];\nint res = 0;\nint main() {\nfreopen(\"input.txt\", \"r\", stdin);\ncin >> N >> M;\nfor (int i = 0; i < N; i++) {\nfor (int j = 0; j < M; j++) {\ncin >> c[i][j];\n}\n}\nfor (int j = 0; j < M; j++) {\nmemset(tt, 0, sizeof(tt));\nint max = 0;\nint chk = 0;\nfor (int i = 0; i < N; i++) {\nfor (int k = 0; k < 4; k++) {\nif (c[i][j] == dna[k]) {\ntt[k]++;\n}\n}\n}\nfor (int i = 0; i < 4; i++) {\nint temp = tt[i];\nif (max < temp) {\nmax = temp;\nchk = i;\n}\n}\nres += N - max;\ncout << dna[chk];\n}\ncout << endl;\ncout << res;\nreturn 0;\n}"
    },
    {
        "problem_tier": 10,
        "solution_code": "#include <iostream>\n#include <vector>\n#include <algorithm>\nusing namespace std;\nvector<int> graph[100001];\nbool visited[100001] = {false};\nint result[100001] = {0};\nint cnt = 0;\nvoid dfs(int R) {\nif (visited[R]) {\nreturn;\n}\nvisited[R] = true;\ncnt++;\nresult[R] = cnt;\nfor (int i = 0; i < graph[R].size(); i++) {\ndfs(graph[R][i]);\n}\n}\nint main() {\nios_base::sync_with_stdio(false);\ncin.tie(NULL);\ncout.tie(NULL);\nint N, M, R, tempX, tempY;\ncin >> N >> M >> R;\nfor (int i = 0; i < M; i++) {\ncin >> tempX >> tempY;\ngraph[tempX].push_back(tempY);\ngraph[tempY].push_back(tempX);\n}\nfor (int i = 1; i <= N; i++) {\nsort(graph[i].begin(), graph[i].end(), greater<int>());\n}\ndfs(R);\nfor (int i = 1; i <= N; i++) {\ncout << result[i] << '\\n';\n}\nreturn 0;\n}"
    },
    {
        "problem_tier": 6,
        "solution_code": "#include <iostream>\nint main() {\nlong long num;\nstd::cin >> num;\nlong long result = 0;\nfor (long long i = 1; i < num; i++) {\nresult += (num + 1) * i;\n}\nstd::cout << result;\nreturn 0;\n}"
    },
    {
        "problem_tier": 6,
        "solution_code": "#include <iostream>\n#include <algorithm>\nusing namespace std;\nint main() {\nint a[5];\nfor (int i = 0; i < 5; i++)\ncin >> a[i];\nwhile (1) {\nbool c = true;\nfor (int i = 0; i < 5; i++) {\nif (a[i] != i + 1)\nc = false;\n}\nif (c) {\nbreak;\n}\nfor (int i = 0; i < 4; i++) {\nif (a[i] > a[i + 1]) {\nswap(a[i + 1], a[i]);\nfor (int j = 0; j < 5; j++)\ncout << a[j] << ' ';\ncout << '\\n';\n}\n}\n}\nreturn 0;\n}"
    },
    {
        "problem_tier": 5,
        "solution_code": "#include<iostream>\nusing namespace std;\nint main() {\nint n, k = 1, time = 0;\ncin >> n;\nwhile (true) {\nk++;\nif (n == 0)\nbreak;\nif (n < k)\nk = 1;\nn -= k;\ntime++;\n}\ncout << time << '\\n';\nreturn 0;\n}"
    },
    {
        "problem_tier": 9,
        "solution_code": "#include <iostream>\n#include <algorithm>\n#include <vector>\nusing namespace std;\nvoid fast_io(void){\nios_base::sync_with_stdio(false);\ncin.tie(NULL);\ncout.tie(NULL);\n}\nvector<int> v;\nint main(void){\nfast_io();\nint n, res = 1000001, ans = 0;\ncin >> n;\nfor(int i=0; i<n; i++){\nint num;\ncin >> num;\nv.push_back(num);\n}\nsort(v.begin(), v.end());\nfor(int i=0; i<n; i++){\nint min = 0;\nfor(int j=0; j<n; j++){\nif(i > j)\nmin += v[i] - v[j];\nelse\nmin += v[j] - v[i];\n}\nif(res > min){\nres = min;\nans = v[i];\n}\n}\ncout << ans;\nreturn 0;\n}"
    },
    {
        "problem_tier": 7,
        "solution_code": "#include <iostream>\n#include <vector>\n#include <algorithm>\nusing namespace std;\nint main() {\nint n, snakeBirdLength;\ncin >> n >> snakeBirdLength;\nvector<int> fruitHeight(n);\nfor(int i = 0; i < n; i++) {\ncin >> fruitHeight[i];\n}\nsort(fruitHeight.begin(), fruitHeight.end());\nfor(auto f : fruitHeight) {\nif(snakeBirdLength >= f) {\nsnakeBirdLength++;\n}\n}\ncout << snakeBirdLength;\nreturn 0;\n}"
    },
    {
        "problem_tier": 9,
        "solution_code": "#include <iostream>\n#include <vector>\n#include <algorithm>\nusing namespace std;\nint main(){\nint T;\ncin>>T;\nwhile(T--){\nint N, M;\ncin>>N>>M;\nint setA[20000];\nint setB[20000];\nfor(int i=0;i<N;i++){\ncin>>setA[i];\n}\nfor(int i=0;i<M;i++){\ncin>>setB[i];\n}\nsort(setA, setA+N);\nsort(setB, setB+M);\nint count = 0;\nfor(int i=0;i<N;i++){\nfor(int j=0;j<M;j++){\nif(setA[i]>setB[j]){\ncount++;\n}\nelse{\nbreak;\n}\n}\n}\ncout<<count<<'\\n';\n}\nreturn 0;\n}"
    },
    {
        "problem_tier": 3,
        "solution_code": "#include <iostream>\nusing namespace std;\nint main() {\nint n;\ncin >> n;\nfor (int i = 0; i < n; i++) {\nint cnt;\ncin >> cnt;\nfor (int j = 0; j < cnt; j++) {\ncout << \"=\";\n}\ncout << \"\\n\";\n}\nreturn 0;\n}"
    },
    {
        "problem_tier": 10,
        "solution_code": "#include<iostream>\n#include<algorithm>\nusing namespace std;\nint N;\nint max_pos, max_h; int arr[1001];\nint res = 0;\nint main(void) {\ncin >> N;\nfor(int i=0; i<N; i++) {\nint L, H;\ncin >> L >> H;\narr[L] = H;\nif(max_h < H) {\nmax_pos = L;\nmax_h = H;\n}\n}\nint Lh = 0;     for(int i=1; i<max_pos; i++) {\nLh = max(Lh, arr[i]);\nres += Lh;\n}\nint Rh = 0;     for(int i=1000; i>max_pos; i--) {\nRh = max(Rh, arr[i]);\nres += Rh;\n}\ncout << res + max_h;\nreturn 0;\n}"
    },
    {
        "problem_tier": 5,
        "solution_code": "#include <iostream>\n#include <vector>\n#include <string>\n#include <algorithm>\nusing namespace std;\nint main() {\nint n;\ncin >> n;\nwhile (n--) {\nint p;\ncin >> p;\nvector<pair<int, string>> s(p);\nint ans = 0, ex = 0;\nfor (int i = 0; i < p; i++) {\ncin >> s[i].first >> s[i].second;\nif (s[i].first > ex) {\nex = s[i].first;\nans = i;\n}\n}\ncout << s[ans].second << '\\n';\n}\nreturn 0;\n}"
    },
    {
        "problem_tier": 8,
        "solution_code": "#include <iostream>\n#include <vector>\n#include <algorithm>\n#include <cmath>\nusing namespace std;\nint main() {\nint N;\ndouble avg = 0;\nvector<double> scores;\ncin >> N;\nif (N == 0) {\ncout << 0 << endl;\nreturn 0;\n}"
    },
    {
        "problem_tier": 4,
        "solution_code": "#include<iostream>\n#include<string>\nusing namespace std;\nvoid solve(int number){\nstring s = to_string(number);\nint res = 0;\nfor(int i=0;i<s.length();i++){\nif(s[i]=='1'){\nres += 2;\n}\nelse if(s[i]=='0'){\nres += 4;\n}\nelse{\nres += 3;\n}\n}\ncout<<res+s.length()+1<<'\\n';\n}\nint main(){\nint number;\nwhile(1){\ncin>>number;\nif(number==0)\nbreak;\nsolve(number);\n}\nreturn 0;\n}"
    },
    {
        "problem_tier": 12,
        "solution_code": "#include<iostream>\n#include<vector>\n#include<queue>\n#include<utility>\nusing namespace std;\nint N, M;\nint map[51][51];\nint dx[9] = { 99,-1,-1,0,1,1,1,0,-1 };\nint dy[9] = { 99,0,-1,-1,-1,0,1,1,1 };\nint main() {\nscanf(\"%d%d\", &N, &M);\nfor (int i = 1; i <= N; i++) {\nfor (int j = 1; j <= N; j++) {\nscanf(\"%d\", &map[i][j]);\n}\n}\nqueue<pair<int, int>> q;\nq.push({ N, 1 });\nq.push({ N, 2 });\nq.push({ N - 1, 1 });\nq.push({ N - 1, 2 });\nfor (int i = 0; i < M; i++) {\nbool visited[51][51] = { false };\nvector<pair<int, int>> v;\nint di, si;\nscanf(\"%d%d\", &di, &si);\nint size = q.size();\nfor (int j = 0; j < size; j++) {\nint r = q.front().first;\nint c = q.front().second;\nq.pop();\nfor (int k = 0; k < si; k++) {\nr += dy[di];\nc += dx[di];\nif (r < 1) {\nr = N;\n}\nif (r > N) {\nr = 1;\n}\nif (c < 1) {\nc = N;\n}\nif (c > N) {\nc = 1;\n}\n}\nmap[r][c]++;\nvisited[r][c] = true;\nv.push_back({ r, c });\n}\nfor (int j = 0; j < size; j++) {\nint r = v[j].first;\nint c = v[j].second;\nfor (int k = 2; k <= 9; k += 2) {\nint nr = r + dy[k];\nint nc = c + dx[k];\nif (nr <= N && nc <= N && nr >= 1 && nc >= 1 && map[nr][nc]) {\nmap[r][c]++;\n}\n}\n}\nfor (int j = 1; j <= N; j++) {\nfor (int k = 1; k <= N; k++) {\nif (map[j][k] >= 2 && !visited[j][k]) {\nq.push({ j, k });\nmap[j][k] -= 2;\n}\n}\n}\n}\nint cnt = 0;\nfor (int i = 1; i <= N; i++) {\nfor (int j = 1; j <= N; j++) {\nif (map[i][j] > 0) {\ncnt += map[i][j];\n}\n}\n}\nprintf(\"%d\", cnt);\nreturn 0;\n}"
    },
    {
        "problem_tier": 4,
        "solution_code": "#include <iostream>\nusing namespace std;\nint main() {\nint n, a, b;\ncin >> n;\nfor (int i = 1; i <= n; i++) {\ncin >> a >> b;\ncout << \"Case \" << i << \": \" << a + b << \"\\n\";\n}\nreturn 0;\n}"
    },
    {
        "problem_tier": 7,
        "solution_code": "#include <iostream>\n#include <stack>\n#include <math.h>\nusing namespace std;\nvoid baseConversion(int a, int b, int m) {\nint to_dec = 0;\nfor (int i = 0; i < m; i++) {\nint num;\ncin >> num;\nto_dec += num * pow(a, m - i - 1);\n}\nstack<int> ans;\nint div = to_dec;\nwhile (div) {\nans.push(div % b);\ndiv /= b;\n}\nwhile (!ans.empty()) {\ncout << ans.top() << ' ';\nans.pop();\n}\n}\nint main() {\nint a, b, m;\ncin >> a >> b >> m;\nbaseConversion(a, b, m);\nreturn 0;\n}"
    },
    {
        "problem_tier": 5,
        "solution_code": "#include <iostream>\n#include <string>\nusing namespace std;\nint main(){\nstring k;\nint cnt = 0;\ncin >> k;\nfor(int i=0; i<k.size(); i++){\nif(k[i] == ',')\ncnt++;\n}\ncout << cnt+1 <<'\\n';\nreturn 0;\n}"
    },
    {
        "problem_tier": 5,
        "solution_code": "#include <iostream>\n#define ll long long\nusing namespace std;\nint main() {\nios_base::sync_with_stdio(false);\ncin.tie(NULL);\nll a, b;\nll sum = 0;\ncin >> a >> b;\nif(a<b)\nsum = b * (b + 1) / 2 - (a) * (a - 1) / 2;\nelse\nsum = a * (a + 1) / 2 - (b) * (b - 1) / 2;\ncout << sum << '\\n';\n}"
    },
    {
        "problem_tier": 4,
        "solution_code": "#include <iostream>\n#include <string>\n#include <vector>\nusing namespace std;\nint main() {\nvector<string> agents(5);\nvector<int> foundAgents;\nfor (int i = 0; i < 5; i++) {\ncin >> agents[i];\n}\nfor (int i = 0; i < 5; i++) {\nif (agents[i].find(\"FBI\") != string::npos) {\nfoundAgents.push_back(i+1);\n}\n}\nif (foundAgents.empty()) {\ncout << \"HE GOT AWAY!\" << endl;\n} else {\nfor (int i = 0; i < foundAgents.size(); i++) {\ncout << foundAgents[i] << \" \";\n}\n}\nreturn 0;\n}"
    },
    {
        "problem_tier": 6,
        "solution_code": "#include <iostream>\n#include <map>\nusing namespace std;\nint main() {\nint total = 0, cups = 0;\nmap<char, int> maps;\nint n;\ncin >> n;\nwhile (n--) {\nchar temp;\ncin >> temp;\nmaps[temp]++;\n}\ntotal = maps['S'] + maps['L'];\ncups = maps['S'] + maps['L'] / 2 + 1;\nif (cups <= total)\ncout << cups;\nelse\ncout << total;\nreturn 0;\n}"
    },
    {
        "problem_tier": 11,
        "solution_code": "#include <iostream>\n#include <queue>\nusing namespace std;\nint R, C;\nint Total_Wolf, Total_Sheep;\nchar MAP[251][251];\nbool Visit[251][251];\nint dx[] = { 0, 0, 1, -1 };\nint dy[] = { 1, -1, 0, 0 };\nvoid Input() {\ncin >> R >> C;\nfor (int i = 0; i < R; i++) {\nfor (int j = 0; j < C; j++) {\ncin >> MAP[i][j];\n}\n}\n}\nvoid BFS(int a, int b) {\nint Wolf, Sheep;\nWolf = Sheep = 0;\nqueue<pair<int, int>> Q;\nQ.push(make_pair(a, b));\nVisit[a][b] = true;\nwhile (!Q.empty()) {\nint x = Q.front().first;\nint y = Q.front().second;\nQ.pop();\nif (MAP[x][y] == 'v') Wolf++;\nif (MAP[x][y] == 'o') Sheep++;\nfor (int i = 0; i < 4; i++) {\nint nx = x + dx[i];\nint ny = y + dy[i];\nif (nx >= 0 && ny >= 0 && nx < R && ny < C) {\nif (MAP[nx][ny] != '#' && Visit[nx][ny] == false) {\nVisit[nx][ny] = true;\nQ.push(make_pair(nx, ny));\n}\n}\n}\n}\nif (Sheep > Wolf) Total_Sheep += Sheep;\nelse Total_Wolf += Wolf;\n}\nvoid Solution() {\nfor (int i = 0; i < R; i++) {\nfor (int j = 0; j < C; j++) {\nif (Visit[i][j] == false) {\nBFS(i, j);\n}\n}\n}\ncout << Total_Sheep << \" \" << Total_Wolf << endl;\n}\nvoid Solve() {\nInput();\nSolution();\n}\nint main(void) {\nios::sync_with_stdio(false);\ncin.tie(NULL);\ncout.tie(NULL);\nSolve();\nreturn 0;\n}"
    },
    {
        "problem_tier": 13,
        "solution_code": "#include <iostream>\n#include <vector>\n#define MAX 51\nusing namespace std;\nstruct Ball {\nint m, s, d;\n};\nint N, M, K;\nint dx[8] = {-1, -1, 0, 1, 1, 1, 0, -1};\nint dy[8] = {0, 1, 1, 1, 0, -1, -1, -1};\nvector<Ball> fireBall[MAX][MAX];\nvoid moveBall() {\nvector<Ball> tmpBall[MAX][MAX];\nfor (int i = 1; i <= N; i++) {\nfor (int j = 1; j <= N; j++) {\nfor (int k = 0; k < fireBall[i][j].size(); k++) {\nint s = fireBall[i][j][k].s % N;\nint d = fireBall[i][j][k].d;\nint nx = i + dx[d] * s;\nint ny = j + dy[d] * s;\nif (nx < 1) nx += N;\nif (nx > N) nx -= N;\nif (ny < 1) ny += N;\nif (ny > N) ny -= N;\ntmpBall[nx][ny].push_back(fireBall[i][j][k]);\n}\n}\n}\nfor (int i = 1; i <= N; i++) {\nfor (int j = 1; j <= N; j++) {\nfireBall[i][j].clear();\nfireBall[i][j] = tmpBall[i][j];\n}\n}\n}\nvoid divideBall() {\nvector<Ball> tmpBall[MAX][MAX];\nfor (int i = 1; i <= N; i++) {\nfor (int j = 1; j <= N; j++) {\nif (fireBall[i][j].size() == 1) {\ntmpBall[i][j] = fireBall[i][j];\n}\nelse if (fireBall[i][j].size() >= 2) {\nint totalS = 0;\nint totalM = 0;\nbool even = false;\nbool odd = false;\nfor (int k = 0; k < fireBall[i][j].size(); k++) {\nint dir = fireBall[i][j][k].d;\nif (dir % 2 == 0) even = true;\nelse odd = true;\ntotalS += fireBall[i][j][k].s;\ntotalM += fireBall[i][j][k].m;\n}\nint m = totalM / 5;\nint s = totalS / fireBall[i][j].size();\nint dir = even && odd ? 1 : 0;\nif (m > 0) {\nfor (int d = dir; d < 8; d += 2) {\ntmpBall[i][j].push_back({m, s, d});\n}\n}\n}\nfireBall[i][j].clear();\nfireBall[i][j] = tmpBall[i][j];\n}\n}\n}\nint main(void) {\nios::sync_with_stdio(false);\ncin >> N >> M >> K;\nfor (int i = 0; i < M; i++) {\nint x, y, m, s, d;\ncin >> x >> y >> m >> s >> d;\nfireBall[x][y].push_back({m, s, d});\n}\nfor (int i = 0; i < K; i++) {\nmoveBall();\ndivideBall();\n}\nlong long totalM = 0;\nfor (int i = 1; i <= N; i++) {\nfor (int j = 1; j <= N; j++) {\nfor (int k = 0; k < fireBall[i][j].size(); k++) {\ntotalM += fireBall[i][j][k].m;\n}\n}\n}\ncout << totalM;\nreturn 0;\n}"
    },
    {
        "problem_tier": 11,
        "solution_code": "#include <iostream>\n#include <vector>\n#include <algorithm>\nusing namespace std;\nint main() {\nint n, d, k, c;\ncin >> n >> d >> k >> c;\nvector<int> sushi(n);\nfor (int i = 0; i < n; i++) {\ncin >> sushi[i];\n}\nvector<int> check(d + 1, 0);\nint maxCount = 0;\nint coupon = 1;\nfor (int i = 0; i < k; i++) {\nif (check[sushi[i]] == 0) {\nmaxCount++;\n}\ncheck[sushi[i]]++;\nif (sushi[i] == c) {\ncoupon = 0;\n}\n}\nint count = maxCount;\nfor (int i = k; i < n + k; i++) {\nif (count == k) {\nbreak;\n}\nif (check[sushi[i % n]] == 0) {\ncount++;\n}\ncheck[sushi[i % n]]++;\nif (sushi[i % n] == c) {\ncoupon = 0;\n}\nif (check[sushi[i - k]] == 1) {\ncount--;\n}\ncheck[sushi[i - k]]--;\nmaxCount = max(maxCount, count + coupon);\n}\ncout << maxCount << endl;\nreturn 0;\n}"
    },
    {
        "problem_tier": 11,
        "solution_code": "#include<iostream>\nusing namespace std;\nint main() {\nint N, M, K;\ncin >> N >> M >> K;\nint DP[16][16] = {0};\nDP[1][1] = 1;\nint cnt = 1, point_x = -1, point_y = -1;\nfor (int i = 1; i <= N; i++) {\nfor (int j = 1; j <= M; j++) {\nif (cnt == K) {\npoint_x = j;\npoint_y = i;\n}\ncnt++;\nif (i == 1 && j == 1)\ncontinue;\nDP[i][j] = DP[i - 1][j] + DP[i][j - 1];\n}\n}\nif (K == 0) {\ncout << DP[N][M] << endl;\n} else {\nint sum_1 = DP[point_y][point_x];\nDP[point_y][point_x] = 1;\nfor (int i = point_y; i <= N; i++) {\nfor (int j = point_x; j <= M; j++) {\nif (i == point_y && j == point_x)\ncontinue;\nDP[i][j] = 0;\nif (i > point_y)\nDP[i][j] += DP[i - 1][j];\nif (j > point_x)\nDP[i][j] += DP[i][j - 1];\n}\n}\ncout << sum_1 * DP[N][M] << endl;\n}\nreturn 0;\n}"
    },
    {
        "problem_tier": 12,
        "solution_code": "#include <iostream>\n#include <queue>\nusing namespace std;\nint dx[4] = {-1, 0, 1, 0};\nint dy[4] = {0, 1, 0, -1};\nint main() {\nint n, k;\ncin >> n >> k;\nint nn[n][n];\nint time[n][n];\nqueue<pair<int, int>> q;\nfor (int i = 0; i < n; i++) {\nfor (int j = 0; j < n; j++) {\ncin >> nn[i][j];\nif (nn[i][j] != 0) {\nq.push({i, j});\ntime[i][j] = 0;\n}\nelse {\ntime[i][j] = 20000;\n}\n}\n}\nwhile (!q.empty()) {\nint a = q.front().first;\nint b = q.front().second;\nq.pop();\nfor (int i = 0; i < 4; i++) {\nint x = a + dx[i];\nint y = b + dy[i];\nif (x < n && x >= 0 && y < n && y >= 0) {\nif (time[x][y] >= time[a][b] + 1 && (nn[x][y] > nn[a][b] || nn[x][y] == 0)) {\nq.push({x, y});\ntime[x][y] = time[a][b] + 1;\nnn[x][y] = nn[a][b];\n}\n}\n}\n}\nint s, ansx, ansy;\ncin >> s >> ansx >> ansy;\nif (time[ansx-1][ansy-1] <= s)\ncout << nn[ansx-1][ansy-1];\nelse\ncout << 0;\nreturn 0;\n}"
    },
    {
        "problem_tier": 14,
        "solution_code": "#include<bits/stdc++.h>\nusing namespace std;\nstruct P{\nint r, c;\nint cnt = 1;\nint wall = 0;\n};\nint N, M, K;\nint Map[1001][1001];\nint dx[4] = {-1, 1, 0, 0}, dc[4] = {0, 0, -1, 1};\nint visited[1001][1001][11] = {0, };\nvoid input(){\ncin >> N >> M >> K;\nstring in;\nfor(int i = 0; i < N; i++){\ncin >> in;\nfor(int j = 0; j < M; j++){\nMap[i][j] = in[j] - '0';\n}\n}\n}\nint BFS(){\nint result = -1;\nqueue<P> que;\nP temp;\ntemp.r = 0;\ntemp.c = 0;\nque.push(temp);\nvisited[0][0][0] = 1;\nwhile(!que.empty()){\nP now = que.front();\nque.pop();\nif(now.r == N-1 && now.c == M-1){\nresult = now.cnt;\nbreak;\n}\nfor(int i = 0; i < 4; i++){\nint nr = now.r + dx[i];\nint nc = now.c + dc[i];\nif(nr < 0 || nr >= N || nc < 0 || nc >= M) continue;\nif(visited[nr][nc][now.wall]) continue;\nif(!Map[nr][nc] && !visited[nr][nc][now.wall]){\nvisited[nr][nc][now.wall] = 1;\nque.push({nr, nc, now.cnt+1, now.wall});\n}\nif(Map[nr][nc] && now.wall < K && !visited[nr][nc][now.wall+1]){\nvisited[nr][nc][now.wall+1] = 1;\nque.push({nr, nc, now.cnt+1, now.wall+1});\n}\n}\n}\nreturn result;\n}\nint main(){\nios_base::sync_with_stdio(false);\ncin.tie(NULL);\ncout.tie(NULL);\ninput();\nint result = BFS();\ncout << result;\nreturn 0;\n}"
    },
    {
        "problem_tier": 9,
        "solution_code": "#include <iostream>\n#include <algorithm>\nusing namespace std;\nint main() {\nint N, K;\ncin >> N >> K;\nint A[N];\nfor (int i = 0; i < N; i++)\ncin >> A[i];\nsort(A, A + N);\nif (K > N)\ncout << -1;\nelse\ncout << A[K - 1];\nreturn 0;\n}"
    },
    {
        "problem_tier": 5,
        "solution_code": "#include <iostream>\n#include <algorithm>\n#include <vector>\nusing namespace std;\nint main() {\nvector<int> w(10);\nvector<int> k(10);\nfor (int i = 0; i < 10; i++) {\ncin >> w[i];\n}\nfor (int i = 0; i < 10; i++) {\ncin >> k[i];\n}\nsort(w.begin(), w.end(), greater<int>());\nsort(k.begin(), k.end(), greater<int>());\nint w_sum = w[0] + w[1] + w[2];\nint k_sum = k[0] + k[1] + k[2];\ncout << w_sum << \"\\n\";\ncout << k_sum << \"\\n\";\nreturn 0;\n}"
    },
    {
        "problem_tier": 4,
        "solution_code": "#include<iostream>\n#include<cmath>\nusing namespace std;\nint main(){\nint n, w, h;\ncin >> n >> w >> h;\nwhile(n--){\nint s;\ncin >> s;\nif(s <= w || s <= h || s <= sqrt(w*w + h*h)){\ncout << \"DA\" << '\\n';\n}\nelse{\ncout << \"NE\" << '\\n';\n}\n}\nreturn 0;\n}"
    },
    {
        "problem_tier": 12,
        "solution_code": "#include<iostream>\n#include<algorithm>\nusing namespace std;\nint arr[100001];\nint dp[100001][2];\nint main() {\nios_base::sync_with_stdio(false);\ncin.tie(NULL);\ncout.tie(NULL);\nint N;\ncin >> N;\nfor (int i = 0; i < N; i++) {\ncin >> arr[i];\n}\ndp[0][0] = arr[0];\ndp[0][1] = arr[0];\nint MAX = arr[0];\nfor (int i = 1; i < N; i++) {\ndp[i][0] = max(dp[i-1][0] + arr[i], arr[i]);\ndp[i][1] = max(dp[i-1][0], dp[i-1][1] + arr[i]);\nMAX = max(MAX, max(dp[i][0], dp[i][1]));\n}\ncout << MAX << endl;\nreturn 0;\n}"
    },
    {
        "problem_tier": 7,
        "solution_code": "#include<iostream>\n#include<algorithm>\nusing namespace std;\nlong long dp[81] = {0};\nlong long getFibo(int x){\nif(x == 1 || x == 2) return 1;\nlong long& ret = dp[x];\nif(ret != -1) return ret;\nreturn ret = getFibo(x-1) + getFibo(x-2);\n}\nint main(){\nint n;\ncin >> n;\nmemset(dp, -1, sizeof(dp));\ndp[1] = 4;\ndp[2] = 6;\nfor(int i = 3; i <= n; i++){\nif(dp[i] == -1) dp[i] = getFibo(i);\ndp[i] = dp[i-1] + dp[i-2];\n}\ncout << dp[n] << endl;\nreturn 0;\n}"
    },
    {
        "problem_tier": 15,
        "solution_code": "#include <iostream>\n#include <algorithm>\nusing namespace std;\ntypedef struct {\nint y, x;\nint dir;\nbool alive;\n}fish;\nint result = 0;\nint y_ar[9] = {0, -1, -1, 0, 1, 1, 1, 0, -1};\nint x_ar[9] = {0, 0, -1, -1, -1, 0, 1, 1, 1};\nbool ended = false;\nvoid dfs(fish a[17], fish b, int c[4][4],int cnt) {\nresult = max(result, cnt);\nfish fishes[17];\nfish shark;\nint arr[4][4];\nfor (int i = 1; i <= 16; i++)\nfishes[i] = a[i];\nshark = b;\nfor (int i = 0; i < 4; i++)\nfor (int j = 0; j < 4; j++)\narr[i][j] = c[i][j];\nfor (int i = 1; i <= 16; i++) {\nif (fishes[i].alive== false)\ncontinue;\nint y = fishes[i].y;\nint x = fishes[i].x;\nint dir = fishes[i].dir;\nint ny = y + y_ar[dir];\nint nx = x + x_ar[dir];\nbool jud = false;\nif (ny >= 0 && ny < 4 && nx >= 0 && nx < 4) {\nif (arr[ny][nx] == 0) {\njud = true;\nfishes[i].y = ny;\nfishes[i].x = nx;\narr[ny][nx] = i;\narr[y][x] = 0;\n}\nelse if (arr[ny][nx] != -1) {\t\t\t\tjud = true;\nfish temp = fishes[i];\nfishes[i].y = fishes[arr[ny][nx]].y;\nfishes[i].x = fishes[arr[ny][nx]].x;\nfishes[arr[ny][nx]].y = temp.y;\nfishes[arr[ny][nx]].x = temp.x;\nint temp2;\ntemp2 = arr[y][x];\narr[y][x] = arr[ny][nx];\narr[ny][nx] = temp2;\n}\n}\nif (jud == true) continue;\nelse {\nint ndir = dir + 1;\nif (ndir == 9) ndir = 1;\nint ny = y + y_ar[ndir];\nint nx = x + x_ar[ndir];\nwhile (ndir != dir) {\nif (ny >= 0 && ny < 4 && nx >= 0 && nx < 4) {\nif (arr[ny][nx] == 0) {\nfishes[i].y = ny;\nfishes[i].x = nx;\nfishes[i].dir = ndir;\narr[ny][nx] = i;\narr[y][x] = 0;\nbreak;\n}\nelse if (arr[ny][nx] != -1) {\nfish temp = fishes[i];\nfishes[i].y = fishes[arr[ny][nx]].y;\nfishes[i].x = fishes[arr[ny][nx]].x;\nfishes[arr[ny][nx]].y = temp.y;\nfishes[arr[ny][nx]].x = temp.x;\nint temp2;\ntemp2 = arr[y][x];\narr[y][x] = arr[ny][nx];\narr[ny][nx] = temp2;\nfishes[i].dir = ndir;\nbreak;\n}\n}\nndir++;\nif (ndir == 9) ndir = 1;\nny = y + y_ar[ndir];\nnx = x + x_ar[ndir];\n}\n}\n}\nint nx = shark.x;\nint ny = shark.y;\nwhile (1) {\nny += y_ar[shark.dir];\nnx += x_ar[shark.dir];\nif (ny >= 0 && ny < 4 && nx >= 0 && nx < 4) {\nif (arr[ny][nx] == 0) continue;\nint fishnum = arr[ny][nx];\nint ndir = fishes[fishnum].dir;\narr[shark.y][shark.x] = 0;\narr[ny][nx] = -1;\nshark = fishes[fishnum];\nfishes[fishnum].alive = false;\ndfs(fishes, shark, arr, cnt + fishnum);\nfishes[fishnum].alive = true;\narr[ny][nx] = fishnum;\nshark = b;\narr[shark.y][shark.x] = -1;\n}\nelse\nbreak;\n}\n}\nint main() {\nint a, b;\nfish fishes[17];\nfish shark;\nint arr[4][4];\nint fishnum;\nfor(int i=0;i<4;i++)\nfor (int j = 0; j < 4; j++) {\ncin >> a >> b;\nif (i == 0 && j == 0) {\nshark = { i,j,b,1 };\nfishes[a] = { 0,0,0,0 };\narr[0][0] = -1;\nfishnum = a;\ncontinue;\n}\nelse{\nfishes[a] = { i,j,b,1 };\narr[i][j] = a;\n}\n}\ndfs(fishes, shark, arr, fishnum);\ncout << result << endl;\n}"
    },
    {
        "problem_tier": 5,
        "solution_code": "#include<iostream>\n#include<algorithm>\nusing namespace std;\nint A, B, C, a, b, ret;\nint cnt[104];\nint main(){\ncin >> A >> B >> C;\nfor(int i = 0; i < 3; i++){\ncin >> a >> b;\nfor(int j = a; j < b; j++)             cnt[j]++;\n}\nfor(int i = 1; i < 100; i++){\nif(cnt[i]){\nif(cnt[i] == 1)\nret += A;\nelse if(cnt[i] == 2)\nret += B * 2;\nelse if(cnt[i] == 3)\nret += C * 3;\n}\n}\ncout << ret;\nreturn 0;\n}"
    },
    {
        "problem_tier": 10,
        "solution_code": "#include<iostream>\n#include<vector>\n#include<algorithm>\n#include<queue>\n#define fastio ios::sync_with_stdio(0),cin.tie(0),cout.tie(0)\nusing namespace std;\nvector<vector<int>> graph;\nvector<int> visited;\nint N, M, R, Seq;\nqueue<int> que;\nvoid input();\nvoid bfs(int n);\nvoid sol();\nint main() {\nfastio;\ninput();\nsol();\nreturn 0;\n}"
    },
    {
        "problem_tier": 15,
        "solution_code": "#include <iostream>\n#include <algorithm>\n#include <vector>\nusing namespace std;\nint N;\nint arr[4001][4];\nvector<int> A, B;\nlong long answer = 0;\nint main(){\nios_base::sync_with_stdio(false);\ncin.tie(NULL);\ncin >> N;\nfor(int i=0;i<N;i++)\nfor(int j=0;j<4;j++)\ncin >> arr[i][j];\nfor(int i=0;i<N;i++){\nfor(int j=0;j<N;j++){\nA.push_back(arr[i][0]+arr[j][1]);\nB.push_back(arr[i][2]+arr[j][3]);\n}\n}\nsort(A.begin(),A.end());\nsort(B.begin(),B.end());\nfor(int i=0;i<A.size();i++){\nint B_pre = lower_bound(B.begin(),B.end(),-A[i])-B.begin();\nint B_end = upper_bound(B.begin(),B.end(),-A[i])-B.begin();\nanswer += (B_end - B_pre);\n}\ncout << answer << endl;\nreturn 0;\n}"
    },
    {
        "problem_tier": 2,
        "solution_code": "#include <iostream>\nusing namespace std;\nint main() {\ncout << \":8DDDDDDDDDDDDDD$.\" << endl;\ncout << \"DDDNNN8~~~~~~~~~~=~7DNNDNDDDNNI\" << endl;\ncout << \"?NNDD=~=~~~~~~~~~~~~~~~~~=~~==~=INNDNN7\" << endl;\ncout << \"+NDDI~~~~~~~~~~~~~~~~~~~~~~~=~~========~ODND+\" << endl;\ncout << \":NND~~~~~~~~~~~~~~~~~~~~~~~~~~~=~~============7NDN\" << endl;\ncout << \"$DD$~~~~~~~~~~~~~~~~~~~~~~~~~~~~~=~~==============~DNN\" << endl;\ncout << \"$DD=~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~=~~=================NND\" << endl;\ncout << \"ND7~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~=~~===================DD7\" << endl;\ncout << \"~DD=~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~=======================8DN.\" << endl;\ncout << \"8DO~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~=========================DD\" << endl;\ncout << \"8N~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~=~~=======================DN\" << endl;\ncout << \"NN::::::::~~~~~~~~~~~=~~~~~~~~~~~~~~~~~~~=~~========================DDO\" << endl;\ncout << \"$D$:::::::::::::::~~~~DD~~~~~~~~~~~~~~~~~~=~~=========================DN.\" << endl;\ncout << \"D8:::::::::::::::::::DN=::~~~~~~~~~~~~~~~~=~~======================~~:~DN\" << endl;\ncout << \"DN:::::::::::::::::::ONO::::::::::::::::::::~~~~~~~~~~~~:::::::::::::::::DN\" << endl;\ncout << \"DN::::::::::::::::::::NN.:::::::::::::::::::::::::::DN::::::::::::::::::::$DO\" << endl;\ncout << \"DD:::::::::::::::::::DNI:::::::::::::::::::::::::::::D=::::::::::::::::::::NN\" << endl;\ncout << \"NN~~~~:::::$N?:::::::.NN::::::::::::::::::::::::::::::ND.:::::::::::::::::::+N8\" << endl;\ncout << \"N7~~~~~~~~OD7::::::::~DD::::::::::::::::::::::::::::::~D$::::::::::::::::::::DN\" << endl;\ncout << \"NN~~~~~~~~IDZ~~~~~::::DN~:::::::::::::::::::::::::::::::DN::::::::::::::::::::=N~\" << endl;\ncout << \"DD~~~~~~~~NN~~~~~~~~~=NN::::::::::::::::::::::::::::::::DN:::::::::::::::~~====NN\" << endl;\ncout << \"8D~~~~~~~~ND~~~~~~~~~~~ND~~~~~~~~:::::::::::::::::::::::::N7:::~~===============NN\" << endl;\ncout << \"DD~~~~~~~ON+~~~~~~~~~~"
    },
    {
        "problem_tier": 4,
        "solution_code": "#include <iostream>\n#include <algorithm>\n#include <string>\nusing namespace std;\nint arr[3];\nstring str;\nint main() {\ncin >> arr[0] >> arr[1] >> arr[2];\nsort(arr, arr + 3);\ncin >> str;\nfor (int i = 0; i < 3; i++) {\ncout << arr[str[i] - 'A'] << ' ';     }\nreturn 0;\n}"
    },
    {
        "problem_tier": 11,
        "solution_code": "#include <iostream>\n#include <cmath>\n#include <string>\nusing namespace std;\nvoid hanoi(int n, int start, int end, int temp) {\nif (n == 1) {\ncout << start << \" \" << end << \"\\n\";\nreturn;\n}\nelse {\nhanoi(n - 1, start, temp, end);\ncout << start << \" \" << end << \"\\n\";\nhanoi(n - 1, temp, end, start);\n}\n}\nint main() {\nint n;\ncin >> n;\nstring s = to_string(pow(2, n));\nint finddot = s.find('.');\ns = s.substr(0, finddot);\ns[s.length() - 1] -= 1;\ncout << s << '\\n';\nif (n <= 20) {\nhanoi(n, 1, 3, 2);\n}\nreturn 0;\n}"
    },
    {
        "problem_tier": 10,
        "solution_code": "#include <iostream>\n#include <vector>\n#include <algorithm>\nusing namespace std;\nint main() {\nint T, N;\ncin >> T;\nwhile (T--) {\ncin >> N;\nvector<int> v;\nfor (int i = 0; i < N; i++) {\nint x;\ncin >> x;\nv.push_back(x);\n}\nlong long result = 0;\nint max_value = -1;\nfor (int i = N-1; i >= 0; i--) {\nmax_value = max(max_value, v[i]);\nresult += max_value - v[i];\n}\ncout << result << \"\\n\";\n}\nreturn 0;\n}"
    },
    {
        "problem_tier": 10,
        "solution_code": "#include <iostream>\n#include <vector>\n#include <algorithm>\nusing namespace std;\nint map[5][5];\nint dy[] = { 0, 0, -1, 1 };\nint dx[] = { -1, 1, 0, 0 };\nvector<int> v;\nvoid DFS(int y, int x, int num, int cnt) {\nif (cnt == 6) {\nv.push_back(num);\nreturn;\n}\nfor (int i = 0; i < 4; i++) {\nint ny = y + dy[i];\nint nx = x + dx[i];\nif (ny < 0 || nx < 0 || ny >= 5 || nx >= 5)\ncontinue;\nDFS(ny, nx, num * 10 + map[ny][nx], cnt + 1);\n}\n}\nint main() {\nfor (int i = 0; i < 5; i++) {\nfor (int j = 0; j < 5; j++) {\ncin >> map[i][j];\n}\n}\nfor (int i = 0; i < 5; i++) {\nfor (int j = 0; j < 5; j++) {\nDFS(i, j, 0, 0);\n}\n}\nsort(v.begin(), v.end());\nv.erase(unique(v.begin(), v.end()), v.end());\ncout << v.size();\nreturn 0;\n}"
    },
    {
        "problem_tier": 10,
        "solution_code": "#include<iostream>\n#include<vector>\nusing namespace std;\nint main() {\nint N, L;\ncin >> N >> L;\nint start = -1;\nint end = -1;\nfor (int i = L; i <= 100; i++) {\nif (i % 2 == 1) {             if (N % i == 0) {\nstart = N / i - i / 2;\nend = N / i + i / 2;\nbreak;\n}\n}\nelse {             if (N % i == i / 2) {\nstart = N / i - i / 2 + 1;\nend = N / i + i / 2;\nbreak;\n}\n}\n}\nif (start < 0) {\ncout << -1 << endl;\n}\nelse {\nfor (int i = start; i <= end; i++) {\ncout << i << \" \";\n}\ncout << endl;\n}\nreturn 0;\n}"
    },
    {
        "problem_tier": 6,
        "solution_code": "#include <iostream>\n#include <vector>\nusing namespace std;\nint main() {\nint n, m;\ncin >> n >> m;\nvector<vector<char>> grid(n, vector<char>(m));\nfor (int i = 0; i < n; i++) {\nfor (int j = 0; j < m; j++) {\ncin >> grid[i][j];\n}\n}\nint row_count = 0, col_count = 0;\nfor (int i = 0; i < n; i++) {\nbool flag = true;\nfor (int j = 0; j < m; j++) {\nif (grid[i][j] == 'X') {\nflag = false;\nbreak;\n}\n}\nif (flag) {\nrow_count++;\n}\n}\nfor (int j = 0; j < m; j++) {\nbool flag = true;\nfor (int i = 0; i < n; i++) {\nif (grid[i][j] == 'X') {\nflag = false;\nbreak;\n}\n}\nif (flag) {\ncol_count++;\n}\n}\ncout << max(row_count, col_count) << endl;\nreturn 0;\n}"
    },
    {
        "problem_tier": 3,
        "solution_code": "#include <iostream>\n#include <algorithm>\nusing namespace std;\nint main() {\nint s, k, h;\ncin >> s >> k >> h;\nint sum = s + k + h;\nif (sum >= 100) {\ncout << \"OK\" << endl;\n} else {\nint min_val = min(min(s, k), h);\nif (min_val == s) {\ncout << \"Soongsil\" << endl;\n} else if (min_val == k) {\ncout << \"Korea\" << endl;\n} else {\ncout << \"Hanyang\" << endl;\n}\n}\nreturn 0;\n}"
    },
    {
        "problem_tier": 3,
        "solution_code": "#include <iostream>\n#include <algorithm>\n#include <string>\nusing namespace std;\nstring name;\nint age, weight;\nint main(){\nios::sync_with_stdio(0);\ncin.tie(0);\ncout.tie(0);\nwhile(true){\ncin >> name >> age >> weight;\nif(name == \"#\" && age == 0 && weight == 0)\nbreak;\nif(age > 17 || weight >= 80)\ncout << name << \" Senior\" << '\\n';\nelse\ncout << name << \" Junior\" << '\\n';\n}\nreturn 0;\n}"
    },
    {
        "problem_tier": 14,
        "solution_code": "#include <iostream>\n#include <cmath>\n#include <algorithm>\n#include <cstring>\n#define MAX 31\nusing namespace std;\nint N, M;\nint bead[MAX];\nint target[MAX];\nbool dp[MAX][15001];\nvoid solve(int i, int w) {\nif (i > N || dp[i][w]) return;\ndp[i][w] = true;\nsolve(i + 1, w + bead[i]);\nsolve(i + 1, abs(w - bead[i]));\nsolve(i + 1, w);\n}\nint main() {\nios_base::sync_with_stdio(false);\ncin.tie(NULL);\ncout.tie(NULL);\ncin >> N;\nfor (int i = 0; i < N; i++) {\ncin >> bead[i];\n}\nsolve(0, 0);\ncin >> M;\nfor (int i = 0; i < M; i++) {\ncin >> target[i];\n}\nfor (int i = 0; i < M; i++) {\nif (target[i] > 15000) cout << \"N\";\nelse if (dp[N][target[i]]) cout << \"Y\";\nelse cout << \"N\";\nif (i != M - 1) cout << \" \";\n}\ncout << endl;\nreturn 0;\n}"
    },
    {
        "problem_tier": 8,
        "solution_code": "#include <iostream>\n#include <vector>\nusing namespace std;\nint getMaxIncrease(vector<int>& v) {\nint len = 1;\nint maxLen = 1;\nfor (int i = 1; i < v.size(); i++) {\nif (v[i - 1] <= v[i]) {\nlen++;\n} else {\nlen = 1;\n}\nmaxLen = max(len, maxLen);\n}\nreturn maxLen;\n}\nint getMaxDecrease(vector<int>& v) {\nint len = 1;\nint maxLen = 1;\nfor (int i = 1; i < v.size(); i++) {\nif (v[i - 1] >= v[i]) {\nlen++;\n} else {\nlen = 1;\n}\nmaxLen = max(len, maxLen);\n}\nreturn maxLen;\n}\nvoid solve() {\nint n;\ncin >> n;\nvector<int> arr(n);\nfor (int i = 0; i < n; i++) {\ncin >> arr[i];\n}\nint inc = getMaxIncrease(arr);\nint dec = getMaxDecrease(arr);\nint answer = max(inc, dec);\ncout << answer << endl;\n}\nint main() {\nios::sync_with_stdio(false);\ncin.tie(NULL);\ncout.tie(NULL);\nsolve();\nreturn 0;\n}"
    },
    {
        "problem_tier": 15,
        "solution_code": "#include <iostream>\n#include <vector>\nusing namespace std;\nvector<int> p;\nint find(int a){\nif(a == p[a]) return a;\nreturn p[a] = find(p[a]);\n}\nvoid uni(int a, int b){\na = find(a);\nb = find(b);\nif(a > b){\nswap(a, b);\n}\np[b] = a;\n}\nint main(){\nint n, m, ans = 0;\ncin >> n >> m;\np.resize(n+1);\nfor(int i=0; i<=n; i++){\np[i] = i;\n}\nwhile(m--){\nint a;\ncin >> a;\na = find(a);\nif(a == 0) break;\nuni(a, a-1);\nans++;\n}\ncout << ans;\nreturn 0;\n}"
    },
    {
        "problem_tier": 11,
        "solution_code": "#include <iostream>\n#include <queue>\nusing namespace std;\nint n, w, L, ans, a[1000];\nqueue<int> q;\nvoid input() {\ncin >> n >> w >> L;\nfor (int i = 0; i < n; i++) {\ncin >> a[i];\n}\n}\nvoid solution() {\nint weightSum = 0;     for (int i = 0; i < n; i++) {\nwhile (true) {\nif (q.size() == w) {\nweightSum -= q.front();                 q.pop();\n}\nif (a[i] + weightSum <= L) {\nbreak;\n}\nq.push(0);             ans++;\n}\nq.push(a[i]);\nweightSum += a[i];\nans++;\n}\n}\nint main() {\ninput();\nsolution();\ncout << ans + w;     return 0;\n}"
    },
    {
        "problem_tier": 13,
        "solution_code": "#include <iostream>\n#include <string>\nusing namespace std;\nint N;\nbool isBad(string str) {\nint len = str.length();\nint half = len / 2;\nfor (int i = 1; i <= half; i++) {\nstring first = str.substr(len - (i * 2), i);\nstring second = str.substr(len - i, i);\nif (first == second) {\nreturn true;\n}\n}\nreturn false;\n}\nvoid DFS(int index, string str) {\nif (isBad(str)) {\nreturn;\n}\nif (index == N) {\ncout << str << \"\\n\";\nexit(0);\n}\nDFS(index + 1, str + '1');\nDFS(index + 1, str + '2');\nDFS(index + 1, str + '3');\n}\nint main() {\nios_base::sync_with_stdio(0);\ncin.tie(0);\ncin >> N;\nDFS(0, \"\");\nreturn 0;\n}"
    },
    {
        "problem_tier": 11,
        "solution_code": "#include <iostream>\nusing namespace std;\nint DP[45];\nvoid fillDP() {\nDP[0] = 1;\nDP[1] = 1;\nfor (int i = 2; i <= 44; i++) {\nDP[i] = DP[i-1] + DP[i-2];\n}\n}\nint main() {\nios::sync_with_stdio(false);\ncin.tie(0);\ncout.tie(0);\nint N, M;\ncin >> N >> M;\nint vip[M];\nfor (int i = 0; i < M; i++) {\ncin >> vip[i];\n}\nfillDP();\nint answer = 1;\nint start = 0;\nfor (int i = 0; i < M; i++) {\nint end = vip[i];\nanswer *= DP[end - start - 1];\nstart = end;\n}\nanswer *= DP[N - start];\ncout << answer << endl;\nreturn 0;\n}"
    },
    {
        "problem_tier": 17,
        "solution_code": "#include <iostream>\n#include <vector>\nusing namespace std;\nvector<long long> arr;\nvector<long long> tmp;\nlong long merge(int left, int mid, int right) {\nint i = left, j = mid + 1, k = left, l;\nlong long inversion_cnt = 0;\nwhile (i <= mid && j <= right) {\nif (arr[i] <= arr[j]) {\ntmp[k++] = arr[i++];\n} else {\ninversion_cnt += (long long)(mid - i + 1);\ntmp[k++] = arr[j++];\n}\n}\nif (i > mid) {\nfor (l = j; l <= right; l++, k++) {\ntmp[k] = arr[l];\n}\n} else {\nfor (l = i; l <= mid; l++, k++) {\ntmp[k] = arr[l];\n}\n}\nfor (l = left; l <= right; l++) {\narr[l] = tmp[l];\n}\nreturn inversion_cnt;\n}\nlong long mergeSort(int left, int right) {\nlong long inversion_cnt = 0;\nif (left < right) {\nint mid = (left + right) / 2;\ninversion_cnt += mergeSort(left, mid);\ninversion_cnt += mergeSort(mid + 1, right);\ninversion_cnt += merge(left, mid, right);\n}\nreturn inversion_cnt;\n}\nint main() {\nios_base::sync_with_stdio(0);\ncin.tie(0);\nint N;\ncin >> N;\narr.resize(N);\ntmp.resize(N);\nfor (int i = 0; i < N; i++) {\ncin >> arr[i];\n}\ncout << mergeSort(0, N - 1);\nreturn 0;\n}"
    },
    {
        "problem_tier": 3,
        "solution_code": "#include <iostream>\n#include <string>\nusing namespace std;\nint main() {\nint N;\nstring input;\ncin >> N;\ncin.ignore();\nfor (int i = 0; i < N; i++) {\ngetline(cin, input);\ncin.clear();\ncout << i + 1 << \".\" << input << endl;\n}\nreturn 0;\n}"
    },
    {
        "problem_tier": 12,
        "solution_code": "#include <iostream>\n#include <vector>\n#include <algorithm>\nusing namespace std;\nint main() {\nint N, H;\nvector<int> stalagmite, stalactite;\ncin >> N >> H;\nfor (int i = 0; i < N; i++) {\nint height;\ncin >> height;\nif (i % 2 == 0) {\nstalagmite.push_back(height);\n} else {\nstalactite.push_back(H - height);\n}\n}\nsort(stalagmite.begin(), stalagmite.end());\nsort(stalactite.begin(), stalactite.end());\nint min_break = N, count = 0;\nfor (int i = 1; i <= H; i++) {\nint break_count = stalagmite.size() - (lower_bound(stalagmite.begin(), stalagmite.end(), i) - stalagmite.begin());\nbreak_count += stalactite.size() - (upper_bound(stalactite.begin(), stalactite.end(), i) - stalactite.begin());\nif (break_count < min_break) {\nmin_break = break_count;\ncount = 1;\n} else if (break_count == min_break) {\ncount++;\n}\n}\ncout << min_break << \" \" << count << endl;\nreturn 0;\n}"
    },
    {
        "problem_tier": 3,
        "solution_code": "#include <iostream>\nusing namespace std;\nint main() {\nios::sync_with_stdio(false);\ncin.tie(nullptr);\nfor (int i = 0; i < 3; ++i) {\nint startH, startM, startS, endH, endM, endS, h, m, s;\ncin >> startH >> startM >> startS >> endH >> endM >> endS;\nif (endS < startS) {\ns = endS + 60 - startS;\nendM--;\n} else {\ns = endS - startS;\n}\nif (endM < startM) {\nm = endM + 60 - startM;\nendH--;\n} else {\nm = endM - startM;\n}\nh = endH - startH;\ncout << h << ' ' << m << ' ' << s << '\\n';\n}\nreturn 0;\n}"
    },
    {
        "problem_tier": 13,
        "solution_code": "#include <iostream>\n#include <queue>\n#include <cstring>\nusing namespace std;\nint n;\nint map[52][52]; int visit[52][52]; int dx[] = {0, 0, -1, 1}; int dy[] = {1, -1, 0, 0};\nvoid bfs(){\nqueue<pair<int, int>> q;\nq.push(make_pair(0, 0));\nvisit[0][0] = 0;     while(!q.empty()){\nint x = q.front().first;\nint y = q.front().second;\nq.pop();\nfor (int i = 0; i < 4; i++){\nint nx = x + dx[i];             int ny = y + dy[i];             if(nx >=0 && nx < n && ny>=0 && ny < n){\nif(map[ny][nx] == 1){                     if(visit[ny][nx] > visit[y][x]){\nvisit[ny][nx] = visit[y][x];\nq.push(make_pair(nx, ny));                     }\n}else{                     if(visit[ny][nx] > visit[y][x]+1){\nvisit[ny][nx] = visit[y][x]+1;\nq.push(make_pair(nx, ny));                     }\n}\n}\n}\n}\n}\nint main(){\nios::sync_with_stdio(false);\ncin >> n;\nchar a;\nfor (int i = 0; i < n; i++){\nfor (int j = 0; j < n; j++){\ncin >> a;\nmap[i][j] = a - '0';         }\n}\nfor (int i = 0; i < n; i++){\nfor (int j = 0; j < n; j++){\nvisit[i][j] = 987654321;         }\n}\nbfs();\ncout << visit[n - 1][n - 1] << endl;\nreturn 0;\n}"
    },
    {
        "problem_tier": 4,
        "solution_code": "#include <iostream>\n#include <string>\nusing namespace std;\nint main() {\nint n;\nstring k;\ncin >> n;\nfor (int i = 0; i < n; i++) {\ncin >> k;\nint num = (k[k.size() - 1]) - '0';\nif (num % 2 == 0) {\ncout << \"even\";\n} else {\ncout << \"odd\";\n}\ncout << endl;\n}\nreturn 0;\n}"
    },
    {
        "problem_tier": 15,
        "solution_code": "#include<iostream>\n#include<algorithm>\nusing namespace std;\nint ans, cnt;\nint paper[11][11];\nint paper_cnt[6];\nbool pa_ch(int x, int y, int sizee) {\nfor (int Y = y; Y < y + sizee; Y++) {\nfor (int X = x; X <x + sizee; X++) {\nif (paper[Y][X] == 0)\nreturn false;\n}\n}\nreturn true;\n}\nvoid dfs(int ans_temp, int x, int y, int cnt_temp) {\nif (ans_temp > ans) return;\nif (cnt_temp == cnt) {\nans = ans_temp;\nreturn;\n}\nif (ans_temp == 25) return;\nbool out = false;\nfor (int Y = y; Y < 10; Y++) {\nfor (int X = x; X < 10; X++) {\nif (paper[Y][X] == 1) {\nout = true;\nfor (int i = 5; i >= 1; i--) {                     if (paper_cnt[i] == 0) continue;\nif (paper_cnt[i] == 0 && i == 1) return;\nif (!pa_ch(X, Y, i)) continue;\npaper_cnt[i]--;\nint gob = i*i;\nfor (int YY = Y; YY < Y + i; YY++) {\nfor (int XX = X; XX < X + i; XX++) {\npaper[YY][XX] = 0;\n}                     }\ndfs(ans_temp + 1, X, Y, cnt_temp + gob);\npaper_cnt[i]++;\nfor (int YY = Y; YY < Y + i; YY++) {\nfor (int XX = X; XX <X + i; XX++) {\npaper[YY][XX] = 1;\n}                    }\n}              }             if (out == true) break;\n}         if (out == true) break;\nx = 0;\n} }\nint main() {\nios_base::sync_with_stdio(false);\ncin.tie(0); cout.tie(0);\ncnt = 0;\nfor (int i = 1; i < 6; i++) paper_cnt[i] = 5;\nfor (int Y = 0; Y < 10; Y++) {\nfor (int X = 0; X < 10; X++) {\nscanf(\"%d\", &paper[Y][X]);\nif (paper[Y][X] == 1) cnt++;\n}\n}\nans = 40;\ndfs(0, 0, 0, 0);\nif (ans == 40)\nprintf(\"-1\");\nelse\nprintf(\"%d\",ans);\n}\n"
    },
    {
        "problem_tier": 4,
        "solution_code": "#include <iostream>\n#include <iomanip>\nusing namespace std;\nint main() {\nint t;\ncin >> t;\nwhile (t--) {\nint n;\nint tot_c = 0;\ndouble tot_g = 0.0;\ncin >> n;\nwhile (n--) {\nint c;\ndouble g;\ncin >> c >> g;\ntot_c += c;\ntot_g += g * c;\n}\ncout << tot_c << \" \" << fixed << setprecision(1) << tot_g / tot_c << '\\n';\n}\nreturn 0;\n}"
    },
    {
        "problem_tier": 5,
        "solution_code": "#include <iostream>\nusing namespace std;\nint main() {\nlong long a, b;\ncin >> a >> b;\nif (a < b) {\ncout << b - a - 1 << '\\n';\nfor (long long i = a + 1; i < b; i++)\ncout << i << ' ';\n}\nelse if (a > b) {\ncout << a - b - 1 << '\\n';\nfor (long long i = b + 1; i < a; i++)\ncout << i << ' ';\n}\nelse\ncout << \"0\" << '\\n';\nreturn 0;\n}"
    },
    {
        "problem_tier": 9,
        "solution_code": "#include<iostream>\nusing namespace std;\nint main() {\nint n, x, y, dir, findNum, cnt=1, piv=1;\nint a[1001][1001];\ncin>>n>>findNum;\nx = n/2;\ny = n/2;\na[x][y] = 1;\nwhile(cnt < n*n) {\nif(dir == 0) {\nfor(int k=0; k<piv; k++) {\na[--x][y] = ++cnt;\nif(cnt == n*n) break;\n}\n}\nelse if(dir == 1) {\nfor(int k=0; k<piv; k++)\na[x][++y] = ++cnt;\npiv++;\n}\nelse if(dir == 2) {\nfor(int k=0; k<piv; k++)\na[++x][y] = ++cnt;\n}\nelse if(dir == 3) {\nfor(int k=0; k<piv; k++)\na[x][--y] = ++cnt;\npiv++;\n}\ndir = (dir+1) % 4;\n}\nfor(int i=0; i<n; i++) {\nfor(int j=0; j<n; j++)\ncout<<a[i][j]<<' ';\ncout<<'\\n';\n}\nfor(int i=0; i<n; i++) {\nfor(int j=0; j<n; j++) {\nif(a[i][j] == findNum) {\ncout<<i+1<<' '<<j+1<<'\\n';\nbreak;\n}\n}\n}\nreturn 0;\n}"
    },
    {
        "problem_tier": 4,
        "solution_code": "#include <iostream>\n#include <string>\nusing namespace std;\nint main() {\nint n;\ncin >> n;\ncin.ignore();\nfor (int i = 0; i < n; i++) {\nstring str;\ngetline(cin, str);\nif ('a' <= str[0] && str[0] <= 'z') {\nstr[0] -= 32;\n}\ncout << str << endl;\n}\nreturn 0;\n}"
    },
    {
        "problem_tier": 2,
        "solution_code": "#include <iostream>\n#include <string>\nusing namespace std;\nint main() {\nstring str;\ncin >> str;\nstring fan = \":fan:\";\ncout << fan << fan << fan << \"\\n\";\ncout << fan << \":\" << str << \":\" << fan << \"\\n\";\ncout << fan << fan << fan << \"\\n\";\nreturn 0;\n}"
    },
    {
        "problem_tier": 3,
        "solution_code": "#include <iostream>\n#include <algorithm>\nusing namespace std;\nint main() {\nint arr1[4];\nint arr2[2];\nfor (int i = 0; i < 4; i++) {\ncin >> arr1[i];\n}\nfor (int i = 0; i < 2; i++) {\ncin >> arr2[i];\n}\nsort(arr1, arr1 + 4);\nsort(arr2, arr2 + 2);\ncout << arr1[3] + arr1[2] + arr1[1] + arr2[1] << endl;\nreturn 0;\n}"
    },
    {
        "problem_tier": 14,
        "solution_code": "#include <iostream>\n#include <vector>\n#include <queue>\n#define MAX 50001\nusing namespace std;\nint N, M;\nvector<int> graph[MAX];\nint parent[MAX];\nint depth[MAX];\nbool visited[MAX];\nint max_depth = 0;\nvoid BFS(int start) {\nqueue<int> q;\nq.push(start);\ndepth[start] = 0;\nvisited[start] = true;\nwhile (!q.empty()) {\nint temp = q.front();\nq.pop();\nfor (int i = 0; i < graph[temp].size(); i++) {\nint next = graph[temp][i];\nif (!visited[next]) {\nvisited[next] = true;\nparent[next] = temp;\ndepth[next] = depth[temp] + 1;\nif (depth[next] > max_depth) {\nmax_depth = depth[next];\n}\nq.push(next);\n}\n}\n}\n}\nint findCommonParent(int a, int b) {\nint a_d = depth[a];\nint b_d = depth[b];\nwhile (true) {\nif (a_d > b_d) {\na_d--;\na = parent[a];\n} else if (a_d < b_d) {\nb_d--;\nb = parent[b];\n} else {\nif (a == b) {\nreturn a;\n}\na_d--;\na = parent[a];\nb_d--;\nb = parent[b];\n}\n}\n}\nint main() {\ncin >> N;\nfor (int i = 1; i < N; i++) {\nint a, b;\ncin >> a >> b;\ngraph[a].push_back(b);\ngraph[b].push_back(a);\n}\nBFS(1);\ncin >> M;\nfor (int i = 0; i < M; i++) {\nint a, b;\ncin >> a >> b;\ncout << findCommonParent(a, b) << endl;\n}\nreturn 0;\n}"
    },
    {
        "problem_tier": 13,
        "solution_code": "#include <bits/stdc++.h>\nusing namespace std;\n#define INF 987654321\nint item[105];\nvector<pair<int,int>> node[105];\npriority_queue<pair<int,int>, vector<pair<int,int>>, greater<pair<int,int>>> pq;\nint value[105];\nint n, m, r;\nint a, b, l;\nint ans;\nint Dij(int k){\nfor(int i=1; i<=n; i++)\nvalue[i] = INF;\nvalue[k] = 0;\npq.push(make_pair(0,k));\nwhile(!pq.empty()){\nint x = pq.top().first;\nint U = pq.top().second;\npq.pop();\nfor(int i=0; i<node[U].size(); i++){\nint V = node[U][i].first;\nint W = node[U][i].second;\nif(x+W < value[V]){\nvalue[V] = x+W;\npq.push(make_pair(x+W,V));\n}\n}\n}\nint sum = 0;\nfor(int i=1; i<=n; i++){\nif(value[i] <= m)\nsum += item[i];\n}\nreturn sum;\n}\nint main(){\nscanf(\"%d%d%d\", &n, &m, &r);\nfor(int i=1; i<=n; i++)\nscanf(\"%d\", &item[i]);\nfor(int i=0; i<r; i++){\nscanf(\"%d%d%d\", &a, &b, &l);\nnode[a].push_back(make_pair(b,l));\nnode[b].push_back(make_pair(a,l));\n}\nfor(int i=1; i<=n; i++)\nans = max(ans, Dij(i));\nprintf(\"%d\", ans);\nreturn 0;\n}"
    },
    {
        "problem_tier": 5,
        "solution_code": "#include <iostream>\n#include <algorithm>\nusing namespace std;\nint main() {\nint n;\nint arr[1001];\ncin >> n;\nfor(int i=0; i<n; i++) {\ncin >> arr[i];\n}\nsort(arr, arr+n);\ncout << arr[n-1] - arr[0];\nreturn 0;\n}"
    },
    {
        "problem_tier": 11,
        "solution_code": "#include<iostream>\n#include<vector>\nusing namespace std;\nvector<vector<int>> rotateArray(vector<vector<int>>& arr, int n, int m, int r) {\nint repeat = min(n, m) / 2;\nvector<vector<int>> result = arr;\nwhile (r--) {\nfor (int size = 0; size < repeat; size++) {\nint cntX = size, cntY = size;\nint temp = result[cntX][cntY];\nwhile (true) {\nint prev = temp;\ncntY++;\nif (cntY >= m - size) {\ncntY--;\nbreak;\n}\ntemp = result[cntX][cntY];\nresult[cntX][cntY] = prev;\n}\nwhile (true) {\nint prev = temp;\ncntX++;\nif (cntX >= n - size) {\ncntX--;\nbreak;\n}\ntemp = result[cntX][cntY];\nresult[cntX][cntY] = prev;\n}\nwhile (true) {\nint prev = temp;\ncntY--;\nif (cntY < size) {\ncntY++;\nbreak;\n}\ntemp = result[cntX][cntY];\nresult[cntX][cntY] = prev;\n}\nwhile (true) {\nint prev = temp;\ncntX--;\nif (cntX < size) {\ncntX++;\nbreak;\n}\ntemp = result[cntX][cntY];\nresult[cntX][cntY] = prev;\n}\n}\n}\nreturn result;\n}\nint main() {\nint N, M, R;\ncin >> N >> M >> R;\nvector<vector<int>> arr(N, vector<int>(M));\nfor (int i = 0; i < N; i++) {\nfor (int j = 0; j < M; j++) {\ncin >> arr[i][j];\n}\n}\nvector<vector<int>> result = rotateArray(arr, N, M, R);\nfor (int i = 0; i < N; i++) {\nfor (int j = 0; j < M; j++) {\ncout << result[i][j] << \" \";\n}\ncout << endl;\n}\nreturn 0;\n}"
    },
    {
        "problem_tier": 4,
        "solution_code": "#include <iostream>\n#include <vector>\n#include <algorithm>\nusing namespace std;\nint main() {\nint t;\ncin >> t;\nvector<pair<int, int>> result(t);\nfor (int i = 0; i < t; i++) {         vector<int> vtr(7);\nint sum = 0;\nfor (int j = 0; j < 7; j++) {\ncin >> vtr[j];\nif (vtr[j] % 2 == 0) {\nsum += vtr[j];\n}\n}\nsort(vtr.begin(), vtr.end());\nint stt = 0;\nfor (int j = 0; ;) {\nif (vtr[j] != 0) {\nstt = j;\nbreak;\n}\n}\nfor (int j = stt; j < vtr.size(); j++) {\nsum += vtr[j];\n}\nresult[i].first = sum;\nresult[i].second = vtr[stt];\n}\nfor (int i = 0; i < t; i++) {\ncout << result[i].first << \" \" << result[i].second << \"\\n\";\n}\nreturn 0;\n}"
    },
    {
        "problem_tier": 9,
        "solution_code": "#include <iostream>\n#include <algorithm>\nusing namespace std;\nint main() {\nint n, m;\ncin >> n >> m;\nif(n == 1) {\ncout << 1 << endl;\n}\nelse if(n == 2) {\nif(m >= 7)\ncout << 4 << endl;\nelse\ncout << (m + 1) / 2 << endl;\n}\nelse {\nif(m <= 6)\ncout << min(4, m) << endl;\nelse\ncout << m - 2 << endl;\n}\nreturn 0;\n}"
    },
    {
        "problem_tier": 4,
        "solution_code": "#include <iostream>\n#include <vector>\nusing namespace std;\nint main(void) {\nios_base::sync_with_stdio(0);\ncin.tie(0);\ncout.tie(0);\nint t, v, e;\ncin >> t;\nvector<int> res;\nfor (int i = 0; i < t; i++) {\ncin >> v >> e;\nres.push_back(2 - v + e);\n}\nfor (auto k : res) {\ncout << k << \"\\n\";\n}\nreturn 0;\n}"
    },
    {
        "problem_tier": 14,
        "solution_code": "#include <iostream>\n#include <vector>\n#include <cstring>\n#include <algorithm>\nusing namespace std;\nvector<int> v[1000001];\nint dp[1000001][2];\nbool visit[1000001];\nvoid solve(int x){\nvisit[x] = true;\ndp[x][1] = 1;\nfor(int i=0; i<v[x].size(); i++){\nint child = v[x][i];\nif(visit[child] == false){\nsolve(child);\ndp[x][0] += dp[child][1];\ndp[x][1] += min(dp[child][1], dp[child][0]);\n}\n}\n}\nint main(void){\ncin.tie(0);\nios_base::sync_with_stdio(0);\nmemset(visit, false, sizeof(visit));\nint N;\ncin>>N;\nfor(int i=0; i<N-1; i++){\nint a, b;\ncin >> a >> b;\nv[a].push_back(b);\nv[b].push_back(a);\n}\nsolve(1);\ncout << min(dp[1][0], dp[1][1]);\n}"
    },
    {
        "problem_tier": 3,
        "solution_code": "#include <iostream>\n#include <string>\n#include <vector>\n#include <algorithm>\nusing namespace std;\nint main() {\nint test, test1;\ncin >> test >> test1;\nstring str;\nvector<string> vec;\nfor(int i = 0; i < test; i++) {\ncin >> str;\nvec.push_back(str);\n}\nfor(int i = 0; i < test; i++) {\nreverse(vec[i].begin(), vec[i].end());\ncout << vec[i] << \"\\n\";\n}\nreturn 0;\n}"
    },
    {
        "problem_tier": 12,
        "solution_code": "#include <iostream>\n#include <vector>\n#include <algorithm>\nusing namespace std;\nint main() {\nios_base::sync_with_stdio(false);\ncin.tie(NULL);\ncout.tie(NULL);\nint n;\ncin >> n;\nvector<pair<int, int>> v(n, {0, 0});\nfor (int i = 0; i < n; i++) {\nint st, ed;\ncin >> st >> ed;\nif (st > ed) {\nint temp = st;\nst = ed;\ned = temp;\n}\nv[i] = {st, ed};\n}\nsort(v.begin(), v.end());\nint st = v[0].first;\nint ed = v[0].second;\nlong long ans = 0;\nfor (int i = 1; i < n; i++) {\nif (ed > v[i].first) {\nif (v[i].second > ed) ed = v[i].second;\n} else {\nans += ed - st;\nst = v[i].first;\ned = v[i].second;\n}\n}\nans += ed - st;\ncout << ans << \"\\n\";\nreturn 0;\n}"
    },
    {
        "problem_tier": 11,
        "solution_code": "#include <bits/stdc++.h>\nusing namespace std;\nint main() {\nios_base::sync_with_stdio(0);\ncin.tie(0);\ncout.tie(0);\nint n, m;\ncin >> n >> m;\npriority_queue<long long, vector<long long>, greater<long long>> cards;\nfor (int i = 0; i < n; i++) {\nlong long input;\ncin >> input;\ncards.push(input);\n}\nfor (int i = 0; i < m; i++) {\nlong long x = cards.top();\ncards.pop();\nlong long y = cards.top();\ncards.pop();\nlong long sum = x + y;\ncards.push(sum);\ncards.push(sum);\n}\nlong long answer = 0;\nwhile (!cards.empty()) {\nanswer += cards.top();\ncards.pop();\n}\ncout << answer << \"\\n\";\nreturn 0;\n}"
    },
    {
        "problem_tier": 4,
        "solution_code": "#include<iostream>\n#include<algorithm>\nusing namespace std;\nint main(int argc, char* argv[]){\nint K[3];\ncin >> K[0];\ncin >> K[1];\ncin >> K[2];\nsort(K,K+3);\ncout << max(K[2]-K[1],K[1]-K[0])-1 << endl;\nreturn 0;\n}"
    },
    {
        "problem_tier": 5,
        "solution_code": "#include <iostream>\n#include <string>\nusing namespace std;\nint main() {\nstring a, b = \"CAMBRIDGE\";\ncin >> a;\nfor(int i = 0; i < a.size(); i++) {\nfor(int j = 0; j < b.size(); j++) {\nif(a[i] == b[j])\na[i] = 0;\n}\n}\nfor(int i = 0; i < a.size(); i++) {\nif(a[i] != 0)\ncout << a[i];\n}\nreturn 0;\n}"
    },
    {
        "problem_tier": 14,
        "solution_code": "#include <iostream>\n#include <stack>\n#include <unordered_map>\n#include <vector>\nusing namespace std;\nint main() {\nint N;\ncin >> N;\nvector<int> datas;\ndatas.reserve(N);\nvector<int> outputs(N);\nunordered_map<int, int> dataMap;\nint count = N;\nwhile (count-- > 0) {\nint data;\ncin >> data;\ndatas.push_back(data);\ndataMap[data]++;\n}\nstack<int> st;\nfor (int i = datas.size() - 1; i >= 0; i--) {\nwhile (!st.empty() && dataMap[st.top()] <= dataMap[datas[i]]) {\nst.pop();\n}\nif (st.empty()) {\noutputs[i] = -1;\n} else {\noutputs[i] = st.top();\n}\nst.push(datas[i]);\n}\nfor (int i = 0; i < outputs.size(); i++) {\ncout << outputs[i] << ' ';\n}\nreturn 0;\n}"
    },
    {
        "problem_tier": 10,
        "solution_code": "#include <iostream>\n#include <vector>\n#include <cmath>\nusing namespace std;\nint N;\nint ans = INT32_MAX; vector<vector<int>> stuff;\nvector<int> solution(int idx, bool contain, vector<int> cnt) {\nif (idx >= N) {\nvector<int> tmp(2);         for (auto it : cnt) {\nif (it == 0) {\ntmp[0] = INT32_MAX;                 tmp[1] = 0;                 return tmp;\n}\n}\nreturn cnt;\n}\nif (contain) {\ncnt[0] = cnt[0] * stuff[idx][0];\ncnt[1] = cnt[1] + stuff[idx][1];\n}\nvector<int> case1 = solution(idx + 1, true, cnt);     vector<int> case2 = solution(idx + 1, false, cnt);\nint val1 = abs(case1[0] - case1[1]);\nint val2 = abs(case2[0] - case2[1]);\nif (val1 < val2) {\nans = min(ans, val1);\ncnt[0] = case1[0];\ncnt[1] = case1[1];\n}\nelse {\nans = min(ans, val2);\ncnt[0] = case2[0];\ncnt[1] = case2[1];\n}\nreturn cnt;\n}\nint main() {\nscanf(\"%d\", &N);\nfor (int i = 0; i < N; i++) {\nvector<int> tmp;\nint sour, bitter;\nscanf(\"%d%d\", &sour, &bitter);\ntmp.push_back(sour);\ntmp.push_back(bitter);\nstuff.push_back(tmp);\n}\nvector<int> tmp = {1, 0};\nvector<int> val1 = solution(0, true, tmp);\nvector<int> val2 = solution(0, false, tmp);\nprintf(\"%d\", ans);\nreturn 0;\n}"
    },
    {
        "problem_tier": 12,
        "solution_code": "#include <iostream>\n#include <string>\n#include <algorithm>\nusing namespace std;\nint dp[4001][4001] = {0};\nint main() {\nstring arr, arr2;\ncin >> arr >> arr2;\nint result = 0;\nfor (int j = 0; j < arr2.size(); j++) {\nif (arr[0] == arr2[j]) {\ndp[0][j] = 1;\nresult = max(result, dp[0][j]);\n}\n}\nfor (int j = 0; j < arr2.size(); j++) {\nif (arr[j] == arr2[0]) {\ndp[j][0] = 1;\nresult = max(result, dp[j][0]);\n}\n}\nfor (int i = 1; i < arr.size(); i++) {\nfor (int j = 1; j < arr2.size(); j++) {\nif (arr[i] == arr2[j]) {\ndp[i][j] = dp[i-1][j-1] + 1;\nresult = max(result, dp[i][j]);\n}\n}\n}\ncout << result << endl;\nreturn 0;\n}"
    },
    {
        "problem_tier": 8,
        "solution_code": "#include<iostream>\n#include<cmath>\nusing namespace std;\nint check[300001]; int p; void dfs(int x);\nint main(){\nint n;\ncin >> n >> p;\ndfs(n);\nint ans = 0;     for(int i=0;i<300001;i++){\nif(check[i]==1)\nans++;\n}\ncout << ans;\nreturn 0;\n}"
    },
    {
        "problem_tier": 1,
        "solution_code": "#include <iostream>\nusing namespace std;\nint main() {\nint n;\ncin >> n;\nfor (int i = 0; i < n; i++) {\nfor (int j = 0; j < n; j++) {\ncout << \"*\";\n}\ncout << endl;\n}\nreturn 0;\n}"
    },
    {
        "problem_tier": 2,
        "solution_code": "#include <iostream>\nusing namespace std;\nint main() {\nint ax, ay, az;\nint cx, cy, cz;\ncin >> ax >> ay >> az;\ncin >> cx >> cy >> cz;\ncout << cx - az << \" \" << cy / ay << \" \" << cz - ax << endl;\nreturn 0;\n}"
    },
    {
        "problem_tier": 5,
        "solution_code": "#include <iostream>\n#include <string>\ntypedef long long ll;\nint main() {\nstd::string a, b;\nstd::cin >> a >> b;\nll ans = 0;\nfor (int i = 0; i < a.size(); i++) {\nfor (int j = 0; j < b.size(); j++) {\nans += (a[i] - '0') * (b[j] - '0');\n}\n}\nstd::cout << ans << '\\n';\nreturn 0;\n}"
    },
    {
        "problem_tier": 2,
        "solution_code": "#include <iostream>\n#include <string>\nusing namespace std;\nint main() {\nstring a;\ncin >> a;\nint ans = 0;\nfor (int i = 0; i < a.size(); i++)\nans = (ans * 10 + (a[i] - '0')) % 20000303;\ncout << ans;\nreturn 0;\n}"
    },
    {
        "problem_tier": 5,
        "solution_code": "#include <iostream>\n#include <string>\nusing namespace std;\nint main() {\nint T;\ncin >> T;\nfor (int i = 0; i < T; i++) {\nint index;\nstring w;\ncin >> index >> w;\nfor (int j = 0; j < w.size(); j++) {\nif (j != index - 1) {\ncout << w[j];\n}\n}\ncout << '\\n';\n}\nreturn 0;\n}"
    },
    {
        "problem_tier": 12,
        "solution_code": "#include<iostream>\n#include<algorithm>\n#include<vector>\nusing namespace std;\nint main(void){\nint N, K;\nvector<int> v, v2;\ncin >> N;\ncin >> K;\nif(K >= N){\ncout << \"0\";\nreturn 0;\n}"
    },
    {
        "problem_tier": 12,
        "solution_code": "#include <iostream>\n#include <vector>\n#include <cmath>\n#include <algorithm>\nusing namespace std;\nint N;\nint arr[21][21];\nint like[401][4];\nint dx[4] = {0, 0, 1, -1};\nint dy[4] = {1, -1, 0, 0};\nbool isInLikeStudent(int cur, int x, int y) {\nfor (int i = 0; i < 4; i++) {\nif (like[cur][i] == arr[x][y])\nreturn true;\n}\nreturn false;\n}\nint calculateSatisfaction(int cnt) {\nif (cnt == 1) return 1;\nif (cnt == 2) return 10;\nif (cnt == 3) return 100;\nif (cnt == 4) return 1000;\nreturn 0;\n}\npair<int, int> findEmptySeat(int cur) {\npair<int, int> res = make_pair(-1, -1);\nint maxLikes = -1, maxEmpties = -1;\nfor (int i = 1; i <= N; i++) {\nfor (int j = 1; j <= N; j++) {\nif (arr[i][j] != 0)\ncontinue;\nint likes = 0, empties = 0;\nfor (int k = 0; k < 4; k++) {\nint nx = i + dx[k];\nint ny = j + dy[k];\nif (nx < 1 || nx > N || ny < 1 || ny > N)\ncontinue;\nif (arr[nx][ny] == 0) {\nempties++;\n} else if (isInLikeStudent(cur, nx, ny)) {\nlikes++;\n}\n}\nif (likes > maxLikes) {\nmaxLikes = likes;\nmaxEmpties = empties;\nres.first = i;\nres.second = j;\n} else if (likes == maxLikes) {\nif (empties > maxEmpties) {\nmaxEmpties = empties;\nres.first = i;\nres.second = j;\n}\n}\n}\n}\nreturn res;\n}\nint calculateTotalSatisfaction() {\nint totalSatisfaction = 0;\nfor (int i = 1; i <= N; i++) {\nfor (int j = 1; j <= N; j++) {\nint cur = arr[i][j];\nint cnt = 0;\nfor (int k = 0; k < 4; k++) {\nint nx = i + dx[k];\nint ny = j + dy[k];\nif (nx < 1 || nx > N || ny < 1 || ny > N)\ncontinue;\nif (isInLikeStudent(cur, nx, ny))\ncnt++;\n}\ntotalSatisfaction += calculateSatisfaction(cnt);\n}\n}\nreturn totalSatisfaction;\n}\nint main() {\nios::sync_with_stdio(0);\ncin.tie(0);\ncin >> N;\nfor (int i = 1; i <= N * N; i++) {\nint cur;\ncin >> cur;\nfor (int j = 0; j < 4; j++) {\ncin >> like[cur][j];\n}\npair<int, int> emptySeat = findEmptySeat(cur);\narr[emptySeat.first][emptySeat.second] = cur;\n}\ncout << calculateTotalSatisfaction() << \"\\n\";\nreturn 0;\n}"
    },
    {
        "problem_tier": 16,
        "solution_code": "#include <iostream>\n#include <vector>\n#include <queue>\n#include <cstring>\n#include <algorithm>\nusing namespace std;\nqueue<pair<int, int>> q; vector<pair<int, int>> v; vector < pair<int, pair<int, int>> > bridge;\nint arr[10][10]; int parent[7]; int land[10][10]; bool visit[10][10]; int side[4][2] = { {-1,0},{1,0},{0,-1},{0,1} };\nint islandCnt = 0; int N, M;\nint find(int a)\n{\nif (parent[a] == a)\nreturn a;\nreturn parent[a] = find(parent[a]);\n}\nvoid Union(int a, int b)\n{\na = find(a);\nb = find(b);\nif (a != b)\n{\nif (a < b)\nparent[b] = a;\nelse\nparent[a] = b;\n}\n}\nbool sameParent(int a, int b)\n{\na = find(a);\nb = find(b);\nif (a != b)\nreturn false;\nreturn true;\n}\nvoid numbering()\n{\nfor (int i = 0; i < v.size(); i++)\n{\nif (visit[v[i].first][v[i].second] == true) \t\t\tcontinue;\nq.push(make_pair(v[i].first, v[i].second));\nvisit[q.front().first][q.front().second]=true;\nland[q.front().first][q.front().second] = ++islandCnt;\nwhile (!q.empty()) \t\t{\nint y = q.front().first;\nint x = q.front().second;\nq.pop();\nfor (int j = 0; j < 4; j++)\n{\nint ny = y + side[j][0];\nint nx = x + side[j][1];\nif (nx >= 0 && ny >= 0 && ny < N && nx < M && visit[ny][nx] == false && arr[ny][nx] == 1)\n{\nq.push(make_pair(ny, nx));\nvisit[ny][nx] = true;\nland[ny][nx] = islandCnt;\n}\n}\n}\n}\n}\nvoid make_bridge(int y,int x,int dir) {\nint len = 0;\nint start = land[y][x];\nwhile (1)\n{\nint ny = y + side[dir][0];\nint nx = x + side[dir][1];\nif (ny >= 0 && nx >= 0 && ny < N && nx < M)\n{\nif (arr[ny][nx] == 0) \t\t\t{\ny = ny;\nx = nx;\nlen += 1;\n}\nelse if (arr[ny][nx] == 1 && len >= 2 && start != land[ny][nx]) \t\t\t{\nbridge.push_back(make_pair(len, make_pair(start, land[ny][nx])));\nbreak;\n}\nelse \t\t\t\tbreak;\n}\nelse \t\t\tbreak;\n}\n}\nvoid solve()\n{\nfor (int i = 0; i < v.size(); i++) \t{\nfor (int j = 0; j < 4; j++) \t\t\tmake_bridge(v[i].first, v[i].second, j);\n}\nsort(bridge.begin(), bridge.end());\nfor (int i = 1; i <= islandCnt; i++) \t\tparent[i] = i;\nint res = 0;\nfor (int i = 0; i < bridge.size(); i++) \t{\nif (!sameParent(bridge[i].second.first, bridge[i].second.second)) \t\t{\nUnion(bridge[i].second.first, bridge[i].second.second);\nres += bridge[i].first;\n}\n}\nfor (int i = 1; i <= islandCnt; i++) \t{\nif (find(i) != 1) {\ncout << \"-1\";\nreturn;\n}\n}\ncout << res;\n}\nint main(void)\n{\ncin.tie(0);\ncout.tie(0);\nios_base::sync_with_stdio(0);\ncin >> N >> M;\nfor (int i = 0; i < N; i++)\nfor (int j = 0; j < M; j++)\n{\ncin >> arr[i][j];\nif (arr[i][j] == 1)\nv.push_back(make_pair(i, j));\n}\nnumbering();\nsolve();\n}"
    },
    {
        "problem_tier": 14,
        "solution_code": "#include <iostream>\n#include <algorithm>\n#include <cmath>\n#define ll long long\nusing namespace std;\nll liquid[5001];\nll answerArr[3];\nint n;\nvoid twoPointer(){\nll result = 3e9;\nfor(int first=0; first<n-2; first++){\nll left = first + 1;\nll right = n - 1;\nwhile(left < right){\nll sum = liquid[left] + liquid[right] + liquid[first];\nif(abs(result) > abs(sum)){\nresult = sum;\nanswerArr[0] = liquid[first];\nanswerArr[1] = liquid[left];\nanswerArr[2] = liquid[right];\n}\nif(sum >= 0){\nright--;\n}else{\nleft++;\n}\n}\n}\nsort(answerArr, answerArr+3);\n}\nint main(){\ncin >> n;\nfor(int i=0; i<n; i++){\ncin >> liquid[i];\n}\nsort(liquid, liquid+n);\ntwoPointer();\nfor(int i=0; i<3; i++){\ncout << answerArr[i] << \" \";\n}\nreturn 0;\n}"
    },
    {
        "problem_tier": 14,
        "solution_code": "#include <iostream>\n#include <string>\n#include <climits>\n#include <algorithm>\nusing namespace std;\nint n, max_ans;\nstring str;\nint cal(int a, int b, char oper){\nint result = a;\nswitch(oper){\ncase '+':\nresult += b;\nbreak;\ncase '*':\nresult *= b;\nbreak;\ncase '-':\nresult -= b;\nbreak;\n}\nreturn result;\n}\nvoid recur(int idx, int cur){\nif(idx > n-1){\nmax_ans = max(max_ans, cur);\nreturn;\n}\nchar oper = (idx == 0) ? '+' : str[idx-1];\nif(idx + 2 < n){\nint bracket = cal(str[idx]-'0', str[idx+2]-'0', str[idx+1]);\nrecur(idx+4, cal(cur, bracket, oper));\n}\nrecur(idx+2, cal(cur, str[idx]-'0', oper));\n}\nint main() {\nios_base::sync_with_stdio(0);\ncin.tie(0);\ncin >> n >> str;\nmax_ans = INT_MIN;\nrecur(0, 0);\ncout << max_ans;\nreturn 0;\n}"
    },
    {
        "problem_tier": 12,
        "solution_code": "#include <iostream>\n#include <queue>\n#include <string>\nusing namespace std;\nstruct Pos {\nint x;\nint y;\nint z;\nint time;\n};\nchar board[32][32][32];\nbool visited[32][32][32];\nint dx[6] = {1, -1, 0, 0, 0, 0};\nint dy[6] = {0, 0, 1, -1, 0, 0};\nint dz[6] = {0, 0, 0, 0, 1, -1};\nint main() {\nwhile (1) {\nint L, R, C;\nstring str;\nqueue<Pos> Q;\ncin >> L >> R >> C;\nif (L == 0 || R == 0 || C == 0)\nbreak;\nfor (int i = 0; i < L; i++) {\nfor (int j = 0; j < R; j++) {\ncin >> str;\nfor (int k = 0; k < C; k++) {\nboard[i][j][k] = str[k];\nif (board[i][j][k] == 'S') {\nQ.push({i, j, k, 0});\nvisited[i][j][k] = true;\n}\n}\n}\n}\nwhile (!Q.empty()) {\nauto cur = Q.front();\nQ.pop();\nfor (int i = 0; i < 6; i++) {\nint nx = cur.x + dx[i];\nint ny = cur.y + dy[i];\nint nz = cur.z + dz[i];\nif (nx < 0 || nx > L-1 || ny < 0 || ny > R-1 || nz < 0 || nz > C-1)\ncontinue;\nif (board[nx][ny][nz] == 'E') {\ncout << \"Escaped in \" << cur.time + 1 << \" minute(s).\" << endl;\ngoto ij_silver;\n}\nif (board[nx][ny][nz] == '.' && visited[nx][ny][nz] == false) {\nQ.push({nx, ny, nz, cur.time + 1});\nvisited[nx][ny][nz] = true;\n}\n}\n}\ncout << \"Trapped!\" << endl;\nij_silver:\nfor (int i = 0; i < L; i++) {\nfor (int j = 0; j < R; j++) {\nfor (int k = 0; k < C; k++) {\nvisited[i][j][k] = false;\n}\n}\n}\n}\nreturn 0;\n}"
    },
    {
        "problem_tier": 13,
        "solution_code": "#include <iostream>\n#include <vector>\nusing namespace std;\nint parent[500001];\nint find_parent(int x){\nif(x == parent[x])\nreturn x;\nelse\nreturn parent[x] = find_parent(parent[x]);\n}\nvoid union_parent(int a, int b){\na = find_parent(a);\nb = find_parent(b);\nif(a < b)\nparent[b] = a;\nelse\nparent[a] = b;\n}\nint main(){\nios_base::sync_with_stdio(false);\ncin.tie(0);\nint N, M;\ncin >> N >> M;\nint ans = 0;\nfor(int i=1; i<=N; i++)\nparent[i] = i;\nfor(int i=0; i<M; i++){\nint a, b;\ncin >> a >> b;\nif(find_parent(a) == find_parent(b)){\nans = i+1;\nbreak;\n}\nunion_parent(a, b);\n}\ncout << ans;\nreturn 0;\n}"
    },
    {
        "problem_tier": 12,
        "solution_code": "#include<iostream>\n#include<string>\n#include<algorithm>\nusing namespace std;\nbool isPossible(string s, string t) {\nwhile (1) {\nif (s.size() == t.size()) {\nif (s == t)\nreturn true;\nbreak;\n}\nif (t[t.size() - 1] == 'A')\nt.pop_back();\nelse {\nt.pop_back();\nreverse(t.begin(), t.end());\n}\n}\nreturn false;\n}\nint main() {\nios_base::sync_with_stdio(0);\ncin.tie(0), cout.tie(0);\nstring s, t;\ncin >> s >> t;\nif (isPossible(s, t))\ncout << 1 << endl;\nelse\ncout << 0 << endl;\nreturn 0;\n}"
    },
    {
        "problem_tier": 14,
        "solution_code": "#include <iostream>\n#include <vector>\n#include <queue>\n#include <cstring>\nusing namespace std;\nint N, M, Max_Cost, Start, End;\nbool Visit[100001];\nvector<pair<int, int>> V[100001];\nint Bigger(int A, int B) {\nif (A > B) return A;\nreturn B;\n}\nvoid Input(){\ncin >> N >> M;\nfor (int i = 0; i < M; i++) {\nint Pos1, Pos2, Cost;\ncin >> Pos1 >> Pos2 >> Cost;\nV[Pos1].push_back(make_pair(Pos2, Cost));\nV[Pos2].push_back(make_pair(Pos1, Cost));\nMax_Cost = Bigger(Max_Cost, Cost);\n}\ncin >> Start >> End;\n}\nbool BFS(int Cur_Cost){\nqueue<int> Q;\nQ.push(Start);\nVisit[Start] = true;\nwhile (Q.empty() == 0)\n{\nint Cur_Factory = Q.front();\nQ.pop();\nif (Cur_Factory == End) return true;\nfor (int i = 0; i < V[Cur_Factory].size(); i++)\n{\nint Next_Factory = V[Cur_Factory][i].first;\nint Next_Factory_Cost = V[Cur_Factory][i].second;\nif (Visit[Next_Factory] == false && Cur_Cost <= Next_Factory_Cost)\n{\nVisit[Next_Factory] = true;\nQ.push(Next_Factory);\n}\n}\n}\nreturn false;\n}\nvoid Solution(){\nint Low = 0;\nint High = Max_Cost;\nwhile (Low <= High)\n{\nmemset(Visit, false, sizeof(Visit));\nint Mid = (Low + High) / 2;\nif (BFS(Mid) == true) Low = Mid + 1;\nelse High = Mid - 1;\n}\ncout << High << endl;\n}\nint main(void){\nios::sync_with_stdio(false);\ncin.tie(NULL);\ncout.tie(NULL);\nInput();\nSolution();\nreturn 0;\n}"
    },
    {
        "problem_tier": 4,
        "solution_code": "#include <iostream>\nusing namespace std;\nint main() {\nint X_price, Y_base, Y_limit, Y_extra, water_usage;\nint X_total, Y_total;\ncin >> X_price >> Y_base >> Y_limit >> Y_extra >> water_usage;\nX_total = X_price * water_usage;\nif (water_usage <= Y_limit) {\nY_total = Y_base;\n} else {\nY_total = Y_base + Y_extra * (water_usage - Y_limit);\n}\nint answer = min(X_total, Y_total);\ncout << answer << endl;\nreturn 0;\n}"
    },
    {
        "problem_tier": 15,
        "solution_code": "#include <iostream>\nusing namespace std;\nint R, C, Answer;\nchar MAP[10001][501];\nbool Visit[10001][501];\nbool Ans;\nint dx[] = { -1, 0, 1 };\nint dy[] = { 1, 1, 1 };\nvoid DFS(int x, int y) {\nVisit[x][y] = true;\nif (y == C - 1) {\nAns = true;\nAnswer++;\nreturn;\n}\nfor (int i = 0; i < 3; i++) {\nint nx = x + dx[i];\nint ny = y + dy[i];\nif (nx >= 0 && ny >= 0 && nx < R && ny < C) {\nif (MAP[nx][ny] == '.' && Visit[nx][ny] == false) {\nDFS(nx, ny);\nif (Ans == true)\nreturn;\n}\n}\n}\n}\nvoid Solve() {\ncin >> R >> C;\nfor (int i = 0; i < R; i++) {\nfor (int j = 0; j < C; j++) {\ncin >> MAP[i][j];\n}\n}\nfor (int i = 0; i < R; i++) {\nAns = false;\nDFS(i, 0);\n}\ncout << Answer << endl;\n}\nint main(void) {\nios::sync_with_stdio(false);\ncin.tie(NULL);\ncout.tie(NULL);\nSolve();\nreturn 0;\n}"
    },
    {
        "problem_tier": 7,
        "solution_code": "#include <iostream>\nusing namespace std;\nint main() {\nint a1, a0, c, n0;\ncin >> a1 >> a0 >> c >> n0;\nint fn = a1 * n0 + a0;\nint gn = c * n0;\nif (fn <= gn && a1 <= c) {\ncout << 1;\n} else {\ncout << 0;\n}\nreturn 0;\n}"
    },
    {
        "problem_tier": 6,
        "solution_code": "#include <iostream>\n#include <algorithm>\nusing namespace std;\nint main() {\nint n;\nint p[1001];\nint ans = 0;\nint l = 1, r = 1;\ncin >> n;\nfor (int i = 1; i <= n; i++)\ncin >> p[i];\nfor (int i = 1; i <= n - 1; i++) {\nif (p[i] < p[i + 1]) {            r++;\nans = max(ans, p[r] - p[l]);\n}\nelse if(p[i] >= p[i+1]) {            l = i + 1;\nr = i + 1;\n}\n}\ncout << ans << '\\n';\nreturn 0;\n}"
    },
    {
        "problem_tier": 8,
        "solution_code": "#include <iostream>\n#include <map>\n#include <vector>\n#include <algorithm>\nusing namespace std;\nint main() {\nint T;\ncin >> T;\nfor (int test = 0; test < T; test++) {\nint N;\ncin >> N;\nmap<int, int> m;\nfor (int i = 0; i < N; i++) {\nint num;\ncin >> num;\nm[num] = 1;\n}\nint M;\ncin >> M;\nfor (int i = 0; i < M; i++) {\nint num;\ncin >> num;\nif (m[num] == 1)\ncout << \"1\\n\";\nelse\ncout << \"0\\n\";\n}\n}\nreturn 0;\n}"
    },
    {
        "problem_tier": 12,
        "solution_code": "#include<iostream>\n#include<vector>\n#include<algorithm>\nusing namespace std;\nint n, cnt = 0;\nint arr[101];\nbool check[101];\nbool fin[101];\nint ans[101];\nvoid dfs(int a) {\ncheck[a] = true;\nif (!check[arr[a]])\ndfs(arr[a]);\nelse if (!fin[arr[a]]) {\nans[cnt++] = a;\nfor (int i = arr[a]; i != a; i = arr[i])\nans[cnt++] = i;\n}\nfin[a] = true;\n}\nint main(void) {\nios_base::sync_with_stdio(false);\ncin.tie(NULL);\ncin >> n;\nfor (int i = 1; i <= n; i++)\ncin >> arr[i];\nfor (int i = 1; i <= n; i++) {\nif (!check[i])\ndfs(i);\n}\ncout << cnt << \"\\n\";\nsort(ans, ans + cnt);\nfor (int i = 0; i < cnt; i++)\ncout << ans[i] << \"\\n\";\nreturn 0;\n}"
    },
    {
        "problem_tier": 14,
        "solution_code": "#include <iostream>\n#include <vector>\n#include <algorithm>\nusing namespace std;\nint T, N, M;\nint A[1001], B[1001];\nint main() {\ncin >> T >> N;\nfor (int i = 0; i < N; i++)\ncin >> A[i];\ncin >> M;\nfor (int i = 0; i < M; i++)\ncin >> B[i];\nvector<int> aSum, bSum;\nfor (int i = 0; i < N; i++) {\nint sum = A[i];\naSum.push_back(sum);\nfor (int j = i + 1; j < N; j++) {\nsum += A[j];\naSum.push_back(sum);\n}\n}\nfor (int i = 0; i < M; i++) {\nint sum = B[i];\nbSum.push_back(sum);\nfor (int j = i + 1; j < M; j++) {\nsum += B[j];\nbSum.push_back(sum);\n}\n}\nsort(bSum.begin(), bSum.end());\nlong long ans = 0;\nfor (int i = 0; i < aSum.size(); i++) {\nint target = T - aSum[i];\nint lo = lower_bound(bSum.begin(), bSum.end(), target) - bSum.begin();\nint hi = upper_bound(bSum.begin(), bSum.end(), target) - bSum.begin();\nans += (hi - lo);\n}\ncout << ans;\nreturn 0;\n}"
    },
    {
        "problem_tier": 5,
        "solution_code": "#include<iostream>\n#include<algorithm>\nusing namespace std;\nvoid section_swap(int arr[], int a, int b){\nwhile(true){\nswap(arr[a], arr[b]);\nif(b-a == 1 || b-a == 0)\nbreak;\na++;\nb--;\n}\n}\nint main(int argc, char** argv){\nios::sync_with_stdio(0);\ncin.tie(0);\nint arr[21], start, end;\nfor(int i=0; i<21; i++){\narr[i] = i;\n}\nfor(int i=0; i<10; i++){\ncin>>start>>end;\nsection_swap(arr, start, end);\n}\nfor(int i=1; i<21; i++){\ncout<<arr[i]<<\" \";\n}\nreturn 0;\n}"
    },
    {
        "problem_tier": 12,
        "solution_code": "#include <iostream>\n#include <queue>\n#include <vector>\n#include <algorithm>\nusing namespace std;\nint A, B, C;\nbool visited[201][201][201];\nvector<int> answer;\nvoid bfs() {\nqueue<tuple<int, int, int>> q;\nq.push({0, 0, C});\nwhile (!q.empty()) {\nint a, b, c;\ntie(a, b, c) = q.front();\nq.pop();\nif (visited[a][b][c]) continue;\nvisited[a][b][c] = true;\nif (a == 0) {\nanswer.push_back(c);\n}\nif (a + b > B) {\nq.push({a + b - B, B, c});\n} else {\nq.push({0, a + b, c});\n}\nif (a + c > C) {\nq.push({a + c - C, b, C});\n} else {\nq.push({0, b, a + c});\n}\nif (b + a > A) {\nq.push({A, b + a - A, c});\n} else {\nq.push({b + a, 0, c});\n}\nif (b + c > C) {\nq.push({a, b + c - C, C});\n} else {\nq.push({a, 0, b + c});\n}\nif (c + a > A) {\nq.push({A, b, c + a - A});\n} else {\nq.push({c + a, b, 0});\n}\nif (c + b > B) {\nq.push({a, B, c + b - B});\n} else {\nq.push({a, c + b, 0});\n}\n}\n}\nint main() {\nios::sync_with_stdio(0);\ncin.tie(0);\ncin >> A >> B >> C;\nbfs();\nsort(answer.begin(), answer.end());\nfor (auto x : answer) {\ncout << x << \" \";\n}\nreturn 0;\n}"
    },
    {
        "problem_tier": 11,
        "solution_code": "#include<iostream>\n#include<algorithm>\n#define MAX_NUM 101\n#define MAX_VOLUME 1001\nusing namespace std;\nint v[MAX_NUM];\nint dp[MAX_NUM][MAX_VOLUME];\nint main() {\nint n, s, m;\nint max_val = -1;\nfill_n(v, MAX_NUM, 0);\nfor(int i=0;i<MAX_NUM;i++){\nmemset(dp[i], -1, sizeof(int)*MAX_VOLUME);\n}\ncin>>n>>s>>m;\nfor(int i=1;i<=n;i++){\ncin>>v[i];\n}\nif(s+v[1]<=m){\ndp[1][s+v[1]] = s+v[1];\n}\nif(s-v[1]>=0){\ndp[1][s-v[1]] = s-v[1];\n}\nfor(int i=1;i<=n-1;i++){\nfor(int j=0;j<=m;j++){\nif(dp[i][j]!=-1){\nif(dp[i][j]+v[i+1]<=m){\ndp[i+1][dp[i][j]+v[i+1]] = max(dp[i+1][dp[i][j]+v[i+1]], dp[i][j]+v[i+1]);\n}\nif(dp[i][j]-v[i+1]>=0){\ndp[i+1][dp[i][j]-v[i+1]] = max(dp[i+1][dp[i][j]-v[i+1]], dp[i][j]-v[i+1]);\n}\n}\n}\n}\nfor(int i=0;i<=m;i++){\nif(max_val < dp[n][i]){\nmax_val = dp[n][i];\n}\n}\ncout<<max_val;\nreturn 0;\n}"
    },
    {
        "problem_tier": 4,
        "solution_code": "#include <iostream>\nusing namespace std;\nint main() {\nint T;\ncin >> T;\nfor (int i = 0; i < T; i++) {\nint s, n;\ncin >> s;\ncin >> n;\nint price = s;\nfor (int j = 0; j < n; j++) {\nint q, p;\ncin >> q;\ncin >> p;\nprice += q * p;\n}\ncout << price << '\\n';\n}\nreturn 0;\n}"
    },
    {
        "problem_tier": 5,
        "solution_code": "#include <iostream>\n#include <string>\nusing namespace std;\nint main() {\nstring str;\ncin >> str;\nfor (int i = 0; i < str.size(); i++) {\nif (str[i] > 'C') {\ncout << (char)(str[i] - 3);\n}\nelse {\ncout << (char)(str[i] + 23);\n}\n}\nreturn 0;\n}"
    },
    {
        "problem_tier": 3,
        "solution_code": "#include <iostream>\nusing namespace std;\nint main() {\nint n;\ncin >> n;\nint answer = 1;\nwhile (n--) {\nanswer *= 2;\n}\ncout << answer;\nreturn 0;\n}"
    },
    {
        "problem_tier": 5,
        "solution_code": "#include <iostream>\n#include <vector>\n#include <algorithm>\nusing namespace std;\nint main() {\nint n, m;\ncin >> n >> m;\nvector<int> v;\nfor(int i = 1; i <= n; i++) {\nv.push_back(i);\n}\nwhile(m--) {\nint i, j, k;\ncin >> i >> j >> k;\nrotate(v.begin()+(i-1), v.begin()+(k-1), v.begin()+j);\n}\nfor(int a : v) {\ncout << a << \" \";\n}\ncout << endl;\nreturn 0;\n}"
    },
    {
        "problem_tier": 13,
        "solution_code": "#include <stdio.h>\n#include <stdlib.h>\n#include <string.h>\n#include <iostream>\n#include <algorithm>\n#include <vector>\n#include <queue>\n#include <stack>\n#include <cmath>\n#define INF 987654321\nusing namespace std;\nstruct node {\nint y;\nint x;\n};\nint N, M, K, start_y, start_x, end_y, end_x;\nint adj[51][51], copy_adj[51][51], Init_adj[51][51];\nint r[6], c[6], s[6];\nint Rotate[6];\nvoid Init_Copy() {\nfor (int i = 1; i <= N; i++) {\nfor (int j = 1; j <= M; j++) {\nadj[i][j] = Init_adj[i][j];\n}\n}\n}\nvoid Copy() {\nfor (int i = 1; i <= N; i++) {\nfor (int j = 1; j <= M; j++) {\ncopy_adj[i][j] = adj[i][j];\n}\n}\n}\nint main() {\nios::sync_with_stdio(false);\ncin.tie(0);\ncin >> N >> M >> K;\nfor (int i = 1; i <= N; i++) {\nfor (int j = 1; j <= M; j++) {\ncin >> adj[i][j];\nInit_adj[i][j] = adj[i][j];\n}\n}\nfor (int i = 0; i < K; i++) {\ncin >> r[i] >> c[i] >> s[i];\nRotate[i] = i;\n}\nint Answer = INF;\ndo {\nInit_Copy();\nfor (int i = 0; i < K; i++) {\nCopy();\nstart_y = r[Rotate[i]] - s[Rotate[i]];\nstart_x = c[Rotate[i]] - s[Rotate[i]];\nend_y = r[Rotate[i]] + s[Rotate[i]];\nend_x = c[Rotate[i]] + s[Rotate[i]];\nint ps = 0;\nwhile (1){\nnode start1, start2, start3, start4;\nstart1.y = start_y + ps, start1.x = start_x + ps;\nstart2.y = start_y + ps, start2.x = end_x - ps;\nstart3.y = end_y - ps, start3.x = start_x + ps;\nstart4.y = end_y - ps, start4.x = end_x - ps;\nint len1 = start2.x - start1.x;\nint len2 = start3.y - start1.y;\nif (len1 <= 0 || len2 <= 0) break;\nfor (int x = start1.x + 1; x <= start2.x; x++) {\nadj[start1.y][x] = copy_adj[start1.y][x - 1];\n}\nfor (int y = start2.y + 1; y <= start3.y; y++) {\nadj[y][start2.x] = copy_adj[y - 1][start2.x];\n}\nfor (int x = start4.x - 1; x >= start3.x; x--) {\nadj[start4.y][x] = copy_adj[start4.y][x + 1];\n}\nfor (int y = start3.y - 1; y >= start1.y; y--) {\nadj[y][start1.x] = copy_adj[y + 1][start1.x];\n}\nps++;\n}\n}\nint cur_Answer = INF;\nfor (int i = 1; i <= N; i++) {\nint ps = 0;\nfor (int j = 1; j <= M; j++) {\nps += adj[i][j];\n}\ncur_Answer = min(cur_Answer, ps);\n}\nAnswer = min(Answer, cur_Answer);\n} while (next_permutation(Rotate, Rotate+K));\ncout << Answer << endl;\nreturn 0;\n}"
    },
    {
        "problem_tier": 10,
        "solution_code": "#include<iostream>\n#include<algorithm>\n#include<vector>\n#define INF 1e8\nusing namespace std;\nint main() {\nint N;\ncin >> N;\nvector<int> board(N);\nfor(int i=0; i<N; i++) {\ncin >> board[i];\n}\nvector<int> dp(N, INF);\ndp[0] = 0;\nfor(int i=0; i<N; i++) {\nif(dp[i] == INF) continue;\nint num = board[i];\nfor(int k=1; k<=num; k++) {\nif(i+k >= N) break;\ndp[i+k] = min(dp[i+k], dp[i]+1);\n}\n}\nif(dp[N-1] == INF) cout << -1 << endl;\nelse cout << dp[N-1] << endl;\nreturn 0;\n}"
    },
    {
        "problem_tier": 8,
        "solution_code": "#include <iostream>\n#include <vector>\n#include <algorithm>\nusing namespace std;\nint gcd(int a, int b) {\nif (a % b == 0) return b;\nelse return gcd(b, a % b);\n}\nint main(void) {\nios::sync_with_stdio(false);\nint N;\ncin >> N;\nvector<int> vec;\nvec.resize(N);\nfor (int i = 0; i < N; i++) {\ncin >> vec[i];\n}\nsort(vec.begin(), vec.end());\nint temp = vec[1] - vec[0];\nfor (int i = 1; i < N - 1; i++) {\nint next = vec[i+1] - vec[i];\nif (next > temp) {\nint swap_num = next;\nnext = temp;\ntemp = swap_num;\n}\ntemp = gcd(temp, next);\n}\nint answer = ((vec[N-1] - vec[0]) / temp) - N + 1;\ncout << answer << endl;\nreturn 0;\n}"
    },
    {
        "problem_tier": 16,
        "solution_code": "#include <iostream>\n#include <vector>\n#include <set>\nusing namespace std;\nint main() {\nint N, K;\nset<int> plugged;\nvector<int> schedule;\ncin >> N >> K;\nfor (int i=0; i<K; i++) {\nint input;\ncin >> input;\nschedule.push_back(input);\n}\nint ans = 0;\nfor (int i=0; i<K; i++) {\nint device = schedule[i];\nif (plugged.size() < N) {\nplugged.insert(device);\ncontinue;\n}\nif (plugged.find(device) != plugged.end()) continue;\nint farthestIdx = -1;\nauto toUnplug = plugged.begin();\nfor (auto iter=plugged.begin(); iter!=plugged.end(); ++iter) {\nint curIdx = 0;\nint curDevice = *iter;\nbool found = false;\nfor (int j=i+1; j<K; ++j) {\nif (schedule[j] == curDevice) {\nfound = true;\ncurIdx = j;\nbreak;\n}\n}\nif (!found) curIdx = K;\nif (farthestIdx < curIdx) {\nfarthestIdx = curIdx;\ntoUnplug = iter;\n}\n}\nplugged.erase(toUnplug);\nplugged.insert(device);\nans++;\n}\ncout << ans << \"\\n\";\nreturn 0;\n}"
    },
    {
        "problem_tier": 14,
        "solution_code": "#include<iostream>\n#include<string>\n#include<deque>\nusing namespace std;\nint main() {\nint n, k;\nstring val;\ndeque<char> deq;\ncin.tie(0);\ncin >> n >> k;\ncin >> val;\nfor(int i=0; i<val.length(); i++) {\nwhile(k && !deq.empty() && deq.back() < val[i]) {\ndeq.pop_back();\nk--;\n}\ndeq.push_back(val[i]);\n}\nfor(int i=0; i<deq.size()-k; i++)\ncout << deq[i];\ncout << \"\\n\";\nreturn 0;\n}"
    },
    {
        "problem_tier": 4,
        "solution_code": "#include<iostream>\n#include<vector>\nusing namespace std;\nint prizeTable1[21]={500,300,300,200,200,200,50,50,50,50,30,30,30,30,30,10,10,10,10,10,10};\nint prizeTable2[31]={512,256,256,128,128,128,128,64,64,64,64,64,64,64,64,32,32,32,32,32,32,32,32,32,32,32,32,32,32,32,32};\nint MyPrize(int a, int b){\nint total=0;\nif((a>=1)&&(a<=21)){\ntotal+=prizeTable1[a-1];\n}\nif((b>=1)&&(b<=31)){\ntotal+=prizeTable2[b-1];\n}\ntotal*=10000;\nreturn total;\n}\nint main(){\nint testcase;\ncin>>testcase;\nint a;\nint b;\nfor(int i=0;i<testcase;i++){\ncin>>a>>b;\ncout<<MyPrize(a,b)<<\"\\n\";\n}\nreturn 0;\n}"
    },
    {
        "problem_tier": 17,
        "solution_code": "#include <iostream>\n#include <vector>\n#include <queue>\n#include <cmath>\n#define maxN 100001\nusing namespace std;\nint N, M;\nvector<int> graph[maxN];\nint parent[maxN][17];\nint depth[maxN];\nvoid dfs(int node, int parent_node) {\nparent[node][0] = parent_node;\ndepth[node] = depth[parent_node] + 1;\nfor (int i = 1; i < 17; i++) {\nparent[node][i] = parent[parent[node][i-1]][i-1];\n}\nfor (int i = 0; i < graph[node].size(); i++) {\nint next = graph[node][i];\nif (next != parent_node) {\ndfs(next, node);\n}\n}\n}\nint lca(int a, int b) {\nif (depth[a] > depth[b]) {\nswap(a, b);\n}\nfor (int i = 16; i >= 0; i--) {\nif (depth[b] - depth[a] >= (1 << i)) {\nb = parent[b][i];\n}\n}\nif (a == b) {\nreturn a;\n}\nfor (int i = 16; i >= 0; i--) {\nif (parent[a][i] != parent[b][i]) {\na = parent[a][i];\nb = parent[b][i];\n}\n}\nreturn parent[a][0];\n}\nint main() {\nios_base::sync_with_stdio(false);\ncin.tie(NULL);\ncout.tie(NULL);\ncin >> N;\nfor (int i = 0; i < N-1; i++) {\nint a, b;\ncin >> a >> b;\ngraph[a].push_back(b);\ngraph[b].push_back(a);\n}\ndepth[0] = -1;     dfs(1, 0);\ncin >> M;\nfor (int i = 0; i < M; i++) {\nint a, b;\ncin >> a >> b;\ncout << lca(a, b) << \"\\n\";\n}\nreturn 0;\n}"
    },
    {
        "problem_tier": 16,
        "solution_code": "#include <iostream>\n#include <vector>\n#include <cmath>\n#include <cstdio>\n#define MOD 1000000007\nusing namespace std;\nvector<int> v;\nvector<long long> tree;\nlong long init(int node, int start, int end) {\nif (start == end) {\nreturn tree[node] = v[start];\n} else {\nreturn tree[node] = init(node * 2, start, (start + end) / 2) * init(node * 2 + 1, (start + end) / 2 + 1, end) % MOD;\n}\n}\nlong long update(int node, int start, int end, int idx, int num) {\nif (idx > end || idx < start) {\nreturn tree[node];\n}\nif (start == end) {\nreturn tree[node] = num;\n}\nreturn tree[node] = update(node * 2, start, (start + end) / 2, idx, num) * update(node * 2 + 1, (start + end) / 2 + 1, end, idx, num) % MOD;\n}\nlong long sum(int node, int start, int end, int left, int right) {\nif (left > end || right < start) {\nreturn 1;\n}\nif (left <= start && right >= end) {\nreturn tree[node];\n} else {\nreturn sum(node * 2, start, (start + end) / 2, left, right) * sum(node * 2 + 1, (start + end) / 2 + 1, end, left, right) % MOD;\n}\n}\nint main(void) {\nint N, M, K;\nscanf(\"%d%d%d\", &N, &M, &K);\nv.resize(N);\nint h = (int)ceil(log2(N));\nint vector_size = (1 << (h + 1));\ntree.resize(vector_size);\nfor (int i = 0; i < N; i++) {\nscanf(\"%d\", &v[i]);\n}\ninit(1, 0, N-1);\nfor (int i = 0; i < M+K; i++) {\nint a, b, c;\nscanf(\"%d%d%d\", &a, &b, &c);\nif (a == 1) {\nupdate(1, 0, N-1, b-1, c);\n} else if (a == 2) {\ncout << sum(1, 0, N-1, b-1, c-1) << \"\\n\";\n}\n}\nreturn 0;\n}"
    },
    {
        "problem_tier": 11,
        "solution_code": "#include <iostream>\n#include <vector>\n#include <cmath>\n#include <string>\nusing namespace std;\nbool visited[2000000];\nvector<int> prime;\nvoid init() {\nprime.reserve(2000000);\nfor(int i=2; i<=sqrt(2000000); i++) {\nfor(int j=i+i; j<2000000; j+=i) {\nif(!visited[j])\nvisited[j] = true;\n}\n}\nfor(int i=2; i<2000000; i++) {\nif(!visited[i])\nprime.push_back(i);\n}\n}\nbool is_palindrome(int num) {\nstring str = to_string(num);\nbool ret = true;\nfor(int i=0; i<str.size()/2; i++) {\nif(str[i] != str[str.size()-1-i]) {\nret = false;\nbreak;\n}\n}\nreturn ret;\n}\nint main(void) {\nint n;\ncin>>n;\ninit();\nint pos = lower_bound(prime.begin(), prime.end(), n) - prime.begin();\nwhile(1) {\nif(is_palindrome(prime[pos])) {\ncout<<prime[pos];\nreturn 0;\n}"
    },
    {
        "problem_tier": 9,
        "solution_code": "#include<iostream>\nusing namespace std;\nint main() {\nint n;\nwhile (cin >> n) {\nint tmp = 0;\nfor (int i = 1; i <= n; i++) {\ntmp = tmp * 10 + 1;\ntmp %= n;\nif (tmp == 0) {\ncout << i << \"\\n\";\nbreak;\n}\n}\n}\nreturn 0;\n}"
    },
    {
        "problem_tier": 5,
        "solution_code": "#include <iostream>\n#include <vector>\nusing namespace std;\nint main() {\nios_base::sync_with_stdio(false);\ncin.tie(NULL);\ncout.tie(NULL);\nint tc, num;\ncin >> tc;\nwhile (tc--) {\ncin >> num;\nvector<bool> prison(num + 1, false);\nfor (int i = 1; i <= num; i++) {\nfor (int j = i; j <= num; j += i) {\nprison[j] = !prison[j];\n}\n}\nint result = 0;\nfor (int i = 1; i <= num; i++) {\nresult += prison[i];\n}\ncout << result << '\\n';\n}\nreturn 0;\n}"
    },
    {
        "problem_tier": 11,
        "solution_code": "#include <iostream>\n#include <queue>\n#include <utility>\nusing namespace std;\nint board[1002][1002];\nint dist[1002][1002];\nint dx[4] = {0, 0, 1, -1};\nint dy[4] = {1, -1, 0, 0};\nqueue<pair<int, int>> q;\nint main() {\nios::sync_with_stdio(0);\ncin.tie(0);\nint n, m;\ncin >> n >> m;\nfor (int i = 0; i < n; i++) {\nfor (int j = 0; j < m; j++) {\ndist[i][j] = -1;\n}\n}\nfor (int i = 0; i < n; i++) {\nfor (int j = 0; j < m; j++) {\ncin >> board[i][j];\nif (board[i][j] == 2) {\nq.push({i, j});\ndist[i][j] = 0;\n}\n}\n}\nwhile (!q.empty()) {\nauto cur = q.front();\nq.pop();\nfor (int i = 0; i < 4; i++) {\nint nx = cur.first + dx[i];\nint ny = cur.second + dy[i];\nif (nx < 0 || nx >= n || ny < 0 || ny >= m) continue;\nif (dist[nx][ny] != -1) continue;\nif (board[nx][ny] == 0) continue;\ndist[nx][ny] = dist[cur.first][cur.second] + 1;\nq.push({nx, ny});\n}\n}\nfor (int i = 0; i < n; i++) {\nfor (int j = 0; j < m; j++) {\nif (board[i][j] == 0) cout << 0 << \" \";\nelse cout << dist[i][j] << \" \";\n}\ncout << \"\\n\";\n}\nreturn 0;\n}"
    },
    {
        "problem_tier": 6,
        "solution_code": "#include <iostream>\nusing namespace std;\nint num[5];\nint getCnt(int n) {\nint cnt = 0;\nfor (int i = 0; i < 5; i++) {\nif (n % num[i] == 0)\ncnt++;\n}\nreturn cnt;\n}\nint main() {\nfor (int i = 0; i < 5; i++)\ncin >> num[i];\nint ans = 1;\nwhile (getCnt(ans) < 3)\nans++;\ncout << ans << '\\n';\nreturn 0;\n}"
    },
    {
        "problem_tier": 7,
        "solution_code": "#include<iostream>\nusing namespace std;\nint main() {\nint n, l = 1, r = 1, sum, ans;\ncin >> n;\nwhile (l <= r && r <= n) {\nif (sum < n)\nsum += r++;\nelse {\nif (sum == n)\nans++;\nsum -= l++;\n}\n}\ncout << ans + 1;\nreturn 0;\n}"
    },
    {
        "problem_tier": 8,
        "solution_code": "#include <iostream>\n#include <vector>\n#include <algorithm>\nusing namespace std;\nint main() {\nint N, result = 0;\ncin >> N;\nvector<int> arr(N);\nfor (int i = 0; i < N; i++) {\ncin >> arr[i];\n}\nreverse(arr.begin(), arr.end());\nfor (int i = 1; i < N; i++) {\nif (arr[i] >= arr[i-1]) {\nint decrease = arr[i] - arr[i-1] + 1;\narr[i] -= decrease;\nresult += decrease;\n}\n}\ncout << result;\nreturn 0;\n}"
    },
    {
        "problem_tier": 17,
        "solution_code": "#include<iostream>\n#include<vector>\n#include<cmath>\n#include<algorithm>\nusing namespace std;\nint parent[100001];\nint N, res;\nvector<pair<int,int>> v[3]; vector<pair<int,pair<int,int>>> planet;\nint Find(int x){\nif(parent[x] == x)\nreturn x;\nreturn parent[x] = Find(parent[x]);\n}\nbool SameParent(int a, int b){\na = Find(a);\nb = Find(b);\nif(a != b)\nreturn false;\nelse\nreturn true;\n}\nvoid Union(int a, int b){\na = Find(a);\nb = Find(b);\nif(a != b)\nparent[a] = b;\n}\nint main(void){\nint x, y, z;\ncin >> N;\nfor(int i = 0; i < N; i++) {\ncin >> x >> y >> z;\nv[0].push_back(make_pair(x, i));\nv[1].push_back(make_pair(y, i));\nv[2].push_back(make_pair(z, i));\nparent[i] = i;\n}\nsort(v[0].begin(), v[0].end());\nsort(v[1].begin(), v[1].end());\nsort(v[2].begin(), v[2].end());\nfor(int i = 0; i < N-1; i++) {\nplanet.push_back(make_pair(abs(v[0][i].first - v[0][i+1].first), make_pair(v[0][i].second, v[0][i+1].second)));\nplanet.push_back(make_pair(abs(v[1][i].first - v[1][i+1].first), make_pair(v[1][i].second, v[1][i+1].second)));\nplanet.push_back(make_pair(abs(v[2][i].first - v[2][i+1].first), make_pair(v[2][i].second, v[2][i+1].second)));\n}\nsort(planet.begin(), planet.end());\nfor(int i = 0; i < planet.size(); i++) {\nif(!SameParent(planet[i].second.first, planet[i].second.second)) {\nres += planet[i].first;\nUnion(planet[i].second.first, planet[i].second.second);\n}\n}\ncout << res;\n}"
    },
    {
        "problem_tier": 8,
        "solution_code": "#include <iostream>\n#include <vector>\n#include <algorithm>\nint main() {\nstd::ios::sync_with_stdio(false);\nstd::cin.tie(NULL);\nint n;\nstd::cin >> n;\nstd::vector<int> a(n);\nfor (int i = 0; i < n; i++) {\nstd::cin >> a[i];\n}\nstd::vector<int> b = a;\nstd::sort(b.begin(), b.end());\nstd::vector<int> ans(n);\nstd::vector<int> ck(n, 0);\nstd::vector<int> answer;\nfor (int i = 0; i < n; i++) {\nfor (int j = 0; j < n; j++) {\nif (a[i] == b[j] && !ck[j]) {\nck[j] = 1;\nanswer.push_back(j);\nbreak;\n}\n}\n}\nfor (auto p : answer) {\nstd::cout << p << \" \";\n}\nreturn 0;\n}"
    },
    {
        "problem_tier": 6,
        "solution_code": "#include <iostream>\n#include <string>\n#include <algorithm>\n#include <vector>\nusing namespace std;\nbool sortFunction(pair<string, int> a, pair<string, int> b){\nreturn a.second > b.second;\n}\nint main() {\nios::sync_with_stdio(false);\ncin.tie(NULL);\ncout.tie(NULL);\nint T;\ncin >> T;\nfor (int i = 0; i < T; ++i) {\nint N;\ncin >> N;\nvector<pair<string, int>> rank;\nstring name;\nint num;\nfor (int j = 0; j < N; ++j) {\ncin >> name >> num;\nrank.push_back({name, num});\n}\nsort(rank.begin(), rank.end(), sortFunction);\ncout << rank[0].first << '\\n';\n}\nreturn 0;\n}"
    },
    {
        "problem_tier": 3,
        "solution_code": "#include <iostream>\nusing namespace std;\nint main() {\nint month, day;\ncin >> month >> day;\nif (month < 2)\ncout << \"Before\" << '\\n';\nelse if (month == 2) {\nif (day < 18)\ncout << \"Before\" << '\\n';\nelse if (day == 18)\ncout << \"Special\" << '\\n';\nelse\ncout << \"After\" << '\\n';\n} else\ncout << \"After\" << '\\n';\nreturn 0;\n}"
    },
    {
        "problem_tier": 13,
        "solution_code": "#include <iostream>\n#include <algorithm>\n#include <vector>\nusing namespace std;\nconst int INF = 2000000000;\nint arr[401][401];\nint main() {\nios_base::sync_with_stdio(0);\ncin.tie(0), cout.tie(0);\nint v, e;\ncin >> v >> e;\nfor (int i = 1; i <= v; i++)\nfor (int j = 1; j <= v; j++){\nif (i == j)\narr[i][j] = 0;\nelse\narr[i][j] = INF;\n}\nint a, b, c;\nfor (int i = 0; i < e; i++) {\ncin >> a >> b >> c;\nif (arr[a][b] > c)             arr[a][b] = c;\n}\nfor (int k = 1; k <= v; k++)\nfor (int i = 1; i <= v; i++)\nfor (int j = 1; j <= v; j++)\narr[i][j] = min(arr[i][j], arr[i][k] + arr[k][j]);\nlong long result = INF;\nfor (int i = 1; i <= v; i++)\nfor (int j = 1; j <= v; j++) {\nif (i == j)\ncontinue;\nresult = min(result, arr[i][j] + arr[j][i]);\n}\nif (result == INF)\ncout << -1 << endl;\nelse\ncout << result << endl;\nreturn 0;\n}"
    },
    {
        "problem_tier": 10,
        "solution_code": "#include <iostream>\n#include <vector>\n#include <algorithm>\nusing namespace std;\nvector<vector<int>> graph;\nvector<int> visited;\nvector<int> sequence;\nint N, M, R, Seq;\nvoid dfs(int n) {\nsequence[n] = ++Seq;\nvisited[n] = 1;\nint graphSize = graph[n].size();\nfor (int i = 0; i < graphSize; i++) {\nint v = graph[n][i];\nif (visited[v] == 0)\ndfs(v);\n}\n}\nint main() {\nios::sync_with_stdio(0);\ncin.tie(0);\ncout.tie(0);\ncin >> N >> M >> R;\ngraph.resize(N + 1);\nvisited.resize(N + 1);\nsequence.resize(N + 1);\nint u, v;\nfor (int i = 0; i < M; i++) {\ncin >> u >> v;\ngraph[u].push_back(v);\ngraph[v].push_back(u);\n}\nfor (int i = 1; i <= N; i++)\nsort(graph[i].begin(), graph[i].end());\ndfs(R);\nfor (int i = 1; i <= N; i++)\nprintf(\"%d\\n\", sequence[i]);\nreturn 0;\n}"
    },
    {
        "problem_tier": 1,
        "solution_code": "#include<iostream>\nusing namespace std;\nint main(int argc, char* argv[]) {\ncout << \"Avengers:Endgame\" << endl;\nreturn 0;\n}"
    },
    {
        "problem_tier": 12,
        "solution_code": "#include <iostream>\n#include <algorithm>\nusing namespace std;\n#define MAX 1500000\nint n;\npair<int, int> input[MAX];\nint dp[MAX + 1];\nint answer;\nint curMax;\nint main() {\nios::sync_with_stdio(false);\ncin.tie(0);\ncout.tie(0);\ncin >> n;\nfor (int i = 0; i < n; i++) {\ncin >> input[i].first >> input[i].second;\n}\nfor (int i = 0; i <= n; i++) {\ncurMax = max(curMax, dp[i]);\nif (i + input[i].first > n) continue;\ndp[i + input[i].first] = max(dp[i + input[i].first], curMax + input[i].second);\nanswer = max(answer, dp[i + input[i].first]);\n}\ncout << answer << '\\n';\nreturn 0;\n}"
    },
    {
        "problem_tier": 13,
        "solution_code": "#include <iostream>\n#include <queue>\n#include <cstring>\n#define MAX 10000\nusing namespace std;\nbool prime[MAX];\nbool visited[MAX];\nvoid makePrime(){\nmemset(prime, true, sizeof(prime));\nfor(int i=2; i*i<=MAX; i++){\nif(prime[i]){\nfor(int j=i*i; j<=MAX; j+=i){\nprime[j] = false;\n}\n}\n}\n}\nint bfs(string a, string b){\nqueue<string> q;\nq.push(a);\nvisited[stoi(a)] = true;\nwhile(!q.empty()){\nstring x = q.front();\nq.pop();\nif(x == b){\nreturn visited[stoi(b)] - 1;\n}\nfor(int j=0; j<4; j++){\nstring tmp = x;\nfor(int i=0; i<10; i++){\nif(!i && !j) continue;\ntmp[j] = i + '0';\nint newX = stoi(tmp);\nif(!visited[newX] && prime[newX]){\nvisited[newX] = visited[stoi(x)] + 1;\nq.push(tmp);\n}\n}\n}\n}\nreturn MAX;\n}\nint main(){\nint t;\ncin >> t;\nmakePrime();\nwhile(t--){\nstring a, b;\nmemset(visited, 0, sizeof(visited));\ncin >> a >> b;\nint ans = bfs(a, b);\nif(ans != MAX){\ncout << ans << '\\n';\n}\nelse{\ncout << \"Impossible\\n\";\n}\n}\nreturn 0;\n}"
    },
    {
        "problem_tier": 2,
        "solution_code": "#include<iostream>\nusing namespace std;\nint main(){\nios::sync_with_stdio(0);\ncin.tie(0);\ncout.tie(0);\nlong long a, b;\ncin >> a >> b;\nif(a == b)\ncout << 1 << endl;\nelse\ncout << 0 << endl;\nreturn 0;\n}"
    },
    {
        "problem_tier": 7,
        "solution_code": "#include <iostream>\n#include <vector>\nusing namespace std;\nint main() {\nint n;\ncin >> n;\nvector<vector<char>> room(n, vector<char>(n));\nfor (int i = 0; i < n; i++) {\nfor (int j = 0; j < n; j++) {\ncin >> room[i][j];\n}\n}\nint row_cnt = 0, col_cnt = 0;\nfor (int i = 0; i < n; i++) {\nint cnt = 0;\nbool check = false;\nfor (int j = 0; j < n; j++) {\nif (room[i][j] == '.') {\ncnt++;\n}\nelse {\ncnt = 0;\ncheck = false;\n}\nif (cnt >= 2 && check == false) {\nrow_cnt++;\ncheck = true;\n}\n}\n}\nfor (int i = 0; i < n; i++) {\nint cnt = 0;\nbool check = false;\nfor (int j = 0; j < n; j++) {\nif (room[j][i] == '.') {\ncnt++;\n}\nelse {\ncnt = 0;\ncheck = false;\n}\nif (cnt >= 2 && check == false) {\ncol_cnt++;\ncheck = true;\n}\n}\n}\ncout << row_cnt << \" \" << col_cnt << \"\\n\";\nreturn 0;\n}"
    },
    {
        "problem_tier": 5,
        "solution_code": "#include<iostream>\nusing namespace std;\ntypedef long long ll;\nint main(){\nios::sync_with_stdio(0);\ncin.tie(0);\nll N;\ncin >> N;\ncout << (N*(N-1)*(N-2))/6 << '\\n' << 3;\nreturn 0;\n}"
    },
    {
        "problem_tier": 13,
        "solution_code": "#include <iostream>\n#include <vector>\n#include <queue>\n#include <algorithm>\n#include <cstring>\n#define MAX 101\nusing namespace std;\nint R, C, K, Answer;\nint MAP[MAX][MAX];\nint Number_Cnt[MAX];\nvoid Input(){\ncin >> R >> C >> K;\nfor (int i = 1; i <= 3; i++)\n{\nfor (int j = 1; j <= 3; j++)\n{\ncin >> MAP[i][j];\n}\n}\n}\nvoid Print(){\nfor (int i = 1; i < 50; i++)\n{\nfor (int j = 1; j < 50; j++)\n{\ncout << MAP[i][j] << \" \";\n}\ncout << endl;\n}\ncout << \"########################################\" << endl;\n}\nvoid Find(){\nint Time = 0;\nint Hang = 3;\nint Yul = 3;\nwhile (1)\n{\nif (MAP[R][C] == K) { Answer = Time; break; }\nif (Time > 100) { Answer = -1; break; }\nvector<int> Size;\nif (Hang >= Yul)            {\nfor (int i = 1; i <= Hang; i++)\n{\nvector<pair<int, int>> V;\nmemset(Number_Cnt, 0, sizeof(Number_Cnt));\nfor (int j = 1; j <= Yul; j++) Number_Cnt[MAP[i][j]]++;\nfor (int j = 1; j < MAX; j++)\n{\nif (Number_Cnt[j] == 0) continue;\nV.push_back(make_pair(Number_Cnt[j], j));\n}\nsort(V.begin(), V.end());\nfor (int j = 1; j <= Yul; j++) MAP[i][j] = 0;\nint Idx = 1;\nfor (int j = 0; j < V.size(); j++)\n{\nMAP[i][Idx++] = V[j].second;\nMAP[i][Idx++] = V[j].first;\n}\nIdx--;\nSize.push_back(Idx);\n}\nsort(Size.begin(), Size.end());\nYul = Size.back();\n}\nelse            {\nfor (int i = 1; i <= Yul; i++)\n{\nvector<pair<int, int>> V;\nmemset(Number_Cnt, 0, sizeof(Number_Cnt));\nfor (int j = 1; j <= Hang; j++) Number_Cnt[MAP[j][i]]++;\nfor (int j = 1; j < MAX; j++)\n{\nif (Number_Cnt[j] != 0)\n{\nV.push_back(make_pair(Number_Cnt[j], j));\n}\n}\nsort(V.begin(), V.end());\nfor (int j = 1; j <= Hang; j++) MAP[j][i] = 0;\nint Idx = 1;\nfor (int j = 0; j < V.size(); j++)\n{\nMAP[Idx++][i] = V[j].second;\nMAP[Idx++][i] = V[j].first;\n}\nIdx--;\nSize.push_back(Idx);\n}\nsort(Size.begin(), Size.end());\nHang = Size.back();\n}\nTime++;\n}\n}\nvoid Solution(){\nif (MAP[R][C] == K)\n{\nAnswer = 0;\ncout << Answer << endl;\nreturn;\n}\nFind();\ncout << Answer << endl;\n}\nvoid Solve(){\nInput();\nSolution();\n}\nint main(void){\nios::sync_with_stdio(false);\ncin.tie(NULL);\ncout.tie(NULL);\nSolve();\nreturn 0;\n}"
    },
    {
        "problem_tier": 12,
        "solution_code": "#include <iostream>\nusing namespace std;\nint main() {\nint T;\ncin >> T;\nfor (int i = 0; i < T; i++) {\nint dp[10001];\nfor (int j = 0; j < 10001; j++) {\ndp[j] = 0;\n}\ndp[0] = 1;\nint N;\nint coin[21];\ncin >> N;\nfor (int j = 0; j < N; j++) {\ncin >> coin[j];\n}\nint m;\ncin >> m;\nfor (int j = 0; j < N; j++) {\nfor (int k = coin[j]; k <= m; k++) {\ndp[k] += dp[k - coin[j]];\n}\n}\ncout << dp[m] << endl;\n}\nreturn 0;\n}"
    },
    {
        "problem_tier": 5,
        "solution_code": "#include <iostream>\nusing namespace std;\nint main() {\nint N, seat[101] = {0}, cnt = 0, x;\ncin >> N;\nfor (int i = 0; i < N; i++) {\ncin >> x;\nif (seat[x] == 0) {\nseat[x] = 1;\n}\nelse {\ncnt++;\n}\n}\ncout << cnt << \"\\n\";\nreturn 0;\n}"
    },
    {
        "problem_tier": 10,
        "solution_code": "#include <iostream>\n#include <vector>\nusing namespace std;\n#define MAX 100000\n#define MOD 1000000009\nlong long dp[MAX + 1][4];\nint main() {\ncin.tie(0);\nios_base::sync_with_stdio(0);\ndp[1][1] = dp[2][2] = 1;\ndp[3][1] = dp[3][2] = dp[3][3] = 1;\nfor (int i = 4; i <= MAX; i++) {\ndp[i][1] = (dp[i-1][2] + dp[i-1][3]) % MOD;\ndp[i][2] = (dp[i-2][1] + dp[i-2][3]) % MOD;\ndp[i][3] = (dp[i-3][1] + dp[i-3][2]) % MOD;\n}\nint t;\ncin >> t;\nwhile (t--) {\nint n;\ncin >> n;\ncout << ((long long)dp[n][1] + dp[n][2] + dp[n][3]) % MOD << '\\n';\n}\nreturn 0;\n}"
    },
    {
        "problem_tier": 13,
        "solution_code": "#include <iostream>\n#include <queue>\n#include <cstring>\nusing namespace std;\nconst int MAX = 2000;\nint S;\nbool Visit[MAX][MAX];\nvoid Input(){\ncin >> S;\n}\nint BFS(){\nqueue<pair<pair<int, int>, int>> Q;\nQ.push(make_pair(make_pair(1, 0), 0));\nVisit[1][0] = true;\nwhile (!Q.empty()){\nint Dis = Q.front().first.first;\nint Clip = Q.front().first.second;\nint Time = Q.front().second;\nQ.pop();\nif (Dis == S) return Time;\nif (Dis > 0 && Dis < MAX){\nif (Visit[Dis][Dis] == false){\nVisit[Dis][Dis] = true;\nQ.push(make_pair(make_pair(Dis, Dis), Time + 1));\n}\nif (Visit[Dis - 1][Clip] == false){\nVisit[Dis - 1][Clip] = true;\nQ.push(make_pair(make_pair(Dis - 1, Clip), Time + 1));\n}\n}\nif (Clip > 0 && Dis + Clip < MAX){\nif (Visit[Dis + Clip][Clip] == false){\nVisit[Dis + Clip][Clip] = true;\nQ.push(make_pair(make_pair(Dis + Clip, Clip), Time + 1));\n}\n}\n}\n}\nvoid Solution(){\nint R = BFS();\ncout << R << endl;\n}\nvoid Solve(){\nInput();\nSolution();\n}\nint main(void){\nios::sync_with_stdio(false);\ncin.tie(NULL);\ncout.tie(NULL);\nSolve();\nreturn 0;\n}"
    },
    {
        "problem_tier": 15,
        "solution_code": "#include<iostream>\n#include<vector>\nusing namespace std;\nint N;\nint Arr[1000010];\nvector<int> V;\nvoid Input(){\ncin >> N;\nfor (int i = 0; i < N; i++)\ncin >> Arr[i];\n}\nvoid Solution(){\nV.push_back(Arr[0]);\nfor (int i = 1; i < N; i++){\nif (V[V.size() - 1] < Arr[i])\nV.push_back(Arr[i]);\nelse{\nint Left = 0;\nint Right = V.size() - 1;\nwhile (Left < Right){\nint Mid = (Left + Right) / 2;\nif (V[Mid] >= Arr[i])\nRight = Mid;\nelse\nLeft = Mid + 1;\n}\nV[Left] = Arr[i];\n}\n}\ncout << V.size() << endl;\n}\nvoid Solve(){\nInput();\nSolution();\n}\nint main(void){\nios::sync_with_stdio(false);\ncin.tie(NULL);\ncout.tie(NULL);\nSolve();\nreturn 0;\n}"
    },
    {
        "problem_tier": 13,
        "solution_code": "#include <iostream>\n#include <vector>\n#define INF 9999999\n#define MAX 502\nusing namespace std;\nint N, M;\nint map[MAX][MAX];\nvoid floyd() {\nfor (int k = 1; k <= N; k++) {\nfor (int i = 1; i <= N; i++) {\nfor (int j = 1; j <= N; j++) {\nif (map[i][j] > map[i][k] + map[k][j]) {\nmap[i][j] = map[i][k] + map[k][j];\n}\n}\n}\n}\n}\nint main() {\ncin >> N >> M;\nfor (int i = 1; i <= N; i++) {\nfor (int j = 1; j <= N; j++) {\nmap[i][j] = INF;\n}\n}\nfor (int i = 0; i < M; i++) {\nint a, b;\ncin >> a >> b;\nmap[a][b] = 1;\n}\nfloyd();\nint ans = 0;\nfor (int i = 1; i <= N; i++) {\nint cnt = 0;\nfor (int j = 1; j <= N; j++) {\nif (map[i][j] != INF || map[j][i] != INF) {\ncnt++;\n}\n}\nif (cnt == N - 1) ans++;\n}\ncout << ans << endl;\nreturn 0;\n}"
    },
    {
        "problem_tier": 13,
        "solution_code": "#include <iostream>\n#include <vector>\n#include <algorithm>\nusing namespace std;\nint main() {\nint n;\ncin >> n;\nvector<int> arr(n);\nfor (int i = 0; i < n; i++) {\ncin >> arr[i];\n}\nvector<int> dp(n);\nint LIS = 0;\nfor (int i = 0; i < n; i++) {\nint temp = 0;\nfor (int j = 0; j < i; j++) {\nif (arr[j] < arr[i]) {\ntemp = max(dp[j], temp);\n}\n}\ndp[i] = temp + 1;\nLIS = max(LIS, dp[i]);\n}\ncout << n - LIS << endl;\nreturn 0;\n}"
    },
    {
        "problem_tier": 17,
        "solution_code": "#include<iostream>\n#include<algorithm>\n#include<stack>\n#include<vector>\nusing namespace std;\nint N, ans, h[100002];\nstack<int> s;\nint main(){\ncin >> N;\nfor(int i=1; i<=N; i++)\ncin >> h[i];\ns.push(0);\nfor(int i=1; i<=N+1; i++){\nwhile(!s.empty() && h[s.top()] > h[i]){\nint check = s.top();\ns.pop();\nans = max(ans, h[check] * (i - s.top() - 1));\n}\ns.push(i);\n}\ncout << ans;\nreturn 0;\n}"
    },
    {
        "problem_tier": 5,
        "solution_code": "#include<iostream>\n#include<string>\nusing namespace std;\nint main(void){\nstring s1, s2;\ncin >> s1 >> s2;\nint alphabet1[26] = {};\nint alphabet2[26] = {};\nfor(int i=0;i<s1.length();i++){\nalphabet1[s1[i]-'a']++;\n}\nfor(int i=0;i<s2.length();i++){\nalphabet2[s2[i]-'a']++;\n}\nint ans = 0;\nfor(int i=0;i<26;i++){\nif(alphabet1[i]!=alphabet2[i]){\nans += abs(alphabet1[i]-alphabet2[i]);\n}\n}\ncout << ans;\nreturn 0;\n}"
    },
    {
        "problem_tier": 5,
        "solution_code": "#include<iostream>\nusing namespace std;\nint main(){\nint numList[10];\nint countList[10] = {0};\nint sum = 0;\nint max = 0;\nint maxCount = 0;\nfor(int i=0; i<10; i++){\ncin >> numList[i];\nsum += numList[i];\n}\nfor(int i=0; i<10; i++){\nfor(int j=0; j<10; j++){\nif(numList[i] == numList[j]){\ncountList[i]++;\n}\n}\n}\nfor(int i=0; i<10; i++){\nif(countList[i] > maxCount){\nmax = numList[i];\nmaxCount = countList[i];\n}\n}\ncout << sum/10 << '\\n' << max;\nreturn 0;\n}"
    },
    {
        "problem_tier": 4,
        "solution_code": "#include <iostream>\nusing namespace std;\nvoid coordinate(int x, int y, int* q1, int* q2, int* q3, int* q4, int* ax) {\nif (x == 0 || y == 0)\n(*ax)++;\nelse if (x > 0 && y > 0)\n(*q1)++;\nelse if (x < 0 && y > 0)\n(*q2)++;\nelse if (x < 0 && y < 0)\n(*q3)++;\nelse if (x > 0 && y < 0)\n(*q4)++;\n}\nint main() {\nint q1 = 0, q2 = 0, q3 = 0, q4 = 0, ax = 0;\nint n, x, y;\ncin >> n;\nfor (int i = 0; i < n; i++) {\ncin >> x >> y;\ncoordinate(x, y, &q1, &q2, &q3, &q4, &ax);\n}\ncout << \"Q1: \" << q1 << '\\n';\ncout << \"Q2: \" << q2 << '\\n';\ncout << \"Q3: \" << q3 << '\\n';\ncout << \"Q4: \" << q4 << '\\n';\ncout << \"AXIS: \" << ax << '\\n';\nreturn 0;\n}"
    },
    {
        "problem_tier": 2,
        "solution_code": "#include <iostream>\nusing namespace std;\nint main() {\nint n;\ncin >> n;\nint p1 = n * 78 / 100;\nint p2 = n * (1 - 0.2 * 0.22);\ncout << p1 << \" \" << p2;\nreturn 0;\n}"
    },
    {
        "problem_tier": 3,
        "solution_code": "#include<iostream>\n#include<algorithm>\nusing namespace std;\nint main(){\nint a, b, c, d;\ncin >> a >> b >> c >> d;\ncout << min(a + d, b + c) << endl;\nreturn 0;\n}"
    },
    {
        "problem_tier": 10,
        "solution_code": "#include<iostream>\n#include<vector>\nusing namespace std;\nconst int maxN = 1000000;\nbool isPrime[maxN + 1];\nvoid sieve() {\nfill(isPrime, isPrime + maxN + 1, true);\nisPrime[0] = isPrime[1] = false;\nfor (int i = 2; i * i <= maxN; i++) {\nif (isPrime[i]) {\nfor (int j = i * i; j <= maxN; j += i) {\nisPrime[j] = false;\n}\n}\n}\n}\nint main() {\nios_base::sync_with_stdio(0);\ncin.tie(0);\ncout.tie(0);\nsieve();\nint T;\ncin >> T;\nwhile (T--) {\nint N;\ncin >> N;\nint cnt = 0;\nfor (int i = 2; i <= N / 2; i++) {\nif (isPrime[i] && isPrime[N - i]) {\ncnt++;\n}\n}\ncout << cnt << '\\n';\n}\nreturn 0;\n}"
    },
    {
        "problem_tier": 16,
        "solution_code": "#include <iostream>\n#include <vector>\n#include <cmath>\n#define endl \"\\n\"\nusing namespace std;\nint N, M;\nvector<int> Arr;\nvector<int> Segment_Tree;\nvector<pair<int, int>> Cmd;\nint Min(int A, int B) {\nif (A < B) return A;\nreturn B;\n}\nvoid Input(){\ncin >> N >> M;\nfor (int i = 0; i < N; i++)\n{\nint a;\ncin >> a;\nArr.push_back(a);\n}\nfor (int i = 0; i < M; i++)\n{\nint a, b;\ncin >> a >> b;\nCmd.push_back(make_pair(a, b));\n}\n}\nint Make_SegmentTree(int Node, int Start, int End){\nif (Start == End)\n{\nSegment_Tree[Node] = Arr[Start];\nreturn Segment_Tree[Node];\n}\nint Mid = (Start + End) / 2;\nint Left_Result = Make_SegmentTree(Node * 2, Start, Mid);\nint Right_Result = Make_SegmentTree(Node * 2 + 1, Mid + 1, End);\nSegment_Tree[Node] = Min(Left_Result, Right_Result);\nreturn Segment_Tree[Node];\n}\nint Query(int Node, int Start, int End, int Left, int Right){\nif (Right < Start || Left > End) return 2e9;\nif (Left <= Start && End <= Right) return Segment_Tree[Node];\nint Mid = (Start + End) / 2;\nint Left_Result = Query(Node * 2, Start, Mid, Left, Right);\nint Right_Result = Query(Node * 2 + 1, Mid + 1, End, Left, Right);\nreturn Min(Left_Result, Right_Result);\n}\nvoid Solution(){\nint Tree_Height = ceil(log2(N));\nint Tree_Size = (1 << (Tree_Height + 1));\nSegment_Tree.resize(Tree_Size);\nMake_SegmentTree(1, 0, N - 1);\nfor (int i = 0; i < Cmd.size(); i++)\n{\nint Index = Cmd[i].first - 1;\nint Index2 = Cmd[i].second - 1;\ncout << Query(1, 0, N - 1, Index, Index2) << endl;\n}\n}\nvoid Solve(){\nInput();\nSolution();\n}\nint main(void){\nios::sync_with_stdio(false);\ncin.tie(NULL);\ncout.tie(NULL);\nSolve();\nreturn 0;\n}"
    },
    {
        "problem_tier": 17,
        "solution_code": "#include <iostream>\n#include <deque>\nusing namespace std;\nint main() {\nios::sync_with_stdio(false);\ncin.tie(NULL);\ncout.tie(NULL);\nint N, L;\ncin >> N >> L;\ndeque<pair<int, int>> dq;\nfor (int i = 0; i < N; i++) {\nint num;\ncin >> num;\nif (!dq.empty() && dq.front().second <= i - L) {\ndq.pop_front();\n}\nwhile (!dq.empty() && dq.back().first > num) {\ndq.pop_back();\n}\ndq.push_back({num, i});\ncout << dq.front().first << \" \";\n}\nreturn 0;\n}"
    },
    {
        "problem_tier": 7,
        "solution_code": "#include <iostream>\n#include <vector>\n#include <string>\n#include <algorithm>\nusing namespace std;\nstring sum(string a, string b) {\nint carry = 0;\nstring result = \"\";\nreverse(a.begin(), a.end());\nreverse(b.begin(), b.end());\nwhile (a.length() < b.length()) {\na += \"0\";\n}\nwhile (a.length() > b.length()) {\nb += \"0\";\n}\nfor (int i = 0; i < a.length(); i++) {\nint num = ((a[i]-'0') + (b[i]-'0') + carry) % 10;\nresult += to_string(num);\ncarry = ((a[i]-'0') + (b[i]-'0') + carry) / 10;\n}\nif (carry != 0) {\nresult += to_string(carry);\n}\nreverse(result.begin(), result.end());\nreturn result;\n}\nint main() {\nios_base::sync_with_stdio(0);\ncin.tie(0);\nint N;\ncin >> N;\nvector<string> DP(N + 1);\nDP[0] = \"0\";\nDP[1] = \"1\";\nfor (int i = 2; i <= N; i++) {\nDP[i] = sum(DP[i-1], DP[i-2]);\n}\ncout << DP[N];\nreturn 0;\n}"
    },
    {
        "problem_tier": 3,
        "solution_code": "#include <iostream>\nusing namespace std;\nint main() {\nint a, b, c;\ncin >> a >> b;\nc = b + (b - a);\ncout << c << endl;\nreturn 0;\n}"
    },
    {
        "problem_tier": 7,
        "solution_code": "#include <iostream>\n#include <vector>\n#include <algorithm>\n#include <tuple>\nusing namespace std;\nstruct student {\nstring name;\nint day, mon, year;\n};\nbool cmp(const student& x, const student& y) {\nif (x.year < y.year)\nreturn true;\nelse if (x.year == y.year) {\nif (x.mon < y.mon)\nreturn true;\nelse if (x.mon == y.mon) {\nif (x.day < y.day)\nreturn true;\nelse\nreturn false;\n}\nelse\nreturn false;\n}\nelse\nreturn false;\n}\nint main() {\nios::sync_with_stdio(false);\ncin.tie(NULL);\ncout.tie(NULL);\nint n;\ncin >> n;\nvector<student> arr;\nfor (int i = 0; i < n; i++) {\nstring x;\nint a, b, c;\ncin >> x >> a >> b >> c;\narr.push_back({ x, a, b, c });\n}\nsort(arr.begin(), arr.end(), cmp);\ncout << arr[n-1].name << \"\\n\" << arr[0].name;\nreturn 0;\n}"
    },
    {
        "problem_tier": 7,
        "solution_code": "#include <iostream>\n#include <string>\nusing namespace std;\nint main() {\nstring input;\ncin >> input;\nfor (int i = 0; i < input.size();) {\nif (input[i] == '.') {\ncout << \".\";\ni++;\n} else if (input[i] == 'X') {\nif (i + 1 < input.size() && input[i + 1] == 'X') {\nif (i + 2 < input.size() && input[i + 2] == 'X') {\nif (i + 3 < input.size() && input[i + 3] == 'X') {\ncout << \"AAAA\";\ni += 4;\n} else {\ncout << \"BB\";\ni += 2;\n}\n} else {\ncout << \"BB\";\ni += 2;\n}\n} else {\ncout << -1;\nreturn 0;\n}"
    },
    {
        "problem_tier": 14,
        "solution_code": "#include <iostream>\n#include <algorithm>\nusing namespace std;\nint N, M;\nint memory[101];\nint cost[101];\nint dp[101][10001];\nint main() {\nios_base::sync_with_stdio(false);\ncin.tie(0);\ncin >> N >> M;\nfor(int i = 1; i <= N; i++){\ncin >> memory[i];\n}\nfor(int i = 1; i <= N; i++){\ncin >> cost[i];\n}\nint sum = 0;\nfor(int i = 1; i <= N; i++){\nsum += cost[i];\n}\nfor(int i = 1; i <= N; i++){\nfor(int j = 0; j <= sum; j++){\nif(j - cost[i] >= 0)\ndp[i][j] = max(dp[i][j], dp[i-1][j-cost[i]] + memory[i]);\ndp[i][j] = max(dp[i][j], dp[i-1][j]);\n}\n}\nint result = 1000000000;\nfor(int i = 0; i <= sum; i++){\nif(dp[N][i] >= M){\nresult = min(result, i);\n}\n}\ncout << result << endl;\nreturn 0;\n}"
    },
    {
        "problem_tier": 5,
        "solution_code": "#include <iostream>\n#include <cmath>\nusing namespace std;\nint main() {\ndouble d, h, w;\ncin >> d >> h >> w;\ndouble r = sqrt(w*w + h*h);     double width = d * w / r;\ndouble height = d * h / r;\ncout << (int)height << \" \" << (int)width << endl;\nreturn 0;\n}"
    },
    {
        "problem_tier": 13,
        "solution_code": "#include <iostream>\n#include <algorithm>\nusing namespace std;\n#define MAX 1000\n#define INF 123456789\nint main() {\nint house[MAX][3];\nint dp[MAX][3];\nint n;\ncin >> n;\nfor (int i = 0; i < n; i++) {\nfor (int j = 0; j < 3; j++) {\ncin >> house[i][j];\n}\n}\nint result = INF;\nfor (int i = 0; i < 3; i++) {\nfor (int j = 0; j < 3; j++) {\nif (i == j) {\ndp[0][j] = house[0][j];\n} else {\ndp[0][j] = INF;\n}\n}\nfor (int k = 1; k < n; k++) {\ndp[k][0] = house[k][0] + min(dp[k-1][1], dp[k-1][2]);\ndp[k][1] = house[k][1] + min(dp[k-1][0], dp[k-1][2]);\ndp[k][2] = house[k][2] + min(dp[k-1][0], dp[k-1][1]);\n}\nfor (int j = 0; j < 3; j++) {\nif (i != j) {\nresult = min(result, dp[n-1][j]);\n}\n}\n}\ncout << result << '\\n';\nreturn 0;\n}"
    },
    {
        "problem_tier": 3,
        "solution_code": "#include <iostream>\nusing namespace std;\nint main() {\nint n, m, k;\ncin >> n >> m >> k;\nint row = k / m;\nint col = k % m;\ncout << row << \" \" << col << endl;\nreturn 0;\n}"
    },
    {
        "problem_tier": 6,
        "solution_code": "#include <iostream>\nusing namespace std;\nint triangleNum[45];\nvoid initTriangleNum() {\nfor (int i = 1; i < 45; i++) {\ntriangleNum[i - 1] = (i * i + i) / 2;\n}\n}\nbool isEurekaNumber(int K) {\nfor (int a = 0; a < 44; a++) {\nfor (int b = 0; b < 44; b++) {\nfor (int c = 0; c < 44; c++) {\nif (triangleNum[a] + triangleNum[b] + triangleNum[c] == K) {\nreturn true;\n}\n}\n}\n}\nreturn false;\n}\nint main() {\nint T, K;\ncin >> T;\ninitTriangleNum();\nfor (int i = 0; i < T; i++) {\ncin >> K;\nif (isEurekaNumber(K))\ncout << 1 << endl;\nelse\ncout << 0 << endl;\n}\nreturn 0;\n}"
    },
    {
        "problem_tier": 10,
        "solution_code": "#include<iostream>\n#include<vector>\nusing namespace std;\nint main() {\nios::sync_with_stdio(false);\ncin.tie(NULL);\nint N;\ncin >> N;\nvector<int> v(N), answer(N);\nfor(int i = 0; i < N; i++)\ncin >> v[i];\nfor(int i = 0; i < N; i++) {\nint j = 0;\nwhile(v[i] != 0) {\nif(answer[j] == 0) {\nv[i]--;\n}\nj++;\n}\nwhile(answer[j] != 0)\nj++;\nanswer[j] = i + 1;\n}\nfor(int i = 0; i < N; i++)\ncout << answer[i] << ' ';\nreturn 0;\n}"
    },
    {
        "problem_tier": 10,
        "solution_code": "#include <iostream>\n#include <vector>\n#include <queue>\nusing namespace std;\nint bfs(int start, vector<int> graph[], int n, int visited[]) {\nint ans = 0;\nqueue<int> q;\nvisited[start] = 1;\nq.push(start);\nwhile (!q.empty()) {\nint x = q.front();\nq.pop();\nfor (int i = 0; i < graph[x].size(); i++) {\nif (visited[graph[x][i]]) continue;\nvisited[graph[x][i]] = visited[x] + 1;\nif (visited[x] <= 2) ans++;\nq.push(graph[x][i]);\n}\n}\nreturn ans;\n}\nint main() {\nint n, m;\ncin >> n >> m;\nvector<int> graph[501];\nint visited[501];\nfor (int i = 0; i < m; i++) {\nint u, v;\ncin >> u >> v;\ngraph[u].push_back(v);\ngraph[v].push_back(u);\n}\ncout << bfs(1, graph, n, visited);\nreturn 0;\n}"
    },
    {
        "problem_tier": 11,
        "solution_code": "#include <iostream>\n#include <algorithm>\nusing namespace std;\nint dp[10001];\nint main() {\nint N;\ncin >> N;\nint arr[N+1];\nfor (int i = 1; i <= N; i++) {\ncin >> arr[i];\n}\nfor (int i = 1; i <= N; i++) {\ndp[i] = arr[i];\nfor (int j = 1; j <= i; j++) {\ndp[i] = min(dp[i], dp[i-j] + arr[j]);\n}\n}\ncout << dp[N];\nreturn 0;\n}"
    },
    {
        "problem_tier": 12,
        "solution_code": "#include <iostream>\n#include <deque>\nusing namespace std;\ndeque<int> belt;\ndeque<bool> robot;\nvoid move_belt(int N) {\nbelt.push_front(belt.back());\nbelt.pop_back();\nrobot.push_front(robot.back());\nrobot.pop_back();\nrobot[N-1] = false;\n}\nvoid move_robot(int N) {\nfor (int i = N-2; i >= 0; i--) {\nif (!robot[i+1] && belt[i+1] > 0 && robot[i]) {\nrobot[i] = false;\nrobot[i+1] = true;\nbelt[i+1]--;\n}\n}\nrobot[N-1] = false;\n}\nvoid put_robot() {\nif (!robot[0] && belt[0] > 0) {\nrobot[0] = true;\nbelt[0]--;\n}\n}\nint check(int K) {\nint count_ = 0;\nfor (int i = 0; i < 2*N; i++) {\nif (belt[i] == 0) count_++;\n}\nreturn count_;\n}\nint main() {\nint N, K;\ncin >> N >> K;\nfor (int i = 0; i < 2*N; i++) {\nint in;\ncin >> in;\nbelt.push_back(in);\nrobot.push_back(false);\n}\nint step = 1;\nwhile (true) {\nmove_belt(N);\nmove_robot(N);\nput_robot();\nint c = check(K);\nif (c >= K) {\ncout << step << endl;\nreturn 0;\n}"
    },
    {
        "problem_tier": 7,
        "solution_code": "#include <iostream>\n#include <vector>\n#include <algorithm>\nusing namespace std;\nbool DESC(int a, int b){\nreturn a > b;\n}\nint main(){\nvector<int> v;\nint N;\nint element;\ncin >> N;\nfor(int i=0; i<N; i++){\ncin >> element;\nv.push_back(element);\n}\nsort(v.begin(), v.end(), DESC);\nfor(int i=0; i<N; i++){\ncout << v[i] << \"\\n\";\n}\nreturn 0;\n}"
    },
    {
        "problem_tier": 13,
        "solution_code": "#include <iostream>\n#include <algorithm>\n#include <vector>\nusing namespace std;\nint main() {\nint n = 0, ans = 0;\ncin >> n;\nvector<int> v(n);\nfor (int i = 0; i < n; i++)\ncin >> v[i];\nsort(v.begin(), v.end());\nfor (int i = 0; i < n; i++) {\nint l = 0, r = n - 1;\nwhile (l < r) {\nif (l == i) {\nl++;\ncontinue;\n}\nif (r == i) {\nr--;\ncontinue;\n}\nif (v[i] > v[l] + v[r])\nl++;\nelse if (v[i] == v[l] + v[r]) {\nans++;\nbreak;\n}\nelse\nr--;\n}\n}\ncout << ans << \"\\n\";\nreturn 0;\n}"
    },
    {
        "problem_tier": 9,
        "solution_code": "#include <iostream>\n#include <vector>\n#include <algorithm>\nusing namespace std;\nbool cmp(string a, string b){\nif(a.size() == b.size()){\nint sumA = 0, sumB = 0;\nfor(int i=0;i<a.size();i++){\nif('1'<=a[i] && a[i]<='9')\nsumA += a[i]-'0';\nif('1'<=b[i] && b[i]<='9')\nsumB += b[i]-'0';\n}\nif(sumA == sumB)\nreturn a<b;\nreturn sumA < sumB;\n}\nreturn a.size() < b.size();\n}\nint main(){\nint n;\nvector<string> serial;\ncin >> n;\nwhile(n--){\nstring s;\ncin >> s;\nserial.push_back(s);\n}\nsort(serial.begin(), serial.end(), cmp);\nfor(auto s : serial)\ncout << s << '\\n';\nreturn 0;\n}"
    },
    {
        "problem_tier": 11,
        "solution_code": "#include<iostream>\nusing namespace std;\nlong long gcd(long long a, long long b) {\nreturn a % b ? gcd(b, a%b) : b;\n}\nint main(){\nlong long a, b;\ncin >> a >> b;\nlong long n = gcd(a, b);\nfor (long long i = 0; i < n; i++) {\ncout << \"1\";\n}\nreturn 0;\n}"
    },
    {
        "problem_tier": 12,
        "solution_code": "#include <iostream>\n#include <cmath>\n#include <vector>\nusing namespace std;\nint N;\nvector<int> primes;\nbool isPrime(int num) {\nif (num < 2) return false;\nfor (int i = 2; i <= sqrt(num); i++) {\nif (num % i == 0)\nreturn false;\n}\nreturn true;\n}\nvoid dfs(int num, int len) {\nif (len == N) {\ncout << num << \"\\n\";\nreturn;\n}\nfor (int i = 1; i <= 9; i += 2) {\nint newNum = num * 10 + i;\nif (isPrime(newNum))\ndfs(newNum, len + 1);\n}\n}\nint main() {\ncin >> N;\nprimes.push_back(2);\nprimes.push_back(3);\nprimes.push_back(5);\nprimes.push_back(7);\nfor (int prime : primes) {\ndfs(prime, 1);\n}\nreturn 0;\n}"
    },
    {
        "problem_tier": 7,
        "solution_code": "#include <iostream>\nusing namespace std;\nint main() {\nint K;\nlong long A[46];\nlong long B[46];\nA[0] = 1;\nB[0] = 0;\nA[1] = 0;\nB[1] = 1;\ncin >> K;\nfor (int i = 2; i <= K; i++) {\nA[i] = B[i-1];\nB[i] = B[i-1] + A[i-1];\n}\ncout << A[K] << \" \" << B[K] << endl;\nreturn 0;\n}"
    },
    {
        "problem_tier": 12,
        "solution_code": "#include<iostream>\nusing namespace std;\nint N;\nint arr[101];\nlong long dp[101][21];\nint main() {\nlong long ans;\ncin >> N;\nfor (int i = 1; i <= N; i++) {\ncin >> arr[i];\n}\nint target = arr[N];     dp[1][arr[1]] = 1;\nfor (int i = 2; i <= N - 1; i++) {\nfor (int j = 0; j <= 20; j++) {\nif (dp[i - 1][j] == 0) continue;                         if (j + arr[i] <= 20) {\ndp[i][j + arr[i]] += dp[i - 1][j];\n}\nif (j - arr[i] >= 0) {\ndp[i][j - arr[i]] += dp[i - 1][j];\n}\n}\n}\nans = dp[N - 1][target];     cout << ans;\nreturn 0;\n}"
    },
    {
        "problem_tier": 13,
        "solution_code": "#include <iostream>\n#include <queue>\n#include <cstring>\nusing namespace std;\nchar board[12][6];\nint ck[12][6];\nint dx[] = { 0, 0, -1, 1 };\nint dy[] = { -1, 1, 0, 0 };\nint ans;\nint boomed(int x, int y, char c) {\nqueue<pair<int, int>> q;\nqueue<pair<int, int>> popQ;\nq.push({ x, y });\npopQ.push({ x, y });\nck[x][y] = 1;\nint area = 1;\nwhile (!q.empty()) {\nint x = q.front().first;\nint y = q.front().second;\nq.pop();\nfor (int i = 0; i < 4; i++) {\nint nx = x + dx[i];\nint ny = y + dy[i];\nif (0 > nx || nx >= 12 || 0 > ny || ny >= 6) continue;\nif (ck[nx][ny] || board[nx][ny] != c) continue;\nck[nx][ny] = 1;\nq.push({ nx, ny });\npopQ.push({ nx, ny });\narea++;\n}\n}\nif (area >= 4) {\nwhile (!popQ.empty()) {\nint x = popQ.front().first;\nint y = popQ.front().second;\nboard[x][y] = '.';\npopQ.pop();\n}\n}\nreturn area;\n}\nvoid goDown() {\nqueue<char> q;\nfor (int j = 0; j < 6; j++) {\nfor (int i = 11; i >= 0; i--) {\nif (board[i][j] != '.') q.push(board[i][j]);\n}\nfor (int i = 11; i >= 0; i--) {\nboard[i][j] = '.';\n}\nint piv = 11;\nwhile (!q.empty()) {\nchar c = q.front();\nq.pop();\nboard[piv--][j] = c;\n}\n}\n}\nint main() {\nfor (int i = 0; i < 12; i++) {\ncin >> board[i];\n}\nwhile (1) {\nint area = 0;\nmemset(ck, 0, sizeof(ck));\nfor (int i = 0; i < 12; i++) {\nfor (int j = 0; j < 6; j++) {\nif (board[i][j] != '.') area = max(area, boomed(i, j, board[i][j]));\n}\n}\ngoDown();\nif (area < 4) break;\nelse ans++;\n}\ncout << ans;\nreturn 0;\n}"
    },
    {
        "problem_tier": 14,
        "solution_code": "#include <iostream>\n#include <vector>\n#include <limits.h>\nusing namespace std;\nstruct edge {\nint s, e, t;\n};\nbool bellmanFord(int n, vector<edge> edges) {\nvector<int> dist(n + 1, INT_MAX);\ndist[1] = 0;\nfor (int i = 1; i < n; i++) {\nfor (int j = 0; j < edges.size(); j++) {\nint s = edges[j].s;\nint e = edges[j].e;\nint t = edges[j].t;\nif (dist[e] > dist[s] + t) {\ndist[e] = dist[s] + t;\n}\n}\n}\nfor (int j = 0; j < edges.size(); j++) {\nint s = edges[j].s;\nint e = edges[j].e;\nint t = edges[j].t;\nif (dist[e] > dist[s] + t) {\nreturn true;\n}\n}\nreturn false;\n}\nint main() {\ncin.tie(NULL);\ncout.tie(NULL);\nios_base::sync_with_stdio(false);\nint TC;\ncin >> TC;\nwhile (TC > 0) {\nint n, m, w;\ncin >> n >> m >> w;\nvector<edge> edges;\nfor (int i = 0; i < m; i++) {\nint s, e, t;\ncin >> s >> e >> t;\nedges.push_back({s, e, t});\nedges.push_back({e, s, t});\n}\nfor (int i = 0; i < w; i++) {\nint s, e, t;\ncin >> s >> e >> t;\nedges.push_back({s, e, -t});\n}\nif (bellmanFord(n, edges)) {\ncout << \"YES\\n\";\n} else {\ncout << \"NO\\n\";\n}\nTC--;\n}\nreturn 0;\n}"
    },
    {
        "problem_tier": 9,
        "solution_code": "#include<iostream>\n#include<vector>\n#include<algorithm>\nusing namespace std;\nvector<int> v;\nint main()\n{\nios::sync_with_stdio(false);\ncin.tie(NULL);\nint n;\ncin >> n;\nfor(int i=0;i<n;i++){\nint x;\ncin >> x;\nv.push_back(x);\n}\nif(prev_permutation(v.begin(),v.end())){\nfor(int i=0;i<n;i++){\ncout << v[i] << \" \";\n}\n}else{\ncout<<-1<<\"\\n\";\n}\nreturn 0;\n}"
    },
    {
        "problem_tier": 12,
        "solution_code": "#include <iostream>\n#include <queue>\n#include <algorithm>\n#include <cstring>\n#include <vector>\nusing namespace std;\nvector<long long> v;\nvoid fun(int target) {\nqueue<long long> q;\nfor (int i = 0; i <= 9; i++) {\nq.push(i);\nv.push_back(i);\n}\nwhile (!q.empty()) {\nlong long num = q.front();\nint last = num % 10;\nq.pop();\nfor (int i = 0; i < last; i++) {\nlong long newnum = num * 10 + i;\nq.push(newnum);\nv.push_back(newnum);\n}\n}\nif (target >= v.size()) {\ncout << -1;\n}\nelse {\ncout << v[target];\n}\n}\nint main() {\nint N;\ncin >> N;\nfun(N);\nreturn 0;\n}"
    },
    {
        "problem_tier": 4,
        "solution_code": "#include <iostream>\n#include <string>\nusing namespace std;\nint main() {\nint N;\nstring votes;\nint A = 0, B = 0;\ncin >> N >> votes;\nfor (int i = 0; i < N; i++) {\nif (votes[i] == 'A')\nA++;\nelse\nB++;\n}\nif (A > B)\ncout << \"A\\n\";\nelse if (B > A)\ncout << \"B\\n\";\nelse\ncout << \"Tie\\n\";\nreturn 0;\n}"
    },
    {
        "problem_tier": 13,
        "solution_code": "#include <iostream>\n#include <vector>\n#include <cstring>\n#include <algorithm>\n#include <queue>\nusing namespace std;\nint n;\nint population[11];\nbool check[11];\nbool arr[11][11];\nbool visit[11];\nint answer = 987654321;\nbool bfs(vector<int> v, bool t) {\nmemset(visit, false, sizeof(visit));\nvisit[v[0]] = true;\nqueue<int> q;\nq.push(v[0]);\nint cnt = 1;\nwhile (!q.empty()) {\nint x = q.front();\nq.pop();\nfor (int i = 1; i <= n; i++) {\nif (check[i] == t && arr[x][i] == true && visit[i] == false) {\nvisit[i] = true;\nq.push(i);\ncnt++;\n}\n}\n}\nif (v.size() == cnt) return true;\nreturn false;\n}\nvoid calculate() {\nint agroup = 0;\nint bgroup = 0;\nfor (int i = 1; i <= n; i++) {\nif (check[i] == true) agroup += population[i];\nelse bgroup += population[i];\n}\nint result = agroup - bgroup;\nif (result < 0) result *= (-1);\nanswer = min(answer, result);\n}\nbool right() {\nvector<int> a, b;\nfor (int i = 1; i <= n; i++) {\nif (check[i] == true) a.push_back(i);\nelse b.push_back(i);\n}\nif (bfs(a, true) != true) return false;\nif (bfs(b, false) != true) return false;\nreturn true;\n}\nvoid dfs(int x, int cnt) {\nif (cnt >= 1) {\nif (right() == true)\ncalculate();\n}\nif (cnt == n - 1)\nreturn;\nfor (int i = x; i <= n; i++) {\nif (check[i] == true) continue;\ncheck[i] = true;\ndfs(i, cnt + 1);\ncheck[i] = false;\n}\n}\nint main() {\ncin >> n;\nfor (int i = 1; i <= n; i++)\ncin >> population[i];\nfor (int i = 1; i <= n; i++) {\nint cnt;\ncin >> cnt;\nfor (int j = 0; j < cnt; j++) {\nint x; cin >> x;\narr[i][x] = true;\narr[x][i"
    },
    {
        "problem_tier": 8,
        "solution_code": "#include <iostream>\n#include <vector>\nusing namespace std;\nbool checkBingo(vector<vector<int>>& board) {\nint bingoCount = 0;\nfor (int i = 0; i < 5; i++) {\nbool valid = false;\nfor (int j = 0; j < 5; j++) {\nif (board[i][j] != 0) {\nvalid = true;\nbreak;\n}\n}\nif (!valid) {\nbingoCount++;\n}\n}\nfor (int i = 0; i < 5; i++) {\nbool valid = false;\nfor (int j = 0; j < 5; j++) {\nif (board[j][i] != 0) {\nvalid = true;\nbreak;\n}\n}\nif (!valid) {\nbingoCount++;\n}\n}\nbool valid = false;\nfor (int i = 0; i < 5; i++) {\nif (board[i][i] != 0) {\nvalid = true;\n}\nif (valid) {\nbreak;\n}\n}\nif (!valid) {\nbingoCount++;\n}\nvalid = false;\nfor (int i = 4; i >= 0; i--) {\nif (board[i][4 - i] != 0) {\nvalid = true;\nbreak;\n}\n}\nif (!valid) {\nbingoCount++;\n}\nif (bingoCount >= 3) {\nreturn true;\n}\nreturn false;\n}\nint main() {\nvector<vector<int>> board(5, vector<int>(5));\nfor (int i = 0; i < 5; i++) {\nfor (int j = 0; j < 5; j++) {\ncin >> board[i][j];\n}\n}\nint count = 0;\nint num;\nfor (int i = 0; i < 5; i++) {\nfor (int j = 0; j < 5; j++) {\ncin >> num;\ncount++;\nfor (int k = 0; k < 5; k++) {\nfor (int q = 0; q < 5; q++) {\nif (board[k][q] == num) {\nboard[k][q] = 0;\n}\n}\n}\nif (checkBingo(board)) {\ncout << count-1;\nreturn 0;\n}"
    },
    {
        "problem_tier": 2,
        "solution_code": "#include<iostream>\nusing namespace std;\nint main(){\nint n1, n2, k1, k2;\ncin >> n1 >> k1 >> n2 >> k2;\ncout << n1 * k1 + n2 * k2;\nreturn 0;\n}"
    },
    {
        "problem_tier": 9,
        "solution_code": "#include <iostream>\n#include <vector>\n#include <string>\n#include <cstring>\nusing namespace std;\ntypedef struct {\nint Number;\nint Strike;\nint Ball;\n} Game;\nint N;\nbool Can_Number[1000];\nvector<Game> V;\nvoid Initialize() {\nmemset(Can_Number, true, sizeof(Can_Number));\nfor (int i = 123; i <= 999; i++) {\nstring Tmp = to_string(i);\nif (Tmp[0] == Tmp[1] || Tmp[0] == Tmp[2] || Tmp[1] == Tmp[2])\nCan_Number[i] = false;\nif (Tmp[0] - '0' == 0 || Tmp[1] - '0' == 0 || Tmp[2] - '0' == 0)\nCan_Number[i] = false;\n}\n}\nvoid Input() {\ncin >> N;\nfor (int i = 0; i < N; i++) {\nint a, b, c;\ncin >> a >> b >> c;\nGame G;\nG.Number = a;\nG.Strike = b;\nG.Ball = c;\nV.push_back(G);\n}\n}\nvoid Solution() {\nfor (int i = 0; i < V.size(); i++) {\nint Num = V[i].Number;\nint Strike = V[i].Strike;\nint Ball = V[i].Ball;\nstring Origin = to_string(Num);\nfor (int j = 123; j <= 999; j++) {\nint Tmp_Strike = 0;\nint Tmp_Ball = 0;\nif (Can_Number[j] == true) {\nstring Tmp = to_string(j);\nfor (int a = 0; a < 3; a++) {\nfor (int b = 0; b < 3; b++) {\nif (a == b && Origin[a] == Tmp[b])\nTmp_Strike++;\nif (a != b && Origin[a] == Tmp[b])\nTmp_Ball++;\n}\n}\nif (Strike != Tmp_Strike || Ball != Tmp_Ball)\nCan_Number[j] = false;\n}\n}\n}\nint Answer = 0;\nfor (int i = 123; i <= 999; i++) {\nif (Can_Number[i] == true)\nAnswer++;\n}\ncout << Answer << endl;\n}\nvoid Solve() {\nInitialize();\nInput();\nSolution();\n}\nint main(void) {\nios::sync_with_stdio(false);\ncin.tie(NULL);\ncout.tie(NULL);\nSolve();\nreturn 0;\n}"
    },
    {
        "problem_tier": 13,
        "solution_code": "#include <iostream>\n#include <queue>\n#include <cstring>\nusing namespace std;\n#define MAX 1000\n#define X second\n#define Y first\nint dx[4] = {0, 0, -1, 1};\nint dy[4] = {1, -1, 0, 0};\nchar map[MAX][MAX];\nint w, h;\nqueue<pair<int, int>> sq;\nqueue<pair<int, int>> fq;\nvoid MoveFire(){\nint cnt = fq.size();\nfor(int i=0; i<cnt; i++){\npair<int, int> cur = fq.front();\nfq.pop();\nfor(int dir=0; dir<4; dir++){\nint nx = cur.X + dx[dir];\nint ny = cur.Y + dy[dir];\nif(ny < 0 || nx < 0 || ny >= h || nx >= w)\ncontinue;\nif(map[ny][nx] != '.')\ncontinue;\nmap[ny][nx] = '*';\nfq.push({ny, nx});\n}\n}\n}\nint MoveS(){\nint time = 0;\nwhile(!sq.empty()){\ntime++;\nMoveFire();\nint cnt = sq.size();\nfor(int i=0; i<cnt; i++){\npair<int, int> cur = sq.front();\nsq.pop();\nfor(int dir=0; dir<4; dir++){\nint nx = cur.X + dx[dir];\nint ny = cur.Y + dy[dir];\nif(ny < 0 || nx < 0 || ny >= h || nx >= w)\nreturn time;\nif(map[ny][nx] != '.')\ncontinue;\nmap[ny][nx] = '@';\nsq.push({ny, nx});\n}\n}\n}\nreturn -1;\n}\nvoid Reset(int w, int h){\nfor(int y=0; y<h; y++){\nfor(int x=0; x<w; x++){\nmap[y][x] = '.';\n}\n}\nwhile(!sq.empty())\nsq.pop();\nwhile(!fq.empty())\nfq.pop();\n}\nint main(){\nint t;\ncin >> t;\nfor(int i=0; i<t; i++){\ncin >> w >> h;\nfor(int y=0; y<h; y++){\nfor(int x=0; x<w; x++){\ncin >> map[y][x];\nif(map[y][x] == '@')\nsq.push({y, x});\nelse if(map[y][x] == '*')\nfq.push({y, x});\n}\n}\nint time = MoveS();\nif(time == -1)\ncout << \"IMPOSSIBLE\" << endl;\nelse\ncout << time << endl;\nReset(w, h);\n}\nreturn 0;\n}"
    },
    {
        "problem_tier": 11,
        "solution_code": "#include <iostream>\n#include <vector>\n#include <algorithm>\ntypedef long long ll;\nusing namespace std;\nint n, m;\nvector<int> lessons;\nint getBlueRayCount(int mid) {\nint cnt = 0;\nint sum = 0;\nfor (int i = 0; i < n; i++) {\nsum += lessons[i];\nif (sum > mid) {\ni--;\nsum = 0;\ncnt++;\n}\n}\nreturn cnt;\n}\nint binarySearch() {\nint left = *max_element(lessons.begin(), lessons.end());\nint right = 1000000000;\nwhile (left <= right) {\nint mid = (left + right) / 2;\nint cnt = getBlueRayCount(mid);\nif (cnt >= m)\nleft = mid + 1;\nelse\nright = mid - 1;\n}\nreturn left;\n}\nint main() {\ncin >> n >> m;\nfor (int i = 0; i < n; i++) {\nint lesson;\ncin >> lesson;\nlessons.push_back(lesson);\n}\ncout << binarySearch();\nreturn 0;\n}"
    },
    {
        "problem_tier": 4,
        "solution_code": "#include <iostream>\nint main() {\nlong long n;\nstd::cin >> n;\nstd::cout << n * n * n << \"\\n3\";\nreturn 0;\n}"
    },
    {
        "problem_tier": 4,
        "solution_code": "#include <iostream>\nusing namespace std;\nint main() {\nint T;\ncin >> T;\nwhile(T--) {\nint Y[9], K[9], Ysum = 0, Ksum = 0;\nfor(int i = 0; i < 9; i++) {\ncin >> Y[i] >> K[i];\nYsum += Y[i];\nKsum += K[i];\n}\nif(Ysum > Ksum) {\ncout << \"Yonsei\" << endl;\n}\nelse if(Ysum < Ksum) {\ncout << \"Korea\" << endl;\n}\nelse {\ncout << \"Draw\" << endl;\n}\n}\nreturn 0;\n}"
    },
    {
        "problem_tier": 14,
        "solution_code": "#include <iostream>\n#include <vector>\n#include <queue>\nusing namespace std;\nint N, M;\nint inDeg[1002] = { 0, };\nvector<int> v[1002];\nvector<int> ans;\nint main() {\ncin >> N >> M;\nwhile (M--) {\nint sNum;\nint s1, s2;\ncin >> sNum;\nif (sNum == 0) continue;\ncin >> s1;\nif (sNum == 1) continue;\nfor (int i = 0; i < sNum - 1; i++) {\ncin >> s2;\nv[s1].push_back(s2);\ninDeg[s2]++;\ns1 = s2;\n}\n}\nqueue<int> q;\nfor (int i = 1; i <= N; i++) {\nif (inDeg[i] == 0) {\nq.push(i);\n}\n}\nwhile (!q.empty()) {\nint s = q.front();\nq.pop();\nans.push_back(s);\nfor (int i = 0; i < v[s].size(); i++) {\nint next = v[s][i];\ninDeg[next]--;\nif (inDeg[next] == 0) {\nq.push(next);\n}\n}\n}\nif (ans.size() != N) {\ncout << 0 << endl;\nreturn 0;\n}"
    },
    {
        "problem_tier": 15,
        "solution_code": "#include <iostream>\n#include <vector>\n#include <algorithm>\nusing namespace std;\nint main() {\nint N;\ncin >> N;\nvector<int> arr(N);\nfor (int i = 0; i < N; i++) {\ncin >> arr[i];\n}\nsort(arr.begin(), arr.end());\nint result = 1;\nfor (int i = 0; i < N; i++) {\nif (arr[i] > result) {\nbreak;\n}\nresult += arr[i];\n}\ncout << result << endl;\nreturn 0;\n}"
    },
    {
        "problem_tier": 11,
        "solution_code": "#include <iostream>\n#include <vector>\n#include <queue>\n#include <algorithm>\nusing namespace std;\n#define MAX 102\nbool trash[MAX][MAX] = { false, };\nbool visited[MAX][MAX] = { false, };\nint dx[4] = { 0, 0, 1, -1 };\nint dy[4] = { 1, -1, 0, 0 };\nint N, M, K;\nint maxSize = 0;\nvoid DFS(int x, int y) {\nvisited[x][y] = true;\nmaxSize++;\nfor (int i = 0; i < 4; i++) {\nint nx = x + dx[i];\nint ny = y + dy[i];\nif (nx < 1 || ny < 1 || nx > N || ny > M) continue;\nif (visited[nx][ny] == false && trash[nx][ny] == true) {\nDFS(nx, ny);\n}\n}\n}\nint main() {\nios_base::sync_with_stdio(false);\ncin.tie(NULL);\ncout.tie(NULL);\ncin >> N >> M >> K;\nfor (int i = 0; i < K; i++) {\nint r, c;\ncin >> r >> c;\ntrash[r][c] = true;\n}\nfor (int i = 1; i <= N; i++) {\nfor (int j = 1; j <= M; j++) {\nif (trash[i][j] == true && visited[i][j] == false) {\nmaxSize = 0;\nDFS(i, j);\n}\n}\n}\ncout << maxSize << \"\\n\";\nreturn 0;\n}"
    },
    {
        "problem_tier": 2,
        "solution_code": "#include <iostream>\n#include <ctime>\nint main() {\ntime_t curr_time = time(NULL);\nstruct tm* curr_tm = localtime(&curr_time);\nint curr_year = curr_tm->tm_year + 1900;\nint curr_month = curr_tm->tm_mon + 1;\nint curr_day = curr_tm->tm_mday;\nstd::cout << curr_year << std::endl;\nstd::cout << curr_month << std::endl;\nstd::cout << curr_day;\nreturn 0;\n}"
    },
    {
        "problem_tier": 13,
        "solution_code": "#include <iostream>\n#include <vector>\nusing namespace std;\nint map[9][9];\nint cnt = 0;\nbool flag = false;\nvector<pair<int, int>> vacant;\nbool visit[81] = { false, };\nvoid print() {\nfor (int i = 0; i < 9; i++) {\nfor (int j = 0; j < 9; j++) {\ncout << map[i][j];\n}\ncout << '\\n';\n}\n}\nbool possible(int x, int y, int num) {\nfor (int i = 0; i < 9; i++) {\nif (map[y][i] == num || map[i][x] == num)\nreturn false;\n}\nint start_x = x / 3;\nint start_y = y / 3;\nfor (int i = 0; i < 3; i++) {\nfor (int j = 0; j < 3; j++) {\nif (map[start_y * 3 + i][start_x * 3 + j] == num)\nreturn false;\n}\n}\nreturn true;\n}\nvoid dfs(int c) {\nif (c == cnt) {\nprint();\nflag = true;\nreturn;\n}\nif (visit[c]) return;\nvisit[c] = true;\nint x = vacant[c].first;\nint y = vacant[c].second;\nfor (int k = 1; k <= 9; k++) {\nif (possible(x, y, k)) {\nmap[y][x] = k;\ndfs(c + 1);\nif (flag) return;\nmap[y][x] = 0;\n}\n}\nif (flag) return;\nvisit[c] = false;\n}\nint main() {\nfor (int i = 0; i < 9; i++) {\nstring str;\ncin >> str;\nfor (int j = 0; j < 9; j++) {\nmap[i][j] = (int)(str[j] - '0');\nif (map[i][j] == 0) {\nvacant.push_back({j, i});\ncnt++;\n}\n}\n}\ndfs(0);\nreturn 0;\n}"
    },
    {
        "problem_tier": 14,
        "solution_code": "#include<iostream>\n#include<algorithm>\n#include<vector>\n#include<queue>\n#include<limits.h>\nusing namespace std;\ntypedef pair<int, int> P;\nint arr[51][51], visited[51][51];\nint n, m, res = INT_MAX;\nint dx[] = { 0,0,1,-1 };\nint dy[] = { 1,-1,0,0 };\nstruct node {\nint x, y, vis;\n};\nvector<node> vir;\nqueue<P> q;\nvoid bfs() {\nwhile (!q.empty()) {\nP now = q.front();\nq.pop();\nfor (int i = 0; i < 4; i++) {\nint nx = now.first + dx[i];\nint ny = now.second + dy[i];\nif (nx < 0 || nx >= n || ny < 0 || ny >= n)\ncontinue;\nif (arr[nx][ny] != 1 && visited[nx][ny] == -1) {\nvisited[nx][ny] = visited[now.first][now.second] + 1;\nq.push({ nx,ny });\n}\n}\n}\nint time = 0;\nbool flag = true;\nfor (int i = 0; i < n; i++) {\nfor (int j = 0; j < n; j++) {\nif (arr[i][j] == 0) {\nif (visited[i][j] == -1) {\nflag = false;\nbreak;\n}\nelse\ntime = max(time, visited[i][j]);\n}\n}\n}\nif (flag)\nres = min(res, time);\n}\nvoid virus(int cnt, int idx) {\nif (cnt == m) {\nfor (int i = 0; i < n; i++) {\nfor (int j = 0; j < n; j++) {\nvisited[i][j] = -1;\n}\n}\nfor (int i = 0; i < vir.size(); i++) {\nif (vir[i].vis == 1) {\nq.push({ vir[i].x, vir[i].y });\nvisited[vir[i].x][vir[i].y] = 0;\n}\n}\nbfs();\nreturn;\n}\nfor (int i = idx; i < vir.size(); i++) {\nif (vir[i].vis == 1)\ncontinue;\nvir[i].vis = 1;\nvirus(++cnt, ++idx);\nvir[i].vis = 0;\ncnt--;\n}\n}\nint main() {\nios::sync_with_stdio(false);\ncin.tie(NULL);\ncout.tie(NULL);\ncin >> n >> m;\nfor (int i = 0; i < n; i++) {\nfor (int j = 0; j < n; j++) {\ncin >> arr[i][j];\nif (arr[i][j] == 2)\nvir.push_back({ i,j,0 });\n}\n}\nvirus(0, 0);\nif (res == INT_MAX)\ncout << -1;\nelse\ncout << res;\nreturn 0;\n}"
    },
    {
        "problem_tier": 8,
        "solution_code": "#include <iostream>\nusing namespace std;\nint main() {\nint N;\ncin >> N;\nif (N % 2 == 1) {\ncout << \"CY\" << endl;\n} else {\ncout << \"SK\" << endl;\n}\nreturn 0;\n}"
    },
    {
        "problem_tier": 4,
        "solution_code": "#include <iostream>\nusing namespace std;\nint main() {\nios_base::sync_with_stdio(false);\ncin.tie(NULL);\nlong long n, sum = 0;\ncin >> n;\ncout << (n * (n-1)) / 2 << \"\\n2\";\nreturn 0;\n}"
    },
    {
        "problem_tier": 14,
        "solution_code": "#include <iostream>\n#include <vector>\n#include <algorithm>\n#include <cmath>\nusing namespace std;\nint n;\nint parent[101];\nint s[101];\nstruct Edge {\nint v1, v2;\ndouble dist;\nEdge(int v1, int v2, double dist) {\nthis->v1 = v1;\nthis->v2 = v2;\nthis->dist = dist;\n}\nbool operator < (const Edge &a) {\nreturn dist < a.dist;\n}\n};\nvector<pair<double, double>> star;\nvector<Edge> e;\nint Find(int a) {\nif (a == parent[a]) return a;\nreturn parent[a] = Find(parent[a]);\n}\nint main() {\ncin >> n;\ndouble a, b;\nfor (int i = 0; i < n; i++) {\ncin >> a >> b;\nstar.push_back({a, b});\nparent[i] = i;\ns[i] = 1;\n}\nfor (int i = 0; i < star.size(); i++) {\nfor (int j = i + 1; j < star.size(); j++) {\ndouble x = star[i].first - star[j].first;\ndouble y = star[i].second - star[j].second;\ndouble diff = sqrt(pow(x, 2) + pow(y, 2));\ne.push_back({i, j, diff});\n}\n}\ndouble result = 0;\nsort(e.begin(), e.end());\nfor (int i = 0; i < e.size(); i++) {\nint v1 = Find(e[i].v1);\nint v2 = Find(e[i].v2);\nif (v1 == v2) continue;\nif (s[v1] < s[v2]) swap(v1, v2);\nparent[v2] = v1;\ns[v1] += s[v2];\nresult += e[i].dist;\n}\ncout << fixed;\ncout.precision(2);\ncout << result;\nreturn 0;\n}"
    },
    {
        "problem_tier": 4,
        "solution_code": "#include<iostream>\nusing namespace std;\nint main(void) {\nint n;\ncin >> n;\nfor (int i = 0; i < n; i++) {\nfor (int j = 0; j < n - 1 - i; j++) {\ncout << \" \";\n}\ncout << \"*\";\nfor (int j = 0; j < 2 * i - 1; j++) {\ncout << \" \";\n}\nif (i != 0) {\ncout << \"*\";\n}\ncout << \"\\n\";\n}\nreturn 0;\n}"
    },
    {
        "problem_tier": 5,
        "solution_code": "#include <iostream>\n#include <string>\nusing namespace std;\nint main() {\ndouble n;\nint test;\ncin >> test;\nwhile (test--) {\ncin >> n;\nstring x;\ncin.ignore();\ngetline(cin, x);\nfor (int i = 0; i < x.size(); i++) {\nswitch (x[i]) {\ncase '@':\nn *= 3;\nbreak;\ncase '#':\nn -= 7;\nbreak;\ncase '%':\nn += 5;\nbreak;\n}\n}\ncout << fixed;\ncout.precision(2);\ncout << n << \"\\n\";\n}\nreturn 0;\n}"
    },
    {
        "problem_tier": 14,
        "solution_code": "#include <iostream>\n#include <vector>\n#include <queue>\n#include <cstring>\n#include <algorithm>\n#define MAX 15\nusing namespace std;\nint N, M, D;\nint MAP[MAX][MAX];\nint copyMap[MAX][MAX];\nbool visited[MAX][MAX];\nbool check[MAX][MAX];\nint res = INT_MIN;\nint dx[3] = {0, -1, 0}; int dy[3] = {-1, 0, 1};\nvoid mapToCopy() {\nmemset(check, false, sizeof(check));\nfor(int i=0; i<N; i++){\nfor(int j=0; j<M; j++){\ncopyMap[i][j] = MAP[i][j];\n}\n}\n}\nvoid game(int a, int b, int c){\nmapToCopy();\nint archer[3] = {a, b, c};\nint pos = N;\nint kill = 0;\nwhile(pos > 0){\nfor(int i=0; i<3; i++){\nmemset(visited, false, sizeof(visited));\nint arX = pos;\nint arY = archer[i];\nqueue<pair<int, int>> Q;\nQ.push({arX-1, arY});\nvisited[arX-1][arY] = true;\nwhile(!Q.empty()){\nint nowX = Q.front().first;\nint nowY = Q.front().second;\nQ.pop();\nif(copyMap[nowX][nowY] == 1){                     check[nowX][nowY] = true;\nbreak;\n}\nfor(int j=0; j<3; j++){\nint nx = nowX + dx[j];\nint ny = nowY + dy[j];\nif(nx<0 || ny<0 || nx>=N || ny>=M) continue;\nif(!visited[nx][ny] && (abs(arX-nx)+abs(arY-ny) <= D)){\nvisited[nx][ny] = true;\nQ.push({nx, ny});\n}\n}\n}\n}\nfor(int i=0; i<N; i++){\nfor(int j=0; j<M; j++){\nif(check[i][j]){\ncopyMap[i][j] = 0;\n}\n}\n}\npos--;\n}\nfor(int i=0; i<N; i++){\nfor(int j=0; j<M; j++){\nif(check[i][j]){\nkill++;\n}\n}\n}\nres = max(res, kill);\n}\nint main(){\nios_base::sync_with_stdio(0);\ncin.tie(0);\ncin >> N >> M >> D;\nfor(int i=0; i<N; i++){\nfor(int j=0; j<M; j++){\ncin >> MAP[i][j];\n}\n}\nfor(int i=0; i<M-2; i++){\nfor(int j=i+1; j<M-1; j++){\nfor(int k=j+1; k<M; k++){\ngame(i, j, k);\n}\n}\n}\ncout << res;\nreturn 0;\n}"
    },
    {
        "problem_tier": 1,
        "solution_code": "#include<iostream>\nusing namespace std;\nint main() {\ncout << \"10/14\" << endl;\nreturn 0;\n}"
    },
    {
        "problem_tier": 7,
        "solution_code": "#include <iostream>\n#include <algorithm>\nusing namespace std;\nstruct country {\nint country_number;\nint gold;\nint silver;\nint bronze;\n};\nbool cmp(country a, country b) {\nif (a.gold > b.gold)\nreturn true;\nelse if (a.gold == b.gold) {\nif (a.silver > b.silver)\nreturn true;\nif (a.silver == b.silver) {\nif (a.bronze > b.bronze)\nreturn true;\n}\n}\nreturn false;\n}\ncountry arr[1001];\nint n, k;\nint n1, n2, n3, n4;\nint result = 0, val = 0;\nint main() {\ncin >> n >> k;\nfor (int i = 0; i < n; i++) {\ncin >> n1 >> n2 >> n3 >> n4;\narr[i].country_number = n1;\narr[i].gold = n2;\narr[i].silver = n3;\narr[i].bronze = n4;\n}\nsort(arr, arr + n, cmp);\nfor (int i = 0; i < n; i++) {\nif (arr[i].country_number == k) {\nresult = i;\nbreak;\n}\n}\nfor (int i = result - 1;; i--) {\nif (arr[i].gold != arr[result].gold || arr[i].silver != arr[result].silver || arr[i].bronze != arr[result].bronze) {\nbreak;\n}\nval++;\n}\ncout << result - val + 1 << endl;\nreturn 0;\n}"
    },
    {
        "problem_tier": 12,
        "solution_code": "#include <iostream>\n#include <vector>\n#include <cmath>\n#include <algorithm>\nusing namespace std;\ndouble solve(vector<double> x, vector<double> y, int n) {\ndouble answer = 0.0;\nfor (int i = 2; i < n; i++) {\nanswer += x[0] * y[i-1] + x[i-1] * y[i] + x[i] * y[0];\nanswer -= x[i-1] * y[0] + x[i] * y[i-1] + x[0] * y[i];\n}\nreturn answer;\n}\nint main() {\nint n;\ncin >> n;\nvector<double> x(n, 0);\nvector<double> y(n, 0);\nfor (int i = 0; i < n; i++) {\ncin >> x[i];\ncin >> y[i];\n}\ndouble answer = solve(x, y, n) / 2;\ncout << fixed;\ncout.precision(1);\ncout << abs(answer) << endl;\nreturn 0;\n}"
    },
    {
        "problem_tier": 17,
        "solution_code": "#include <iostream>\n#include <algorithm>\n#include <vector>\n#include <stack>\nusing namespace std;\nint main(){\nios::sync_with_stdio(false);\ncin.tie(NULL);\ncout.tie(NULL);\nint N;\ncin >> N;\nint* num = new int[N];\nint* dp = new int[N];\nint a;\nint idx, dp_tmp = 0;\nvector<int> L;\nstack<int> s;\nvector<int>::iterator p;\nfor(int i=0; i<N; i++){\ncin >> a;\nnum[i] = a;\nif(L.size() == 0){\nL.push_back(num[i]);\ndp[i] = 1;\n}\nelse{\nif(L[L.size()-1] < num[i]){\nL.push_back(num[i]);\ndp[i] = L.size();\n}\nelse{\np = lower_bound(L.begin(), L.end(), num[i]);\n*(p) = num[i];\ndp[i] = p - L.begin() + 1;\n}\n}\nif(dp[i] > dp_tmp){\nidx = i;\ndp_tmp = dp[i];\n}\n}\ncout << L.size();\ns.push(num[idx]);\nfor(int i=idx-1; i>=0; i--){\nif(num[i] < num[idx] && dp[i]+1 == dp[idx]){\nidx = i;\ns.push(num[i]);\n}\n}\ncout << \"\\n\";\nwhile(!s.empty()){\ncout << s.top() << \" \";\ns.pop();\n}\nreturn 0;\n}"
    },
    {
        "problem_tier": 17,
        "solution_code": "#include <iostream>\n#include <vector>\n#include <algorithm>\n#include <string>\nusing namespace std;\nstring T, P;\nvector<int> pi; vector<int> result;\nvoid make_text() {\ngetline(cin, T);\ngetline(cin, P);\n}\nvoid get_pi(string p) {\nint m = p.size();\nint j = 0;\npi.resize(m, 0);\nfor (int i = 1; i < m; i++) {\nwhile ((j > 0) && (p[i] != p[j])) {\nj = pi[j - 1];\n}\nif (p[i] == p[j]) {\nj++;\npi[i] = j;\n}\n}\n}\nvoid kmp(string t, string p) {\nint n = t.size();\nint m = p.size();\nint j = 0;\nfor (int i = 0; i < n; i++) {\nwhile ((j > 0) && (t[i] != p[j])) {\nj = pi[j-1];\n}\nif (t[i] == p[j]) {\nif (j == (m - 1)) {\nresult.push_back(i - m + 1);\nj = pi[j];\n}\nelse {\nj++;\n}\n}\n}\n}\nint main() {\nios::sync_with_stdio(false);\ncin.tie(NULL);\ncout.tie(NULL);\nmake_text();\nget_pi(P);\nkmp(T, P);\ncout << result.size() << '\\n';\nfor (int i = 0; i < result.size(); i++)\ncout << result[i] + 1 << '\\n';\nreturn 0;\n}"
    },
    {
        "problem_tier": 4,
        "solution_code": "#include <iostream>\nusing namespace std;\nint main() {\nint n, as = 100, bs = 100;\ncin >> n;\nwhile (n--) {\nint a, b;\ncin >> a >> b;\nif (a > b)\nbs -= a;\nelse if (a < b)\nas -= b;\n}\ncout << as << '\\n' << bs << '\\n';\n}\n"
    },
    {
        "problem_tier": 12,
        "solution_code": "#include <iostream>\n#include <vector>\nusing namespace std;\nint main() {\nint H, W;\ncin >> H >> W;\nvector<int> blocks(W);\nfor (int i = 0; i < W; i++) {\ncin >> blocks[i];\n}\nint Answer = 0;\nfor (int i = 1; i < W - 1; i++) {\nint leftMax = 0;\nint rightMax = 0;\nfor (int j = 0; j < i; j++) {\nleftMax = max(leftMax, blocks[j]);\n}\nfor (int j = i + 1; j < W; j++) {\nrightMax = max(rightMax, blocks[j]);\n}\nint height = min(leftMax, rightMax);\nif (height > blocks[i]) {\nAnswer += height - blocks[i];\n}\n}\ncout << Answer << endl;\nreturn 0;\n}"
    },
    {
        "problem_tier": 5,
        "solution_code": "#include<iostream>\n#include<algorithm>\n#include<vector>\nusing namespace std;\nint main() {\nios_base::sync_with_stdio(0);\ncin.tie(0);\ncout.tie(0);\nint n, tmp;\ncin >> n;\nvector<int> arr(n);\nfor(int i=1; i<=n; i++){\ncin >> tmp;\narr.insert(arr.begin()+tmp, i);\n}\nfor(int i=n-1; i>=0; i--)\ncout << arr[i] << ' ';\nreturn 0;\n}"
    },
    {
        "problem_tier": 16,
        "solution_code": "#include <iostream>\n#define MOD 1000000007\ntypedef long long ll;\nusing namespace std;\nll pow(ll n, ll k) {\nll ret = 1;\nwhile (k) {\nif (k % 2)\nret = (ret * n) % MOD;\nn = (n * n) % MOD;\nk /= 2;\n}\nreturn ret;\n}\nint main() {\nint n, k;\ncin >> n >> k;\nll A = 1, B = 1;\nfor (int i = n; i >= n - k + 1; --i)\nA = (A * i) % MOD;\nfor (int i = 2; i <= k; ++i)\nB = (B * i) % MOD;\ncout << (A * pow(B, MOD - 2)) % MOD;\nreturn 0;\n}"
    },
    {
        "problem_tier": 11,
        "solution_code": "#include <iostream>\n#include <vector>\nusing namespace std;\nvector<vector<int>> matrixA(51, vector<int>(51, 0));\nvector<vector<int>> matrixB(51, vector<int>(51, 0));\nvector<vector<bool>> isFlipped(51, vector<bool>(51, false));\nvoid flip(int m, int n) {\nfor (int i = m; i < m + 3; i++) {\nfor (int j = n; j < n + 3; j++) {\nisFlipped[i][j] = !isFlipped[i][j];\n}\n}\n}\nint main() {\nint m, n;\ncin >> m >> n;\nfor (int i = 0; i < m; i++) {\nfor (int j = 0; j < n; j++) {\nchar c;\ncin >> c;\nmatrixA[i][j] = c - '0';\n}\n}\nfor (int i = 0; i < m; i++) {\nfor (int j = 0; j < n; j++) {\nchar c;\ncin >> c;\nmatrixB[i][j] = c - '0';\nif (matrixB[i][j] != matrixA[i][j]) {\nisFlipped[i][j] = true;\n}\n}\n}\nint answer = 0;\nif (m < 3 || n < 3) {\nfor (int i = 0; i < m; i++) {\nfor (int j = 0; j < n; j++) {\nif (isFlipped[i][j]) {\nanswer = -1;\nbreak;\n}\n}\n}\n} else {\nfor (int i = 0; i <= m - 3; i++) {\nfor (int j = 0; j <= n - 3; j++) {\nif (isFlipped[i][j] == true) {\nflip(i, j);\nanswer++;\n}\n}\n}\n}\nfor (int i = 0; i < m; i++) {\nfor (int j = 0; j < n; j++) {\nif (isFlipped[i][j]) {\nanswer = -1;\nbreak;\n}\n}\n}\ncout << answer << endl;\nreturn 0;\n}"
    },
    {
        "problem_tier": 2,
        "solution_code": "#include <iostream>\n#include <vector>\n#include <algorithm>\nusing namespace std;\nvector<int> multiply(vector<int>& a, vector<int>& b){\nvector<int> c(a.size() + b.size(), 0);\nfor(int i = 0; i < a.size(); i++){\nfor(int j = 0; j < b.size(); j++){\nc[i + j] += a[i] * b[j];\n}\n}\nfor(int i = c.size() - 1; i > 0; i--){\nc[i - 1] += c[i] / 10;\nc[i] %= 10;\n}\nwhile(c.size() > 1 && c.back() == 0){\nc.pop_back();\n}\nreturn c;\n}\nint main(){\nvector<int> a, b;\nstring num;\ncin >> num;\nfor(int i = num.length() - 1; i >= 0; i--){\na.push_back(num[i] - '0');\n}\ncin >> num;\nfor(int i = num.length() - 1; i >= 0; i--){\nb.push_back(num[i] - '0');\n}\nvector<int> result = multiply(a, b);\nfor(int i = result.size() - 1; i >= 0; i--){\ncout << result[i];\n}\nreturn 0;\n}"
    },
    {
        "problem_tier": 9,
        "solution_code": "#include<iostream>\nusing namespace std;\nlong long X, Y, Z;\nint cnt = 0;\nint main() {\ncin >> X >> Y;\nZ = (Y * 100) / X;\nint temp = Z;\nif (Z >= 99) {\ncnt = -1;\n}\nelse {\nwhile (temp != Z + 1) {\nX++;\nY++;\ncnt++;\ntemp = (Y * 100) / X;\n}\n}\ncout << cnt;\nreturn 0;\n}"
    },
    {
        "problem_tier": 15,
        "solution_code": "#include <bits/stdc++.h>\nusing namespace std;\n#define MAX 100001\n#define MOD 1000000007\ntypedef long long ll;\ntypedef vector<vector<ll>> matrix;\nmatrix operator*(const matrix& a, const matrix& b) {\nmatrix temp(2, vector<ll>(2, 0));\nfor (int i = 0; i < 2; i++) {\nfor (int j = 0; j < 2; j++) {\nfor (int k = 0; k < 2; k++) {\ntemp[i][j] += (a[i][k] * b[k][j]) % MOD;\ntemp[i][j] %= MOD;\n}\n}\n}\nreturn temp;\n}\nint main() {\nios_base::sync_with_stdio(0);\ncin.tie(0);\nll n;\ncin >> n;\nmatrix ans = { {1, 0}, {0, 1} };\nmatrix a = { {1, 1}, {1, 0} };\nwhile (n > 0) {\nif (n % 2 == 1) {\nans = ans * a;\n}\na = a * a;\nn /= 2;\n}\ncout << ans[0][1] << '\\n';\nreturn 0;\n}"
    },
    {
        "problem_tier": 14,
        "solution_code": "#include <iostream>\n#include <vector>\n#include <queue>\n#include <algorithm>\n#define MAX 501\nusing namespace std;\nint n, inDegree[MAX], ttime[MAX], result[MAX];\nvector<int> a[MAX];\nvoid topology(){\nqueue<int> q;\nfor(int i=1;i<=n;i++){\nif(inDegree[i]==0){\nresult[i]=ttime[i];\nq.push(i);\n}\n}\nwhile(!q.empty()){\nint x=q.front();\nq.pop();\nfor(int i=0;i<a[x].size();i++){\nint y=a[x][i];\nif(--inDegree[y]==0){\nq.push(y);\n}\nresult[y]=max(result[y],result[x]+ttime[y]);\n}\n}\nfor(int i=1;i<=n;i++){\nprintf(\"%d\\n\",result[i]);\n}\n}\nint main(){\ncin>>n;\nfor(int i=1;i<=n;i++){\nscanf(\"%d\",&ttime[i]);\nwhile(1){\nint x;\nscanf(\"%d\",&x);\nif(x==-1) break;\ninDegree[i]++;\na[x].push_back(i);\n}\n}\ntopology();\nreturn 0;\n}"
    },
    {
        "problem_tier": 13,
        "solution_code": "#include <iostream>\n#include <string>\n#include <queue>\n#include <utility>\n#define X first\n#define Y second\nusing namespace std;\nstring board[1001];\nint dist1[1001][1001]; int dist2[1001][1001]; int n, m;\nint dx[4] = {0, 1, 0, -1};\nint dy[4] = {1, 0, -1, 0};\nint main() {\nios::sync_with_stdio(0);\ncin.tie(0);\nqueue<pair<int, int>> Q1;     queue<pair<int, int>> Q2;\ncin >> n >> m;\nfor (int i = 0; i < n; i++) {\ncin >> board[i];\n}\nfor (int i = 0; i < n; i++) {\nfill(dist1[i], dist1[i] + m, -1);\nfill(dist2[i], dist2[i] + m, -1);\n}\nfor (int i = 0; i < n; i++) {\nfor (int j = 0; j < m; j++) {\nif (board[i][j] == 'F') {\nQ1.push({i, j});\ndist1[i][j] = 0;\n}\nelse if (board[i][j] == 'J') {\nQ2.push({i, j});\ndist2[i][j] = 0;\n}\n}\n}\nwhile (!Q1.empty()) {\nauto cur = Q1.front();\nQ1.pop();\nfor (int dir = 0; dir < 4; dir++) {\nint nx = cur.X + dx[dir];\nint ny = cur.Y + dy[dir];\nif (nx < 0 || nx >= n || ny < 0 || ny >= m) continue;\nif (dist1[nx][ny] >= 0 || board[nx][ny] == '#') continue;\ndist1[nx][ny] = dist1[cur.X][cur.Y] + 1;\nQ1.push({nx, ny});\n}\n}\nwhile (!Q2.empty()) {\nauto cur = Q2.front();\nQ2.pop();\nfor (int dir = 0; dir < 4; dir++) {\nint nx = cur.X + dx[dir];\nint ny = cur.Y + dy[dir];\nif (nx < 0 || nx >= n || ny < 0 || ny >= m) {\ncout << dist2[cur.X][cur.Y] + 1;\nreturn 0;\n}"
    },
    {
        "problem_tier": 7,
        "solution_code": "#include <iostream>\nusing namespace std;\nbool map[101][101];\nvoid countArea() {\nint A, B, C, D;\nfor (int t = 0; t < 4; t++) {\ncin >> A >> B >> C >> D;\nfor (int i = A; i < C; i++) {\nfor (int j = B; j < D; j++) {\nmap[i][j] = true;\n}\n}\n}\nint result = 0;\nfor (int i = 0; i < 101; i++) {\nfor (int j = 0; j < 101; j++) {\nif (map[i][j]) {\nresult++;\n}\n}\n}\ncout << result;\n}\nint main() {\nios_base::sync_with_stdio(false);\ncin.tie(NULL);\ncout.tie(NULL);\ncountArea();\nreturn 0;\n}"
    },
    {
        "problem_tier": 4,
        "solution_code": "#include <iostream>\nusing namespace std;\nint main(){\nios_base::sync_with_stdio(false);\ncin.tie(NULL);\nlong long n;\ncin >> n;\ncout << n * n << \"\\n2\";\nreturn 0;\n}"
    },
    {
        "problem_tier": 13,
        "solution_code": "#include<iostream>\n#include<algorithm>\nusing namespace std;\nint arr[100];\nint gcd(int a, int b){\nreturn a%b ? gcd(b, a%b) : b;\n}\nint main(){\nint n;\ncin>>n;\nfor(int i=0; i<n; i++)\ncin>>arr[i];\nsort(arr, arr+n);\nint sub = arr[1] - arr[0];\nfor(int i=2; i<n; i++)\nsub = gcd(sub, arr[i]-arr[i-1]);\nint count = 0;\nfor(int i=1; i*i<=sub; i++){\nif(sub%i==0){\ncout<<i<<\" \";\nif(i != sub/i)\ncout<<sub/i<<\" \";\ncount++;\n}\n}\nsort(arr, arr+count);\ncout<<endl;\n}"
    },
    {
        "problem_tier": 12,
        "solution_code": "#include <iostream>\n#include <string>\n#define MOD 1000000\nusing namespace std;\nint dp[5001] = {0,};\nint solution(string code, int n){\nif(code[0] == '0') return 0;\ndp[0] = dp[1] = 1;\nfor(int i=2; i<=n; i++){\nif(code[i-1] != '0') dp[i] = dp[i-1] % MOD;\nint tmp = (code[i-2]-'0')*10 + (code[i-1]-'0');\nif(tmp >= 10 && tmp <= 26) dp[i] = (dp[i] + dp[i-2]) % MOD;\n}\nreturn dp[n];\n}\nint main(){\nstring str;\ncin >> str;\nint answer = solution(str, str.length());\ncout << answer;\nreturn 0;\n}"
    },
    {
        "problem_tier": 4,
        "solution_code": "#include <iostream>\n#include <string>\nusing namespace std;\nint main() {\nstring str;\ncin >> str;\nint count = 0;\nfor (int i = 0; i < str.length(); i++) {\nif (str[i] == 'a' || str[i] == 'e' || str[i] == 'i' || str[i] == 'o' || str[i] == 'u') {\ncount++;\n}\n}\ncout << count << endl;\nreturn 0;\n}"
    },
    {
        "problem_tier": 12,
        "solution_code": "#include<iostream>\nusing namespace std;\nstruct pos {\nint x, y;\n};\nint main() {\nios::sync_with_stdio(0);\ncin.tie(0);\ncout.tie(0);\npos a, b, c;\ncin >> a.x >> a.y;\ncin >> b.x >> b.y;\ncin >> c.x >> c.y;\nlong long temp = a.x * b.y + b.x * c.y + c.x * a.y - (b.x * a.y + c.x * b.y + a.x * c.y);\nif (temp < 0)\ncout << \"-1\";\nelse if (temp > 0)\ncout << \"1\";\nelse\ncout << \"0\";\nreturn 0;\n}"
    },
    {
        "problem_tier": 9,
        "solution_code": "#include <iostream>\n#include <vector>\nusing namespace std;\nint main() {\nios_base::sync_with_stdio(false);\ncin.tie(0);\nint N;\ncin >> N;\nvector<pair<int, int>> balloons;\nfor (int i = 0; i < N; i++) {\nint num;\ncin >> num;\nballoons.push_back({i + 1, num});\n}\nint idx = 0;\nwhile (!balloons.empty()) {\ncout << balloons[idx].first << \" \";\nint num = balloons[idx].second;\nballoons.erase(balloons.begin() + idx);\nif (balloons.empty())\nbreak;\nif (num > 0) {\nfor (int i = 0; i < num - 1; i++) {\nballoons.push_back(balloons[idx]);\nballoons.erase(balloons.begin() + idx);\n}\n} else {\nfor (int i = 0; i < -num; i++) {\nballoons.insert(balloons.begin(), balloons.back());\nballoons.erase(balloons.end() - 1);\n}\nidx--;\n}\nidx = (idx >= 0 ? idx : balloons.size() + idx % balloons.size());\nidx %= balloons.size();\n}\nreturn 0;\n}"
    },
    {
        "problem_tier": 2,
        "solution_code": "#include <iostream>\nusing namespace std;\nint main() {\nint distance;\ncin >> distance;\nint time = (distance - 1) / 5 + 1;\ncout << time << endl;\nreturn 0;\n}"
    },
    {
        "problem_tier": 1,
        "solution_code": "#include <iostream>\n#include <string>\nusing namespace std;\nint main() {\nstring name;\ncin >> name;\ncout << \"1\" << '\\n';\nreturn 0;\n}"
    },
    {
        "problem_tier": 6,
        "solution_code": "#include <iostream>\n#include <cmath>\nusing namespace std;\nint main() {\nint score[10];\nfor (int i = 0; i < 10; i++)\ncin >> score[i];\nint sum = 0;\nint ans = 0;\nfor (int i = 0; i < 10; i++) {\nsum += score[i];\nint sumGap = abs(100 - sum);\nint ansGap = abs(100 - ans);\nif (sumGap < ansGap)\nans = sum;\nelse if (sumGap == ansGap)\nans = max(ans, sum);\n}\ncout << ans << '\\n';\nreturn 0;\n}"
    },
    {
        "problem_tier": 16,
        "solution_code": "#include<iostream>\n#include<vector>\nusing namespace std;\nvector<int> inorder;\nvector<int> postorder;\nint index[100001];\nint N, root;\nvoid preorder(int inStart, int inEnd, int postStart, int postEnd){\nif(inStart > inEnd || postStart > postEnd)\nreturn;\nint root = postorder[postEnd];\nint rootIndex = index[root];\nint leftSize = rootIndex - inStart;\nint rightSize = inEnd - rootIndex;\ncout << root << \" \";\npreorder(inStart, rootIndex - 1, postStart, postStart + leftSize - 1);\npreorder(rootIndex + 1, inEnd, postStart + leftSize, postEnd - 1);\n}\nint find(int x){\nfor(int i=0; i<N; i++){\nif(inorder[i] == x){\nreturn i;\n}\n}\n}\nint main(void){\ncin >> N;\nfor(int i=0; i<N; i++){\nint num;\ncin >> num;\ninorder.push_back(num);\nindex[num] = i;\n}\nfor(int i=0; i<N; i++){\nint num;\ncin >> num;\npostorder.push_back(num);\n}\npreorder(0, N-1, 0, N-1);\nreturn 0;\n}"
    },
    {
        "problem_tier": 15,
        "solution_code": "#include <iostream>\n#include <map>\n#include <vector>\n#include <string>\nusing namespace std;\nint parent[2000001];\nint counter[2000001];\nint find(int x) {\nif (x == parent[x])\nreturn x;\nreturn parent[x] = find(parent[x]);\n}\nint merge(int u, int v) {\nu = find(u);\nv = find(v);\nif (u != v) {\nparent[v] = u;\ncounter[u] += counter[v];\ncounter[v] = 1;\n}\nreturn counter[u];\n}\nint main() {\nios_base::sync_with_stdio(false);\ncin.tie(NULL);\ncout.tie(NULL);\nint T;\ncin >> T;\nfor (int i = 0; i < T; i++) {\nint F;\ncin >> F;\nfor (int j = 1; j <= 2 * F; j++) {\nparent[j] = j;\ncounter[j] = 1;\n}\nmap<string, int> index;\nstring u, v;\nint idx1, idx2;\nint num = 1;\nfor (int j = 0; j < F; j++) {\ncin >> u >> v;\nif (index.count(u) == 0)\nindex[u] = num++;\nidx1 = index[u];\nif (index.count(v) == 0)\nindex[v] = num++;\nidx2 = index[v];\ncout << merge(idx1, idx2) << '\\n';\n}\n}\nreturn 0;\n}"
    },
    {
        "problem_tier": 13,
        "solution_code": "#include<bits/stdc++.h>\nusing namespace std;\nint n, k, ans, ck[26];\nvector<string> words;\nstring comb, alphas = \"bdefghjklmopqrsuvwxyz\";\nvoid dfs(int depth, int idx){\nif(depth == k-5){\nint cnt = 0;\nmap<char, int> m;\nfor(auto& a : comb) m[a] = 1;\nfor(int i = 0; i < words.size(); i++){\nint flag = 0;\nfor(auto& cur : words[i]){\nif(cur == 'a' || cur == 'n' || cur == 'c' || cur == 'i' || cur == 't') continue;\nif(!m[cur]){\nflag = 1;\nbreak;\n}\n}\nif(!flag) cnt++;\n}\nans = max(ans, cnt);\nreturn;\n}\nfor(int i = idx; i < alphas.size(); i++){\nif(ck[i]) continue;\nck[i] = 1;\ncomb.push_back(alphas[i]);\ndfs(depth+1, i+1);\ncomb.pop_back();\nck[i] = 0;\n}\n}\nint main(){\ncin >> n >> k;\nfor(int i = 0; i < n; i++){\nmap<char, int> tmp;\nstring s, t;\ncin >> s;\nstring part = s.substr(4, s.size()-8);\nfor(int i = 0; i < part.size(); i++) tmp[part[i]] = 1;\nfor(auto el : tmp) t += el.first;\nwords.push_back(t);\n}\nif(k < 5){\ncout << 0;\nreturn 0;\n}"
    },
    {
        "problem_tier": 9,
        "solution_code": "#include <iostream>\n#include <string>\nusing namespace std;\nint main() {\nint n, m;\nint result = 1;\nint arr[51][51] = {0};\nstring input;\ncin >> n >> m;\nfor (int i = 0; i < n; i++) {\ncin >> input;\nfor (int j = 0; j < input.size(); j++) {\narr[i][j] = input[j] - '0';\n}\n}\nfor (int i = 0; i < n; i++) {\nfor (int j = 0; j < m; j++) {\nint cnt = 0;\nfor (int k = 1;; k++) {\nif ((j + k) >= m || (i + k) >= n) break;\nif (arr[i][j] == arr[i][j + k] && arr[i][j] == arr[i + k][j] && arr[i][j] == arr[i + k][j + k]) {\nif (cnt < k) cnt = k;\n}\n}\nif ((cnt + 1) > result) result = cnt + 1;\n}\n}\ncout << result * result << endl;\nreturn 0;\n}"
    },
    {
        "problem_tier": 4,
        "solution_code": "#include <iostream>\nusing namespace std;\nint main() {\nint N;\ncin >> N;\nfor (int i=0; i<N; i++) {\nif (i%2 == 1)\ncout << \" \";\nfor (int j=0; j<N; j++) {\ncout << \"* \";\n}\ncout << endl;\n}\nreturn 0;\n}"
    },
    {
        "problem_tier": 4,
        "solution_code": "#include <iostream>\nusing namespace std;\nint main() {\nint caseNum, num, element, sum = 0;\ncin >> caseNum;\nfor (int i = 0; i < caseNum; i++) {\ncin >> num;\nfor (int j = 0; j < num; j++) {\ncin >> element;\nsum += element;\n}\ncout << sum << '\\n';\nsum = 0;\n}\nreturn 0;\n}"
    },
    {
        "problem_tier": 14,
        "solution_code": "#include <iostream>\n#include <vector>\n#include <queue>\n#define INF 1e9\nusing namespace std;\nint n, m, start, end;\nint dist[1001];\nint before[1001];\nvector<pair<int, int>> graph[1001];\nvoid dijkstra() {\npriority_queue<pair<int, int>> pq;\npq.push(make_pair(0, start));\ndist[start] = 0;\nwhile(!pq.empty()) {\nint cost = -pq.top().first;\nint current = pq.top().second;\npq.pop();\nif(dist[current] < cost) continue;\nfor(int i=0; i<graph[current].size(); i++) {\nint next_cost = cost + graph[current][i].second;\nint next_node = graph[current][i].first;\nif(dist[next_node] > next_cost) {\ndist[next_node] = next_cost;\npq.push(make_pair(-next_cost, next_node));\nbefore[next_node] = current;\n}\n}\n}\n}\nint main() {\nios_base::sync_with_stdio(0);\ncin.tie(0), cout.tie(0);\ncin >> n;\ncin >> m;\nfor(int i=1; i<=n; i++) {\ndist[i] = INF;\n}\nfor(int i=0; i<m; i++) {\nint a, b, c;\ncin >> a >> b >> c;\ngraph[a].push_back(make_pair(b, c));\n}\ncin >> start >> end;\ndijkstra();\nvector<int> route;\nroute.push_back(end);\nint val = before[end];\nwhile(val) {\nroute.push_back(val);\nval = before[val];\n}\ncout << dist[end] << \"\\n\";\ncout << route.size() << \"\\n\";\nfor(int i=route.size()-1; i>=0; i--) {\ncout << route[i] << \" \";\n}\ncout << \"\\n\";\nreturn 0;\n}"
    },
    {
        "problem_tier": 16,
        "solution_code": "#include <iostream>\n#include <cstring>\n#define INF 987654321\nusing namespace std;\nint N, Answer_Bit;\nint MAP[16][16];\nint Cost[16][1 << 16];\nint Min(int A, int B) {\nif (A < B) return A;\nreturn B;\n}\nvoid Input(){\ncin >> N;\nfor (int i = 0; i < N; i++)\n{\nfor (int j = 0; j < N; j++)\n{\ncin >> MAP[i][j];\n}\n}\nAnswer_Bit = (1 << N) - 1;\n}\nint DFS(int Cur_Node, int Cur_Bit){\nif (Cur_Bit == Answer_Bit)\n{\nif (MAP[Cur_Node][0] == 0) return INF;\nelse return MAP[Cur_Node][0];\n}\nif (Cost[Cur_Node][Cur_Bit] != -1) return Cost[Cur_Node][Cur_Bit];\nCost[Cur_Node][Cur_Bit] = INF;\nfor (int i = 0; i < N; i++)\n{\nif (MAP[Cur_Node][i] == 0) continue;\nif ((Cur_Bit & (1 << i)) == (1 << i)) continue;\nCost[Cur_Node][Cur_Bit] = Min(Cost[Cur_Node][Cur_Bit], MAP[Cur_Node][i] + DFS(i, Cur_Bit | 1 << i));\n}\nreturn Cost[Cur_Node][Cur_Bit];\n}\nvoid Solution(){\nmemset(Cost, -1, sizeof(Cost));\ncout << DFS(0, 1) << endl;\n}\nvoid Solve(){\nInput();\nSolution();\n}\nint main(void){\nios::sync_with_stdio(false);\ncin.tie(NULL);\ncout.tie(NULL);\nSolve();\nreturn 0;\n}"
    },
    {
        "problem_tier": 11,
        "solution_code": "#include <iostream>\n#include <vector>\n#include <cstring>\n#define MAX 10001\nusing namespace std;\nint N, M;\nint maximum, cnt;\nvector<int> computer[MAX];\nint counter[MAX];\nbool visited[MAX];\nvoid DFS(int num, int start);\nint main(void) {\nscanf(\"%d%d\", &N, &M);\nfor (int i = 0; i < M; i++) {\nint num1, num2;\nscanf(\"%d%d\", &num1, &num2);\ncomputer[num2].push_back(num1);\n}\nfor (int i = 1; i <= N; i++) {\nmemset(visited, false, N + 1);\ncnt = 0;\nDFS(i, i);\nmaximum = (counter[i] > maximum ? counter[i] : maximum);\n}\nfor (int i = 1; i <= N; i++) {\nif (counter[i] == maximum)\nprintf(\"%d \", i);\n}\nprintf(\"\\n\");\nreturn 0;\n}"
    },
    {
        "problem_tier": 4,
        "solution_code": "#include <iostream>\nusing namespace std;\nint main() {\nint T, n;\ncin >> T;\nwhile(T--) {\ncin >> n;\nint digit = 0;\nwhile(n > 0) {\nif(n % 2 == 1) {\ncout << digit << \" \";\n}\nn /= 2;\ndigit++;\n}\n}\nreturn 0;\n}"
    },
    {
        "problem_tier": 2,
        "solution_code": "#include <iostream>\nusing namespace std;\nint main() {\nint N;\ncin >> N;\nif (N == 0) {\ncout << 1;\nreturn 0;\n}"
    },
    {
        "problem_tier": 5,
        "solution_code": "#include <iostream>\n#include <stack>\nusing namespace std;\nint main() {\nint n;\ncin >> n;\nstack<int> st;\nfor(int i=0; i<n; i++) {\nint x;\ncin >> x;\nst.push(x);\n}\nint temp = st.top();\nint count = 1;\nwhile(!st.empty()) {\nif(st.top() > temp) {\ntemp = st.top();\ncount++;\n}\nst.pop();\n}\ncout << count << \"\\n\";\nreturn 0;\n}"
    },
    {
        "problem_tier": 11,
        "solution_code": "#include <iostream>\n#include <string>\nusing namespace std;\nint main() {\nint n, m;\ncin >> n >> m;\nstring s;\ncin >> s;\nint ans = 0;\nfor (int i = 0; i < m; i++) {\nif (s[i] == 'I') {\nint cnt = 0;\nwhile (s[i + 1] == 'O' && s[i + 2] == 'I') {\ni += 2;\ncnt++;\nif (cnt == n) {\ncnt--;\nans++;\n}\n}\n}\n}\ncout << ans << '\\n';\nreturn 0;\n}"
    },
    {
        "problem_tier": 4,
        "solution_code": "#include <iostream>\n#include <algorithm>\nusing namespace std;\nint main() {\nint a[3];\ncin >> a[0] >> a[1] >> a[2];\nsort(a, a+3);\nif (a[0] + a[1] > a[2])\ncout << a[0] + a[1] + a[2];\nelse\ncout << (a[0] + a[1]) * 2 - 1;\nreturn 0;\n}"
    },
    {
        "problem_tier": 9,
        "solution_code": "#include <iostream>\n#include <algorithm>\n#include <string>\nusing namespace std;\nint alphabet[26];\nint main(){\nstring name;\ncin >> name;\nfor (int i=0; i<name.size(); i++)\nalphabet[name[i] - 'A']++;\nint err = 0;\nint mid_index = -1;\nfor (int i=0; i<26; i++){\nif (alphabet[i] > 0){\nif (alphabet[i] % 2 == 1){\nmid_index = i;\nalphabet[i]--;\nerr++;\n}\n}\n}\nif (err > 1)\nprintf(\"I'm Sorry Hansoo\\n\");\nelse {\nstring ans = \"\";\nstring temp = \"\";\nfor (int i = 0; i < 26; i++) {\nif (alphabet[i] > 0) {\nfor (int j = 0; j < alphabet[i] / 2; j++) {\nans += i + 'A';\n}\n}\n}\ntemp = ans;\nreverse(temp.begin(), temp.end());\nif (mid_index != -1) {\nans += mid_index + 'A';\n}\nans += temp;\ncout << ans << '\\n';\n}\nreturn 0;\n}"
    },
    {
        "problem_tier": 16,
        "solution_code": "#include<iostream>\n#include<cmath>\nusing namespace std;\nlong long num[1000001];\nint main(){\nios_base::sync_with_stdio(false);\ncin.tie(0);\ncout.tie(0);\nlong long min, max;\ncin >> min >> max;\nfor(long long i = min; i <= max; i++){\nnum[i - min] = i;\n}\nfor(long long i = 2; i * i <= max; i++){\nlong long N = min / (i * i);\nif(min % (i * i) != 0)\nN++;\nwhile(N * i * i <= max){\nnum[N * i * i - min] = 0;\nN++;\n}\n}\nint ans = 0;\nfor(long long i = min; i <= max; i++){\nif(num[i - min] != 0)\nans++;\n}\ncout << ans;\nreturn 0;\n}"
    },
    {
        "problem_tier": 3,
        "solution_code": "#include <iostream>\nusing namespace std;\nint main() {\nint n;\ncin >> n;\nfor(int i = 1; i <= n; i++) {\ncout << \"Hello World, Judge \" << i << \"!\" <<'\\n';\n}\nreturn 0;\n}"
    },
    {
        "problem_tier": 5,
        "solution_code": "#include <iostream>\n#include <string>\nusing namespace std;\nint main() {\nint min, max;\nstring A, B;\ncin >> A >> B;\nfor (int i = 0; i < A.size(); i++) {\nif (A[i] == '5') {\nA[i] = '6';\n}\n}\nfor (int i = 0; i < B.size(); i++) {\nif (B[i] == '5') {\nB[i] = '6';\n}\n}\nmax = stoi(A) + stoi(B);\nfor (int i = 0; i < A.size(); i++) {\nif (A[i] == '6') {\nA[i] = '5';\n}\n}\nfor (int i = 0; i < B.size(); i++) {\nif (B[i] == '6') {\nB[i] = '5';\n}\n}\nmin = stoi(A) + stoi(B);\ncout << min << '\\n' << max;\nreturn 0;\n}"
    },
    {
        "problem_tier": 14,
        "solution_code": "#include <iostream>\n#include <vector>\n#include <algorithm>\nusing namespace std;\nint N, M, K;\nint a[11][11];\nint nutri[11][11];\nvector<int> tree[11][11];\nint dx[] = { -1, -1, -1, 0, 0, 1, 1, 1 };\nint dy[] = { -1, 0, 1, -1, 1, -1, 0, 1 };\nvoid simulation() {\nfor (int i = 0; i < N; i++) {\nfor (int j = 0; j < N; j++) {\nfor (int k = tree[i][j].size() - 1; k >= 0; k--) {\nif (tree[i][j][k] <= nutri[i][j]) {\nnutri[i][j] -= tree[i][j][k];\ntree[i][j][k]++;\n}\nelse {\nint temp = 0;\nfor (int t = 0; t <= k; t++) {\nnutri[i][j] += tree[i][j][t] / 2;\n}\ntree[i][j].erase(tree[i][j].begin(), tree[i][j].begin() + k + 1);\nbreak;\n}\n}\n}\n}\nfor (int i = 0; i < N; i++) {\nfor (int j = 0; j < N; j++) {\nfor (int k = 0; k < tree[i][j].size(); k++) {\nif ((tree[i][j][k] % 5) == 0) {\nfor (int t = 0; t < 8; t++) {\nint ny = i + dy[t];\nint nx = j + dx[t];\nif (ny < 0 || nx < 0 || ny >= N || nx >= N)\ncontinue;\ntree[ny][nx].push_back(1);\n}\n}\n}\n}\n}\nfor (int i = 0; i < N; i++) {\nfor (int j = 0; j < N; j++) {\nnutri[i][j] += a[i][j];\n}\n}\n}\nint main() {\ncin >> N >> M >> K;\nfor (int i = 0; i < N; i++) {\nfor (int j = 0; j < N; j++) {\ncin >> a[i][j];\nnutri[i][j] = 5;\n}\n}\nfor (int i = 0; i < M; i++) {\nint x, y, z;\ncin >> x >> y >> z;\ntree[x-1][y-1].push_back(z);\n}\nfor (int i = 0; i < K; i++) {\nsimulation();\n}\nint res = 0;\nfor (int i = 0; i < N; i++) {\nfor (int j = 0; j < N; j++) {\nres += tree[i][j].size();\n}\n}\ncout << res;\nreturn 0;\n}"
    },
    {
        "problem_tier": 4,
        "solution_code": "#include <iostream>\n#include <algorithm>\nusing namespace std;\nint main() {\nint minX = INT_MAX, maxX = INT_MIN, minY = INT_MAX, maxY = INT_MIN;\nint x, y;\nfor (int i = 0; i < 4; i++) {\ncin >> x >> y;\nminX = min(minX, x);\nmaxX = max(maxX, x);\nminY = min(minY, y);\nmaxY = max(maxY, y);\n}\nint area = (maxX - minX) * (maxY - minY);\ncout << area << endl;\nreturn 0;\n}"
    },
    {
        "problem_tier": 15,
        "solution_code": "#include <iostream>\nusing namespace std;\n#define mod 1000000\n#define period 1500000\nvoid fibonacci(long long arr[]) {\narr[0] = 0;\narr[1] = 1;\nfor (int i = 2; i <= period; i++) {\narr[i] = (arr[i - 1] + arr[i - 2]) % mod;\n}\n}\nint main() {\nios_base::sync_with_stdio(0);\ncin.tie(0);\ncout.tie(0);\nlong long arr[period + 1];\nfibonacci(arr);\nlong long n;\ncin >> n;\ncout << arr[n % period] << \"\\n\";\nreturn 0;\n}"
    },
    {
        "problem_tier": 5,
        "solution_code": "#include<iostream>\nusing namespace std;\nint main(int argc, char** argv){\nios::sync_with_stdio(0);\ncin.tie(0);\nint arr[2][7] = {0};\nint N, K;\nint res = 0;\ncin >> N >> K;\nfor(int i=0; i<N; i++){\nint S, G;\ncin >> S >> G;\narr[S][G]++;\n}\nfor(int i=0; i<2; i++){\nfor(int j=1; j<7; j++){\nif(arr[i][j] != 0){\nres += arr[i][j] / K;\nif(arr[i][j] % K != 0)\nres++;\n}\n}\n}\ncout << res;\nreturn 0;\n}"
    },
    {
        "problem_tier": 7,
        "solution_code": "#include <iostream>\nusing namespace std;\nint main() {\nios::sync_with_stdio(false);\ncin.tie(0);\ncout.tie(0);\nint cost;\ncin >> cost;\nint five = cost / 5;\nif (cost % 5 == 0) {\ncout << five;\nreturn 0;\n}"
    },
    {
        "problem_tier": 14,
        "solution_code": "#include <iostream>\n#include <queue>\n#include <algorithm>\n#include <cstring>\n#define MAX 201\n#define INF 987654321\nusing namespace std;\nint K, W, H;\nint map[MAX][MAX];\nint visited[MAX][MAX][31];\nint dr[12] = { -1, -2, -2, -1, 1, 2, 2, 1, -1, 1, 0, 0 };\nint dc[12] = { -2, -1, 1, 2, 2, 1, -1, -2, 0, 0, 1, -1 };\nint bfs() {\nmemset(visited, -1, sizeof(visited));\nqueue<pair<pair<int, int>, pair<int, int>>> q;\nq.push({ {0, 0}, {K, 0} });\nvisited[0][0][K] = 0;\nwhile (!q.empty()) {\nint r = q.front().first.first;\nint c = q.front().first.second;\nint k = q.front().second.first;\nint cnt = q.front().second.second;\nq.pop();\nif (r == H - 1 && c == W - 1) {\nreturn visited[r][c][k];\n}\nif (k > 0) {\nfor (int i = 0; i < 12; i++) {\nint nr = r + dr[i];\nint nc = c + dc[i];\nif (nr >= 0 && nr < H && nc >= 0 && nc < W && map[nr][nc] == 0 && visited[nr][nc][k - 1] == -1) {\nvisited[nr][nc][k - 1] = cnt + 1;\nq.push({ {nr, nc}, {k - 1, cnt + 1} });\n}\n}\n}\nfor (int i = 0; i < 4; i++) {\nint nr = r + dr[i + 8];\nint nc = c + dc[i + 8];\nif (nr >= 0 && nr < H && nc >= 0 && nc < W && map[nr][nc] == 0 && visited[nr][nc][k] == -1) {\nvisited[nr][nc][k] = cnt + 1;\nq.push({ {nr, nc}, {k, cnt + 1} });\n}\n}\n}\nreturn -1;\n}\nint main() {\ncin >> K;\ncin >> W >> H;\nfor (int i = 0; i < H; i++) {\nfor (int j = 0; j < W; j++) {\ncin >> map[i][j];\n}\n}\ncout << bfs() << \"\\n\";\nreturn 0;\n}"
    },
    {
        "problem_tier": 14,
        "solution_code": "#include <iostream>\n#include <vector>\nusing namespace std;\ntypedef unsigned long long ull;\nint main() {\nint n, m;\ncin >> n >> m;\nvector<int> arr(n);\nfor (int i = 0; i < n; i++) {\ncin >> arr[i];\n}\nvector<int> mod(m, 0);\null psum = 0;\nfor (int i = 0; i < n; i++) {\npsum += arr[i];\nmod[psum % m]++;\n}\null cnt = 0;\nfor (int i = 0; i < m; i++) {\ncnt += ((ull)mod[i] * (mod[i] - 1)) / 2;\n}\ncout << mod[0] + cnt;\nreturn 0;\n}"
    },
    {
        "problem_tier": 10,
        "solution_code": "#include <iostream>\n#include <queue>\nusing namespace std;\nint main() {\nios::sync_with_stdio(false);\ncin.tie(NULL);\nint N;\ncin >> N;\npriority_queue<int, vector<int>, greater<int>> pq;\nfor (int i = 0; i < N; i++) {\nfor (int j = 0; j < N; j++) {\nint num;\ncin >> num;\npq.push(num);\nif (pq.size() > N) {\npq.pop();\n}\n}\n}\ncout << pq.top();\nreturn 0;\n}"
    },
    {
        "problem_tier": 3,
        "solution_code": "#include<iostream>\nusing namespace std;\nint main() {\nint h, m, d;\ncin >> h >> m >> d;\nif (m + d >= 60) {\nh += (m + d) / 60;\nm = (m + d) % 60;\n} else {\nm += d;\n}\nif (h >= 24) {\nh %= 24;\n}\ncout << h << \" \" << m << endl;\nreturn 0;\n}"
    },
    {
        "problem_tier": 9,
        "solution_code": "#include <iostream>\n#include <algorithm>\nusing namespace std;\nint main() {\nint N, L;     int location[1000];     int start;     int tape = 0;\ncin >> N >> L;\nfor(int i=0; i<N; i++) {\ncin >> location[i];\n}\nsort(location, location+N);\nstart = location[0];\nfor(int i=1; i<N; i++) {\nif(L <= location[i]-start) {\ntape++;\nstart = location[i];\n}\n}\ncout << tape+1;\nreturn 0;\n}"
    },
    {
        "problem_tier": 13,
        "solution_code": "#include <iostream>\n#include <vector>\n#define INF 987654321\nusing namespace std;\nint N, M;\nvector<pair<pair<int, int>, int>> Edge;\nlong long Dist[501];\nvoid Input() {\ncin >> N >> M;\nfor (int i = 1; i <= N; i++) Dist[i] = INF;\nfor (int i = 0; i < M; i++) {\nint From, To, Cost;\ncin >> From >> To >> Cost;\nEdge.push_back(make_pair(make_pair(From, To), Cost));\n}\n}\nvoid Solution() {\nDist[1] = 0;\nfor (int i = 1; i <= N - 1; i++) {\nfor (int j = 0; j < Edge.size(); j++) {\nint From = Edge[j].first.first;\nint To = Edge[j].first.second;\nint Cost = Edge[j].second;\nif (Dist[From] == INF) continue;\nif (Dist[To] > Dist[From] + Cost) Dist[To] = Dist[From] + Cost;\n}\n}\nfor (int i = 0; i < Edge.size(); i++) {\nint From = Edge[i].first.first;\nint To = Edge[i].first.second;\nint Cost = Edge[i].second;\nif (Dist[From] == INF) continue;\nif (Dist[To] > Dist[From] + Cost) {\ncout << -1 << endl;\nreturn;\n}\n}\nfor (int i = 2; i <= N; i++) {\nif (Dist[i] == INF) cout << -1 << endl;\nelse cout << Dist[i] << endl;\n}\n}\nvoid Solve() {\nInput();\nSolution();\n}\nint main(void) {\nios::sync_with_stdio(false);\ncin.tie(NULL);\ncout.tie(NULL);\nSolve();\nreturn 0;\n}"
    },
    {
        "problem_tier": 8,
        "solution_code": "#include<iostream>\n#include<vector>\nusing namespace std;\nint main() {\nint n, m, cnt = 0;\ncin >> n >> m;\nvector<int> armor(n);\nfor(int i = 0; i < n; i++)\ncin >> armor[i];\nfor(int i = 0; i < n-1; i++) {\nfor(int j = i+1; j < n; j++) {\nif(armor[i] + armor[j] == m)\ncnt++;\n}\n}\ncout << cnt << '\\n';\nreturn 0;\n}"
    },
    {
        "problem_tier": 10,
        "solution_code": "#include<bits/stdc++.h>\nusing namespace std;\nint N, M;\nint arr[8];\nvector<int> v;\nset<vector<int>> s;\nvoid dfs(int start) {\nif(start == M) {\nvector<int> temp;\nfor(int i = 0; i < M; i++) {\ntemp.push_back(arr[i]);\n}\ns.insert(temp);\n}\nelse {\nfor(int i = 0; i < N; i++) {\narr[start] = v[i];\ndfs(start + 1);\n}\n}\n}\nint main() {\nios_base::sync_with_stdio(false);\ncin.tie(0);\ncin >> N >> M;\nfor(int i = 0; i < N; i++) {\nint num;\ncin >> num;\nv.push_back(num);\n}\nsort(v.begin(), v.end());\ndfs(0);\nfor(auto temp : s) {\nfor(auto num : temp) {\ncout << num << \" \";\n}\ncout << \"\\n\";\n}\nreturn 0;\n}"
    },
    {
        "problem_tier": 10,
        "solution_code": "#include <iostream>\n#include <algorithm>\nusing namespace std;\nint main() {\nios_base::sync_with_stdio(false);\ncin.tie(NULL);\ncout.tie(NULL);\nint n;\ncin >> n;\nint a[1001];\nint dp[1001];\nint ans = 1;\nfor (int i = 1; i <= n; i++) {\ncin >> a[i];\n}\nfor (int i = 1; i <= n; i++) {\ndp[i] = 1;\nfor (int j = 1; j < i; j++) {\nif (a[j] < a[i]) {\ndp[i] = max(dp[i], dp[j] + 1);\n}\n}\nans = max(ans, dp[i]);\n}\ncout << ans;\nreturn 0;\n}"
    },
    {
        "problem_tier": 9,
        "solution_code": "#include<iostream>\n#include<vector>\n#include<cstring>\nusing namespace std;\nconst int MAX = 1000 + 1;\nint t, n, idx;\nint cnt;\nint adj[MAX];\nbool visited[MAX];\nvoid DFS(int idx){\nif(!visited[idx]){\nvisited[idx] = true;\nDFS(adj[idx]);\n}\nelse{\ncnt++;\n}\n}\nint main(void){\nios_base::sync_with_stdio(0);\ncin.tie(0);\ncin >> t;\nfor(int i=0; i<t; i++){\ncnt = 0;\ncin >> n;\nfor(int j=1; j<=n; j++){\ncin >> idx;\nadj[j] = idx;\n}\nfor(int k=1; k<=n; k++){\nif(!visited[k]){\nDFS(k);\n}\n}\ncout << cnt << \"\\n\";\ncnt = 0;\nmemset(visited, false, sizeof(visited));\n}\nreturn 0;\n}"
    },
    {
        "problem_tier": 16,
        "solution_code": "#include <iostream>\n#include <vector>\n#include <cmath>\n#define INF 1000000001\nusing namespace std;\nvector<int> Arr;\nvector<pair<int, int>> Tree;\nint initTreeMin(int Begin, int End, int Node) {\nif (Begin == End) return Tree[Node].first = Arr[Begin];\nint Mid = (Begin + End) / 2;\nreturn Tree[Node].first = min(initTreeMin(Begin, Mid, Node * 2), initTreeMin(Mid + 1, End, Node * 2 + 1));\n}\nint initTreeMax(int Begin, int End, int Node) {\nif (Begin == End) return Tree[Node].second = Arr[Begin];\nint Mid = (Begin + End) / 2;\nreturn Tree[Node].second = max(initTreeMax(Begin, Mid, Node * 2), initTreeMax(Mid + 1, End, Node * 2 + 1));\n}\nint findMin(int Begin, int End, int Node, int Left, int Right) {\nif (Left > End || Right < Begin) return INF;\nif (Left <= Begin && Right >= End) return Tree[Node].first;\nint Mid = (Begin + End) / 2;\nreturn min(findMin(Begin, Mid, Node * 2, Left, Right), findMin(Mid + 1, End, Node * 2 + 1, Left, Right));\n}\nint findMax(int Begin, int End, int Node, int Left, int Right) {\nif (Left > End || Right < Begin) return -INF;\nif (Left <= Begin && Right >= End) return Tree[Node].second;\nint Mid = (Begin + End) / 2;\nreturn max(findMax(Begin, Mid, Node * 2, Left, Right), findMax(Mid + 1, End, Node * 2 + 1, Left, Right));\n}\nint main() {\nint N, M;\ncin >> N >> M;\nfor (int i = 0; i < N; i++) {\nint data;\ncin >> data;\nArr.push_back(data);\n}\nTree.resize(N * 4);\ninitTreeMin(0, N - 1, 1);\ninitTreeMax(0, N - 1, 1);\nfor (int i = 0; i < M; i++) {\nint a, b;\ncin >> a >> b;\ncout << findMin(0, N - 1, 1, a - 1, b - 1) << \" \" << findMax(0, N - 1, 1, a - 1, b - 1) << endl;\n}\nreturn 0;\n}"
    },
    {
        "problem_tier": 16,
        "solution_code": "#include <iostream>\n#include <vector>\n#include <algorithm>\n#define MAX 100 + 1\nusing namespace std;\nstruct Shark_Info{\nint R;\nint C;\nint Speed;\nint Direct;\nint Size;\nint Num;\n};\nint R, C, M, Answer;\nvector<int> MAP[MAX][MAX];\nvector<Shark_Info> Shark;\nint dx[] = { 0, -1, 1, 0, 0 };\nint dy[] = { 0, 0, 0, 1, -1 };\nbool Standard(int A, int B){\nif (Shark[A].Size > Shark[B].Size) return true;\nreturn false;\n}\nvoid Input(){\ncin >> R >> C >> M;\nfor (int i = 0; i < M; i++){\nint r, c, s, d, z;\ncin >> r >> c >> s >> d >> z;\nShark.push_back({ r,c,s,d,z,i });\nMAP[r][c].push_back(i);\n}\n}\nbool Check(){\nfor (int i = 0; i < Shark.size(); i++){\nif (Shark[i].Size != 0) return false;\n}\nreturn true;\n}\nvoid Fishing(int Idx){\nfor (int i = 1; i <= R; i++){\nif (MAP[i][Idx].size() != 0){\nAnswer = Answer + Shark[MAP[i][Idx][0]].Size;\nShark[MAP[i][Idx][0]].Size = 0;\nMAP[i][Idx].clear();\nbreak;\n}\n}\n}\nvoid Move_Shark(){\nfor (int i = 0; i < Shark.size(); i++){\nif (Shark[i].Size == 0) continue;\nint x = Shark[i].R;\nint y = Shark[i].C;\nMAP[x][y].clear();\n}\nfor (int i = 0; i < Shark.size(); i++){\nif (Shark[i].Size == 0) continue;\nint x = Shark[i].R;\nint y = Shark[i].C;\nint Direct = Shark[i].Direct;\nint Speed = Shark[i].Speed;\nif (Direct == 1 || Direct == 2){\nint Rotate = (R - 1) * 2;\nif (Speed >= Rotate) Speed = Speed % Rotate;\nfor (int j = 0; j < Speed; j++){\nint nx = x + dx[Direct];\nint ny = y + dy[Direct];\nif (nx < 1){\nDirect = 2;\nnx = nx + 2;\n}\nif (nx > R){\nDirect = 1;\nnx = nx - 2;\n}\nx = nx;\ny = ny;\n}\n}\nelse{\nint Rotate = (C - 1) * 2;\nif (Speed >= Rotate) Speed = Speed % Rotate;\nfor (int j = 0; j < Speed; j++){\nint nx = x + dx[Direct];\nint ny = y + dy[Direct];\nif (ny < 1){\nDirect = 3;\nny = ny + 2;\n}\nif (ny > C){\nDirect = 4;\nny = ny - 2;\n}\nx = nx;\ny = ny;\n}\n}\nShark[i].R = x;\nShark[i].C = y;\nShark[i].Direct = Direct;\nMAP[x][y].push_back(i);\n}\n}\nvoid Kill_Shark(){\nfor (int i = 1; i <= R; i++){\nfor (int j = 1; j <= C; j++){\nif (MAP[i][j].size() > 1){\nsort(MAP[i][j].begin(), MAP[i][j].end(), Standard);\nint Live_Index = MAP[i][j][0];\nfor (int k = 1; k < MAP[i][j].size(); k++){\nShark[MAP[i][j][k]].Size = 0;\nShark[MAP[i][j][k]].R = -1;\nShark[MAP[i][j][k]].C = -1;\n}\nMAP[i][j].clear();\nMAP[i][j].push_back(Shark[Live_Index].Num);\n}\n}\n}\n}\nvoid Solution(){\nif (M == 0){\ncout << 0 << endl;\nreturn;\n}\nfor (int i = 1; i <= C; i++){\nif (Check() == true) break;\nFishing(i);\nMove_Shark();\nKill_Shark();\n}\ncout << Answer << endl;\n}\nvoid Solve(){\nInput();\nSolution();\n}\nint main(void){\nios::sync_with_stdio(false);\ncin.tie(NULL);\ncout.tie(NULL);\nSolve();\nreturn 0;\n}"
    },
    {
        "problem_tier": 14,
        "solution_code": "#include <iostream>\nusing namespace std;\nint n, m, h;\nbool ladder_pos[31][11];\nint ladder_cnt; bool flag = false;\nbool isPossible() {\nfor (int i = 1; i <= n; i++) {\nint verti = i;\nfor (int j = 1; j <= h; j++) {\nif (ladder_pos[j][verti]) {                 verti++;\n}\nelse if (verti > 1 && ladder_pos[j][verti - 1]) {                 verti--;\n}\n}\nif (verti != i) {             return false;\n}\n}\nreturn true;\n}\nvoid dfs(int y, int cnt) {\nif (ladder_cnt == cnt) {\nif (isPossible()) {\nflag = true;         }\nreturn;\n}\nfor (int i = y; i <= h; i++) {\nfor (int j = 1; j < n; j++) {\nif (!ladder_pos[i][j] && !ladder_pos[i][j + 1]) {\nladder_pos[i][j] = true;\ndfs(i, cnt + 1);\nladder_pos[i][j] = false;\n}\n}\n}\n}\nint main() {\nios::sync_with_stdio(false);\ncin.tie(NULL);\ncout.tie(NULL);\ncin >> n >> m >> h;\nfor (int i = 0; i < m; i++) {\nint a, b;\ncin >> a >> b;\nladder_pos[a][b] = true;     }\nfor (int i = 0; i <= 3; i++) {         ladder_cnt = i;\ndfs(1, 0);\nif (flag) {             cout << ladder_cnt << endl;\nreturn 0;\n}"
    },
    {
        "problem_tier": 10,
        "solution_code": "#include <iostream>\n#include <vector>\n#include <algorithm>\nusing namespace std;\nbool cmp(pair<int, int> a, pair<int, int> b) {\nif (a.first == b.first)\nreturn a.second < b.second;\nreturn a.first < b.first;\n}\nint main() {\nios_base::sync_with_stdio(false);\ncin.tie(NULL);\ncout.tie(NULL);\nint K, temp1, temp2, total = 1, small = 1;\nvector<int> count(4, 0);\nvector<pair<int, int>> vp;\ncin >> K;\nfor (int i = 0; i < 6; i++) {\ncin >> temp1 >> temp2;\nvp.push_back(pair<int, int>(temp1, temp2));\ncount[temp1 - 1]++;\n}\nfor (int i = 0; i < 6; i++) {\nif (count[vp[i].first - 1] == 1) {\ntotal *= vp[i].second;\ncontinue;\n}\nint next = (i + 1) % 6;\nint nextnext = (i + 2) % 6;\nif (vp[i].first == vp[nextnext].first) {\nsmall *= vp[next].second;\n}\n}\ncout << (total - small) * K;\nreturn 0;\n}"
    },
    {
        "problem_tier": 13,
        "solution_code": "#include <iostream>\n#include <vector>\n#include <algorithm>\n#include <string>\nusing namespace std;\nstruct TrieNode {\nbool isEnd;\nTrieNode* child[10];\nTrieNode() {\nisEnd = false;\nfor (int i = 0; i < 10; i++) {\nchild[i] = NULL;\n}\n}\n};\nbool insert(TrieNode* root, string str) {\nTrieNode* cur = root;\nfor (int i = 0; i < str.length(); i++) {\nint idx = str[i] - '0';\nif (cur->child[idx] == NULL) {\ncur->child[idx] = new TrieNode();\n}\nif (cur->isEnd) {\nreturn false;\n}\ncur = cur->child[idx];\n}\ncur->isEnd = true;\nfor (int i = 0; i < 10; i++) {\nif (cur->child[i] != NULL) {\nreturn false;\n}\n}\nreturn true;\n}\nint main() {\nios::sync_with_stdio(false);\ncin.tie(0);\ncout.tie(0);\nint t;\ncin >> t;\nwhile (t--) {\nint n;\ncin >> n;\nTrieNode* root = new TrieNode();\nbool isConsistent = true;\nfor (int i = 0; i < n; i++) {\nstring phone;\ncin >> phone;\nif (!isConsistent) {\ncontinue;\n}\nif (!insert(root, phone)) {\nisConsistent = false;\n}\n}\nif (isConsistent) {\ncout << \"YES\\n\";\n} else {\ncout << \"NO\\n\";\n}\n}\nreturn 0;\n}"
    },
    {
        "problem_tier": 2,
        "solution_code": "#include <iostream>\n#include <string>\n#include <algorithm>\nusing namespace std;\nstring operator+(string a, string b) {\nbool na = false;\nbool nb = false;\nstring ret;\nif(a[0] == '-') {\na.erase(begin(a));\nif(a[0] == '0')\nna = false;\nelse\nna = true;\n}\nif(b[0] == '-') {\nb.erase(begin(b));\nif(b[0] == '0')\nna = false;\nelse\nnb = true;\n}\nreverse(begin(a), end(a));\nreverse(begin(b), end(b));\nwhile(a.size() > b.size())\nb += '0';\nwhile(a.size() < b.size())\na += '0';\nint altb = -1;\nfor(int i = int(a.size()) - 1; i >= 0; --i) {\nif(a[i] > b[i]) {\naltb = 1;\nbreak;\n} else if(a[i] < b[i]) {\naltb = 0;\nbreak;\n}\n}\nif((na && !nb) || (!na && nb)) {         if(altb == 1) {             for(int i = 0; i < b.size(); ++i)                 b[i] = '9' - b[i] + '0';\nreverse(begin(b), end(b));\nb = b + string(\"1\");\nreverse(begin(b), end(b));\nif(b.size() > a.size())\nb.erase(end(b) - 1);\nint carry = 0;\nfor(int i = 0; i < b.size(); ++i) {\nint s = (a[i] - '0') + (b[i] - '0');\nret += (s + carry) % 10 + '0';\ncarry = (s + carry) / 10;\n}\nreverse(begin(ret), end(ret));\nif(na)\nret.insert(begin(ret), '-');\n} else if(altb == 0) {             for(int i = 0; i < a.size(); ++i)                 a[i] = '9' - a[i] + '0';\nreverse(begin(a), end(a));\na = a + string(\"1\");\nreverse(begin(a), end(a));\nif(a.size() > b.size())\na.erase(end(a) - 1);\nint carry = 0;\nfor(int i = 0; i < a.size(); ++i) {\nint s = (a[i] - '0') + (b[i] - '0');\nret += (s + carry) % 10 + '0';\ncarry = (s + carry) / 10;\n}\nreverse(begin(ret), end(ret));\nif(nb)\nret.insert(begin(ret), '-');\n} else if(altb == -1)             ret = \"0\";\n} else {         int carry = 0;\nfor(int i = 0; i < a.size(); ++i) {\nint s = (a[i] - '0') + (b[i] - '0');\nret += (s + carry) % 10 + '0';\ncarry = (s + carry) / 10;\n}\nif(carry != 0)\nret += carry + '0';\nreverse(begin(ret), end(ret));\nif((na && nb) && altb != -1)\nret.insert(begin(ret), '-');\n}\nreturn ret;\n}\nint main() {\nios_base::sync_with_stdio(false);\ncin.tie(nullptr);\ncout.tie(nullptr);\nstring a, b;\ncin >> a >> b;\nstring ret = a + b;\nchar buho = '';\nfor(int i = 0; i < ret.size(); ++i) {\nif(ret[i] == '-') {\nbuho = '-';\ncontinue;\n}\nif(ret[i] != '0') {\nret = ret.substr(i, ret.size() - i);\nbreak;\n}\n}\nif(buho == '-')\nret.insert(begin(ret), buho);\ncout << ret << endl;\nreturn 0;\n}"
    },
    {
        "problem_tier": 10,
        "solution_code": "#include <iostream>\n#define MAX 1000000\n#define MOD 1000000009\ntypedef unsigned long long ll;\nll dp[MAX + 1] = {0, 1, 2, 4};\nusing namespace std;\nint main() {\nios_base::sync_with_stdio(false);\ncin.tie(nullptr);\ncout.tie(nullptr);\nint t;\ncin >> t;\nint n;\nwhile(t--) {\ncin >> n;\nfor(int i = 4; i <= n; ++i) {\ndp[i] = (dp[i-1] + dp[i-2] + dp[i-3]) % MOD;\n}\ncout << dp[n] << \"\\n\";\n}\nreturn 0;\n}"
    },
    {
        "problem_tier": 13,
        "solution_code": "#include <iostream>\n#include <vector>\n#include <algorithm>\nusing namespace std;\nint parent[100001];\nint result;\nint getParent(int num){\nif(num == parent[num])\nreturn num;\nreturn parent[num] = getParent(parent[num]);\n}\nvoid unionParent(int a, int b){\na = getParent(a);\nb = getParent(b);\nif(a != b){\nparent[a] = b;\n}\n}\nbool findParent(int a, int b){\na = getParent(a);\nb = getParent(b);\nif(a == b){\nreturn true;\n}\nelse{\nreturn false;\n}\n}\nint main(){\nios::sync_with_stdio(false);\ncin.tie(0);\ncout.tie(0);\nint n, m;\ncin >> n >> m;\nvector<pair<int, pair<int, int>>> edge(m);\nfor(int i=0; i<m; i++){\nint cost, a, b;\ncin >> a >> b >> cost;\nedge[i] = {cost, {a, b}};\n}\nfor(int i=1; i<=n; i++){\nparent[i] = i;\n}\nsort(edge.begin(), edge.end());\nint maxCost = 0;\nfor(int i=0; i<m; i++){\nint cost = edge[i].first;\nint a = edge[i].second.first;\nint b = edge[i].second.second;\nif(!findParent(a, b)){\nmaxCost = max(maxCost, cost);\nresult += cost;\nunionParent(a, b);\n}\n}\ncout << result - maxCost;\nreturn 0;\n}"
    },
    {
        "problem_tier": 9,
        "solution_code": "#include <iostream>\n#include <vector>\n#include <algorithm>\nusing namespace std;\nbool next_permutation(vector<int>& a, int n){\nint i = n - 1;\nwhile(i > 0 && a[i-1] >= a[i]) i--;\nif(i <= 0) return false;\nint j = n - 1;\nwhile(a[j] <= a[i-1]) j--;\nswap(a[i-1], a[j]);\nj = n - 1;\nwhile(i < j){\nswap(a[i], a[j]);\ni++;\nj--;\n}\nreturn true;\n}\nint main(){\nint n;\ncin >> n;\nvector<int> a(n);\nfor(int i = 0; i < n; i++){\ncin >> a[i];\n}\nif(next_permutation(a, n)){\nfor(int i = 0; i < n; i++){\ncout << a[i] << ' ';\n}\ncout << '\\n';\n}\nelse{\ncout << -1 << '\\n';\n}\nreturn 0;\n}"
    },
    {
        "problem_tier": 13,
        "solution_code": "#include <iostream>\n#include <algorithm>\nusing namespace std;\nint matrix[1002][1002] = {0,};\nint dp[1002][1002] = {0,};\nint main() {\nint n, m;\ncin >> n >> m;\nfor (int i = 0; i < n; i++) {\nstring input;\ncin >> input;\nfor (int j = 0; j < m; j++) {\nmatrix[i][j] = input[j] - '0';\n}\n}\nint answer = 0;\nfor (int i = 1; i <= n; i++) {\nfor (int j = 1; j <= m; j++) {\nif (matrix[i - 1][j - 1] == 1) {\ndp[i][j] = min({dp[i - 1][j - 1], dp[i - 1][j], dp[i][j - 1]}) + 1;\nanswer = max(answer, dp[i][j]);\n}\n}\n}\ncout << answer * answer << endl;\nreturn 0;\n}"
    },
    {
        "problem_tier": 9,
        "solution_code": "#include <iostream>\n#include <vector>\n#include <algorithm>\n#include <limits.h>\nusing namespace std;\nint main() {\nios::sync_with_stdio(false);\ncin.tie(NULL);\ncout.tie(NULL);\nint n;\ncin >> n;\nvector<int> dp(n+1, 0);\ndp[1] = 1;\nfor (int i = 2; i <= n; i++) {\nint minn = INT_MAX;\nfor (int j = 1; j*j <= i; j++) {\nint tmp = i - j*j;\nminn = min(minn, dp[tmp]);\n}\ndp[i] = minn + 1;\n}\ncout << dp[n];\nreturn 0;\n}"
    },
    {
        "problem_tier": 3,
        "solution_code": "#include <iostream>\nusing namespace std;\nint main() {\nint n;\ncin >> n;\ncout << n * (n - 1) << endl;\nreturn 0;\n}"
    },
    {
        "problem_tier": 7,
        "solution_code": "#include<iostream>\n#include<string>\nusing namespace std;\nint main() {\ncin.tie(NULL);\nios::sync_with_stdio(false);\nstring document, word;\ngetline(cin, document);\ngetline(cin, word);\nint answer = 0;\nfor (int i = 0; document.length() > i; i++) {\nif (word.length() > document.length() - i)\nbreak;\nstring tmp = document.substr(i, word.length());\nif (tmp == word) {\nanswer++;\ni += word.length() - 1;\n}\n}\ncout << answer;\nreturn 0;\n}"
    },
    {
        "problem_tier": 7,
        "solution_code": "#include <iostream>\n#include <algorithm>\n#include <vector>\nusing namespace std;\nclass Problem {\npublic:\nint score;\nint num;\n};\nbool compare(Problem a, Problem b) {\nreturn a.score > b.score;\n}\nint main() {\nvector<Problem> inputList;\nconst int INPUT_NUM = 8;\nint inputNumber;\nfor (int i = 0; i < INPUT_NUM; i++) {\ncin >> inputNumber;\ninputList.push_back({ inputNumber, i + 1 });\n}\nsort(inputList.begin(), inputList.end(), compare);\nint sum = 0;\nvector<int> index;\nfor (int i = 0; i < 5; i++) {\nsum += inputList[i].score;\nindex.push_back(inputList[i].num);\n}\ncout << sum << \"\\n\";\nsort(index.begin(), index.end());\nfor (int i = 0; i < index.size(); i++) {\ncout << index[i] << \" \";\n}\ncout << \"\\n\";\nreturn 0;\n}"
    },
    {
        "problem_tier": 4,
        "solution_code": "#include<iostream>\nusing namespace std;\nint main(){\nint n;\ncin >> n;\nint sum = 0;\nfor(int i=0; i<n; i++){\nint student, apple;\ncin >> student >> apple;\nsum += apple % student;\n}\ncout << sum << endl;\nreturn 0;\n}"
    },
    {
        "problem_tier": 14,
        "solution_code": "#include <iostream>\n#include <queue>\n#include <cstring>\nusing namespace std;\n#define MAX 100\nint N, M;\nint paper[MAX][MAX];\nint visited[MAX][MAX];\ntypedef struct {\nint x, y;\n} box;\nbox moveD[4] = { {-1, 0}, {1, 0}, {0, -1}, {0, 1} };\nvoid init_visit() {\nfor (int i = 0; i < N; i++)\nfor (int j = 0; j < M; j++)\nvisited[i][j] = 0;\n}\nint remain_cheese() {\nint cnt = 0;\nfor (int i = 0; i < N; i++)\nfor (int j = 0; j < M; j++)\nif (paper[i][j])\ncnt++;\nreturn cnt; }\nvoid meltingCheese() {\nfor (int i = 0; i < N; i++) {\nfor (int j = 0; j < M; j++) {\nif (paper[i][j] && visited[i][j] >= 2)\npaper[i][j] = 0;         }\n}\n}\nvoid relWithAir() {\nqueue<pair<int, int>> q;\nq.push({0, 0});     visited[0][0] = 1;\nwhile (!q.empty()) {\nint cx = q.front().first;\nint cy = q.front().second;\nq.pop();\nfor (int i = 0; i < 4; i++) {\nint nx = cx + moveD[i].x;\nint ny = cy + moveD[i].y;\nif (nx < 0 || N <= nx || ny < 0 || M <= ny)\ncontinue;\nif (paper[nx][ny] == 0 && visited[nx][ny] == 0) {\nq.push({nx, ny});\nvisited[nx][ny] = 1;\n}\nelse if (paper[nx][ny] == 1) {\nvisited[nx][ny]++;\n}\n}\n}\n}\nint main() {\nios::sync_with_stdio(0);\ncin.tie(0);\ncin >> N >> M;\nfor (int i = 0; i < N; i++)\nfor (int j = 0; j < M; j++)\ncin >> paper[i][j];\nint time = 0;     while (1) {\nif (remain_cheese() == 0)\nbreak;\ninit_visit();         time++;\nrelWithAir();         meltingCheese();     }\ncout << time;\nreturn 0;\n}"
    },
    {
        "problem_tier": 7,
        "solution_code": "#include<iostream>\n#include<queue>\nusing namespace std;\nint main() {\nint n;\nqueue<int> q;\ncin >> n;\nfor (int i = 1; i <= n; i++) {\nq.push(i);\n}\nwhile (!q.empty()) {\ncout << q.front() << \" \";\nq.pop();\nif (!q.empty()) {\nq.push(q.front());\nq.pop();\n}\n}\nreturn 0;\n}"
    },
    {
        "problem_tier": 8,
        "solution_code": "#include <iostream>\n#include <stack>\nusing namespace std;\nint main() {\nint n;\nint cnt = 0;\ncin >> n;\nwhile (n--) {\nstring word;\ncin >> word;\nstack<char> s;\nfor (int i = 0; i < word.size(); i++) {\nif (s.empty()) {\ns.push(word[i]);\n} else {\nif (s.top() == word[i]) {\ns.pop();\n} else {\ns.push(word[i]);\n}\n}\n}\nif (s.empty()) {\ncnt++;\n}\n}\ncout << cnt << \"\\n\";\nreturn 0;\n}"
    },
    {
        "problem_tier": 6,
        "solution_code": "#include <iostream>\nusing namespace std;\nint fib(int N) {\nif(N == 1 || N == 2){\nreturn 1;\n}\nelse {\nreturn fib(N - 1) + fib(N - 2);\n}\n}\nint fibonacci(int N) {\nint* f = new int[N];\nf[0] = 1;\nf[1] = 1;\nfor(int i = 2; i < N; i++){\nf[i] = f[i - 1] + f[i - 2];\n}\nreturn f[N - 1];\n}\nint main() {\nint n;\ncin >> n;\nfib(n);\nfibonacci(n);\ncout << recur_cnt << \" \" << dynamic_cnt;\nreturn 0;\n}"
    },
    {
        "problem_tier": 3,
        "solution_code": "#include <iostream>\nusing namespace std;\nint main() {\nint m, f;\nwhile (1) {\ncin >> m >> f;\nif (m == 0 && f == 0)\nbreak;\ncout << m + f << '\\n';\n}\nreturn 0;\n}"
    },
    {
        "problem_tier": 7,
        "solution_code": "#include <iostream>\nusing namespace std;\nlong long gcd(long long a, long long b) {\nif (b == 0)\nreturn a;\nreturn gcd(b, a % b);\n}\nlong long lcm(long long a, long long b) {\nreturn a * b / gcd(a, b);\n}\nint main() {\nlong long a, b;\ncin >> a >> b;\ncout << lcm(a, b) << endl;\nreturn 0;\n}"
    },
    {
        "problem_tier": 10,
        "solution_code": "#include<iostream>\n#include<vector>\n#include<set>\n#include<algorithm>\nusing namespace std;\n#define MAX 9\nint N, M;\nint arr[MAX];\nbool visited[MAX];\nset<vector<int>> s;\nvoid dfs(int num, int k){\nif(k == M){\nvector<int> v;\nfor(auto i = 0; i < M; i++)\nv.push_back(arr[i]);\ns.insert(v);         v.clear();     }\nelse{\nfor(auto i = num; i < N; i++){\nif(!visited[i]){                 visited[i] = true;                 arr[k] = first[i];                 dfs(i+1, k+1);                 visited[i] = false;             }\n}\n}\n}\nint main(){\ncin >> N >> M;\nfor(int i = 0; i < N; i++)\ncin >> first[i];\nsort(first, first+N);     dfs(0, 0);\nfor(auto vector : s){\nfor(auto temp : vector)\ncout << temp << \" \";\ncout << \"\\n\";\n}\n}"
    },
    {
        "problem_tier": 2,
        "solution_code": "#include <iostream>\nusing namespace std;\nint main() {\nint A, B;\ncin >> A >> B;\ncout << B - A << \" \" << B << endl;\nreturn 0;\n}"
    },
    {
        "problem_tier": 3,
        "solution_code": "#include <iostream>\n#include <string>\nusing namespace std;\nint main() {\nstring str;\nwhile (true) {\ngetline(cin, str);\nif (str == \"END\")\nreturn 0;\nfor (int i = str.length() - 1; i >= 0; i--) {\ncout << str[i];\n}"
    },
    {
        "problem_tier": 17,
        "solution_code": "#include <iostream>\n#include <algorithm>\n#include <vector>\nusing namespace std;\nlong long n;\nvector<long long> h;\nlong long seg[1000001];\nlong long x, ans;\nint init(int node, int s, int e) {\nif (s == e) return seg[node] = s;\nint mid = (s + e) / 2;\nint left_index = init(2 * node, s, mid);\nint right_index = init(2 * node + 1, mid + 1, e);\nreturn seg[node] = (h[left_index] < h[right_index]) ? left_index : right_index;\n}\nint query(int node, int s, int e, int l, int r) {\nif (e < l || r < s) return INF;\nif (l <= s && e <= r) return seg[node];\nint mid = (s + e) / 2;\nint left_index = query(2 * node, s, mid, l, r);\nint right_index = query(2 * node + 1, mid + 1, e, l, r);\nif (left_index == INF) return right_index;\nelse if (right_index == INF) return left_index;\nelse return (h[left_index] < h[right_index]) ? left_index : right_index;\n}\nvoid solve(long long left, long long right) {\nif (left > right) return;\nlong long index = query(1, 0, n - 1, left, right);\nans = max(ans, h[index] * (right - left + 1));\nsolve(left, index - 1);\nsolve(index + 1, right);\n}\nint main() {\nwhile (1) {\nans = 0;\ncin >> n;\nif (n == 0) break;\nh = vector<long long>(n);\nfor (int i = 0; i < n; i++) {\ncin >> h[i];\n}\ninit(1, 0, n - 1);         solve(0, n - 1);\ncout << ans << endl;\n}\nreturn 0;\n}"
    },
    {
        "problem_tier": 9,
        "solution_code": "#include <iostream>\n#include <stack>\n#include <string>\nusing namespace std;\nint main() {\ncout << fixed;\ncout.precision(2);\nstack<double> s;\nint n;\nstring ch;\nint num[26];\ncin >> n;\ncin >> ch;\nfor(int i = 0; i < n; i++){\ncin >> num[i];\n}\nfor(int i = 0; i < ch.length(); i++){\nif(ch[i] == '+' || ch[i] == '-' || ch[i] == '*' || ch[i] == '/'){\ndouble a = s.top();\ns.pop();\ndouble b = s.top();\ns.pop();\ndouble result;\nswitch(ch[i]){\ncase '+':\nresult = a + b;\nbreak;\ncase '-':\nresult = b - a;\nbreak;\ncase '*':\nresult = a * b;\nbreak;\ncase '/':\nresult = b / a;\nbreak;\n}\ns.push(result);\n}\nelse{\ns.push(num[ch[i] - 'A']);\n}\n}\ncout << s.top() << endl;\nreturn 0;\n}"
    },
    {
        "problem_tier": 4,
        "solution_code": "#include <iostream>\nusing namespace std;\nint main() {\nint n;\ncin >> n;\nwhile (n--) {\nint r, e, c;\ncin >> r >> e >> c;\nif (r < e - c) {\ncout << \"advertise\" << '\\n';\n}\nelse if (r > e - c) {\ncout << \"do not advertise\" << '\\n';\n}\nelse {\ncout << \"does not matter\" << '\\n';\n}\n}\nreturn 0;\n}"
    },
    {
        "problem_tier": 14,
        "solution_code": "#include <iostream>\n#include <algorithm>\n#include <cstring>\nusing namespace std;\nint n;\nint arr[501][501] = {0,};\nint dp[501][501];\nint y_ar[4] = {0, 0, 1, -1};\nint x_ar[4] = {1, -1, 0, 0};\nint result = 0;\nint solved(int y, int x){\nint& ret = dp[y][x];\nif(ret != -1)\nreturn ret;\nret = 0;\nfor(int i=0; i<4; i++){\nint ny = y + y_ar[i];\nint nx = x + x_ar[i];\nif(ny >= 1 && ny <= n && nx >= 1 && nx <= n)\nif(arr[y][x] < arr[ny][nx]){\nret = max(ret, solved(ny, nx) + 1);\n}\n}\nreturn ret;\n}\nint main(){\nios_base::sync_with_stdio(0);\ncin.tie(0);\ncout.tie(0);\ncin >> n;\nfor(int i=1; i<=n; i++)\nfor(int j=1; j<=n; j++)\ncin >> arr[i][j];\nmemset(dp, -1, sizeof(dp));\nfor(int i=1; i<=n; i++)\nfor(int j=1; j<=n; j++){\nresult = max(result, solved(i, j));\n}\ncout << result + 1 << endl;\nreturn 0;\n}"
    },
    {
        "problem_tier": 8,
        "solution_code": "#include <iostream>\n#include <algorithm>\n#include <map>\nusing namespace std;\nint main() {\nios_base::sync_with_stdio(false);\ncin.tie(NULL);\ncout.tie(NULL);\nint N;\nlong long max_cnt = 0;\nlong long cnt, answer = 0;\nmap<long long, int> n_map;\ncin >> N;\nwhile(N--) {\ncin >> cnt;\nn_map[cnt]++;\n}\nfor(auto m : n_map) {\nif(m.second > max_cnt) {\nmax_cnt = m.second;\nanswer = m.first;\n}\n}\ncout << answer << endl;\nreturn 0;\n}"
    },
    {
        "problem_tier": 12,
        "solution_code": "#include <iostream>\n#include <vector>\n#include <algorithm>\n#include <queue>\nusing namespace std;\nint main() {\nint N;\ncin >> N;\nvector<pair<int, int>> lectures(N);\npriority_queue<int, vector<int>, greater<int>> pq;\nfor (int i = 0; i < N; i++) {\nint start, end;\ncin >> start >> end;\nlectures[i] = make_pair(start, end);\n}\nsort(lectures.begin(), lectures.end());\npq.push(lectures[0].second);\nfor (int i = 1; i < N; i++) {\nif (lectures[i].first >= pq.top()) {\npq.pop();\npq.push(lectures[i].second);\n}\nelse {\npq.push(lectures[i].second);\n}\n}\ncout << pq.size() << '\\n';\nreturn 0;\n}"
    },
    {
        "problem_tier": 4,
        "solution_code": "#include <iostream>\n#include <algorithm>\nusing namespace std;\nint main(){\nios::sync_with_stdio(0);\ncin.tie(nullptr);\nint f;\nint a;\ncin >> f;\nint Y = 0;\nint M = 0;\nfor(int i = 0; i < f; i++){\ncin >> a;\nY += ((a/30)+1) * 10;\nM += ((a/60)+1) * 15;\n}\nif(Y < M){\ncout << \"Y\" << Y;\n} else if(Y > M){\ncout << \"M\" << M;\n} else{\ncout << \"Y\" << \"M\" << M;\n}\nreturn 0;\n}"
    },
    {
        "problem_tier": 8,
        "solution_code": "#include <iostream>\nusing namespace std;\nint main() {\nint T;\ncin >> T;\nwhile (T--) {\nint N, M;\ncin >> N >> M;\nfor (int m_idx = 0; m_idx < M; m_idx++){\nint a, b;\ncin >> a >> b;\n}\ncout << N - 1 << \"\\n\";\n}\nreturn 0;\n}"
    },
    {
        "problem_tier": 8,
        "solution_code": "#include <iostream>\n#include <string>\nusing namespace std;\nint main() {\nios_base::sync_with_stdio(false);\ncin.tie(0);\nstring a, b;\ncin >> a >> b;\nint ans = 100;\nfor(int i = 0; i <= b.size()-a.size(); i++) {\nint cnt = 0;\nfor(int j = 0; j < a.size(); j++) {\nif(a[j] != b[j+i])\ncnt++;\n}\nans = min(ans, cnt);\n}\ncout << ans << '\\n';\nreturn 0;\n}"
    },
    {
        "problem_tier": 12,
        "solution_code": "#include <iostream>\n#include <vector>\n#include <queue>\n#include <cmath>\n#include <cstring>\nusing namespace std;\nint Dist(pair<int, int> a, pair<int, int> b) {\nreturn abs(b.first - a.first) + abs(b.second - a.second);\n}\nint main() {\nint T;\ncin >> T;\nwhile (T--) {\nint N;\ncin >> N;\nvector<pair<int, int>> Store;\nbool Visited[102] = {};\nfor (int i = 0; i < N + 2; ++i) {\npair<int, int> Pos;\ncin >> Pos.first >> Pos.second;\nStore.push_back(Pos);\n}\nqueue<pair<int, int>> q;\nq.push(Store[0]);\nbool canGo = false;\nwhile (!q.empty()) {\nauto current = q.front();\nq.pop();\nif (current == Store[N + 1]) {\ncanGo = true;\nbreak;\n}\nfor (int i = 1; i < N + 2; i++) {\nif (!Visited[i] && Dist(current, Store[i]) <= 1000) {\nVisited[i] = true;\nq.push(Store[i]);\n}\n}\n}\nif (canGo)\ncout << \"happy\" << endl;\nelse\ncout << \"sad\" << endl;\n}\nreturn 0;\n}"
    },
    {
        "problem_tier": 12,
        "solution_code": "#include<bits/stdc++.h>\nusing namespace std;\nint main(){\nint N;\ncin>>N;\nvector<int> vec(N);\nfor(int i=0;i<N;i++){\nint num;\ncin>>num;\nvec[i]=num;\n}\nsort(vec.begin(),vec.end());\nint left=0;\nint right=N-1;\nint resA, resB;\nint minDiff=abs(vec[left]+vec[right]);\nwhile(left<right){\nint midValue=vec[left]+vec[right];\nif(minDiff>abs(midValue)){\nminDiff=abs(midValue);\nresA=vec[left];\nresB=vec[right];\n}\nif(midValue<0){\nleft++;\n}else if(midValue>0){\nright--;\n}else{\nbreak;\n}\n}\ncout<<resA<<\" \"<<resB;\nreturn 0;\n}"
    },
    {
        "problem_tier": 5,
        "solution_code": "#include<iostream>\n#include<string.h>\nusing namespace std;\nint recursion(const char* s, int l, int r) {\nif(l >= r) return 1;\nelse if(s[l] != s[r]) return 0;\nelse return recursion(s, l+1, r-1);\n}\nint isPalindrome(const char* s) {\nreturn recursion(s, 0, strlen(s)-1);\n}\nint main() {\nint inputNumber = 0;\nscanf(\"%d\", &inputNumber);\nfor(int i=0; i<inputNumber; i++) {\nchar str[1000];\nscanf(\"%s\", str);\nprintf(\"%d\\n\", isPalindrome(str));\n}\nreturn 0;\n}"
    },
    {
        "problem_tier": 12,
        "solution_code": "#include <iostream>\n#include <vector>\nusing namespace std;\nvector<int> friends[2001];\nbool visited[2001];\nbool answer = false;\nvoid DFS(int length, int current) {\nif (length == 4) {\nanswer = true;\nreturn;\n}\nfor (auto friendIdx : friends[current]) {\nif (!visited[friendIdx]) {\nvisited[friendIdx] = true;\nDFS(length + 1, friendIdx);\nvisited[friendIdx] = false;\n}\n}\n}\nvoid solve() {\nint N, M;\ncin >> N >> M;\nint a, b;\nfor (int i = 0; i < M; i++) {\ncin >> a >> b;\nfriends[a].push_back(b);\nfriends[b].push_back(a);\n}\nfor (int i = 0; i < N; i++) {\nvisited[i] = true;\nDFS(0, i);\nvisited[i] = false;\nif (answer) break;\n}\ncout << answer;\n}\nint main() {\nios_base::sync_with_stdio(false);\ncin.tie(NULL);\ncout.tie(NULL);\nsolve();\nreturn 0;\n}"
    },
    {
        "problem_tier": 13,
        "solution_code": "#include <iostream>\n#include <vector>\n#define endl \"\\n\"\nusing namespace std;\nint parent[51];\nvector<int> truth;\nvector<int> people[51];\nint answer;\nint find(int x) {\nif (parent[x] == x)\nreturn x;\nelse\nreturn find(parent[x]);\n}\nvoid Union(int x, int y) {\nx = find(x);\ny = find(y);\nif (x == y)\nreturn;\nparent[y] = x;\n}\nbool isUnion(int x, int y) {\nx = find(x);\ny = find(y);\nif (x == y)\nreturn true;\nelse\nreturn false;\n}\nvoid Answer() {\nint N, M;\ncin >> N >> M;\nint a, b;\ncin >> a;\nanswer = M;\nfor (int i = 0; i < a; i++) {\ncin >> b;\ntruth.push_back(b);\n}\nfor (int i = 0; i < M; i++) {\ncin >> a;\nfor (int j = 0; j < a; j++) {\ncin >> b;\npeople[i].push_back(b);\n}\n}\nfor (int i = 1; i <= N; i++) {\nparent[i] = i;\n}\nfor (int i = 0; i < M; i++) {\na = people[i][0];\nfor (int j = 1; j < people[i].size(); j++) {\nb = people[i][j];\nUnion(a, b);\n}\n}\nfor (int i = 0; i < M; i++) {\nbool check = true;\nfor (int j = 0; j < people[i].size(); j++) {\nif (!check)\nbreak;\na = people[i][j];\nfor (int k = 0; k < truth.size(); k++) {\nb = truth[k];\nif (isUnion(a, b)) {\ncheck = false;\nbreak;\n}\n}\n}\nif (!check)\nanswer--;\n}\ncout << answer;\n}\nint main() {\nios_base::sync_with_stdio(false);\ncin.tie(NULL);\ncout.tie(NULL);\nAnswer();\nreturn 0;\n}"
    },
    {
        "problem_tier": 13,
        "solution_code": "#include <iostream>\n#include <queue>\n#include <vector>\n#define INF 987654321\nusing namespace std;\nint n;\nvector<vector<int>> graph;\nvoid input() {\ngraph.clear();\ngraph.resize(n);\nfor (auto& row : graph) {\nrow.resize(n);\nfor (auto& x : row)\ncin >> x;\n}\n}\nint sol() {\nint dx[4] = {1, 0, -1, 0};\nint dy[4] = {0, 1, 0, -1};\npriority_queue<tuple<int, int, int>, vector<tuple<int, int, int>>, greater<tuple<int, int, int>>> pq;\nint dist[125][125];\nfill(&dist[0][0], &dist[124][124], INF);\nbool visited[125][125] = {false,};\ndist[0][0] = graph[0][0];\npq.push(make_tuple(dist[0][0], 0, 0));\nwhile (!pq.empty()) {\nauto[cur_dist, cur_x, cur_y] = pq.top();\npq.pop();\nif (visited[cur_y][cur_x])\ncontinue;\nvisited[cur_y][cur_x] = true;\nfor (int i = 0; i < 4; i++) {\nint next_x = cur_x + dx[i], next_y = cur_y + dy[i];\nif (next_x >= n || next_x < 0 || next_y >= n || next_y < 0)\ncontinue;\nif (dist[next_y][next_x] > dist[cur_y][cur_x] + graph[next_y][next_x]) {\ndist[next_y][next_x] = dist[cur_y][cur_x] + graph[next_y][next_x];\npq.push(make_tuple(dist[next_y][next_x], next_x, next_y));\n}\n}\n}\nreturn dist[n - 1][n - 1];\n}\nint main() {\nios_base::sync_with_stdio(false);\ncin.tie(nullptr);\nfor (int i = 1;; i++) {\ncin >> n;\nif (!n)\nbreak;\ninput();\ncout << \"Problem \" << i << \": \" << sol() << endl;\n}\nreturn 0;\n}"
    },
    {
        "problem_tier": 2,
        "solution_code": "#include <iostream>\nusing namespace std;\nint main() {\ncout << \"Welcome to UCPC\\n\";\nreturn 0;\n}"
    },
    {
        "problem_tier": 2,
        "solution_code": "#include <iostream>\nusing namespace std;\nint main() {\nios::sync_with_stdio(0);\ncin.tie(0);\ncout.tie(0);\nint n;\ncin >> n;\nif (n == 0) {\ncout << \"YONSEI\" << endl;\n} else {\ncout << \"LeadingtheWaytotheFuture\" << endl;\n}\nreturn 0;\n}"
    },
    {
        "problem_tier": 6,
        "solution_code": "#include <iostream>\n#include <algorithm>\nusing namespace std;\nint main() {\nint t;     cin >> t;\nfor(int i = 0; i < t; i++) {\nint a[10];\nfor(int j = 0; j < 10; j++) {\ncin >> a[j];         }\nsort(a, a + 10);\ncout << a[7] << endl;     }\nreturn 0;\n}"
    },
    {
        "problem_tier": 5,
        "solution_code": "#include <iostream>\nusing namespace std;\nint main() {\nint num[9];\nint sum = 0;\nint a, b;\nfor (int i = 0; i < 9; i++) {\ncin >> num[i];\nsum += num[i];\n}\nfor (int i = 0; i < 9; i++) {\nfor (int j = i + 1; j < 9; j++) {\nif (sum - (num[i] + num[j]) == 100) {\na = i;\nb = j;\n}\n}\n}\nfor (int k = 0; k < 9; k++) {\nif (k == a || k == b)\ncontinue;\nelse\ncout << num[k] << endl;\n}\nreturn 0;\n}"
    },
    {
        "problem_tier": 4,
        "solution_code": "#include <iostream>\n#include <algorithm>\nusing namespace std;\nint main() {\nint m;\ncin >> m;\nint arr[4] = {0, 1, 2, 3};\nfor (int i = 0; i < m; i++) {\nint first, second;\ncin >> first >> second;\nswap(arr[first], arr[second]);     }\nint i = 1;\nwhile (true) {\nif (arr[i] == 1) {             cout << i << '\\n';\nbreak;\n}\ni++;\n}\nreturn 0;\n}"
    },
    {
        "problem_tier": 2,
        "solution_code": "#include<iostream>\nusing namespace std;\nint main() {\ncout << \"I'm Sexy\\n\";\nreturn 0;\n}"
    },
    {
        "problem_tier": 4,
        "solution_code": "#include <iostream>\n#include <vector>\n#include <algorithm>\nusing namespace std;\nint main() {\nint n;\ncin >> n;\nvector<int> prizes;\nfor (int i = 0; i < n; i++) {\nint a, b, c;\ncin >> a >> b >> c;\nif (a == b && b == c) {\nprizes.push_back(10000 + a * 1000);\n} else if (a == b || b == c || a == c) {\nint match = (a == b) ? a : c;\nprizes.push_back(1000 + match * 100);\n} else {\nint max_val = max({a, b, c});\nprizes.push_back(max_val * 100);\n}\n}\nsort(prizes.begin(), prizes.end());\ncout << prizes.back() << endl;\nreturn 0;\n}"
    },
    {
        "problem_tier": 7,
        "solution_code": "#include <iostream>\n#include <set>\nusing namespace std;\nint main() {\nset<int> arr;\nint n;\ncin >> n;\nwhile (n--) {\nint tmp;\ncin >> tmp;\narr.insert(tmp);\n}\nfor (set<int>::iterator it = arr.begin(); it != arr.end(); it++) {\ncout << *it << ' ';\n}\ncout << '\\n';\nreturn 0;\n}"
    },
    {
        "problem_tier": 14,
        "solution_code": "#include <iostream>\n#include <queue>\n#include <cstring>\n#include <algorithm>\nusing namespace std;\nint n, answer = 999999999;\nint map[101][101];\nbool visit[101][101];\nint moveX[] = {0,0,1,-1};\nint moveY[] = {1,-1,0,0};\nint IsOut(int y, int x) {\nif (y < 0 || x < 0 || y >= n || x >= n)\nreturn true;\nreturn false;\n}\nvoid SearchBridge(int islandNo) {\nmemset(visit, false, sizeof(visit));\nqueue<pair<int,int>> q;\nfor (int i = 0; i < n; i++) {\nfor (int j = 0; j < n; j++) {\nif (map[i][j] == islandNo)\nq.push({i,j});\n}\n}\nint setCount = 0;\nwhile (!q.empty()) {\nint curTurn = q.size();\nfor (int i = 0; i < curTurn; i++) {\nint curY = q.front().first;\nint curX = q.front().second;\nq.pop();\nfor (int i = 0; i < 4; i++) {\nint nextY = curY + moveY[i];\nint nextX = curX + moveX[i];\nif (IsOut(nextY, nextX))\ncontinue;\nif (map[nextY][nextX] == islandNo)\ncontinue;\nif (visit[nextY][nextX])\ncontinue;\nif (map[nextY][nextX] != 0) {\nanswer = min(answer, setCount);\nreturn;\n}\nq.push({nextY, nextX});\nvisit[nextY][nextX] = true;\n}\n}\nsetCount++;\n}\n}\nvoid DivideIsland(int y, int x, int islandNo) {\nvisit[y][x] = true;\nmap[y][x] = islandNo;\nqueue<pair<int,int>> q;\nq.push({y,x});\nwhile (!q.empty()) {\nint curY = q.front().first;\nint curX = q.front().second;\nq.pop();\nfor (int i = 0; i < 4; i++) {\nint nextY = curY + moveY[i];\nint nextX = curX + moveX[i];\nif (IsOut(nextY, nextX))\ncontinue;\nif (map[nextY][nextX] == 0)\ncontinue;\nif (visit[nextY][nextX])\ncontinue;\nvisit[nextY][nextX] = true;\nmap[nextY][nextX] = islandNo;\nq.push({nextY, nextX});\n}\n}\n}\nint main() {\nios_base::sync_with_stdio(0);\ncin.tie(0);\ncout.tie(0);\nmemset(visit, false, sizeof(visit));\ncin >> n;\nfor (int i = 0; i < n; i++) {\nfor (int j = 0; j < n; j++) {\ncin >> map[i][j];\n}\n}\nint number = 1;\nfor (int i = 0; i < n; i++) {\nfor (int j = 0; j < n; j++) {\nif (visit[i][j])\ncontinue;\nif (map[i][j] != 1)\ncontinue;\nDivideIsland(i, j, number);\nnumber++;\n}\n}\nmemset(visit, false, sizeof(visit));\nfor (int i = 1; i <= number; i++)\nSearchBridge(i);\ncout << answer << '\\n';\nreturn 0;\n}"
    },
    {
        "problem_tier": 6,
        "solution_code": "#include <iostream>\n#include <algorithm>\n#include <string>\nusing namespace std;\nint Rev(int a){\nstring ans = to_string(a);\nreverse(ans.begin(), ans.end());\nreturn stoi(ans);\n}\nint main(){\nint X, Y;\ncin >> X >> Y;\ncout << Rev(Rev(X) + Rev(Y));\nreturn 0;\n}"
    },
    {
        "problem_tier": 4,
        "solution_code": "#include<iostream>\nusing namespace std;\nint main(){\nint n;\ncin >> n;\nint res[100];\nint score = 0;\nint bonus = 0;\nfor(int i=0; i<n; i++){\ncin >> res[i];\nif(res[i] == 1){             score++;\nif(res[i-1] == 1){                 bonus++;\nscore += bonus;             }\nelse{\nbonus = 0;\n}\n}\n}\ncout << score;\nreturn 0;\n}"
    },
    {
        "problem_tier": 13,
        "solution_code": "#include <iostream>\n#include <queue>\n#include <algorithm>\nusing namespace std;\nint dist[100002];\nint cnt[100002];\nint main(void){\nios::sync_with_stdio(0);\ncin.tie(0);\nint n, k;\ncin >> n >> k;\nif(n == k){\ncout << 0 << \"\\n\" << 1;\nreturn 0;\n}"
    },
    {
        "problem_tier": 11,
        "solution_code": "#include<iostream>\n#include<vector>\n#include<algorithm>\nusing namespace std;\nbool check(vector<int>& perm, vector<char>& vec) {\nfor(int i=0; i<vec.size(); i++) {\nif(vec[i] == '<' && perm[i] > perm[i+1]) return false;\nif(vec[i] == '>' && perm[i] < perm[i+1]) return false;\n}\nreturn true;\n}\nint main(void) {\nios::sync_with_stdio(false);\ncin.tie(0);\ncout.tie(0);\nint k;\ncin >> k;\nvector<char> vec(k);     for(int i=0; i<k; i++) {\ncin >> vec[i];\n}\nvector<int> small(k+1);     vector<int> big(k+1);     for(int i=0; i<=k; i++) {\nsmall[i] = i;\nbig[i] = 9 - i;\n}\ndo {\nif(check(small, vec)) break;\n} while(next_permutation(small.begin(), small.end()));\ndo {\nif(check(big, vec)) break;\n} while(prev_permutation(big.begin(), big.end()));\nfor(int i=0; i<big.size(); i++) {\ncout << big[i];\n}\ncout << '\\n';\nfor(int i=0; i<small.size(); i++) {\ncout << small[i];\n}\ncout << '\\n';\nreturn 0;\n}"
    },
    {
        "problem_tier": 8,
        "solution_code": "#include<iostream>\n#include<algorithm>\nusing namespace std;\nint main() {\nint n, a, b;\ncin >> n >> a >> b;\nint round = 0;\nwhile (1) {\nround++;\nif (a == 1 && b == 2 || a == b) {\nif (a == b)\nround--;\nbreak;\n}\nif (a % 2 == 1)\na = a / 2 + 1;\nelse\na /= 2;\nif (b % 2 == 1)\nb = b / 2 + 1;\nelse\nb /= 2;\n}\ncout << round << '\\n';\nreturn 0;\n}"
    },
    {
        "problem_tier": 8,
        "solution_code": "#include <bits/stdc++.h>\n#define INF 0x7f7f7f7f\nusing namespace std;\nint n, m, case1, case2, case3;\nint packageMin = INF, eachMin = INF;\nint main() {\ncin >> n >> m;\nfor (int i = 0; i < m; i++) {\nint six, one;\ncin >> six >> one;\npackageMin = min(six, packageMin);\neachMin = min(one, eachMin);\n}\nif (n % 6 == 0)\ncase1 = n / 6 * packageMin;\nelse\ncase1 = (n / 6 + 1) * packageMin;\ncase2 = eachMin * n;\ncase3 = n / 6 * packageMin + n % 6 * eachMin;\ncout << min({case1, case2, case3});\nreturn 0;\n}"
    },
    {
        "problem_tier": 5,
        "solution_code": "#include <iostream>\n#include <string>\n#include <vector>\nusing namespace std;\nint main() {\nint n;\ncin >> n;\nvector<int> alphabet(26, 0);\nfor (int i = 0; i < n; i++) {\nstring input;\ncin >> input;\nalphabet[input[0] - 'a']++;\n}\nbool predaja = true;\nfor (int i = 0; i < 26; i++) {\nif (alphabet[i] >= 5) {\ncout << char(i + 'a');\npredaja = false;\n}\n}\nif (predaja) {\ncout << \"PREDAJA\";\n}\nreturn 0;\n}"
    },
    {
        "problem_tier": 6,
        "solution_code": "#include <iostream>\nusing namespace std;\nint main() {\nint cnt = 1;\nwhile (true) {\nint L, P, V;\ncin >> L >> P >> V;\nif (L == 0 && P == 0 && V == 0)\nbreak;\nint use = V / P;\nint remain = V % P;\nif (L < remain)\nremain = L;\nint result = L * use + remain;\ncout << \"Case \" << cnt << \": \" << result << endl;\ncnt++;\n}\nreturn 0;\n}"
    },
    {
        "problem_tier": 4,
        "solution_code": "#include <iostream>\n#include <string>\nusing namespace std;\nint main() {\nstring A, B, op;\ncin >> A >> op >> B;\nif (op == \"*\") {\nint zeroCount = A.size() + B.size() - 2;\ncout << \"1\";\nfor (int i = 0; i < zeroCount; i++) {\ncout << \"0\";\n}\n}\nelse if (op == \"+\") {\nif (A.size() == B.size()) {\ncout << \"2\";\nfor (int i = 0; i < A.size() - 1; i++) {\ncout << \"0\";\n}\n}\nelse {\nint diff = abs(int(A.size() - B.size()));\nstring zeros(diff, '0');\nif (A.size() > B.size()) {\ncout << \"1\" << zeros;\ncout << B;\n}\nelse {\ncout << \"1\" << zeros;\ncout << A;\n}\n}\n}\nreturn 0;\n}"
    },
    {
        "problem_tier": 10,
        "solution_code": "#include <iostream>\n#include <vector>\n#include <queue>\nusing namespace std;\nint n, m, k, x;\nvector<int> edge[300001];\nbool visited[300001];\nvoid bfs() {\npriority_queue<int, vector<int>, greater<int>> resultQ;\nqueue<int> q;\nq.push(x);\nvisited[x] = true;\nint dis = 0;\nwhile (!q.empty()) {\nint size = q.size();\nfor (int i = 0; i < size; i++) {\nint cur = q.front();\nq.pop();\nif (dis == k) {\nresultQ.push(cur);\ncontinue;\n}\nfor (auto next : edge[cur]) {\nif (visited[next]) continue;\nvisited[next] = true;\nq.push(next);\n}\n}\ndis++;\n}\nif (resultQ.empty()) {\ncout << -1;\n}\nelse {\nwhile (!resultQ.empty()) {\ncout << resultQ.top() << '\\n';\nresultQ.pop();\n}\n}\n}\nint main() {\nios::sync_with_stdio(false);\ncin.tie(0);\ncout.tie(0);\ncin >> n >> m >> k >> x;\nfor (int i = 0; i < m; i++) {\nint from, to;\ncin >> from >> to;\nedge[from].push_back(to);\n}\nbfs();\nreturn 0;\n}"
    },
    {
        "problem_tier": 14,
        "solution_code": "#include<iostream>\n#include<vector>\nusing namespace std;\n#define MAX 101\nint N, x, y, d, g, cnt;\nint map[MAX][MAX];\nint dx[4] = {1, 0, -1, 0};\nint dy[4] = {0, -1, 0, 1};\nvector<int> direction;\nvoid Make_Dragon_Curve(){\nint size = direction.size();\nfor(int i=size-1; i>=0; i--){\nint temp = (direction.at(i)+1) % 4;\nx += dx[temp];\ny += dy[temp];\nmap[x][y] = 1;\ndirection.push_back(temp);\n}\n}\nvoid Count_Square(){\nfor(int i=0; i<MAX; i++){\nfor(int j=0; j<MAX; j++){\nif(map[i][j]==1 && map[i][j+1]==1 && map[i+1][j+1]==1 && map[i+1][j]==1)\ncnt++;\n}\n}\n}\nvoid Solution(){\ncin >> N;\nwhile(N--){\ndirection.clear();\ncin >> x >> y >> d >> g;\nmap[x][y] = 1;\nx += dx[d];\ny += dy[d];\nmap[x][y] = 1;\ndirection.push_back(d);\nwhile(g--){\nMake_Dragon_Curve();\n}\n}\nCount_Square();\ncout << cnt << endl;\n}\nint main(){\nSolution();\nreturn 0;\n}"
    },
    {
        "problem_tier": 12,
        "solution_code": "#include <iostream>\n#include <queue>\nusing namespace std;\nint map[102] = {0};\nbool visit[102] = {0};\nvoid game(int x, int c) {\nqueue<pair<int, int>> q;\nq.push(make_pair(x, c));\nwhile (!q.empty()) {\nint loc = q.front().first;          int cnt = q.front().second;          q.pop();\nfor (int i = 1; i <= 6; i++) {\nint nx = loc + i;\nif (nx == 100) {\ncout << cnt + 1;                  return;\n}\nelse if (nx < 100) {                  while (map[nx] != 0) {                      nx = map[nx];                  }\nif (!visit[nx]) {                      q.push(make_pair(nx, cnt + 1));                      visit[nx] = true;                  }\n}\n}\n}\n}\nint main() {\nint n, m, t1, t2;\ncin >> n >> m;\nfor (int i = 0; i < n; i++) {\ncin >> t1 >> t2;\nmap[t1] = t2;      }\nfor (int i = 0; i < m; i++) {\ncin >> t1 >> t2;\nmap[t1] = t2;      }\ngame(1, 0);\nreturn 0;\n}"
    },
    {
        "problem_tier": 3,
        "solution_code": "#include <iostream>\nusing namespace std;\nint main() {\nint a[4], b[4], sum1 = 0, sum2 = 0;\nfor (int i = 0; i < 4; i++) {\ncin >> a[i];\nsum1 += a[i];\n}\nfor (int i = 0; i < 4; i++) {\ncin >> b[i];\nsum2 += b[i];\n}\nif (sum1 >= sum2) {\ncout << sum1 << endl;\n} else {\ncout << sum2 << endl;\n}\nreturn 0;\n}"
    },
    {
        "problem_tier": 13,
        "solution_code": "#include <iostream>\n#include <vector>\n#include <algorithm>\nusing namespace std;\nvector<int> minusNum;\nvector<int> plusNum;\nint n, ans;\nint main() {\ncin >> n;\nfor (int i = 0, x; i < n; i++) {\ncin >> x;\nif (x > 0) plusNum.push_back(x);\nelse minusNum.push_back(x);\n}\nsort(plusNum.begin(), plusNum.end());\nsort(minusNum.begin(), minusNum.end());\nfor (int i = plusNum.size() - 1; i >= 0; i -= 2) {\nint mul = 1;\nint sum = 0;\nmul *= plusNum[i];\nsum += plusNum[i];\nif (i - 1 >= 0) {\nmul *= plusNum[i - 1];\nsum += plusNum[i - 1];\n}\nans += max(mul, sum);\n}\nfor (int i = 0; i < minusNum.size(); i += 2) {\nint mul = 1;\nmul *= minusNum[i];\nif (i + 1 < minusNum.size()) {\nmul *= minusNum[i + 1];\n}\nans += mul;\n}\ncout << ans << '\\n';\nreturn 0;\n}"
    },
    {
        "problem_tier": 8,
        "solution_code": "#include <iostream>\nusing namespace std;\nint n, m;\nbool swit[101];\nvoid manSwitch(int num) {\nfor (int i = num; i <= n; i += num) {\nswit[i] = !swit[i];\n}\n}\nvoid womanSwitch(int num) {\nswit[num] = !swit[num];\nint start = num - 1;\nint end = num + 1;\nwhile (swit[start] == swit[end]) {\nif (start == 0 || end == n + 1) return;\nswit[start] = !swit[start];\nswit[end] = !swit[end];\nstart--;\nend++;\n}\nreturn;\n}\nint main() {\nios_base::sync_with_stdio(false);\ncin.tie(0);\ncout.tie(0);\ncin >> n;\nfor (int i = 1; i <= n; i++) {\ncin >> swit[i];\n}\ncin >> m;\nfor (int i = 0; i < m; i++) {\nint gender, light;\ncin >> gender >> light;\nif (gender == 1) {\nmanSwitch(light);\n} else if (gender == 2) {\nwomanSwitch(light);\n}\n}\nfor (int i = 1; i <= n; i++) {\ncout << swit[i];\nif (i % 20 == 0) cout << \"\\n\";\n}\nreturn 0;\n}"
    },
    {
        "problem_tier": 13,
        "solution_code": "#include <iostream>\n#include <set>\nusing namespace std;\nint main() {\nios::sync_with_stdio(0);\ncin.tie(0);\nint t;\ncin >> t;\nwhile (t--) {\nmultiset<int> ms;\nint k;\ncin >> k;\nwhile (k--) {\nchar c;\nint x;\ncin >> c >> x;\nif (c == 'I') {\nms.insert(x);\n} else if (c == 'D' && !ms.empty()) {\nif (x == 1) ms.erase(--ms.end());\nelse ms.erase(ms.begin());\n}\n}\nif (!ms.empty()) {\ncout << *(--ms.end()) << ' ' << *ms.begin() << \"\\n\";\n} else {\ncout << \"EMPTY\" << \"\\n\";\n}\n}\nreturn 0;\n}"
    },
    {
        "problem_tier": 11,
        "solution_code": "#include <iostream>\n#include <vector>\nusing namespace std;\nint main() {\nios::sync_with_stdio(false);\ncin.tie(0);\ncout.tie(0);\nint n;\ncin >> n;\nvector<int> dp(n+1);\nvector<int> before(n+1);\nbefore[1] = 1;\nfor(int i=2; i<=n; i++){\ndp[i] = dp[i-1] + 1;\nbefore[i] = i-1;\nif(i%3 == 0){\nif(dp[i] > dp[i/3] + 1){\ndp[i] = dp[i/3] + 1;\nbefore[i] = i/3;\n}\n}\nif(i%2 == 0){\nif(dp[i] > dp[i/2] + 1){\ndp[i] = dp[i/2] + 1;\nbefore[i] = i/2;\n}\n}\n}\ncout << dp[n] << '\\n';\nif(n != 0)\ncout << n << ' ';\nwhile(n != 1){\nn = before[n];\ncout << n << ' ';\n}\nreturn 0;\n}"
    },
    {
        "problem_tier": 13,
        "solution_code": "#include <iostream>\n#include <vector>\n#include <queue>\n#include <stack>\n#include <algorithm>\n#define MAX 100001\nusing namespace std;\nint n, k, pos, temp, m[] = {-1, 1, 0};\nint path[MAX], arr[MAX];\nint main() {\nios_base::sync_with_stdio(false);\ncin.tie(NULL);\ncout.tie(NULL);\ncin >> n >> k;\nif(n == k) {\ncout << 0 << \"\\n\" << n << \"\\n\";\nreturn 0;\n}"
    },
    {
        "problem_tier": 3,
        "solution_code": "#include<iostream>\n#include<string>\n#define endl '\\n'\nusing namespace std;\nint main() {\nios::sync_with_stdio(false);\ncin.tie(NULL);\ncout.tie(NULL);\nwhile (1) {\nstring st;\ngetline(cin, st);\nif (st == \"#\") {\nbreak;\n}\nint num = 0;\nfor (int i = 0; i < st.length(); i++) {\nif (st[i] == 'a' || st[i] == 'e' || st[i] == 'i' || st[i] == 'o' || st[i] == 'u') {\nnum++;\n} else if (st[i] == 'A' || st[i] == 'E' || st[i] == 'I' || st[i] == 'O' || st[i] == 'U') {\nnum++;\n}\n}\ncout << num << endl;\n}\nreturn 0;\n}"
    },
    {
        "problem_tier": 13,
        "solution_code": "#include<iostream>\nusing namespace std;\nlong long int n, b;\nlong long int a[5][5];\nlong long int tmp[5][5];\nlong long int ans[5][5];\nvoid Matrix_multi(long long int x[5][5], long long int y[5][5]) {\nfor(int i=0; i<n; i++) {\nfor(int j=0; j<n; j++) {\ntmp[i][j] = 0;             for(int k=0; k<n; k++) {\ntmp[i][j] += (x[i][k] * y[k][j]);\n}\ntmp[i][j] %= 1000;         }\n}\nfor(int i=0; i<n; i++) {\nfor(int j=0; j<n; j++) {\nx[i][j] = tmp[i][j];\n}\n}\n}\nint main() {\ncin >> n >> b;\nfor(int i=0; i<n; i++) {\nfor(int j=0; j<n; j++) {\ncin >> a[i][j];\n}\nans[i][i] = 1;     }\nwhile(b > 0) {\nif(b % 2 == 1) {             Matrix_multi(ans, a);\n}\nMatrix_multi(a, a);         b /= 2;\n}\nfor(int i=0; i<n; i++) {\nfor(int j=0; j<n; j++) {\ncout << ans[i][j] << \" \";\n}\ncout << endl;\n}\nreturn 0;\n}"
    },
    {
        "problem_tier": 4,
        "solution_code": "#include <iostream>\n#include <algorithm>\nusing namespace std;\nint main() {\nint N, M, K;\ncin >> N >> M >> K;\nint max_num = 0;\nfor (int i = 0; i <= K; i++) {\nint a = (N - i) / 2;\nint b = M - (K - i);\nmax_num = max(max_num, min(a, b));\n}\ncout << max_num << '\\n';\nreturn 0;\n}"
    },
    {
        "problem_tier": 14,
        "solution_code": "#include <iostream>\n#include <algorithm>\n#include <limits.h>\nusing namespace std;\nint t;\nint dp[501][501];\nint sum[501];\nint main() {\nios_base::sync_with_stdio(false);\ncin.tie(0);\ncin >> t;\nwhile (t--) {\nint k;\ncin >> k;\nfor (int i = 1; i <= k; i++) {\nint a;\ncin >> a;\nsum[i] = sum[i - 1] + a;         }\nfor (int i = 1; i < k; i++) {             for (int x = 1; x <= k - i; x++) {                 int y = x + i;\ndp[x][y] = INT_MAX;\nfor (int mid = x; mid < y; mid++) {                     dp[x][y] = min(dp[x][y], dp[x][mid] + dp[mid + 1][y] + sum[y] - sum[x - 1]);                 }\n}\n}\ncout << dp[1][k] << \"\\n\";\n}\nreturn 0;\n}"
    },
    {
        "problem_tier": 2,
        "solution_code": "#include <iostream>\nusing namespace std;\nint main() {\nint n, k, a, b;\ncin >> n >> k;\nfor (int i = 0; i < n; i++) {\ncin >> a >> b;\nk = k + a - b;\n}\ncout << \"비와이\";\nreturn 0;\n}"
    },
    {
        "problem_tier": 15,
        "solution_code": "#include <cstdio>\n#include <queue>\n#include <vector>\nusing namespace std;\nconst int MXN = 32001;\nint main() {\nint N, M, inDegree[MXN] = {0};\nvector<int> Problem[MXN + 1];\npriority_queue<int, vector<int>, greater<int>> pq;\nscanf(\"%d%d\", &N, &M);\nfor (int i = 0; i < M; i++) {\nint a, b;\nscanf(\"%d%d\", &a, &b);\nProblem[a].push_back(b);\ninDegree[b]++;\n}\nfor (int i = 1; i <= N; i++) {\nif (inDegree[i] == 0) {\npq.push(i);\n}\n}\nwhile (!pq.empty()) {\nint node = pq.top();\npq.pop();\nprintf(\"%d \", node);\nfor (int i = 0; i < Problem[node].size(); i++) {\nint nextNode = Problem[node][i];\ninDegree[nextNode]--;\nif (inDegree[nextNode] == 0) {\npq.push(nextNode);\n}\n}\n}\nreturn 0;\n}"
    },
    {
        "problem_tier": 3,
        "solution_code": "#include <iostream>\nusing namespace std;\nint main() {\nint L, A, B, C, D;\ncin >> L >> A >> B >> C >> D;\nint kor_day, math_day;\nif (A % C == 0)\nkor_day = A / C;\nelse\nkor_day = A / C + 1;\nif (B % D == 0)\nmath_day = B / D;\nelse\nmath_day = B / D + 1;\nint max_day = max(kor_day, math_day);\ncout << L - max_day << endl;\nreturn 0;\n}"
    },
    {
        "problem_tier": 2,
        "solution_code": "#include <iostream>\nusing namespace std;\nint main() {\nint n;\ncin >> n;\ncout << n - 1946 << endl;\nreturn 0;\n}"
    },
    {
        "problem_tier": 5,
        "solution_code": "#include<iostream>\n#include<string>\nusing namespace std;\nint main() {\nstring a;\nint sum = 10;\ncin >> a;\nfor(unsigned int i=1; i<a.size(); i++) {\nif(a[i-1] == a[i]) {\nsum += 5;\n}\nelse {\nsum += 10;\n}\n}\ncout << sum << endl;\nreturn 0;\n}"
    },
    {
        "problem_tier": 7,
        "solution_code": "#include <iostream>\nusing namespace std;\nint main() {\nint N, M, K;\nint pro1[101][101];\nint pro2[101][101];\nint res[101][101];\ncin >> N >> M;\nfor (int i = 0; i < N; i++) {\nfor (int j = 0; j < M; j++) {\ncin >> pro1[i][j];\n}\n}\ncin >> M >> K;\nfor (int i = 0; i < M; i++) {\nfor (int j = 0; j < K; j++) {\ncin >> pro2[i][j];\n}\n}\nfor (int i = 0; i < N; i++) {\nfor (int j = 0; j < K; j++) {\nfor (int k = 0; k < M; k++) {\nres[i][j] += pro1[i][k] * pro2[k][j];\n}\ncout << res[i][j] << \" \";\n}\ncout << endl;\n}\nreturn 0;\n}"
    },
    {
        "problem_tier": 14,
        "solution_code": "#include <iostream>\n#include <vector>\n#include <algorithm>\nusing namespace std;\n#define INF 1000000000\nint N;\nvector<pair<int, int>> matrix;\nvector<vector<int>> dp;\nint main() {\ncin >> N;\nmatrix.resize(N);\ndp.resize(N, vector<int>(N, INF));\nfor (int i = 0; i < N; i++) {\nint r, c;\ncin >> r >> c;\nmatrix[i] = make_pair(r, c);\n}\nfor (int i = 0; i < N; i++) {\ndp[i][i] = 0;\n}\nfor (int i = 1; i < N; i++) {\nfor (int j = 0; j < N - i; j++) {\nint end = j + i;\nfor (int k = j; k < end; k++) {\ndp[j][end] = min(dp[j][end], dp[j][k] + dp[k + 1][end] + matrix[j].first * matrix[k].second * matrix[end].second);\n}\n}\n}\ncout << dp[0][N - 1] << endl;\nreturn 0;\n}"
    },
    {
        "problem_tier": 8,
        "solution_code": "#include <iostream>\n#include <string>\n#include <map>\n#include <algorithm>\nusing namespace std;\nint main() {\nint n;\ncin >> n;\nmap<string, int> m;\nstring str;\nwhile (n--) {\ncin >> str;\nm[str]++;\n}\nint result = 0;\nfor (auto i = m.begin(); i != m.end(); i++) {\nresult = max(result, i->second);\n}\nfor (auto j = m.begin(); j != m.end(); j++) {\nif (result == j->second) {\ncout << j->first;\nreturn 0;\n}"
    },
    {
        "problem_tier": 15,
        "solution_code": "#include <iostream>\n#include <vector>\n#include <queue>\n#include <algorithm>\n#define MAX 300001\nusing namespace std;\nint N; int K; pair<int, int> v_jewelry[MAX];\nint v_bag[MAX];\npriority_queue<int, vector<int>, less<int>> pq;\nlong long solve() {\nsort(v_jewelry, v_jewelry + N);\nsort(v_bag, v_bag + K);\nint idx = 0;\nlong long sum = 0;\nfor (int i = 0; i < K; i++) {\nwhile (idx < N && v_bag[i] >= v_jewelry[idx].first) {\npq.push(v_jewelry[idx].second);\nidx++;\n}\nif (!pq.empty()) {\nsum += pq.top();\npq.pop();\n}\n}\nreturn sum;\n}\nint main() {\ncin >> N >> K;\nfor (int i = 0; i < N; ++i) {\ncin >> v_jewelry[i].first >> v_jewelry[i].second;\n}\nfor (int i = 0; i < K; ++i) {\ncin >> v_bag[i];\n}\ncout << solve();\nreturn 0;\n}"
    },
    {
        "problem_tier": 11,
        "solution_code": "#include <iostream>\n#include <vector>\nusing namespace std;\nint main() {\nvector<int> prime(1000001, 0);\nprime[0] = prime[1] = -1;\nfor (int i = 2; i * i <= 1000000; i++) {\nif (prime[i] == -1) continue;\nfor (int j = 2 * i; j <= 1000000; j += i) {\nif (prime[j] == -1) continue;\nelse prime[j] = -1;\n}\n}\nint n;\nwhile (true) {\nbool flag = false;\ncin >> n;\nif (n == 0) break;\nfor (int i = n; i >= (n / 2); i--) {\nif (prime[i] >= 0 && prime[n - i] >= 0) {\ncout << n << \"=\" << n - i << \"+\" << i << endl;\nflag = true;\nbreak;\n}\n}\nif (!flag) cout << \"Goldbach's conjecture is wrong.\" << endl;\n}\nreturn 0;\n}"
    },
    {
        "problem_tier": 10,
        "solution_code": "#include<iostream>\n#include<algorithm>\nusing namespace std;\nchar candies[51][51];\nint n;\nint ans;\nvoid check() {\nchar c;\nfor (int i = 0; i < n; i++) {\nint count = 1;         c = candies[i][0];\nfor (int j = 1; j < n; j++) {\nif (candies[i][j] == c) {\ncount += 1;\n} else {\ncount = 1;\n}\nc = candies[i][j];\nif (count > ans) ans = count;\n}\n}\nfor (int j = 0; j < n; j++) {\nint count = 1;         c = candies[0][j];\nfor (int i = 1; i < n; i++) {\nif (candies[i][j] == c) {\ncount += 1;\n} else {\ncount = 1;\n}\nc = candies[i][j];\nif (count > ans) ans = count;\n}\n}\n}\nint main() {\ncin >> n;\nfor (int i = 0; i < n; i++) {\nfor (int j = 0; j < n; j++) {\ncin >> candies[i][j];\n}\n}\nfor (int i = 0; i < n; i++) {         for (int j = 0; j < n-1; j++) {\nswap(candies[i][j], candies[i][j+1]);\ncheck();\nswap(candies[i][j], candies[i][j+1]);\n}\n}\nfor (int j = 0; j < n; j++) {         for (int i = 0; i < n-1; i++) {\nswap(candies[i][j], candies[i+1][j]);\ncheck();\nswap(candies[i][j], candies[i+1][j]);\n}\n}\ncout << ans;\nreturn 0;\n}"
    },
    {
        "problem_tier": 14,
        "solution_code": "#include <iostream>\n#include <vector>\n#include <cstring>\nusing namespace std;\nint connect[100001];\nbool done[100001];\nbool visited[100001];\nint T, n, cnt;\nvoid dfs(int x){\nvisited[x] = true;\nint y = connect[x];\nif(!visited[y])\ndfs(y);\nelse{\nif(!done[y]){\nfor(int i = y; i != x; i = connect[i]){\ncnt++;\n}\ncnt++;\n}\n}\ndone[x] = true;\n}\nint main(int argc, const char * argv[]) {\ncin >> T;\nfor(int i = 0; i < T; i++){\ncin >> n;\ncnt = 0;\nmemset(connect, 0, sizeof(connect));\nmemset(done, false, sizeof(done));\nmemset(visited, false, sizeof(visited));\nfor(int j = 1; j <= n; j++){\ncin >> connect[j];\n}\nfor(int j = 1; j <= n; j++){\nif(!visited[j])\ndfs(j);\n}\ncout << n - cnt << '\\n';\n}\nreturn 0;\n}"
    },
    {
        "problem_tier": 6,
        "solution_code": "#include <iostream>\n#include <string>\n#include <cmath>\n#include <algorithm>\nusing namespace std;\nint main() {\nstring binary;\ncin >> binary;\nstring result;\nint len = binary.length();\nint i = 0;\nif (len % 3 == 1) {\ncout << binary[0];\ni = 1;\n} else if (len % 3 == 2) {\ncout << ((binary[0] - '0') * 2) + (binary[1] - '0');\ni = 2;\n}\nfor (; i < len; i += 3) {\ncout << ((binary[i] - '0') * 4) + ((binary[i + 1] - '0') * 2) + (binary[i + 2] - '0');\n}\ncout << '\\n';\nreturn 0;\n}"
    },
    {
        "problem_tier": 5,
        "solution_code": "#include <iostream>\n#include <string>\n#include <vector>\nusing namespace std;\nint main(void){\nios_base::sync_with_stdio(0);\ncin.tie(0);\ncout.tie(0);\nstring str;\nvector<int> cnt(4, 0);\nwhile(getline(cin, str)){\nif(str.size() == 0){\nbreak;\n}\nfor(auto k : str){\nif(islower(k)){                 cnt[0]++;\n}\nelse if(isupper(k)){                 cnt[1]++;\n}\nelse if(isdigit(k)){                 cnt[2]++;\n}\nelse if(k == ' '){                 cnt[3]++;\n}\n}\nfor(auto k : cnt){\ncout << k << \" \";\n}\ncout << \"\\n\";\ncnt.assign(4, 0);\nstr.clear();\n}\nreturn 0;\n}"
    },
    {
        "problem_tier": 4,
        "solution_code": "#include<iostream>\nusing namespace std;\nint main(){\nint Get_on[10];     int Get_off[10];     int max = 0;\nint people = 0;\nfor(int i=0; i<10; i++){\ncin >> Get_on[i] >> Get_off[i];\npeople = Get_off[i] - Get_on[i] + people;\nif(max < people)\nmax = people;\n}\ncout << max << endl;\nreturn 0;\n}"
    },
    {
        "problem_tier": 2,
        "solution_code": "#include <iostream>\nusing namespace std;\nint main() {\nint n;\ncin >> n;\ncout << 1 << \"\\n\" << 0;\nreturn 0;\n}"
    },
    {
        "problem_tier": 13,
        "solution_code": "#include <iostream>\n#include <string>\n#include <algorithm>\nusing namespace std;\nint dp[1001][1001] = {0,};\nint main() {\nstring a, b;\nstring result;\ncin >> a >> b;\na = \" \" + a;\nb = \" \" + b;\nfor (int i = 1; i < b.size(); i++) {\nfor (int j = 1; j < a.size(); j++) {\nif (a[j] == b[i])\ndp[i][j] = dp[i-1][j-1] + 1;\nelse\ndp[i][j] = max(dp[i-1][j], dp[i][j-1]);\n}\n}\nint col = a.size() - 1;\nint row = b.size() - 1;\nwhile (dp[row][col]) {\nif (dp[row][col] == dp[row-1][col]) {\nrow--;\n} else if (dp[row][col] == dp[row][col-1]) {\ncol--;\n} else {\nresult += a[col];\nrow--, col--;\n}\n}\ncout << dp[b.size()-1][a.size()-1] << endl;\nif (result.size() > 0) {\nreverse(result.begin(), result.end());\ncout << result << endl;\n}\nreturn 0;\n}"
    },
    {
        "problem_tier": 10,
        "solution_code": "#include<iostream>\n#include<list>\nusing namespace std;\nint main() {\nint N;\nstring s;\ncin >> N;\nlist<char>::iterator it;\nlist<char> password;\nfor (int i = 0; i < N; ++i) {\ncin >> s;\npassword.clear();\nit = password.begin();\nfor (int j = 0; j < s.length(); ++j) {\nif (s[j] == '<') {\nif (it != password.begin())\nit--;\n}\nelse if (s[j] == '>') {\nif (it != password.end())\nit++;\n}\nelse if (s[j] == '-') {\nif (it != password.begin())\nit = password.erase(--it);\n}\nelse {\nit = password.insert(it, s[j]);\nit++;\n}\n}\nfor (char x : password)\ncout << x;\ncout << endl;\n}\nreturn 0;\n}"
    },
    {
        "problem_tier": 16,
        "solution_code": "#include <iostream>\n#include <algorithm>\nusing namespace std;\nint N, K;\nlong long count(long long x) {\nlong long sum = 0;\nfor(int i = 1; i <= N; i++) {\nsum += min(x / i, (long long)N);\n}\nreturn sum;\n}\nint main() {\ncin >> N >> K;\nK = min((long long)1000000000, (long long)K);\nlong long Low = 1;\nlong long High = N * N;\nwhile(Low <= High) {\nlong long Mid = (Low + High) / 2;\nlong long cnt = count(Mid);\nif(cnt >= K) {\nHigh = Mid - 1;\n}\nelse {\nLow = Mid + 1;\n}\n}\ncout << Low << endl;\nreturn 0;\n}"
    },
    {
        "problem_tier": 13,
        "solution_code": "#include <iostream>\n#include <vector>\n#include <algorithm>\nusing namespace std;\nint main(){\nint N;\ncin >> N;\nvector<int> arr(N+1);\nfor(int i=1; i<=N; i++)\ncin >> arr[i];\nvector<vector<int>> dp(N+1, vector<int>(N+1));\nfor(int i=1; i<=N; i++){\ndp[i][i] = 1;         if(i != 1 && arr[i-1] == arr[i])\ndp[i-1][i] = 1;     }\nfor(int i=2; i<=N-1; i++){\nfor(int j=1; i+j<=N; j++){\nif(arr[j] == arr[i+j] && dp[j+1][i+j-1] == 1)\ndp[j][i+j] = 1;\n}\n}\nint M;\ncin >> M;\nfor(int i=0; i<M; i++){\nint s, e;\ncin >> s >> e;\nif(dp[s][e] == 1)\ncout << 1 << \"\\n\";\nelse\ncout << 0 << \"\\n\";\n}\nreturn 0;\n}"
    },
    {
        "problem_tier": 9,
        "solution_code": "#include <iostream>\n#include <string>\nusing namespace std;\nstring combination[101][101];\nstring bigNumAdd(string num1, string num2) {\nstring ans = \"\";\nint sum = 0;\nint size = max(num1.size(), num2.size());\nfor (int i = 0; i < size || sum; i++) {\nif (i < num1.size())\nsum += num1[i] - '0';\nif (i < num2.size())\nsum += num2[i] - '0';\nans += sum % 10 + '0';\nsum /= 10;\n}\nreturn ans;\n}\nstring combination(int n, int m) {\nif (n == m || m == 0)\nreturn \"1\";\nif (combination[n][m] != \"\")\nreturn combination[n][m];\nreturn combination[n][m] = bigNumAdd(combination(n-1, m-1), combination(n-1, m));\n}\nint main() {\nint n, m;\ncin >> n >> m;\ncout << combination(n, m);\nreturn 0;\n}"
    },
    {
        "problem_tier": 2,
        "solution_code": "#include<iostream>\nusing namespace std;\nint main(){\ncout<<\"NFC West W L T\"<<endl;\ncout<<\"-----------------------\"<<endl;\ncout<<\"Seattle     13 3 0\"<<endl;\ncout<<\"San Francisco     12 4 0\"<<endl;\ncout<<\"Arizona     10 6 0\"<<endl;\ncout<<\"St. Louis     7 9 0\"<<endl;\ncout<<endl;\ncout<<\"NFC North W L T\"<<endl;\ncout<<\"-----------------------\"<<endl;\ncout<<\"Green Bay     8 7 1\"<<endl;\ncout<<\"Chicago     8 8 0\"<<endl;\ncout<<\"Detroit     7 9 0\"<<endl;\ncout<<\"Minnesota     5 10 1\"<<endl;\nreturn 0;\n}"
    },
    {
        "problem_tier": 8,
        "solution_code": "#include<iostream>\nusing namespace std;\nint main() {\nint n;\ncin >> n;\nint result = 0;\nfor (int i = 1; i <= n; i *= 10) {\nresult += n - i + 1;\n}\ncout << result << endl;\nreturn 0;\n}"
    },
    {
        "problem_tier": 4,
        "solution_code": "#include <iostream>\nusing namespace std;\nint main() {\nint N, A = 0, cnt = 0;\nint p[500001];\ncin >> N;\nfor (int i = 0; i < N; i++) {\ncin >> p[i];\nA = A + p[i];\ncnt ++;\n}\ncout << A - (cnt - 1);\nreturn 0;\n}"
    },
    {
        "problem_tier": 5,
        "solution_code": "#include<iostream>\nusing namespace std;\nint main(){\nint N, F;\ncin >> N >> F;\nN = (N / 100) * 100;\nint answer = 0;\nwhile((N + answer) % F != 0 && answer < 100)\nanswer++;\nif(answer < 10)\nprintf(\"0%d\", answer);\nelse\nprintf(\"%d\", answer);\nreturn 0;\n}"
    },
    {
        "problem_tier": 12,
        "solution_code": "#include<iostream>\n#include<vector>\nusing namespace std;\nstruct Node {\nint val;\nNode *left, *right;\n};\nNode* createNode(int val) {\nNode* newNode = new Node();\nnewNode->val = val;\nnewNode->left = newNode->right = NULL;\nreturn newNode;\n}\nNode* insert(Node* root, int val) {\nif (root == NULL) {\nroot = createNode(val);\nreturn root;\n}\nif (val < root->val)\nroot->left = insert(root->left, val);\nelse\nroot->right = insert(root->right, val);\nreturn root;\n}\nvoid postOrder(Node* root) {\nif (root == NULL)\nreturn;\npostOrder(root->left);\npostOrder(root->right);\ncout << root->val << \"\\n\";\n}\nint main() {\ncin.tie(0);\ncout.tie(0);\nios::sync_with_stdio(false);\nNode* root = NULL;\nint num;\nwhile (cin >> num) {\nroot = insert(root, num);\n}\npostOrder(root);\nreturn 0;\n}"
    },
    {
        "problem_tier": 12,
        "solution_code": "#include <iostream>\n#include <queue>\nusing namespace std;\nint H, W;\nconst int MAX = 51;\nchar map[MAX][MAX];\nbool visited[MAX][MAX];\nint path[MAX][MAX];\nint dy[] = { 0,0,-1,1 };\nint dx[] = { -1,1,0,0 };\nqueue<pair<int, int>> q;\nint max_len = 0;\nint BFS(int y, int x) {\npath[y][x] = 1;\nvisited[y][x] = true;\nq.push(make_pair(y, x));\nwhile (!q.empty()) {\ny = q.front().first;\nx = q.front().second;\nq.pop();\nfor (int i = 0; i < 4; i++) {\nint ny = y + dy[i];\nint nx = x + dx[i];\nif (ny < 0 || nx < 0 || ny >= H || nx >= W)\ncontinue;\nif (map[ny][nx] == 'L' && !visited[ny][nx]) {\nvisited[ny][nx] = true;\npath[ny][nx] = path[y][x] + 1;\nq.push(make_pair(ny, nx));\nif (max_len < path[ny][nx]) {\nmax_len = path[ny][nx];\n}\n}\n}\n}\nreturn max_len - 1;\n}\nvoid reset() {\nfor (int i = 0; i < H; i++) {\nfor (int j = 0; j < W; j++) {\nvisited[i][j] = 0;\npath[i][j] = 0;\n}\n}\nmax_len = 0;\n}\nint main() {\ncin >> H >> W;\nfor (int i = 0; i < H; i++) {\nfor (int j = 0; j < W; j++) {\nscanf(\"%1s\", &map[i][j]);\n}\n}\nint ans = 0;\nfor (int i = 0; i < H; i++) {\nfor (int j = 0; j < W; j++) {\nif (map[i][j] == 'L') {\nint temp = BFS(i, j);\nif (temp > ans) {\nans = temp;\n}\nreset();\n}\n}\n}\ncout << ans;\n}"
    },
    {
        "problem_tier": 8,
        "solution_code": "#include <iostream>\nusing namespace std;\nint GCD(int a, int b){\nif (a < b) { return GCD(a, b % a); }\nif (b == 0) { return a; }\nreturn GCD(b, a % b);\n}\nint main() {\nint n;\ncin >> n;\nint radius[n];\nfor (int i = 0; i < n; i++) {\ncin >> radius[i];\n}\nfor (int i = 1; i < n; i++) {\nint gcd = GCD(radius[0], radius[i]);\nif (gcd == 1) {\ncout << radius[0] << \"/\" << radius[i] << \"\\n\";\n} else {\ncout << radius[0] / gcd << \"/\" << radius[i] / gcd << \"\\n\";\n}\n}\nreturn 0;\n}"
    },
    {
        "problem_tier": 2,
        "solution_code": "#include <iostream>\n#include <string>\nusing namespace std;\nint main() {\nstring able;\nstring want;\ngetline(cin, able, '\\n');\ngetline(cin, want, '\\n');\nif (able.size() >= want.size()) {\ncout << \"go\";\n} else {\ncout << \"no\";\n}\nreturn 0;\n}"
    },
    {
        "problem_tier": 11,
        "solution_code": "#include <iostream>\n#include <queue>\nusing namespace std;\nconst int MAX = 500;\nint arr[MAX][MAX];\nbool visited[MAX][MAX];\nint mov[4][2] = { {-1,0}, {1,0}, {0,-1}, {0,1} };\nint m, n;\nint cnt;\nint picCnt = 0;\nint maxSize = 0;\nbool isInArr(int x, int y) {\nreturn x >= 0 && x < n && y >= 0 && y < m ? true : false;\n}\nvoid DFS(int x, int y) {\nint nx, ny;\nfor (int i = 0; i < 4; ++i) {\nnx = x + mov[i][0];\nny = y + mov[i][1];\nif (isInArr(nx, ny) && arr[nx][ny] && !visited[nx][ny]) {\nvisited[nx][ny] = true;\ncnt++;\nDFS(nx, ny);\n}\n}\n}\nint main(void) {\nios_base::sync_with_stdio(false);\ncin.tie(nullptr);\ncout.tie(nullptr);\ncin >> n >> m;\nfor (int i = 0; i < n; ++i) {\nfor (int j = 0; j < m; ++j) {\ncin >> arr[i][j];\n}\n}\nfor (int i = 0; i < n; ++i) {\nfor (int j = 0; j < m; ++j) {\nif (!visited[i][j] && arr[i][j]) {\npicCnt++;\ncnt = 1;\nvisited[i][j] = true;\nDFS(i, j);\nif (cnt > maxSize) maxSize = cnt;\n}\n}\n}\ncout << picCnt << \"\\n\" << maxSize << \"\\n\";\nreturn 0;\n}"
    },
    {
        "problem_tier": 13,
        "solution_code": "#include<iostream>\n#include<queue>\nusing namespace std;\nint N, M;\nint arr[101][101] = { 0, };\nint result = 0;\nint result2 = 0;\nint y_ar[4] = { 0,0,1,-1 };\nint x_ar[4] = { 1,-1"
    },
    {
        "problem_tier": 13,
        "solution_code": "#include <iostream>\n#include <vector>\n#include <cstring>\nusing namespace std;\nchar board[6144][6144];\nvoid drawStar(int x, int y){\nboard[x][y] = '*';\nboard[x+1][y-1] = '*';\nboard[x+1][y+1] = '*';\nfor(int i=0; i<5; i++){\nboard[x+2][y-2+i] = '*';\n}\n}\nvoid recursive(int n, int x, int y){\nif(n == 3){\ndrawStar(x, y);\nreturn;\n}\nrecursive(n/2, x, y);\nrecursive(n/2, x+n/2, y-n/2);\nrecursive(n/2, x+n/2, y+n/2);\n}\nint main(){\nios::sync_with_stdio(NULL);\ncin.tie(NULL);\nint N;\ncin >> N;\nmemset(board, ' ', sizeof(board));\nrecursive(N, 0, N-1);\nfor(int i=0; i<N; i++){\nfor(int j=0; j<2*N-1; j++){\ncout << board[i][j];\n}\ncout << \"\\n\";\n}\nreturn 0;\n}"
    },
    {
        "problem_tier": 11,
        "solution_code": "#include <iostream>\n#include <queue>\nusing namespace std;\nint N;\nint arr[100][100];\nlong long dp[100][100];\nint round_col[2] = {1, 0};\nint round_row[2] = {0, 1};\nvoid dp_calculate() {\ndp[0][0] = 1;\nfor (int i = 0; i < N; i++) {\nfor (int j = 0; j < N; j++) {\nif (dp[i][j] == 0 || (i == N-1 && j == N-1))\ncontinue;\nint move_val = arr[i][j];\nfor (int k = 0; k < 2; k++) {\nint next_row = i + move_val * round_row[k];\nint next_col = j + move_val * round_col[k];\nif (next_row >= 0 && next_row < N && next_col >= 0 && next_col < N) {\ndp[next_row][next_col] += dp[i][j];\n}\n}\n}\n}\n}\nint main() {\nios::sync_with_stdio(false);\ncin.tie(NULL);\ncout.tie(NULL);\ncin >> N;\nfor (int i = 0; i < N; i++) {\nfor (int j = 0; j < N; j++) {\ncin >> arr[i][j];\n}\n}\ndp_calculate();\ncout << dp[N-1][N-1] << endl;\nreturn 0;\n}"
    },
    {
        "problem_tier": 4,
        "solution_code": "#include <iostream>\n#include <string>\nusing namespace std;\nint main() {\nint a, b, c, d;\ncin >> a >> b >> c >> d;\nstring s1 = to_string(a) + to_string(b);     string s2 = to_string(c) + to_string(d);\nlong long n1 = stoll(s1);\nlong long n2 = stoll(s2);\ncout << n1 + n2 << '\\n';\nreturn 0;\n}"
    },
    {
        "problem_tier": 14,
        "solution_code": "#include <iostream>\n#include <vector>\n#include <cstring>\nusing namespace std;\nint map[100][100] = {0};\nint res = 0;\nint sloped[100] = {0};\nint N, L;\nvoid simulation() {\nfor(int i=0;i<N;i++) {\nmemset(sloped,0,sizeof(int)*100);\nint suc=1;\nint last=map[i][N-1];\nint j;\nfor(j=N-2;j>=0;j--) {\nif(map[i][j]==last) {\nsuc++;\n}\nelse if(map[i][j]-last==1) {\nif(suc>=L) {\nfor(int k=1;k<=L;k++) {\nsloped[j+k]=-1;\n}\nsuc=1;\nlast=map[i][j];\n}\nelse {\nbreak;\n}\n}\nelse if(last-map[i][j]==1) {\nsuc=1;\nlast=map[i][j];\n}\nelse {\nbreak;\n}\n}\nif(j>=0)continue;\nsuc=1;\nlast=map[i][0];\nfor(j=1;j<N;j++) {\nif(sloped[j]==-1) {\nsuc=1;\nlast=map[i][j+L];\nj+=L;\n}\nelse if(map[i][j]==last) {\nsuc++;\n}\nelse if(map[i][j]-last==1) {\nif(suc>=L) {\nfor(int k=1;k<=L;k++) {\nsloped[j-k]=1;\n}\nsuc=1;\nlast=map[i][j];\n}\nelse {\nbreak;\n}\n}\nelse if(last-map[i][j]==1) {\nsuc=1;\nlast=map[i][j];\n}\nelse {\nbreak;\n}\n}\nif(j<N)continue;\nint height=map[i][0];\nint x=0;\nwhile(true) {\nif(x>=N) {\nif(height==map[i][N-1]) {\nres++;\n}\nbreak;\n}\nif(sloped[x]==0) {\nx++;\n}\nelse if(sloped[x]==1) {\nx+=L;\nheight++;\n}\nelse if(sloped[x]==-1) {\nx+=L;\nheight--;\n}\n}\n}\n}\nint main(void) {\nios::sync_with_stdio(false);\ncin.tie(NULL);\ncin>>N>>L;\nfor(int i=0;i<N;i++) {\nfor(int j=0;j<N;j++) {\ncin>>map[i][j];\n}\n}\nsimulation();\nint copied[100][100]={0};\nfor(int i=0;i<N;i++) {\nfor(int j=0;j<N;j++) {\ncopied[i][j]=map[i][j];\n}\n}\nfor(int i=0;i<N;i++) {\nfor(int j=0;j<N;j++) {\nmap[i][j]=copied[j][i];\n}\n}\nsimulation();\ncout<<res<<'\\n';\nreturn 0;\n}"
    },
    {
        "problem_tier": 13,
        "solution_code": "#include <iostream>\n#include <vector>\n#include <string>\n#include <algorithm>\nusing namespace std;\nint main() {\nint N;\ncin >> N;\nvector<string> words(N, \"00000000\");\nvector<char> nums(26, ' ');\nfor (int i = 0; i < N; i++) {\nstring str;\ncin >> str;\nwords[i].replace(8 - str.size(), str.size(), str);\n}\nsort(words.begin(), words.end(), greater<>());\nchar nowNum = '9';\nfor (int i = 0; i < 8; i++) {\nfor (int w = 0; w < words.size(); w++) {\nchar c = words[w][i];\nif (c == '0') continue;\nwords[w].erase(i, 1);\nif (nums[c - 'A'] != ' ') {\nwords[w].insert(i, 1, nums[c - 'A']);\n}\nelse {\nwords[w].insert(i, 1, nowNum);\nnums[c - 'A'] = nowNum;\nnowNum--;\n}\n}\n}\nint ans = 0;\nfor (int w = 0; w < words.size(); w++) {\nans += stoi(words[w]);\n}\ncout << ans << endl;\nreturn 0;\n}"
    },
    {
        "problem_tier": 10,
        "solution_code": "#include<iostream>\n#include<climits>\nusing namespace std;\nint main() {\nint n, m, b;\nint map[500][500];\nint leastTime = INT_MAX;\nint mostHeight;\ncin >> n >> m >> b;\nfor (int i = 0; i < n; i++) {\nfor (int j = 0; j < m; j++) {\ncin >> map[i][j];\n}\n}\nfor (int h = 0; h <= 256; h++) {\nint build = 0;\nint remove = 0;\nfor (int i = 0; i < n; i++) {\nfor (int j = 0; j < m; j++) {\nint height = map[i][j] - h;\nif (height > 0) {\nremove += height;\n} else if (height < 0) {\nbuild -= height;\n}\n}\n}\nif (remove + b >= build) {\nint time = remove * 2 + build;\nif (leastTime >= time) {\nleastTime = time;\nmostHeight = h;\n}\n}\n}\ncout << leastTime << \" \" << mostHeight << '\\n';\nreturn 0;\n}"
    },
    {
        "problem_tier": 16,
        "solution_code": "#include<iostream>\n#include<vector>\n#include<algorithm>\n#include<cmath>\nusing namespace std;\nusing ll = long long;\nstruct Segment{\nvector<ll> tree;\nvector<ll> seq;\nSegment(ll n){\nseq.resize(n+1);\nll log = ceil(log2(n));\nll t = (1LL<<(log+1));\ntree.resize(t);\n}\nvoid init(ll node, ll s, ll e){\nll mid = (s+e)/2;\nif(s==e)\ntree[node] = seq[s];\nelse{\ninit(node*2, s, mid);\ninit(node*2+1, mid+1, e);\ntree[node] = tree[node*2] + tree[node*2+1];\n}\n}\nll query(ll node, ll s, ll e, ll i, ll j){\nll mid = (s+e)/2;\nif(i>e || j<s)\nreturn 0;\nif(i<=s && e<=j)\nreturn tree[node];\nreturn query(node*2, s, mid, i, j) + query(node*2+1, mid+1, e, i, j);\n}\nvoid update(ll node, ll s, ll e, ll i, ll u){\nll mid = (s+e)/2;\nif(i<s || i>e)\nreturn;\ntree[node] += u;\nif(s!=e){\nupdate(node*2, s, mid, i, u);\nupdate(node*2+1, mid+1, e, i, u);\n}\n}\n};\nint main(){\nios::sync_with_stdio(0);\ncin.tie(0);\nll N, M, K;\nll a, b, c;\ncin >> N >> M >> K;\nSegment se(N);\nfor(int i=1; i<=N; i++)\ncin >> se.seq[i];\nse.init(1, 1, N);\nint aa = M + K;\nwhile(aa--){\ncin >> a >> b >> c;\nif(a==1){\nse.update(1, 1, N, b, c-se.seq[b]);\nse.seq[b] = c;\n}\nelse\ncout << se.query(1, 1, N, b, c) << \"\\n\";\n}\n}"
    },
    {
        "problem_tier": 13,
        "solution_code": "#include<iostream>\n#include<queue>\n#include<vector>\nusing namespace std;\nint map[100][100];\nint cost[100][100];\nint X[4] = {1, -1, 0, 0};\nint Y[4] = {0, 0, 1, -1};\npriority_queue<pair<int, pair<int, int>>> pq;\nint main(void){\nint n, m;\nint x, y, cnt;\nint next_x, next_y, next_cnt;\nscanf(\"%d%d\", &m, &n);\nfor(int i=0; i<n; i++){\nfor(int j=0; j<m; j++){\nscanf(\"%1d\", &map[i][j]);\ncost[i][j] = -1;\n}\n}\ncost[0][0] = 0;\npq.push(make_pair(0, make_pair(0, 0)));\nwhile(!pq.empty()){\ncnt = -pq.top().first;\nx = pq.top().second.first;\ny = pq.top().second.second;\npq.pop();\nif(cost[x][y] < cnt) continue;\nfor(int i=0; i<4; i++){\nnext_x = x + X[i];\nnext_y = y + Y[i];\nnext_cnt = cnt + map[next_x][next_y];\nif(next_x < 0 || next_x >= n || next_y < 0 || next_y >= m)\ncontinue;\nif(cost[next_x][next_y] == -1){\ncost[next_x][next_y] = next_cnt;\npq.push(make_pair(-next_cnt, make_pair(next_x, next_y)));\n}\nelse if(cost[next_x][next_y] > next_cnt){\ncost[next_x][next_y] = next_cnt;\npq.push(make_pair(-next_cnt, make_pair(next_x, next_y)));\n}\n}\n}\nprintf(\"%d\\n\", cost[n-1][m-1]);\nreturn 0;\n}"
    },
    {
        "problem_tier": 2,
        "solution_code": "#include<iostream>\nusing namespace std;\nint main(){\nint N;\ncin>>N;\nif(N % 2 == 0){\ncout<<\"white\";\n}\nelse {\ncout<<\"black\";\n}\nreturn 0;\n}"
    },
    {
        "problem_tier": 13,
        "solution_code": "#include<iostream>\n#include<algorithm>\n#include<vector>\n#include<queue>\nusing namespace std;\nint N, M, x;\nint city[201][201];\nbool visit[201];\nbool flag;\nvector<int> check_list;\nqueue<int> q;\nint main() {\nios_base::sync_with_stdio(0);\ncin.tie(0);\ncin >> N >> M;\nfor(int i = 1; i <= N; i++) {\nfor(int j = 1; j <= N; j++) {\ncin >> city[i][j];\n}\n}\nfor(int i = 1; i <= M; i++) {\ncin >> x;\ncheck_list.push_back(x);\n}\nq.push(check_list[0]);\nwhile(!q.empty()) {\nint now = q.front();\nq.pop();\nvisit[now] = true;\nfor(int i = 1; i <= N; i++) {\nif(city[now][i] == 1 && !visit[i]) {\nq.push(i);\n}\n}\n}\nflag = true;\nfor(int i = 0; i < check_list.size(); i++) {\nif(!visit[check_list[i]]) {\nflag = false;\nbreak;\n}\n}\ncout << (flag ? \"YES\" : \"NO\");\nreturn 0;\n}"
    },
    {
        "problem_tier": 9,
        "solution_code": "#include<iostream>\nusing namespace std;\nint gcd(int a, int b){\nif(b>a)\nreturn gcd(b, a);\nif(a%b==0)\nreturn b;\nreturn gcd(b, a%b);\n}\nint main(){\nint up, down, up1, down1;\ncin>>up>>down>>up1>>down1;\nint N = down1 * up + up1 * down;\nint M = down1 * down;\ncout<<N/gcd(N, M)<<\" \"<<M/gcd(N, M)<<endl;\nreturn 0;\n}"
    },
    {
        "problem_tier": 4,
        "solution_code": "#include <iostream>\n#include <algorithm>\nusing namespace std;\nint main() {\nwhile (1) {\nint triangle[3];\nfor (int i = 0; i < 3; i++) {\ncin >> triangle[i];\n}\nif (triangle[0] == 0 && triangle[0] == triangle[1] && triangle[0] == triangle[2]) {\nbreak;\n}\nsort(triangle, triangle + 3);\nif (triangle[2] >= triangle[1] + triangle[0]) {\ncout << \"Invalid\" << '\\n';\n}\nelse if (triangle[0] != triangle[1] && triangle[1] != triangle[2] && triangle[0] != triangle[2]) {\ncout << \"Scalene\" << '\\n';\n}\nelse {\nif (triangle[0] == triangle[1] && triangle[1] == triangle[2]) {\ncout << \"Equilateral\" << '\\n';\n}\nelse {\ncout << \"Isosceles\" << '\\n';\n}\n}\n}\nreturn 0;\n}"
    },
    {
        "problem_tier": 8,
        "solution_code": "#include<iostream>\n#include<algorithm>\nusing namespace std;\ntypedef long long ll;\nll gcd(ll a, ll b){\nif(b==0){\nreturn a;\n}\nelse{\nreturn gcd(b, a%b);\n}\n}\nint main(){\nios_base::sync_with_stdio(0);\ncin.tie(0);\ncout.tie(0);\nint t,n;\ncin >> t;\nll res=0;\nfor(ll i=0; i<t; ++i){\nres=0;\ncin >> n;\nll arr[n];\nfor(ll i=0; i<n; ++i){\ncin >> arr[i];\n}\nfor(ll i=0; i<n-1; ++i){\nfor(ll j=i+1; j<n; ++j){\nres += gcd(arr[i], arr[j]);\n}\n}\ncout << res << \"\\n\";\n}\n}\n2 :\n#include<iostream>\n#include<vector>\nusing namespace std;\nint gcd(int a, int b){\nint c;\nwhile(b != 0){\nc = a % b;\na = b;\nb = c;\n}\nreturn a;\n}\nint main(){\ncin.tie(0);\nios_base::sync_with_stdio(0);\nint t;\ncin >> t;\nwhile(t--){\nint n;\ncin >> n;\nvector<int> arr(n);\nfor(int i=0; i<n; i++){\ncin >> arr[i];\n}\nlong long sum = 0;\nfor(int i=0; i<n-1; i++){\nfor(int j=i+1; j<n; j++){\nsum += gcd(arr[i], arr[j]);\n}\n}\ncout << sum << \"\\n\";\n}\nreturn 0;\n}"
    },
    {
        "problem_tier": 5,
        "solution_code": "#include<iostream>\nusing namespace std;\nint main() {\nint a, b, c, d, e, f;\ncin >> a >> b >> c >> d >> e >> f;\nfor (int i = -999; i <= 999; i++) {\nfor (int j = -999; j <= 999; j++) {\nif ((i * a + j * b == c) && (i * d + j * e == f)) {\ncout << i << \" \" << j;\nreturn 0;\n}"
    },
    {
        "problem_tier": 10,
        "solution_code": "#include <iostream>\n#include <vector>\n#include <set>\n#include <algorithm>\nusing namespace std;\nint N, M;\nint arr[8];\nvector<int> v;\nvoid NandM(int idx, int start){\nif(idx == M){\nfor(int i = 0; i < M; i++){\ncout << v[arr[i]] << \" \";\n}\ncout << \"\\n\";\nreturn;\n}\nfor(int i = start; i < v.size(); i++){\narr[idx] = i;\nNandM(idx + 1, i);\n}\n}\nint main(){\nios::sync_with_stdio(0);\ncin.tie(0);\ncin >> N >> M;\nset<int> s;\nfor(int i = 0; i < N; i++){\nint num;\ncin >> num;\nif(s.find(num) == s.end()){\ns.insert(num);\nv.push_back(num);\n}\n}\nsort(v.begin(), v.end());\nNandM(0, 0);\nreturn 0;\n}"
    },
    {
        "problem_tier": 13,
        "solution_code": "#include <iostream>\n#include <vector>\n#include <algorithm>\nusing namespace std;\nint main() {\nint n;\ncin >> n;\nvector<int> arr(n);\nvector<int> dp(n, 1);\nvector<int> answer;\nfor (int i = 0; i < n; i++) {\ncin >> arr[i];\n}\nfor (int i = 1; i < n; i++) {\nfor (int j = 0; j < i; j++) {\nif (arr[i] > arr[j]) {\ndp[i] = max(dp[i], dp[j] + 1);\n}\n}\n}\nint maxLen = *max_element(dp.begin(), dp.end());\nint idx = max_element(dp.begin(), dp.end()) - dp.begin();\nanswer.push_back(arr[idx]);\nmaxLen--;\nfor (int i = idx - 1; i >= 0; i--) {\nif (arr[i] < arr[idx] && dp[i] + 1 == dp[idx]) {\nanswer.push_back(arr[i]);\nidx = i;\nmaxLen--;\n}\n}\ncout << maxLen << \"\\n\";\nfor (int i = answer.size() - 1; i >= 0; i--) {\ncout << answer[i] << \" \";\n}\nreturn 0;\n}"
    },
    {
        "problem_tier": 2,
        "solution_code": "#include<iostream>\nusing namespace std;\nint main() {\ncout << \"SHIP NAME      CLASS          DEPLOYMENT IN SERVICE\" << endl;\ncout << \"N2 Bomber      Heavy Fighter  Limited    21        \" << endl;\ncout << \"J-Type 327     Light Combat   Unlimited  1         \" << endl;\ncout << \"NX Cruiser     Medium Fighter Limited    18        \" << endl;\ncout << \"N1 Starfighter Medium Fighter Unlimited  25        \" << endl;\ncout << \"Royal Cruiser  Light Combat   Limited    4         \" << endl;\nreturn 0;\n}"
    },
    {
        "problem_tier": 5,
        "solution_code": "#include <iostream>\nusing namespace std;\nint main() {\nios_base::sync_with_stdio(false);\ncin.tie(nullptr);\ncout.tie(nullptr);\nint n;\ncin >> n;\nif (n == 1) {\ncout << \"*\" << '\\n';\n} else {\nfor (int i = 1; i <= n; ++i) {\nfor (int j = 0; j < n/2 + n%2; ++j) {\ncout << \"*\";\n}\ncout << \"\\n\";\nfor (int j = 0; j < n/2; ++j) {\ncout << \" \";\n}\ncout << \"\\n\";\n}\n}\nreturn 0;\n}"
    },
    {
        "problem_tier": 4,
        "solution_code": "#include <iostream>\nusing namespace std;\nint main() {\nint num;\ncin >> num;\nif (num == 1) {\ncout << '*';\n}\nfor (int i = 1; i < num; i++) {\nfor (int t = 1; t <= num - i; t++) {\ncout << ' ';\n}\nfor (int j = 1; j <= i * 2 - 1; j++) {\nif (j == 1 || j == i * 2 - 1) {\ncout << '*';\ncontinue;\n} else {\ncout << ' ';\ncontinue;\n}\n}\ncout << '\\n';\nif (i + 1 == num) {\nfor (int i = 1; i <= num * 2 - 1; i++) {\ncout << '*';\n}\n}\n}\nreturn 0;\n}"
    },
    {
        "problem_tier": 3,
        "solution_code": "#include<iostream>\nusing namespace std;\nint main(){\nint a,b,c,d;\ncin>>a>>b>>c>>d;\nint x,y;\nx=(a+b+c+d)/60;\ny=(a+b+c+d)%60;\ncout<<x<<endl;\ncout<<y<<endl;\nreturn 0;\n}"
    },
    {
        "problem_tier": 10,
        "solution_code": "#include<iostream>\n#include<algorithm>\nusing namespace std;\ntypedef long long ll;\npair<ll, ll> facCal(ll n){\nll cnt2 = 0, cnt5 = 0;\nfor(ll i=2; i<=n; i*=2){\ncnt2 += n/i;\n}\nfor(ll i=5; i<=n; i*=5){\ncnt5 += n/i;\n}\nreturn {cnt2, cnt5};\n}\nint main(void){\nios_base::sync_with_stdio(0);\ncin.tie(0);\ncout.tie(0);\nll n, m;\ncin >> n >> m;\nvector<pair<ll, ll>> res;\nres.push_back(facCal(n));\nres.push_back(facCal(m));\nres.push_back(facCal(n-m));\ncout << min(res[0].first - res[1].first - res[2].first, res[0].second - res[1].second - res[2].second) << \"\\n\";\nreturn 0;\n}"
    },
    {
        "problem_tier": 12,
        "solution_code": "#include <iostream>\n#include <algorithm>\n#include <cstring>\nusing namespace std;\nconst int MAX = 100001;\nvoid solution(){\nint dp[MAX][3] = {0,};\nint map[MAX][3] = {0,};\nint n;\ncin >> n;\nfor(int i=1;i<=n;i++){\ncin >> map[i][0] >> map[i][1] >> map[i][2];\n}\nfor(int i=1;i<=n;i++){\ndp[i][0] = max(dp[i-1][0],dp[i-1][1]) + map[i][0];\ndp[i][1] = max(dp[i-1][0],max(dp[i-1][1],dp[i-1][2])) + map[i][1];\ndp[i][2] = max(dp[i-1][1],dp[i-1][2]) + map[i][2];\n}\nint maxV = max(dp[n][0],max(dp[n][1],dp[n][2]));\nmemset(dp,0,sizeof(dp));\nfor(int i=1;i<=n;i++){\ndp[i][0] = min(dp[i-1][0],dp[i-1][1]) + map[i][0];\ndp[i][1] = min(dp[i-1][0],min(dp[i-1][1],dp[i-1][2])) + map[i][1];\ndp[i][2] = min(dp[i-1][1],dp[i-1][2]) + map[i][2];\n}\nint minV = min(dp[n][0],min(dp[n][1],dp[n][2]));\ncout << maxV << \" \" << minV << '\\n';\n}\nint main(){\nios_base::sync_with_stdio(0);\ncin.tie(0);\ncout.tie(0);\nsolution();\nreturn 0;\n}"
    },
    {
        "problem_tier": 12,
        "solution_code": "#include<iostream>\n#include<vector>\nusing namespace std;\nint n, deleteNodeNum, root;\nvector<int> tree[50];\nint visited[50];\nint ans = 0;\nvoid dfs(int x){\nif(visited[x])\nreturn;\nvisited[x] = 1;\nbool isLeaf = true;\nfor(int i=0; i<tree[x].size(); i++){\nint next = tree[x][i];\nif(!visited[next]){\ndfs(next);\nisLeaf = false;\n}\n}\nif(isLeaf)\nans++;\n}\nint main(){\ncin>>n;\nfor(int i=0; i<n; i++){\nint parent;\ncin>>parent;\nif(parent == -1)\nroot = i;\nelse\ntree[parent].push_back(i);\n}\ncin>>deleteNodeNum;\nvisited[deleteNodeNum] = true;\ndfs(root);\ncout<<ans<<\"\\n\";\nreturn 0;\n}"
    },
    {
        "problem_tier": 10,
        "solution_code": "#include <iostream>\n#include <vector>\n#include <algorithm>\n#define MAX 10\nusing namespace std;\nint N;\nbool visit[MAX];\nint g[MAX][MAX];\nint ans = 9e8;\nvoid bt(int depth, int start, int prev, int cost) {\nif (depth == N) {\nif (g[prev][start] == 0)\nreturn;\ncost += g[prev][start];\nans = min(ans, cost);\nreturn;\n}\nfor (int i = 0; i < N; i++) {\nif (visit[i] || g[prev][i] == 0)\ncontinue;\nvisit[i] = 1;\nbt(depth + 1, start, i, cost + g[prev][i]);\nvisit[i] = 0;\n}\n}\nint main() {\nios_base::sync_with_stdio(0);\ncin.tie(0);\ncout.tie(0);\ncin >> N;\nfor (int i = 0; i < N; i++) {\nfor (int j = 0; j < N; j++) {\ncin >> g[i][j];\n}\n}\nfor (int i = 0; i < N; i++) {\nvisit[i] = 1;\nbt(1, i, i, 0);\nvisit[i] = 0;\n}\ncout << ans;\nreturn 0;\n}"
    },
    {
        "problem_tier": 12,
        "solution_code": "#include <iostream>\n#include <stack>\n#include <string>\nusing namespace std;\nstring str;\nstack<char> s;\nint check(string str) {\nstack<char> s;\nint len = str.length();\nint temp = 0;\nlong long ans = 0;\nfor (int i = 0; i < len; i++) {\nif (str[i] == '(' || str[i] == '[') {\ns.push(str[i]);\n}\nelse if (str[i] == ')') {\nif (s.empty() || s.top() == '[' || s.top() == ')' || s.top() == ']') {\nreturn 0;\n}\nelse {\nif (s.top() == '(') {\ns.pop();\ntemp = 2;\n}\nelse {\nwhile (s.top() != '(') {\ntemp += s.top() - '0';\ns.pop();\n}\ntemp *= 2;\ns.pop();\n}\n}\n}\nelse if (str[i] == ']') {\nif (s.empty() || s.top() == '(' || s.top() == ')' || s.top() == ']') {\nreturn 0;\n}\nelse {\nif (s.top() == '[') {\ns.pop();\ntemp = 3;\n}\nelse {\nwhile (s.top() != '[') {\ntemp += s.top() - '0';\ns.pop();\n}\ntemp *= 3;\ns.pop();\n}\n}\n}\nif (temp != 0) {\ns.push(temp + '0');\ntemp = 0;\n}\n}\nwhile (!s.empty()) {\nif (s.top() == '(' || s.top() == '[' || s.top() == ']' || s.top() == ')') {\nreturn 0;\n}\nans += s.top() - '0';\ns.pop();\n}\nreturn ans;\n}\nint main() {\nstring bracket;\ncin >> bracket;\ncout << check(bracket);\nreturn 0;\n}"
    },
    {
        "problem_tier": 13,
        "solution_code": "#include <iostream>\n#include <queue>\n#include <string>\n#include <cstring>\nusing namespace std;\nint a, b;\nbool visited[10000];\nvoid bfs(){\nqueue<pair<int, string>> q;\nq.push(make_pair(a, \"\"));     visited[a] = true;\nwhile(!q.empty()){\nint cur_num = q.front().first;\nstring cur_op = q.front().second;\nq.pop();\nif(cur_num == b){             cout << cur_op << '\\n';             return;\n}\nint D, S, L, R, temp;\nD = (cur_num * 2) % 10000;\nif(!visited[D]){\nvisited[D] = true;\nq.push(make_pair(D, cur_op + \"D\"));         }\nS = (cur_num - 1 < 0) ? 9999 : cur_num - 1;\nif(!visited[S]){\nvisited[S] = true;\nq.push(make_pair(S, cur_op + \"S\"));         }\nL = (cur_num % 1000) * 10 + (cur_num / 1000);\nif(!visited[L]){\nvisited[L] = true;\nq.push(make_pair(L, cur_op + \"L\"));         }\nR = (cur_num / 10) + (cur_num % 10) * 1000;\nif(!visited[R]){\nvisited[R] = true;\nq.push(make_pair(R, cur_op + \"R\"));         }\n}\n}\nint main(){\nios_base::sync_with_stdio(false);\ncin.tie(NULL);\ncout.tie(NULL);\nint T;\ncin >> T;\nwhile(T--){\ncin >> a >> b;\nmemset(visited, false, sizeof(visited));         bfs();\n}\nreturn 0;\n}"
    },
    {
        "problem_tier": 4,
        "solution_code": "#include <iostream>\nusing namespace std;\nint main() {\nint total, price, sum = 0;\ncin >> total;\nfor (int i = 0; i < 9; i++) {\ncin >> price;\nsum += price;\n}\ncout << total - sum << '\\n';\nreturn 0;\n}"
    },
    {
        "problem_tier": 12,
        "solution_code": "#include <iostream>\nusing namespace std;\nint N;\nint board[17][17];\nint way = 0;\nbool isBoard(int i, int j) {\nif(i < 0 || j < 0 || i >= N || j >= N) {\nreturn false;\n}\nreturn true;\n}\nvoid DFS(int i, int j, int pipeDirection) {\nif(i == N-1 && j == N-1) {\nway++;\nreturn;\n}\nif(pipeDirection == 0) {\nif(isBoard(i, j+1) == true) {\nif(board[i][j+1] == 0) {\nDFS(i, j+1, 0);\n}\n}\nif(isBoard(i+1, j+1) == true) {\nif(board[i][j+1] == 0 && board[i+1][j] == 0 && board[i+1][j+1] == 0) {\nDFS(i+1, j+1, 2);\n}\n}\n}\nelse if(pipeDirection == 1) {\nif(isBoard(i+1, j) == true) {\nif(board[i+1][j] == 0) {\nDFS(i+1, j, 1);\n}\n}\nif(isBoard(i+1, j+1) == true) {\nif(board[i+1][j] == 0 && board[i][j+1] == 0 && board[i+1][j+1] == 0) {\nDFS(i+1, j+1, 2);\n}\n}\n}\nelse if(pipeDirection == 2) {\nif(isBoard(i, j+1) == true) {\nif(board[i][j+1] == 0) {\nDFS(i, j+1, 0);\n}\n}\nif(isBoard(i+1, j) == true) {\nif(board[i+1][j] == 0) {\nDFS(i+1, j, 1);\n}\n}\nif(isBoard(i+1, j+1) == true) {\nif(board[i+1][j] == 0 && board[i][j+1] == 0 && board[i+1][j+1] == 0) {\nDFS(i+1, j+1, 2);\n}\n}\n}\n}\nint main() {\nios_base::sync_with_stdio(false);\ncin.tie(NULL);\ncout.tie(NULL);\ncin >> N;\nfor(int i = 0; i < N; i++) {\nfor(int j = 0; j < N; j++) {\nint num;\ncin >> num;\nboard[i][j] = num;\n}\n}\nDFS(0, 1, 0);\ncout << way << \"\\n\";\nreturn 0;\n}"
    },
    {
        "problem_tier": 7,
        "solution_code": "#include<bits/stdc++.h>\nusing namespace std;\nint main(){\nios::sync_with_stdio(false);\ncin.tie(nullptr);\nint N, M;\ncin >> N >> M;\nvector<int> A(N);\nfor(int i=0; i<N; i++)\ncin >> A[i];\nvector<int> B(M);\nfor(int i=0; i<M; i++)\ncin >> B[i];\nsort(A.begin(), A.end());\nsort(B.begin(), B.end());\nint ptrA = 0;\nint ptrB = 0;\nvector<int> answer(N + M);\nint idx = 0;\nwhile(ptrA < N && ptrB < M){\nif(A[ptrA] < B[ptrB]){\nanswer[idx++] = A[ptrA];\nptrA++;\n}else{\nanswer[idx++] = B[ptrB];\nptrB++;\n}\n}\nwhile(ptrA < N)\nanswer[idx++] = A[ptrA++];\nwhile(ptrB < M)\nanswer[idx++] = B[ptrB++];\nfor(int i : answer)\ncout << i << \" \";\nreturn 0;\n}"
    },
    {
        "problem_tier": 9,
        "solution_code": "#include <iostream>\n#include <string>\n#include <set>\nusing namespace std;\nint main() {\nstring s;\ncin >> s;\nset<string> substrings;\nfor (int i = 0; i < s.size(); i++) {\nfor (int j = i; j < s.size(); j++) {\nstring substring = s.substr(i, j-i+1);\nsubstrings.insert(substring);\n}\n}\ncout << substrings.size();\nreturn 0;\n}"
    },
    {
        "problem_tier": 5,
        "solution_code": "#include <iostream>\n#include <map>\n#include <string>\nusing namespace std;\nint main() {\nmap<string, pair<int,int>> d1 = {\n{\"black\",{0,1}}, {\"brown\",{1,10}}, { \"red\",{ 2,100 } },\n{ \"orange\",{ 3,1000 } },{ \"yellow\",{ 4,10000 } },{ \"green\",{ 5,100000 } },\n{ \"blue\",{ 6,1000000 } },{ \"violet\",{ 7,10000000 } },\n{ \"grey\",{ 8,100000000 } },{ \"white\",{ 9,1000000000 } }\n};\nstring a, b, c;\ncin >> a >> b >> c;\nstring s1, s2, ss;\ns1 = to_string(d1[a].first);\ns2 = to_string(d1[b].first);\nss = s1 + s2;\ncout << stoi(ss) * d1[c].second;\nreturn 0;\n}"
    },
    {
        "problem_tier": 13,
        "solution_code": "#include <iostream>\n#include <queue>\n#define MAX 51\nusing namespace std;\nint R, C;\nchar map[MAX][MAX];\npair<int, int> beaver_nest;\nqueue<pair<int, int>> water_q;\nqueue<pair<int, int>> hedgehog_q;\nint dx[4] = {-1, 1, 0, 0};\nint dy[4] = {0, 0, -1, 1};\nint result_time;\nvoid bfs() {\nwhile (!hedgehog_q.empty()) {\nint water_start_count = water_q.size();\nfor (int i = 0; i < water_start_count; ++i) {\nint current_water_x = water_q.front().first;\nint current_water_y = water_q.front().second;\nwater_q.pop();\nfor (int i = 0; i < 4; ++i) {\nint next_water_x = current_water_x + dx[i];\nint next_water_y = current_water_y + dy[i];\nif ((0 <= next_water_x && next_water_x < R) && (0 <= next_water_y && next_water_y < C) && map[next_water_x][next_water_y] == '.') {\nwater_q.push(make_pair(next_water_x, next_water_y));\nmap[next_water_x][next_water_y] = '*';\n}\n}\n}\nint hedgehog_start_count = hedgehog_q.size();\nfor (int i = 0; i < hedgehog_start_count; ++i) {\nint current_hedgehog_x = hedgehog_q.front().first;\nint current_hedgehog_y = hedgehog_q.front().second;\nhedgehog_q.pop();\nfor (int i = 0; i < 4; ++i) {\nint next_hedgehog_x = current_hedgehog_x + dx[i];\nint next_hedgehog_y = current_hedgehog_y + dy[i];\nif ((next_hedgehog_x == beaver_nest.first) && (next_hedgehog_y == beaver_nest.second)) {\nresult_time++;\ncout << result_time;\nreturn;\n}\nif ((0 <= next_hedgehog_x && next_hedgehog_x < R) && (0 <= next_hedgehog_y && next_hedgehog_y < C) && map[next_hedgehog_x][next_hedgehog_y] == '.') {\nhedgehog_q.push(make_pair(next_hedgehog_x, next_hedgehog_y));\nmap[next_hedgehog_x][next_hedgehog_y] = 'S';\n}\n}\n}\nresult_time++;\n}\ncout << \"KAKTUS\";\nreturn;\n}\nint main() {\ncin >> R >> C;\nstring row;\nfor (int i = 0; i < R; ++i) {\ncin >> row;\nfor (int j = 0; j < C; ++j) {\nmap[i][j] = row[j];\nif (row[j] == 'S') {\nhedgehog_q.push(make_pair(i, j));\n}\nelse if (row[j] == 'D') {\nbeaver_nest = make_pair(i, j);\n}\nelse if (row[j] == '*') {\nwater_q.push(make_pair(i, j));\n}\n}\n}\nbfs();\n}"
    },
    {
        "problem_tier": 8,
        "solution_code": "#include<iostream>\n#include<string>\n#include<map>\nusing namespace std;\nint main() {\ncin.tie(NULL);\nios_base::sync_with_stdio(0);\nint N, M;\ncin >> N >> M;\nmap<string, string> info;\nstring site, pw;\nwhile (N--) {\ncin >> site >> pw;\ninfo[site] = pw;\n}\nwhile (M--) {\ncin >> site;\ncout << info[site] << \"\\n\";\n}\nreturn 0;\n}"
    },
    {
        "problem_tier": 5,
        "solution_code": "#include <iostream>\n#include <string>\nusing namespace std;\nint main() {\nstring str;\ncin >> str;\ncout << str[0];\nfor (int i = 0; i < str.length(); i++) {\nif (str[i] == '-') {\ncout << str[i + 1];\n}\n}\nreturn 0;\n}"
    },
    {
        "problem_tier": 12,
        "solution_code": "#include <iostream>\n#include <vector>\n#include <algorithm>\n#include <cmath>\nusing namespace std;\nint main() {\nint n;\ncin >> n;\nvector<int> arr(n);\nfor (int i = 0; i < n; i++) {\ncin >> arr[i];\n}\nsort(arr.begin(), arr.end());\nint left = 0;\nint right = n - 1;\nint minSum = abs(arr[left] + arr[right]);\nint answer[2] = {arr[left], arr[right]};\nwhile (left < right) {\nint sum = arr[left] + arr[right];\nif (abs(sum) < minSum) {\nminSum = abs(sum);\nanswer[0] = arr[left];\nanswer[1] = arr[right];\n}\nif (sum < 0) {\nleft++;\n} else {\nright--;\n}\n}\ncout << answer[0] << \" \" << answer[1];\nreturn 0;\n}"
    },
    {
        "problem_tier": 8,
        "solution_code": "#include <iostream>\n#include <vector>\nusing namespace std;\nint main(){\nint n, k;\ncin >> n >> k;\nvector<int> primes(n+1);\nfor(int i=2; i<=n; i++){\nprimes[i] = i;\n}\nint cnt = 0;\nint ans = 0;\nfor(int i=2; i<=n; i++){\nif(primes[i] != 0){\nfor(int j=i; j<=n; j+=i){\nif(primes[j] != 0){\nprimes[j] = 0;\ncnt++;\nif(cnt == k){\nans = j;\nbreak;\n}\n}\n}\n}\nif(cnt == k){\nbreak;\n}\n}\ncout << ans << '\\n';\nreturn 0;\n}"
    },
    {
        "problem_tier": 6,
        "solution_code": "#include<iostream>\n#include<string>\nusing namespace std;\nint main() {\nstring s;\ngetline(cin, s);\nfor(int i=0; i<s.length(); i++) {\nchar c = s[i];\nif(c >= 'a' && c <= 'z') {\nif(c - 'a' < 13) {\nc += 13;\n} else {\nc -= 13;\n}\n} else if(c >= 'A' && c <= 'Z') {\nif(c - 'A' < 13) {\nc += 13;\n} else {\nc -= 13;\n}\n}\ns[i] = c;\n}\ncout << s << '\\n';\nreturn 0;\n}"
    },
    {
        "problem_tier": 9,
        "solution_code": "#include <iostream>\n#include <stack>\n#include <algorithm>\nusing namespace std;\nint main() {\nstring s, ans;\nstack<char> st;\nint flag = 0;\ngetline(cin, s);\nfor (int i = 0; i < s.size(); i++) {\nif (s[i] != '<')\nst.push(s[i]);\nif (s[i] == '<') {\nwhile (!st.empty()) {\nans += st.top();\nst.pop();\n}\nst.push(s[i]);\nflag = 1;\n}\nelse if (s[i] == '>') {\nstring tmp;\nwhile (!st.empty()) {\ntmp += st.top();\nst.pop();\n}\nif (flag) {\nflag = 0;\nreverse(tmp.begin(), tmp.end());\nans += tmp;\n}\n}\nelse if (s[i] == ' ' || i == s.size() - 1) {\nif (!flag) {\nint f = 0;\nstring tmp;\nwhile (!st.empty()) {\nif (st.top() != ' ')\ntmp += st.top();\nelse\nf = 1;\nst.pop();\n}\nans += tmp;\nif (f)\nans += ' ';\n}\n}\n}\ncout << ans << '\\n';\nreturn 0;\n}"
    },
    {
        "problem_tier": 11,
        "solution_code": "#include <iostream>\n#include <queue>\n#include <vector>\nusing namespace std;\nint F, S, G, U, D;\nconst int MAX = 1000001;\nint path[MAX];\nbool visited[MAX];\nvector<int> dx;\nqueue<int> q;\nvoid BFS(int v) {\nvisited[v] = true;\nq.push(v);\nwhile (!q.empty()) {\nv = q.front();\nq.pop();\nfor (int i = 0; i < 2; i++) {\nint nv = v + dx[i];\nif (0 < nv && nv <= F) {\nif (!visited[nv]) {\nvisited[nv] = true;\nq.push(nv);\npath[nv] = path[v] + 1;\n}\n}\n}\n}\n}\nint main() {\ncin >> F >> S >> G >> U >> D;\ndx.push_back(U);\ndx.push_back(D * -1);\nBFS(S);\nif (visited[G]) {\ncout << path[G];\n} else {\ncout << \"use the stairs\";\n}\nreturn 0;\n}"
    },
    {
        "problem_tier": 15,
        "solution_code": "#include<iostream>\n#include<stack>\n#include<string>\nusing namespace std;\nstring infixToPostfix(string str) {\nstring ans;\nstack<char> op;\nfor(int i = 0; i < str.size(); i++) {\nif('A' <= str[i] && str[i] <= 'Z') {\nans += str[i];\ncontinue;\n}\nif(str[i] == '(') {\nop.push(str[i]);\ncontinue;\n}\nif(str[i] == ')') {\nwhile(op.top() != '(') {\nans += op.top();\nop.pop();\n}\nop.pop();\ncontinue;\n}\nif(str[i] == '*' || str[i] == '/') {\nwhile(!op.empty() && (op.top() == '*' || op.top() == '/')) {\nans += op.top();\nop.pop();\n}\n} else {\nwhile(!op.empty() && op.top() != '(') {\nans += op.top();\nop.pop();\n}\n}\nop.push(str[i]);\n}\nwhile(!op.empty()) {\nans += op.top();\nop.pop();\n}\nreturn ans;\n}\nint main() {\nios_base::sync_with_stdio(false);\ncin.tie(NULL);\ncout.tie(NULL);\nstring str;\ncin >> str;\ncout << infixToPostfix(str) << \"\\n\";\nreturn 0;\n}"
    },
    {
        "problem_tier": 4,
        "solution_code": "#include <iostream>\n#include <cstdio>\nint main() {\nint n;\nstd::cin >> n;\nint cnt = 2;\nwhile (n--) {\ncnt += (cnt - 1);\n}\nstd::cout << cnt * cnt << std::endl;\nreturn 0;\n}"
    },
    {
        "problem_tier": 14,
        "solution_code": "#include <iostream>\n#include <vector>\nusing namespace std;\nint main() {\nint n;\ncin >> n;\nvector<bool> isPrime(n+1, true);\nisPrime[0] = isPrime[1] = false;\nfor (int i = 2; i * i <= n; i++) {\nif (isPrime[i]) {\nfor (int j = i * i; j <= n; j += i) {\nisPrime[j] = false;\n}\n}\n}\nvector<int> prime;\nfor (int i = 2; i <= n; i++) {\nif (isPrime[i]) {\nprime.push_back(i);\n}\n}\nint start = 0, end = 0;\nint sum = 0;\nint ans = 0;\nwhile (1) {\nif (sum > n) {             sum -= prime[start++];\n} else if (end == prime.size()) {             break;\n} else {\nif (sum < n) {                 sum += prime[end++];\n} else {                 ans++;\nsum += prime[end++];\n}\n}\n}\ncout << ans;\nreturn 0;\n}"
    },
    {
        "problem_tier": 9,
        "solution_code": "#include<algorithm>\n#include<iostream>\n#include<vector>\n#define MAX 9\nusing namespace std;\nint N, M;\nint input[MAX];\nvector<int> output;\nvoid dfs(int count);\nint main(){\ncin >> N >> M;\nfor (int index = 0; index < N; index++) cin >> input[index];\nsort(input, input + N);\ndfs(0);\nreturn 0;\n}"
    },
    {
        "problem_tier": 11,
        "solution_code": "#include <iostream>\nusing namespace std;\nint gcd(int a, int b){\nwhile(b != 0){\nint r = a % b;\na = b;\nb = r;\n}\nreturn a;\n}\nint lcm(int a, int b){\nreturn a * b / gcd(a, b);\n}\nint main(){\nint T;\ncin >> T;\nwhile(T--){\nint result = -1;\nint M, N, x, y;\ncin >> M >> N >> x >> y;\nint limit = lcm(M, N);\nfor(int i = x; i <= limit; i += M){\nif(i % N == y){\nresult = i;\nbreak;\n}\nelse if(i % N == 0){\nif(N == y){\nresult = i;\nbreak;\n}\n}\n}\ncout << result << '\\n';\n}\nreturn 0;\n}"
    },
    {
        "problem_tier": 5,
        "solution_code": "#include <iostream>\n#include <string>\n#include <stack>\nusing namespace std;\nint main() {\nstring octal;\ncin >> octal;\nif (octal == \"0\")\ncout << 0 << '\\n';\nstring result;\nfor (int i = 0; i < octal.length(); i++) {\nresult += to_string((octal[i] - '0') / 4);\nresult += to_string(((octal[i] - '0') % 4) / 2);\nresult += to_string((((octal[i] - '0') % 4) % 2) / 1);\n}\nbool flag = false;\nfor (int i = 0; i < result.length(); i++) {\nif (!flag) {\nif (result[i] == '1') {\nflag = true;\ncout << result[i];\n}\n} else {\ncout << result[i];\n}\n}\ncout << '\\n';\nreturn 0;\n}"
    },
    {
        "problem_tier": 2,
        "solution_code": "#include<iostream>\nusing namespace std;\nint main(){\ncout << \"/~\\\\\" << endl;\ncout << \"(oo|\" << endl;\ncout << \"_\\\\=/_\" << endl;\ncout << \"/_\\\\\" << endl;\ncout << \"    cout << \"||\\\\/||\" << endl;\ncout << \"============\" << endl;\ncout << \"||\" << endl;\ncout << \"||\" << endl;\ncout << \"||\" << endl;\nreturn 0;\n}"
    },
    {
        "problem_tier": 9,
        "solution_code": "#include <iostream>\n#include <algorithm>\nusing namespace std;\nint main() {\nint n, target;\ncin >> n;\nint a[n];\nfor (int i = 0; i < n; i++) {\ncin >> a[i];\n}\ncin >> target;\nsort(a, a+n);\nint left = 0;\nint right = n-1;\nint answer = 0;\nwhile (left < right) {\nint sum = a[left] + a[right];\nif (sum < target) {\nleft++;\n} else if (sum > target) {\nright--;\n} else {\nleft++;\nright--;\nanswer++;\n}\n}\ncout << answer << endl;\nreturn 0;\n}"
    },
    {
        "problem_tier": 2,
        "solution_code": "#include<iostream>\nusing namespace std;\nint main() {\nlong long a, b;\ncin >> a >> b;\ncout << (a + b) * (a - b) << endl;\nreturn 0;\n}"
    },
    {
        "problem_tier": 14,
        "solution_code": "#include<iostream>\n#include<vector>\n#include<queue>\nusing namespace std;\nint main(){\nint T;\ncin >> T;\nwhile(T--){\nint N, K;\ncin >> N >> K;\nint time[1002];\nfor(int i = 1; i <= N; i++){\ncin >> time[i];\n}\nvector<int> adj[1002];\nint inDeg[1002] = { 0, };\nqueue<int> q;\nint result[1002];\nwhile (K--){\nint X, Y;\ncin >> X >> Y;\nadj[X].push_back(Y);\ninDeg[Y]++;\n}\nint W;\ncin >> W;\nfor (int i = 1; i <= N; i++){\nif (inDeg[i] == 0){\nq.push(i);\n}\nresult[i] = time[i];\n}\nwhile (!q.empty()){\nint cur = q.front();\nq.pop();\nfor (int i = 0; i < adj[cur].size(); i++){\nint next = adj[cur][i];\ninDeg[next]--;\nresult[next] = max(result[next], result[cur] + time[next]);\nif (inDeg[next] == 0){\nq.push(next);\n}\n}\n}\ncout << result[W] << endl;\n}\nreturn 0;\n}"
    },
    {
        "problem_tier": 11,
        "solution_code": "#include <iostream>\n#define Moduler 9901\nusing namespace std;\nint N;\nint DP[100001][3];\nvoid Input(){\ncin >> N;\n}\nvoid Solution(){\nDP[1][0] = DP[1][1] = DP[1][2] = 1;\nfor(int i = 2; i <= N; i++){\nDP[i][0] = (DP[i - 1][0] + DP[i - 1][1] + DP[i - 1][2]) % Moduler;\nDP[i][1] = (DP[i - 1][0] + DP[i - 1][2]) % Moduler;\nDP[i][2] = (DP[i - 1][0] + DP[i - 1][1]) % Moduler;\n}\ncout << (DP[N][0] + DP[N][1] + DP[N][2]) % Moduler << endl;\n}\nvoid Solve(){\nInput();\nSolution();\n}\nint main(void){\nios::sync_with_stdio(false);\ncin.tie(NULL);\ncout.tie(NULL);\nSolve();\nreturn 0;}"
    },
    {
        "problem_tier": 4,
        "solution_code": "#include <iostream>\nusing namespace std;\nint main() {\nint n;\ncin >> n;\nfor (int i = 1; i <= n; i++) {\nfor (int j = n - i; j > 0; j--) {\ncout << \" \";\n}\nfor (int k = 1; k <= i; k++) {\ncout <<\"* \";\n}\ncout << endl;\n}\nreturn 0;\n}"
    },
    {
        "problem_tier": 4,
        "solution_code": "#include <iostream>\nusing namespace std;\nint main() {\nint max = 0;\nint num = 0;\nfor (int i = 0; i < 5; i++) {\nint sum = 0;\nfor (int j = 0; j < 4; j++) {\nint score;\ncin >> score;\nsum += score;\n}\nif (sum > max) {\nmax = sum;\nnum = i+1;\n}\n}\ncout << num << \" \" << max << endl;\nreturn 0;\n}"
    },
    {
        "problem_tier": 13,
        "solution_code": "#include <iostream>\n#include <vector>\n#include <cstring>\nusing namespace std;\nint n = 0;\nbool visited[10001] = {0,};\nvector<pair<int,int>> arr[10001];\nint result = 0;\nint destination = 0;\nvoid dfs(int cur, int len) {\nif (result < len) {\nresult = len;\ndestination = cur;\n}\nfor (int i = 0; i < arr[cur].size(); i++) {\nif (visited[arr[cur][i].first] == 0) {\nvisited[arr[cur][i].first] = 1;\ndfs(arr[cur][i].first, len + arr[cur][i].second);\n}\n}\n}\nint main() {\nios_base::sync_with_stdio(0), cin.tie(0), cout.tie(0);\ncin >> n;\nfor (int i = 0; i < n - 1; i++) {\nint s, e, v;\ncin >> s >> e >> v;\narr[s].push_back(make_pair(e, v));\narr[e].push_back(make_pair(s, v));\n}\nvisited[1] = 1;\ndfs(1, 0);\ncout << result << endl;\nmemset(visited, 0, sizeof(visited));\nresult = 0;\nvisited[destination] = 1;\ndfs(destination, 0);\ncout << result << endl;\nreturn 0;\n}"
    },
    {
        "problem_tier": 15,
        "solution_code": "#include<iostream>\n#include<vector>\n#include<algorithm>\nusing namespace std;\nint main() {\nint N;\nvector<int> arr;\ncin >> N;\nfor (int i = 0; i < N; i++) {\nint input;\ncin >> input;\nif (arr.empty() || arr.back() < input) {\narr.push_back(input);\n} else {\n*lower_bound(arr.begin(), arr.end(), input) = input;\n}\n}\ncout << arr.size();\nreturn 0;\n}"
    },
    {
        "problem_tier": 15,
        "solution_code": "#include<iostream>\n#include<vector>\n#include<cstring>\nusing namespace std;\nint v, far, far_val;\nvector<pair<int,int>> vec[100001];\nbool visited[100001];\nvoid dfs(int current, int sum){\nif(sum > far_val){\nfar = current;\nfar_val = sum;\n}\nfor(int i=0;i<vec[current].size();i++){\nint num = vec[current][i].first;\nif(visited[num] == 0){\nvisited[num] = 1;\ndfs(num, sum + vec[current][i].second);\n}\n}\n}\nint main(){\nios_base::sync_with_stdio(0);\ncin.tie(0), cout.tie(0);\ncin >> v;\nfor(int i=1;i<=v;i++){\nint a = 0;\ncin >> a;\nint b = 0, bval = 0;\nwhile(1){\ncin >> b;\nif(b == -1)\nbreak;\ncin >> bval;\nvec[a].push_back(make_pair(b, bval));\nvec[b].push_back(make_pair(a, bval));\n}\n}\nmemset(visited, 0, sizeof(visited));\nvisited[1] = 1;\ndfs(1, 0);\nint f = far;\nfar = 0, far_val = 0;\nmemset(visited, 0, sizeof(visited));\nvisited[f] = 1;\ndfs(f, 0);\ncout << far_val << endl;\nreturn 0;\n}"
    },
    {
        "problem_tier": 15,
        "solution_code": "#include <iostream>\n#include <queue>\nusing namespace std;\nint main() {\nios::sync_with_stdio(false);\ncin.tie(NULL);\ncout.tie(NULL);\nint n;\ncin >> n;\npriority_queue<int> maxHeap;\npriority_queue<int, vector<int>, greater<int>> minHeap;\nfor (int i = 0; i < n; i++) {\nint input;\ncin >> input;\nif (maxHeap.size() > minHeap.size())\nminHeap.push(input);\nelse\nmaxHeap.push(input);\nif (!maxHeap.empty() && !minHeap.empty()) {\nif (minHeap.top() < maxHeap.top()) {\nint minTop = minHeap.top();\nint maxTop = maxHeap.top();\nminHeap.pop();\nmaxHeap.pop();\nmaxHeap.push(minTop);\nminHeap.push(maxTop);\n}\n}\ncout << maxHeap.top() << '\\n';\n}\nreturn 0;\n}"
    },
    {
        "problem_tier": 4,
        "solution_code": "#include <iostream>\nusing namespace std;\nint main() {\nint n;\nint num;\nint cute = 0;\nint notCute = 0;\ncin >> n;\nfor (int i = 0; i < n; i++) {\ncin >> num;\nif (num == 1) {\ncute++;\n}\nelse {\nnotCute++;\n}\n}\nif (cute < notCute) {\ncout << \"Junhee is not cute!\" << endl;\n}\nelse {\ncout << \"Junhee is cute!\" << endl;\n}\nreturn 0;\n}"
    },
    {
        "problem_tier": 7,
        "solution_code": "#include<iostream>\nusing namespace std;\nint main() {\nint n, m;\ncin >> n >> m;\nint arr[300][300];\nfor(int i=0; i<n; i++){\nfor(int j=0; j<m; j++){\ncin>>arr[i][j];\n}\n}\nint testCase;\ncin >> testCase;\nfor(int k=0; k<testCase; k++){\nint i, j, x, y;\ncin >> i >> j >> x >> y;\nint sum = 0;\nfor(int r=i-1; r<x; r++){\nfor(int c=j-1; c<y; c++){\nsum += arr[r][c];\n}\n}\ncout << sum << endl;\n}\nreturn 0;\n}"
    },
    {
        "problem_tier": 10,
        "solution_code": "#include <iostream>\n#include <algorithm>\n#include <vector>\nusing namespace std;\nint main(){\nint N, M;\nscanf(\"%d %d\", &N , &M);\nvector< vector<int> > num_mat(N+1, vector<int>(M+1, 0));\nvector< vector<int> > dp_mat(N+1, vector<int>(M+1, 0));\nfor ( int n_idx = 1 ; n_idx <= N ; n_idx++)\nfor ( int m_idx = 1 ; m_idx <= M ; m_idx++)\nscanf(\"%d\", &(num_mat.at(n_idx).at(m_idx)));\nfor ( int m_idx = 1 ; m_idx <= M ; m_idx++)\ndp_mat.at(1).at(m_idx) += dp_mat.at(1).at(m_idx-1) + num_mat.at(1).at(m_idx);\nfor ( int n_idx = 2 ; n_idx <= N ; n_idx++)\ndp_mat.at(n_idx).at(1) = dp_mat.at(n_idx-1).at(1) +  num_mat.at(n_idx).at(1);\nfor ( int n_idx = 2 ; n_idx <= N ; n_idx++)\nfor ( int m_idx = 2 ; m_idx <= M ; m_idx++)\ndp_mat.at(n_idx).at(m_idx) = num_mat.at(n_idx).at(m_idx) + max({ dp_mat.at(n_idx-1).at(m_idx),\ndp_mat.at(n_idx).at(m_idx-1),\ndp_mat.at(n_idx-1).at(m_idx-1) });\nprintf(\"%d\", dp_mat.at(N).at(M) );\nreturn 0;\n}"
    },
    {
        "problem_tier": 13,
        "solution_code": "#include <iostream>\n#include <stack>\n#include <string>\nusing namespace std;\nint main() {\nstack<char> s;\nstring str, bomb;\ncin >> str >> bomb;\nfor (int i = 0; i < str.length(); i++) {\ns.push(str[i]);\nif (s.top() == bomb.back()) {             if (s.size() >= bomb.size()) {                 bool isBomb = true;\nfor (int j = bomb.size() - 1; j >= 0; j--) {\nif (s.top() != bomb[j]) {\nisBomb = false;\nbreak;\n}\ns.pop();\n}\nif (!isBomb) {                     for (int j = bomb.size() - 1; j >= 0; j--) {\ns.push(bomb[j]);\n}\n}\n}\n}\n}\nstring answer = \"\";\nwhile (!s.empty()) {\nanswer += s.top();\ns.pop();\n}\nif (answer.empty()) {\ncout << \"FRULA\" << endl;\n} else {\nfor (int i = answer.length() - 1; i >= 0; i--) {\ncout << answer[i];\n}\ncout << endl;\n}\nreturn 0;\n}"
    },
    {
        "problem_tier": 13,
        "solution_code": "#include <iostream>\n#include <vector>\nusing namespace std;\nint R, C, T;\nint room[51][51];\nint temp[51][51];\nint cleaner_top, cleaner_bottom;\nint dx[4] = {0, 1, 0, -1};\nint dy[4] = {-1, 0, 1, 0};\nvoid spreadDust() {\nfor (int i = 0; i < R; i++) {\nfor (int j = 0; j < C; j++) {\nif (room[i][j] > 0) {\nint cnt = 0;\nfor (int k = 0; k < 4; k++) {\nint nx = i + dx[k];\nint ny = j + dy[k];\nif (nx >= 0 && nx < R && ny >= 0 && ny < C && room[nx][ny] != -1) {\ntemp[nx][ny] += room[i][j] / 5;\ncnt++;\n}\n}\ntemp[i][j] += room[i][j] - (room[i][j] / 5) * cnt;\n}\n}\n}\nfor (int i = 0; i < R; i++) {\nfor (int j = 0; j < C; j++) {\nroom[i][j] = temp[i][j];\ntemp[i][j] = 0;\n}\n}\n}\nvoid moveTopCleaner() {\nint x = cleaner_top - 1;\nwhile (x > 0) {\nroom[x][0] = room[x - 1][0];\nx--;\n}\nfor (int i = 0; i < C - 1; i++) {\nroom[0][i] = room[0][i + 1];\n}\nfor (int i = 0; i < cleaner_top; i++) {\nroom[i][C - 1] = room[i + 1][C - 1];\n}\nfor (int i = C - 1; i > 1; i--) {\nroom[cleaner_top][i] = room[cleaner_top][i - 1];\n}\nroom[cleaner_top][1] = 0;\n}\nvoid moveBottomCleaner() {\nint x = cleaner_bottom + 1;\nwhile (x < R - 1) {\nroom[x][0] = room[x + 1][0];\nx++;\n}\nfor (int i = 0; i < C - 1; i++) {\nroom[R - 1][i] = room[R - 1][i + 1];\n}\nfor (int i = R - 1; i > cleaner_bottom; i--) {\nroom[i][C - 1] = room[i - 1][C - 1];\n}\nfor (int i = C - 1; i > 1; i--) {\nroom[cleaner_bottom][i] = room[cleaner_bottom][i - 1];\n}\nroom[cleaner_bottom][1] = 0;\n}\nvoid solve() {\nwhile (T--) {\nspreadDust();\nmoveTopCleaner();\nmoveBottomCleaner();\n}\nint ans = 0;\nfor (int i = 0; i < R; i++) {\nfor (int j = 0; j < C; j++) {\nif (room[i][j] > 0) {\nans += room[i][j];\n}\n}\n}\ncout << ans << endl;\n}\nint main() {\ncin >> R >> C >> T;\nint idx = 0;\nfor (int i = 0; i < R; i++) {\nfor (int j = 0; j < C; j++) {\ncin >> room[i][j];\nif (room[i][j] == -1) {\nif (idx == 0) {\ncleaner_top = i;\nidx++;\n} else {\ncleaner_bottom = i;\n}\n}\n}\n}\nsolve();\nreturn 0;\n}"
    },
    {
        "problem_tier": 13,
        "solution_code": "#include <iostream>\n#include <vector>\n#include <algorithm>\nusing namespace std;\nint N, M;\nint arr[8][8];\nvector<pair<int, int>> cctv;\nint ans = 987654321;\nint dx[4] = {0, -1, 0, 1}; int dy[4] = {1, 0, -1, 0};\nvoid check(int x, int y, int dir) {\ndir %= 4;\nwhile (1) {\nint nx = x + dx[dir];\nint ny = y + dy[dir];\nx = nx;\ny = ny;\nif (nx < 0 || ny < 0 || nx >= N || ny >= M)\nreturn;\nif (arr[nx][ny] == 6)\nreturn;\nif (arr[nx][ny] != 0)\ncontinue;\narr[nx][ny] = -1;\n}\n}\nvoid dfs(int idx) {\nif (idx == cctv.size()) {\nint cnt = 0;\nfor (int i = 0; i < N; i++) {\nfor (int j = 0; j < M; j++) {\nif (!arr[i][j])\ncnt++;\n}\n}\nans = min(ans, cnt);\nreturn;\n}\nint x = cctv[idx].first;\nint y = cctv[idx].second;\nint tmp[8][8];\nfor (int dir = 0; dir < 4; dir++) {\nfor (int i = 0; i < N; i++) {\nfor (int j = 0; j < M; j++) {\ntmp[i][j] = arr[i][j];\n}\n}\nif (arr[x][y] == 1)\ncheck(x, y, dir);\nelse if (arr[x][y] == 2) {\ncheck(x, y, dir);\ncheck(x, y, dir + 2);\n}\nelse if (arr[x][y] == 3) {\ncheck(x, y, dir);\ncheck(x, y, dir + 1);\n}\nelse if (arr[x][y] == 4) {\ncheck(x, y, dir);\ncheck(x, y, dir + 1);\ncheck(x, y, dir + 2);\n}\nelse if (arr[x][y] == 5) {\ncheck(x, y, dir);\ncheck(x, y, dir + 1);\ncheck(x, y, dir + 2);\ncheck(x, y, dir + 3);\n}\ndfs(idx + 1);         for (int i = 0; i < N; i++) {\nfor (int j = 0; j < M; j++) {\narr[i][j] = tmp[i][j];\n}\n}\n}\n}\nint main() {\nios::sync_with_stdio(false);\ncin.tie(NULL);\ncout.tie(NULL);\ncin >> N >> M;\nfor (int i = 0; i < N; i++) {\nfor (int j = 0; j < M; j++) {\ncin >> arr[i][j];\nif (arr[i][j] != 0 && arr[i][j] != 6)\ncctv.push_back({i, j});\n}\n}\ndfs(0);\ncout << ans << '\\n';\nreturn 0;\n}"
    },
    {
        "problem_tier": 5,
        "solution_code": "#include <iostream>\n#include <string>\nusing namespace std;\nint main() {\nint n;\nlong long int temp, sum = 0;\nchar c;\ncin >> n;\nfor (int i = 0; i < n; i++) {\ncin >> c;\ntemp = c - 'a' + 1;\nfor (int j = 0; j < i; j++)\ntemp = (temp * 31) % 1234567891;\nsum += temp;\n}\ncout << sum % 1234567891;\nreturn 0;\n}"
    },
    {
        "problem_tier": 2,
        "solution_code": "#include <iostream>\nusing namespace std;\nint main() {\ncout << \"    8888888888  888    88888\" << endl;\ncout << \"   88     88   88 88   88  88\" << endl;\ncout << \"    8888  88  88   88  88888\" << endl;\ncout << \"       88 88 888888888 88   88\" << endl;\ncout << \"88888888  88 88     88 88    888888\" << endl;\ncout << endl;\ncout << \"88  88  88   888    88888    888888\" << endl;\ncout << \"88  88  88  88 88   88  88  88\" << endl;\ncout << \"88 8888 88 88   88  88888    8888\" << endl;\ncout << \" 888  888 888888888 88  88      88\" << endl;\ncout << \"  88  88  88     88 88   88888888\" << endl;\nreturn 0;\n}"
    },
    {
        "problem_tier": 13,
        "solution_code": "#include <iostream>\n#include <queue>\n#include <cstring>\nusing namespace std;\nint N, M;\nint graph[300][300];\nint tmp[300][300];\nbool visited[300][300];\nint dir[4][2] = {{0, 1}, {1, 0}, {0, -1}, {-1, 0}};\nvoid check(int r, int c) {\nqueue<pair<int, int>> q;\nq.push({r, c});\nwhile (!q.empty()) {\nint cr = q.front().first;\nint cc = q.front().second;\nq.pop();\nfor (int i = 0; i < 4; i++) {\nint nr = cr + dir[i][0];\nint nc = cc + dir[i][1];\nif (nr >= 0 && nr < N && nc >= 0 && nc < M) {\nif (graph[nr][nc] != 0 && !visited[nr][nc]) {\nq.push({nr, nc});\nvisited[nr][nc] = true;\n}\n}\n}\n}\n}\nvoid meltIce() {\nmemset(tmp, 0, sizeof(tmp));\nfor (int i = 0; i < N; i++) {\nfor (int j = 0; j < M; j++) {\nif (graph[i][j] == 0) continue;\nint waterCnt = 0;\nfor (int k = 0; k < 4; k++) {\nint nx = i + dir[k][0];\nint ny = j + dir[k][1];\nif (nx < 0 || ny < 0 || nx >= N || ny >= M) continue;\nif (graph[nx][ny] == 0) {\nwaterCnt++;\n}\n}\nint val = graph[i][j] - waterCnt;\nif (val > 0) tmp[i][j] = val;\n}\n}\nfor (int i = 0; i < N; i++) {\nfor (int j = 0; j < M; j++) {\ngraph[i][j] = tmp[i][j];\n}\n}\n}\nint main() {\nios::sync_with_stdio(false);\ncin.tie(0);\ncout.tie(0);\ncin >> N >> M;\nfor (int i = 0; i < N; i++) {\nfor (int j = 0; j < M; j++) {\ncin >> graph[i][j];\n}\n}\nint time = 0;\nwhile (true) {\nint cnt = 0;\nfor (int i = 0; i < N; i++) {\nfor (int j = 0; j < M; j++) {\nif (!visited[i][j] && graph[i][j] != 0) {\ncheck(i, j);\ncnt++;\n}\n}\n}\nif (cnt == 0) {\ncout << 0;\nbreak;\n}\nelse if (cnt >= 2) {\ncout << time;\nbreak;\n}\ntime++;\nmeltIce();\nmemset(visited, false, sizeof(visited));\n}\nreturn 0;\n}"
    },
    {
        "problem_tier": 7,
        "solution_code": "#include <iostream>\n#include <map>\n#include <vector>\n#include <algorithm>\nusing namespace std;\nint main() {\nint n;\ncin >> n;\nmap<string, int> m;\nvector<string> s;\nwhile (n--) {\nstring name, stat;\ncin >> name >> stat;\nif (stat == \"leave\")\nm[name] = 0;\nelse\nm[name] = 1;\n}\nfor (auto el : m) {\nif (el.second)\ns.push_back(el.first);\n}\nsort(s.rbegin(), s.rend());\nfor (auto el : s)\ncout << el << '\\n';\nreturn 0;\n}"
    },
    {
        "problem_tier": 7,
        "solution_code": "#include <iostream>\n#include <vector>\n#include <algorithm>\nusing namespace std;\ntypedef long long ll;\nint main(void){\nios_base::sync_with_stdio(0);\ncin.tie(0);\nint n, k;\ncin >> n >> k;\nvector<ll> num(n);\nfor(int i=0; i<n; i++){\ncin >> num[i];\n}\nsort(num.begin(), num.end());\ncout << num[k-1];\nreturn 0;\n}"
    },
    {
        "problem_tier": 2,
        "solution_code": "#include <iostream>\n#include <cstring>\nint compare(char* a, char* b) {\nif (strlen(a) > strlen(b))\nreturn 1;\nelse if (strlen(a) < strlen(b))\nreturn 0;\nelse {\nfor (int i = 0; i < strlen(a); i++) {\nif (a[i] > b[i])\nreturn 1;\nelse if (a[i] < b[i])\nreturn 0;\n}\n}\nreturn 2;\n}\nvoid add(char* a, char* b) {\nint r[1010] = {0};\nint i = strlen(a) - 1;\nfor (int j = strlen(b) - 1; j >= 0; j--) {\nif (i >= 0) {\nr[i] = (a[i] - '0') + (b[j] - '0');\n}\ni--;\n}\nfor (; i >= 0; i--)\nr[i] = a[i] - '0';\nfor (int i = strlen(a) - 1; i > 0; i--) {\nif (r[i] > 9) {\nr[i] -= 10;\nr[i - 1]++;\n}\n}\nfor (int i = 0; i < strlen(a); i++) {\nstd::cout << r[i];\n}\nstd::cout << std::endl;\n}\nvoid subtract(char* a, char* b) {\nint r[1010] = {0};\nint i = strlen(a) - 1;\nbool chk = false;\nfor (int j = strlen(b) - 1; j >= 0; j--) {\nif (i >= 0) {\nr[i] = (a[i] - '0') - (b[j] - '0');\n}\ni--;\n}\nfor (; i >= 0; i--)\nr[i] = a[i] - '0';\nfor (i = strlen(a) - 1; i > 0; i--) {\nif (r[i] < 0) {\nr[i] += 10;\nr[i - 1]--;\n}\n}\nfor (i = 0; i < strlen(a); i++) {\nif (r[i] != 0)\nchk = true;\n}\nif (!chk)\nstd::cout << 0;\nelse {\nfor (i = 0; r[i] == 0; i++);\nfor (; i < strlen(a); i++) {\nstd::cout << r[i];\n}\n}\nstd::cout << std::endl;\n}\nvoid multiply(char* a, char* b) {\nint r[2020] = {0};\nbool chk = false;\nfor (int i = 0; i < strlen(a); i++) {\nfor (int j = 0; j < strlen(b); j++) {\nr[i + j] += (a[i] - '0') * (b[j] - '0');\n}\n}\nfor (int i = strlen(a) + strlen(b) - 1; i > 0; i--) {\nr[i - 1] += r[i] / 10;\nr[i] = r[i] % 10;\n}\nfor (int i = 0; i < strlen(a); i++) {\nif (r[i] != 0)\nchk = true;\n}\nif (!chk)\nstd::cout << 0;\nelse {\nfor (int i = 0; i < strlen(a) + strlen(b) - 1; i++) {\nstd::cout << r[i];\n}\n}\n}\nint main() {\nchar a[1001], b[1001];\nstd::cin >> a >> b;\nadd(a, b);\nsubtract(a, b);\nmultiply(a, b);\nreturn 0;\n}"
    },
    {
        "problem_tier": 10,
        "solution_code": "#include<iostream>\n#include<algorithm>\n#include<vector>\n#include<set>\nusing namespace std;\nint N, M;\nint input[10];\nint answer[10];\nbool isUsed[10];\nset<vector<int>> s;\nvoid dfs(int cnt) {\nif (cnt == M) {\nvector<int> temp;\nfor (int i = 0; i < M; i++) {\ntemp.push_back(answer[i]);\n}\ns.insert(temp);\nreturn;\n}\nint prev = 0;\nfor (int i = 0; i < N; i++) {\nif (!isUsed[i] && prev != input[i]) {\nanswer[cnt] = input[i];\nprev = answer[cnt];\nisUsed[i] = true;\ndfs(cnt + 1);\nisUsed[i] = false;\n}\n}\n}\nint main() {\ncin >> N >> M;\nfor (int i = 0; i < N; i++) {\ncin >> input[i];\n}\nsort(input, input + N);\ndfs(0);\nfor (auto v : s) {\nfor (auto num : v) {\ncout << num << \" \";\n}\ncout << \"\\n\";\n}\nreturn 0;\n}"
    },
    {
        "problem_tier": 9,
        "solution_code": "#include<iostream>\n#include<algorithm>\nusing namespace std;\n#define MAX 9\nint N, M;\nint input[MAX];\nvector<int> result;\nvoid dfs(int count, int start) {\nif (count == M) {\nfor (int index = 0; index < M; index++) {\ncout << result[index] << \" \";\n}\ncout << \"\\n\";\nreturn;\n} else {\nfor (int index = start; index < N; index++) {\nresult.push_back(input[index]);\ndfs(count+1, index+1);\nresult.pop_back();\n}\n}\n}\nint main() {\ncin >> N >> M;\nfor (int index = 0; index < N; index++) {\ncin >> input[index];\n}\nsort(input, input+N);\ndfs(0, 0);\nreturn 0;\n}"
    },
    {
        "problem_tier": 12,
        "solution_code": "#include <iostream>\n#include <algorithm>\n#include <vector>\nusing namespace std;\nint n, res = 0;\nvector<pair<int, int>> v;\nint dp[100];\nvoid solution(){\nsort(v.begin(), v.end());\nfor(int i = 0; i < n; i++){\ndp[i] = 1;\nfor(int j = 0; j < i; j++){\nif(v[j].second < v[i].second){\ndp[i] = max(dp[i], dp[j] + 1);\n}\n}\nres = max(res, dp[i]);\n}\ncout << n - res;\n}\nint main(){\nios_base::sync_with_stdio(false);\ncin.tie(NULL);\ncout.tie(NULL);\ncin >> n;\nfor(int i = 0; i < n; i++){\nint a, b;\ncin >> a >> b;\nv.push_back({a, b});\n}\nsolution();\nreturn 0;\n}"
    },
    {
        "problem_tier": 13,
        "solution_code": "#include<iostream>\n#include<vector>\n#include<algorithm>\nusing namespace std;\nint N, M, Answer;\nint Parent[1001];\nvector<pair<int, pair<int, int>>> Edge;\nvoid Input(){\ncin >> N >> M;\nfor (int i = 0; i < M; i++){\nint a, b, c;\ncin >> a >> b >> c;\nEdge.push_back(make_pair(c, make_pair(a, b)));\n}\n}\nint Find(int x){\nif (Parent[x] == x) return x;\nelse return Parent[x] = Find(Parent[x]);\n}\nvoid Union(int x, int y){\nx = Find(x);\ny = Find(y);\nif (x != y) Parent[y] = x;\n}\nbool SameParent(int x, int y){\nx = Find(x);\ny = Find(y);\nif (x == y) return true;\nelse return false;\n}\nvoid Solution(){\nsort(Edge.begin(), Edge.end());\nfor (int i = 1; i <= N; i++){\nParent[i] = i;\n}\nfor (int i = 0; i < M; i++){\nif (SameParent(Edge[i].second.first, Edge[i].second.second) == false){\nUnion(Edge[i].second.first, Edge[i].second.second);\nAnswer = Answer + Edge[i].first;\n}\n}\ncout << Answer << endl;\n}\nvoid Solve(){\nInput();\nSolution();\n}\nint main(void){\nios::sync_with_stdio(false);\ncin.tie(NULL);\ncout.tie(NULL);\nSolve();\nreturn 0;\n}"
    },
    {
        "problem_tier": 3,
        "solution_code": "#include <iostream>\nusing namespace std;\nint main() {\nint n, p;\nint news[5];\ncin >> n >> p;\nfor (int i = 0; i < 5; i++) {\ncin >> news[i];\ncout << news[i] - (n * p) << \" \";\n}\nreturn 0;\n}"
    },
    {
        "problem_tier": 9,
        "solution_code": "#include <iostream>\n#include <vector>\n#include <algorithm>\nusing namespace std;\nbool next_permutation(int* a, int n) {\nint i = n - 1;\nwhile (i > 0 && a[i - 1] >= a[i])\ni -= 1;\nif (i <= 0)\nreturn false;\nint j = n - 1;\nwhile (a[j] <= a[i - 1])\nj -= 1;\nswap(a[i - 1], a[j]);\nj = n - 1;\nwhile (i < j) {\nswap(a[i], a[j]);\ni += 1;\nj -= 1;\n}\nreturn true;\n}\nint main(void) {\nint N;\ncin >> N;\nint numlist[10];\nfor (int i = 0; i < N; i++)\nnumlist[i] = i + 1;\ndo {\nfor (int i = 0; i < N; i++)\ncout << numlist[i] << \" \";\ncout << \"\\n\";\n} while (next_permutation(numlist, N));\nreturn 0;\n}"
    },
    {
        "problem_tier": 8,
        "solution_code": "#include <iostream>\n#include <algorithm>\n#include <string>\nint main() {\nstd::string s;\nstd::cin >> s;\nstd::vector<std::string> v;\nfor (int i = 0; i < s.size(); i++) {\nv.push_back(s.substr(i, s.length()));\n}\nstd::sort(v.begin(), v.end());\nfor (int i = 0; i < v.size(); i++) {\nstd::cout << v[i] << \"\\n\";\n}\nreturn 0;\n}"
    },
    {
        "problem_tier": 8,
        "solution_code": "#include<bits/stdc++.h>\nusing namespace std;\nstruct Student{\nstring name;\nint korean, english, math;\n};\nbool cmp(Student& a, Student& b){\nif(a.korean == b.korean){\nif(a.english == b.english){\nif(a.math == b.math){\nreturn a.name < b.name;\n}\nreturn a.math > b.math;\n}\nreturn a.english < b.english;\n}\nreturn a.korean > b.korean;\n}\nint main(){\nint n;\ncin >> n;\nvector<Student> v(n);\nfor(int i=0; i<n; i++){\nstring name;\nint korean, english, math;\ncin >> name >> korean >> english >> math;\nv[i] = {name, korean, english, math};\n}\nsort(v.begin(), v.end(), cmp);\nfor(auto& s : v){\ncout << s.name << '\\n';\n}\nreturn 0;\n}"
    },
    {
        "problem_tier": 5,
        "solution_code": "#include <iostream>\n#include <cmath>\nusing namespace std;\nint main() {\nint M, N;\ncin >> M >> N;\nint sum = 0;\nint cnt = 0;\nint small = 10001;\nfor (int j = 1; j <= 100; j++) {\nif (j * j >= M && j * j <= N) {\nsum += j * j;\ncnt++;\n}\nif (j * j >= M && j * j <= N && small > j * j) {\nsmall = j * j;\n}\n}\nif (cnt == 0) {\ncout << \"-1\";\nreturn 0;\n}"
    },
    {
        "problem_tier": 10,
        "solution_code": "#include <iostream>\nusing namespace std;\nint dp[21][21][21];\nint w(int a, int b, int c) {\nif (a <= 0 || b <= 0 || c <= 0)\nreturn 1;\nelse if (a > 20 || b > 20 || c > 20)\nreturn dp[20][20][20];\nelse if (dp[a][b][c] != 0)\nreturn dp[a][b][c];\nelse if (a < b && b < c)\ndp[a][b][c] = w(a, b, c - 1) + w(a, b - 1, c - 1) - w(a, b - 1, c);\nelse\ndp[a][b][c] = w(a - 1, b, c) + w(a - 1, b - 1, c) + w(a - 1, b, c - 1) - w(a - 1, b - 1, c - 1);\nreturn dp[a][b][c];\n}\nint main() {\nint a, b, c;\nwhile (1) {\ncin >> a >> b >> c;\nif (a == -1 && b == -1 && c == -1)\nbreak;\ncout << \"w(\" << a << \",\" << b << \",\" << c << \")=\" << w(a, b, c) << endl;\n}\nreturn 0;\n}"
    },
    {
        "problem_tier": 10,
        "solution_code": "#include <iostream>\n#include <vector>\n#include <algorithm>\nusing namespace std;\nint n, m;\nvector<int> budget;\nint main() {\ncin >> n;\nfor (int i = 0; i < n; i++) {\nint x;\ncin >> x;\nbudget.push_back(x);\n}\ncin >> m;\nsort(budget.begin(), budget.end());\nint start = 0;\nint end = budget[n-1];\nint result, sum;\nwhile (start <= end) {\nsum = 0;\nint mid = (start + end) / 2;\nfor (int i = 0; i < n; i++) {\nsum += min(budget[i], mid);\n}\nif (m >= sum) {\nresult = mid;\nstart = mid + 1;\n} else {\nend = mid - 1;\n}\n}\ncout << result;\nreturn 0;\n}"
    },
    {
        "problem_tier": 2,
        "solution_code": "#include <iostream>\nusing namespace std;\nint main() {\nint sum = 0, x;\nfor (int i = 0; i < 5; i++) {\ncin >> x;\nsum += x;\n}\ncout << sum << '\\n';\n}\n"
    },
    {
        "problem_tier": 13,
        "solution_code": "#include <iostream>\n#include <vector>\n#include <queue>\n#include <algorithm>\n#include <cstring>\n#define INF 1e9+7\n#define pii pair<int, int>\nusing namespace std;\nint N, E, V1, V2;\nvector<pii> adj[801];\nvector<int> dist;\nvoid input(){\nint a, b, c;\ncin >> N >> E;\nfor(int i = 0; i < E; i++){\ncin >> a >> b >> c;\nadj[a].push_back({c, b});\nadj[b].push_back({c, a});\n}\ncin >> V1 >> V2;\n}\nint dijkstra(int st, int ed){\ndist = vector<int>(N+1, INF);\npriority_queue<pii, vector<pii>, greater<pii> > que;\nque.push({0, st});\ndist[st] = 0;\nwhile(!que.empty()){\nint now = que.top().second;\nint cost = que.top().first;\nque.pop();\nif(cost > dist[now]) continue;\nfor(int i = 0; i < adj[now].size(); i++){\nint next = adj[now][i].second;\nint next_cost = adj[now][i].first + cost;\nif(next_cost < dist[next]){\ndist[next] = next_cost;\nque.push({next_cost, next});\n}\n}\n}\nreturn dist[ed];\n}\nvoid solve(){\nint res1, res2;\nint a1 = dijkstra(1, V1);\nint a2 = dijkstra(V1, V2);\nint a3 = dijkstra(V2, N);\nif(a1 == INF || a2 == INF || a3 == INF) res1 = INF;\nelse res1 = a1 + a2 + a3;\nint b1 = dijkstra(1, V2);\nint b2 = dijkstra(V2, V1);\nint b3 = dijkstra(V1, N);\nif(b1 == INF || b2 == INF || b3 == INF) res2 = INF;\nelse res2 = b1 + b2 + b3;\nif(res1 == INF && res2 == INF) cout << -1;\nelse cout << min(res1, res2);\n}\nint main(){\ninput();\nsolve();\nreturn 0;\n}"
    },
    {
        "problem_tier": 9,
        "solution_code": "#include <iostream>\n#include <algorithm>\n#include <climits>\n#include <vector>\nusing namespace std;\nint main() {\nint n, k;\ncin >> n >> k;\nvector<int> v(n);\nfor (int i = 0; i < n; i++)\ncin >> v[i];\nint start = 0;\nint end = k - 1;\nint sum = 0;\nint answer = INT_MIN;\nfor (int i = 0; i <= k - 1; i++)\nsum += v[i];\nfor (int i = 0; i <= n - k; i++) {\nanswer = max(answer, sum);\nif (end == n - 1)\nbreak;\nelse {\nsum -= v[start++];\nsum += v[++end];\n}\n}\ncout << answer;\nreturn 0;\n}"
    },
    {
        "problem_tier": 7,
        "solution_code": "#include <iostream>\n#include <string>\n#include <algorithm>\nusing namespace std;\nint main() {\nstring numstr;\ncin >> numstr;\nint zeroarea = 0;\nint onearea = 0;\nfor (int i = 0; i < numstr.size(); ++i) {\nif (numstr[i] != numstr[i+1]) {\nif (numstr[i] == '0')\nzeroarea++;\nelse\nonearea++;\n}\n}\ncout << min(zeroarea, onearea);\nreturn 0;\n}"
    },
    {
        "problem_tier": 10,
        "solution_code": "#include<iostream>\n#include<algorithm>\n#include<vector>\nusing namespace std;\nint N;\nint n[9];\nint result;\nvector<int> v;\nint visit[9];\nint cnt = 0;\nvoid solve(){\nif(v.size() == N){\nint tmp = 0;\nfor(int i=0; i<N-1; i++){\ntmp += abs(v[i+1] - v[i]);\n}\nresult = max(result, tmp);\nreturn;\n}\nfor(int i=1; i<=N; i++){\nif(!visit[i]){\nvisit[i] = 1;\nv.push_back(n[i]);\nsolve();\nv.pop_back();\nvisit[i] = 0;\n}\n}\n}\nint main(){\ncin >> N;\nfor(int i=1; i<=N; i++){\ncin >> n[i];\n}\nsolve();\ncout << result << endl;\nreturn 0;\n}"
    },
    {
        "problem_tier": 11,
        "solution_code": "#include<iostream>\n#include<vector>\n#include<algorithm>\nusing namespace std;\nint T, N;\nint main(){\ncin >> T;\nwhile(T--){\ncin >> N;\nvector<pair<int,int>> grades;\nfor(auto i = 0; i < N; i++){\nint x, y;\ncin >> x >> y;\ngrades.push_back({x, y});\n}\nsort(grades.begin(), grades.end());\nint temp = 0;\nint result = 1;\nfor(auto i = 1; i < N; i++){\nif(grades[temp].second > grades[i].second){\nresult++;\ntemp = i;\n}\n}\ncout << result << \"\\n\";\n}\n}"
    },
    {
        "problem_tier": 8,
        "solution_code": "#include <iostream>\n#include <set>\nusing namespace std;\nset<int> a;\nint n, m;\nint main() {\ncin >> n >> m;\nfor (int i = 0; i < n; i++) {\nint x;\ncin >> x;\na.insert(x);\n}\nfor (int i = 0; i < m; i++) {\nint x;\ncin >> x;\nif (a.count(x)) {\na.erase(x);         } else {\na.insert(x);         }\n}\ncout << a.size();\nreturn 0;\n}"
    },
    {
        "problem_tier": 12,
        "solution_code": "#include<iostream>\nusing namespace std;\ntypedef long long ll;\nconst ll MOD = 1000000000;\nll dp[201][201];\nint main(void){\nios_base::sync_with_stdio(0);\ncin.tie(0);\ncout.tie(0);\nint n, k;\ncin >> n >> k;\nfor(int i=0; i<=n; i++){\ndp[1][i] = 1;\n}\nfor(int i=2; i<=k; i++){\nfor(int j=0; j<=n; j++){\nfor(int z=0; z<=j; z++){\ndp[i][j] += dp[i-1][z];\n}\ndp[i][j] %= MOD;\n}\n}\ncout << dp[k][n];\nreturn 0;\n}"
    },
    {
        "problem_tier": 6,
        "solution_code": "#include<iostream>\n#include<stack>\n#include<string>\nusing namespace std;\nint main(){\nint t;\ncin >> t;\ncin.ignore();\nwhile(t--){\nstring sentence, ans = \"\";\ngetline(cin, sentence);\nfor(int pivot=0; pivot<sentence.size(); pivot++){\nstring word = \"\";\nwhile(sentence[pivot]!=' ' && pivot!=sentence.size()){\nword += sentence[pivot++];\n}\nstack<char> st;\nfor(int i=0; i<word.size(); i++){\nst.push(word[i]);\n}\nwhile(!st.empty()){\nans += st.top();\nst.pop();\n}\nans += ' ';\n}\ncout << ans << '\\n';\n}\n}"
    },
    {
        "problem_tier": 13,
        "solution_code": "#include<iostream>\n#define MAX 35\nusing namespace std;\nint DP[MAX];\nvoid Input(){\ncin >> N;\n}\nvoid Solution(){\nif (N % 2 == 1)\n{\ncout << 0 << endl;\nreturn;\n}\nDP[0] = 1;\nDP[1] = 0;\nDP[2] = 3;\nfor (int i = 4; i <= N; i = i + 2)\n{\nDP[i] = DP[i - 2] * DP[2];\nfor (int j = i - 4; j >= 0; j = j - 2)\n{\nDP[i] = DP[i] + (DP[j] * 2);\n}\n}\ncout << DP[N] << endl;\n}\nvoid Solve(){\nInput();\nSolution();\n}\nint main(void){\nios::sync_with_stdio(false);\ncin.tie(NULL);\ncout.tie(NULL);\nSolve();\nreturn 0;\n}"
    },
    {
        "problem_tier": 12,
        "solution_code": "#include<iostream>\n#include<deque>\nusing namespace std;\ndeque<int> gear[5];\nint K;\nvoid rotateGear(int num, int dir) {\nif (dir == 1) {         int temp = gear[num].back();\ngear[num].pop_back();\ngear[num].push_front(temp);\n} else {         int temp = gear[num].front();\ngear[num].pop_front();\ngear[num].push_back(temp);\n}\n}\nvoid solve(int num, int dir) {\nint left_gear = num - 1;     int right_gear = num + 1;\nrotateGear(num, dir);\nif (left_gear > 0 && gear[left_gear][2] != gear[num][6]) {\nsolve(left_gear, -dir);\n}\nif (right_gear < 5 && gear[right_gear][6] != gear[num][2]) {\nsolve(right_gear, -dir);\n}\n}\nint main() {\nfor (int i = 1; i <= 4; i++) {\nstring input;\ncin >> input;\nfor (int j = 0; j < 8; j++) {\ngear[i].push_back(input[j] - '0');\n}\n}\ncin >> K;\nwhile (K--) {\nint gear_num, dir;\ncin >> gear_num >> dir;\nsolve(gear_num, dir);\n}\nint answer = 0;\nfor (int i = 1; i <= 4; i++) {\nif (gear[i][0] == 1) {\nanswer += (1 << (i - 1));\n}\n}\ncout << answer << endl;\nreturn 0;\n}"
    },
    {
        "problem_tier": 15,
        "solution_code": "#include<bits/stdc++.h>\nusing namespace std;\nint n;\nvector<vector<int>> block(21, vector<int> (21, 0));\nint maxValue = -0x3f3f3f3f;\nvoid moveBlock(vector<vector<int>> &board, int type) {\nqueue<int> q;\nif(type == 0) {\nfor(int i = 0; i < n; i++) {\nfor(int j = 0; j < n; j++) {\nif(board[i][j]) {\nq.push(board[i][j]);\n}\nboard[i][j] = 0;\n}\nint idx = 0;\nwhile(!q.empty()) {\nint num = q.front();\nq.pop();\nif(board[i][idx] == 0) {\nboard[i][idx] = num;\n}\nelse if(board[i][idx] == num) {\nboard[i][idx] *= 2;\nidx++;\n}\nelse {\nidx++;\nboard[i][idx] = num;\n}\n}\n}\n}\nelse if(type == 1) {\nfor(int i = 0; i < n; i++) {\nfor(int j = 0; j < n; j++) {\nif(board[j][i]) {\nq.push(board[j][i]);\n}\nboard[j][i] = 0;\n}\nint idx = 0;\nwhile(!q.empty()) {\nint num = q.front();\nq.pop();\nif(board[idx][i] == 0) {\nboard[idx][i] = num;\n}\nelse if(board[idx][i] == num) {\nboard[idx][i] *= 2;\nidx++;\n}\nelse {\nidx++;\nboard[idx][i] = num;\n}\n}\n}\n}\nelse if(type == 2) {\nfor(int i = 0; i < n; i++) {\nfor(int j = n - 1; j >= 0; j--) {\nif(board[i][j]) {\nq.push(board[i][j]);\n}\nboard[i][j] = 0;\n}\nint idx = n - 1;\nwhile(!q.empty()) {\nint num = q.front();\nq.pop();\nif(board[i][idx] == 0) {\nboard[i][idx] = num;\n}\nelse if(board[i][idx] == num) {\nboard[i][idx] *= 2;\nidx--;\n}\nelse {\nidx--;\nboard[i][idx] = num;\n}\n}\n}\n}\nelse if(type == 3) {\nfor(int i = 0; i < n; i++) {\nfor(int j = n - 1; j >= 0; j--) {\nif(board[j][i]) {\nq.push(board[j][i]);\n}\nboard[j][i] = 0;\n}\nint idx = n - 1;\nwhile(!q.empty()) {\nint num = q.front();\nq.pop();\nif(board[idx][i] == 0) {\nboard[idx][i] = num;\n}\nelse if(board[idx][i] == num) {\nboard[idx][i] *= 2;\nidx--;\n}\nelse {\nidx--;\nboard[idx][i] = num;\n}\n}\n}\n}\n}\nvoid solve(vector<vector<int>> &board, int cnt) {\nif(cnt == 5) {\nfor(int i = 0; i < n; i++) {\nfor(int j = 0; j < n; j++) {\nmaxValue = max(maxValue, board[i][j]);\n}\n}\nreturn;\n}\nvector<vector<int>> temp = board;\nfor(int i = 0; i < 4; i++) {\nmoveBlock(board, i);\nsolve(board, cnt + 1);\nboard = temp;\n}\n}\nint main() {\nios_base::sync_with_stdio(false); cin.tie(0); cout.tie(0);\ncin >> n;\nfor(int i = 0; i < n; i++) {\nfor(int j = 0; j < n; j++) {\ncin >> block[i][j];\n}\n}\nsolve(block, 0);\ncout << maxValue;\n}"
    },
    {
        "problem_tier": 9,
        "solution_code": "#include <iostream>\n#include <cmath>\nusing namespace std;\nbool check(int cx, int cy, int r, int x1, int y1, int x2, int y2) {\nif (pow((cx - x1), 2) + pow((cy - y1), 2) < pow(r, 2)) {\nif (pow((cx - x2), 2) + pow((cy - y2), 2) > pow(r, 2))\nreturn true;\n}\nif (pow((cx - x1), 2) + pow((cy - y1), 2) > pow(r, 2)) {\nif (pow((cx - x2), 2) + pow((cy - y2), 2) < pow(r, 2))\nreturn true;\n}\nreturn false;\n}\nint main() {\nint t;\ncin >> t;\nfor (int i = 0; i < t; i++) {\nint x1, y1, x2, y2;\ncin >> x1 >> y1 >> x2 >> y2;\nint n;\ncin >> n;\nint answer = 0;\nfor (int j = 0; j < n; j++) {\nint cx, cy, r;\ncin >> cx >> cy >> r;\nif (check(cx, cy, r, x1, y1, x2, y2))\nanswer++;\n}\ncout << answer << endl;\n}\nreturn 0;\n}"
    },
    {
        "problem_tier": 16,
        "solution_code": "#include <iostream>\n#include <queue>\n#include <cstring>\nusing namespace std;\nint N, M;\nchar map[10][10];\nbool visit[10][10][10][10];\nstruct ball {\nint rx, ry, bx, by, count;\n};\nint dx[] = {1,-1,0,0};\nint dy[] = {0,0,1,-1};\nvoid move(int& x, int& y, int& distance, int& i) {\nwhile (map[x+dx[i]][y+dy[i]] != '#' && map[x][y] != 'O') {\nx += dx[i];\ny += dy[i];\ndistance += 1;\n}\n}\nint BFS(int rx, int ry, int bx, int by) {\nqueue<ball> q;\nq.push({rx, ry, bx, by, 0});\nvisit[rx][ry][bx][by] = true;\nwhile (!q.empty()) {\nint rx = q.front().rx;\nint ry = q.front().ry;\nint bx = q.front().bx;\nint by = q.front().by;\nint count = q.front().count;\nq.pop();\nif (count >= 10) break;\nfor (int i = 0; i < 4; i++) {\nint nrx = rx, nry = ry, nbx = bx, nby = by;\nint rc = 0, bc = 0, ncount = count + 1;\nmove(nrx, nry, rc, i);\nmove(nbx, nby, bc, i);\nif (map[nbx][nby] == 'O') continue;\nif (map[nrx][nry] == 'O') {\nreturn ncount;\n}\nif (nrx == nbx && nry == nby) {\nif (rc > bc) nrx -= dx[i], nry -= dy[i];\nelse nbx -= dx[i], nby -= dy[i];\n}\nif (visit[nrx][nry][nbx][nby]) continue;\nvisit[nrx][nry][nbx][nby] = true;\nq.push({nrx, nry, nbx, nby, ncount});\n}\n}\nreturn -1;\n}\nvoid solve() {\ncin >> N >> M;\nint rx = 0, ry = 0, bx = 0, by = 0;\nfor (int i = 0; i < N; i++) {\nfor (int j = 0; j < M; j++) {\ncin >> map[i][j];\nif (map[i][j] == 'R') {\nrx = i;\nry = j;\n} else if (map[i][j] == 'B') {\nbx = i;\nby = j;\n}\n}\n}\nint answer = BFS(rx, ry, bx, by);\ncout << answer << endl;\n}\nint main() {\nios_base::sync_with_stdio(false);\ncin.tie(NULL);\nsolve();\nreturn 0;\n}"
    },
    {
        "problem_tier": 14,
        "solution_code": "#include <iostream>\n#include <vector>\n#include <queue>\n#define pii pair<int, int>\nusing namespace std;\nconst int INF = 1e9+7;\nvector<pii> graph[1001];\nvector<int> dist;\nint resdist[1001];\nvoid input(){\nint N, M, X;\ncin >> N >> M >> X;\nfor(int i = 0; i < M; i++){\nint u, v, t;\ncin >> u >> v >> t;\ngraph[u].push_back(make_pair(t, v));\n}\n}\nvoid Dijstra(int S){\ndist.clear();\ndist.resize(N+1, INF);\ndist[S] = 0;\npriority_queue<pii, vector<pii>, greater<pii> > que;\nque.push({0, S});\nwhile(!que.empty()){\nint min_cost = que.top().first;\nint now = que.top().second;\nque.pop();\nif(min_cost > dist[now]) continue;\nfor(int i = 0; i < graph[now].size(); i++){\nint next = graph[now][i].second;\nint next_cost = min_cost + graph[now][i].first;\nif(next_cost < dist[next]){\ndist[next] = next_cost;\nque.push({next_cost, next});\n}\n}\n}\n}\nint main(){\nios_base::sync_with_stdio(false);\ncin.tie(NULL);\ncout.tie(NULL);\ninput();\nfor(int i = 1; i <= N; i++){\nDijstra(i);\nresdist[i] = dist[X];\n}\nDijstra(X);\nint res = 0;\nfor(int i = 1; i <= N; i++){\nresdist[i] += dist[i];\nres = max(res, resdist[i]);\n}\ncout << res;\nreturn 0;\n}"
    },
    {
        "problem_tier": 12,
        "solution_code": "#include <iostream>\n#include <algorithm>\n#define MAX 10001\n#define INF 123456789\nusing namespace std;\nint coins[MAX];\nint dp[MAX];\nint main() {\nint n, k;\ncin >> n >> k;\nfor(int i=1; i<=n; i++){\ncin >> coins[i];\n}\nfor(int i=1; i<=k; i++){\ndp[i] = INF;\n}\nfor(int i=1; i<=n; i++){\nfor(int j=coins[i]; j<=k; j++){\ndp[j] = min(dp[j], dp[j-coins[i]]+1);\n}\n}\nif(dp[k] == INF)\ncout << -1;\nelse\ncout << dp[k];\nreturn 0;\n}"
    },
    {
        "problem_tier": 11,
        "solution_code": "#include <bits/stdc++.h>\nusing namespace std;\n#define MAX 101\n#define INF 987654321\nint N, M;\nint MAP[MAX][MAX];\nint main() {\nios_base::sync_with_stdio(0);\ncin.tie(0);\ncin >> N >> M;\nfor(int i = 0; i < M; i++) {\nint a, b;\ncin >> a >> b;\nMAP[a][b] = 1;\nMAP[b][a] = 1;\n}\nfor(int k = 1; k <= N; k++) {\nfor(int i = 1; i <= N; i++) {\nfor(int j = 1; j <= N; j++) {\nif(i == j) continue;\nif(MAP[i][k] != 0 && MAP[k][j] != 0) {\nif(MAP[i][j] == 0) {\nMAP[i][j] = MAP[i][k] + MAP[k][j];\n} else {\nMAP[i][j] = min(MAP[i][j], MAP[i][k] + MAP[k][j]);\n}\n}\n}\n}\n}\nint ans = INF;\nint person = -1;\nfor(int i = 1; i <= N; i++) {\nint sum = 0;\nfor(int j = 1; j <= N; j++) {\nsum += MAP[i][j];\n}\nif(ans > sum) {\nperson = i;\nans = sum;\n}\n}\ncout << person;\nreturn 0;\n}"
    },
    {
        "problem_tier": 7,
        "solution_code": "#include <iostream>\nint main() {\nint N;\nstd::cin >> N;\nif(N % 2 == 1){\nstd::cout << \"SK\";\n} else {\nstd::cout << \"CY\";\n}\nreturn 0;\n}"
    },
    {
        "problem_tier": 8,
        "solution_code": "#include <iostream>\n#include <algorithm>\n#include <vector>\n#include <string>\nusing namespace std;\nint main() {\nstring N;\ncin >> N;\nvector<int> nums;\nfor (int i = 0; i < N.size(); ++i) {\nnums.push_back(N[i] - '0');\n}\nsort(nums.rbegin(), nums.rend());\nint check = 0;\nfor (int i = 0; i < nums.size(); ++i) {\ncheck += nums[i];\n}\nif (check % 3 != 0) {\ncout << -1;\n}\nelse if (nums[nums.size() - 1] != 0) {\ncout << -1;\n}\nelse {\nfor (auto x : nums)\ncout << x;\n}\nreturn 0;\n}"
    },
    {
        "problem_tier": 13,
        "solution_code": "#include<iostream>\n#include<vector>\n#include<queue>\nusing namespace std;\nbool isBipartiteGraph(vector<vector<int>>& graph) {\nint K;\ncin >> K;\nfor (int i = 0; i < K; i++) {\nint V, E;\ncin >> V >> E;\nvector<pair<bool, int>> visited(V + 1, { false, 0 });\nvector<vector<int>> adjList(V + 1);\nfor (int j = 0; j < E; j++) {\nint u, v;\ncin >> u >> v;\nadjList[u].push_back(v);\nadjList[v].push_back(u);\n}\nfor (int k = 1; k <= V; k++) {\nif (visited[k].first == false) {\nqueue<int> q;\nq.push(k);\nvisited[k].first = true;\nvisited[k].second = 1;\nwhile (!q.empty()) {\nint cur = q.front();\nq.pop();\nint curColor = visited[cur].second;\nfor (int l = 0; l < adjList[cur].size(); l++) {\nint next = adjList[cur][l];\nif (visited[next].first == false) {\nvisited[next].first = true;\nvisited[next].second = curColor == 1 ? 2 : 1;\nq.push(next);\n}\n}\n}\n}\n}\nbool isBipartite = true;\nfor (int m = 1; m <= V; m++) {\nfor (int n = 0; n < adjList[m].size(); n++) {\nint next = adjList[m][n];\nif (visited[m].second == visited[next].second) {\nisBipartite = false;\nbreak;\n}\n}\nif (!isBipartite) {\nbreak;\n}\n}\nif (isBipartite) {\ncout << \"YES\" << endl;\n}\nelse {\ncout << \"NO\" << endl;\n}\n}\nreturn 0;\n}"
    },
    {
        "problem_tier": 2,
        "solution_code": "#include<iostream>\n#include<string>\nusing namespace std;\nint main(){\nstring k;\ncout << \"...\" << '\\n';\ncout << \"||_|_._.___\" << '\\n';\ncout << \"|/\\\\|(/.|(_.(_)[|)(/.\" << '\\n';\nreturn 0;\n}"
    },
    {
        "problem_tier": 3,
        "solution_code": "#include <iostream>\nusing namespace std;\nint main() {\nint K, N, M;\ncin >> K >> N >> M;\nif (K * N > M)\ncout << K * N - M << '\\n';\nelse\ncout << \"0\" << '\\n';\nreturn 0;\n}"
    },
    {
        "problem_tier": 6,
        "solution_code": "#include <iostream>\n#include <vector>\nusing namespace std;\nint main() {\nint n, m;\ncin >> n >> m;\nvector<int> arr;\nfor (int i = 1; i <= 1000; i++) {\nfor (int j = 0; j < i; j++) {\narr.push_back(i);\nif (arr.size() >= 1000) {\nbreak;\n}\n}\n}\nint ans = 0;\nfor (int i = n-1; i < m; i++) {\nans += arr[i];\n}\ncout << ans << endl;\nreturn 0;\n}"
    },
    {
        "problem_tier": 10,
        "solution_code": "#include <iostream>\n#include <queue>\nusing namespace std;\nlong long A, B;\nlong long answer = 10000000;\nvoid bfs(long long start, long long end) {\nqueue<pair<long long, long long>> q;\nq.push(make_pair(start, 1));\nwhile (!q.empty()) {\npair<long long, long long> now = q.front();\nq.pop();\nif (now.first == end) {\nanswer = min(answer, now.second);\nreturn;\n}\nif (now.first * 2 <= end) {\nq.push(make_pair(now.first * 2, now.second + 1));\n}\nif (now.first * 10 + 1 <= end) {\nq.push(make_pair((now.first * 10) + 1, now.second + 1));\n}\n}\n}\nint main() {\ncin >> A >> B;\nbfs(A, B);\ncout << (answer == 10000000 ? -1 : answer) << \"\\n\";\nreturn 0;\n}"
    },
    {
        "problem_tier": 7,
        "solution_code": "#include <iostream>\nusing namespace std;\nint main() {\nstring majorName;\ndouble avg = 0;\nfloat sumGrade = 0;\ndouble score[20];\nfloat grade[20];\nstring input;\nfor (int i = 0; i < 20; ++i) {\ncin >> majorName >> grade[i] >> input;\nif (input == \"A+\")\nscore[i] = 4.5;\nelse if (input == \"A0\")\nscore[i] = 4.0;\nelse if (input == \"B+\")\nscore[i] = 3.5;\nelse if (input == \"B0\")\nscore[i] = 3.0;\nelse if (input == \"C+\")\nscore[i] = 2.5;\nelse if (input == \"C0\")\nscore[i] = 2.0;\nelse if (input == \"D+\")\nscore[i] = 1.5;\nelse if (input == \"D0\")\nscore[i] = 1.0;\nelse if (input == \"F\")\nscore[i] = 0.0;\nelse if (input == \"P\") {\nscore[i] = 0.0;\ngrade[i] = 0;\n}\navg += (score[i] * grade[i]);\nsumGrade += grade[i];\n}\navg = avg/sumGrade;\ncout << fixed;\ncout.precision(6);\ncout << avg;\nreturn 0;\n}"
    },
    {
        "problem_tier": 4,
        "solution_code": "#include <iostream>\nusing namespace std;\nint main() {\nios::sync_with_stdio(false);\ncin.tie(NULL);\nunsigned int N;\ncin >> N;\ncout << N * 4;\nreturn 0;\n}"
    },
    {
        "problem_tier": 12,
        "solution_code": "#include <iostream>\n#include <stack>\nusing namespace std;\nint main() {\ncin.tie(0);\nios_base::sync_with_stdio(false);\nint N;\ncin >> N;\nstack<pair<int, int>> st;\nfor (int i = 1; i <= N; i++) {\nint K;\ncin >> K;\nif (st.empty()) {             st.push({i, K});\ncout << \"0 \";\n} else {\nwhile (!st.empty()) {\nif (st.top().second > K) {                     cout << st.top().first << \" \";                     break;\n} else {\nst.pop();                 }\n}\nif (st.empty())\ncout << \"0 \";             st.push({i, K});         }\n}\nreturn 0;\n}"
    },
    {
        "problem_tier": 13,
        "solution_code": "#include <iostream>\n#include <vector>\n#include <queue>\n#include <cmath>\n#include <cstring>\nusing namespace std;\nint n, L, R;\nint map[52][52];\nint open[52][52];\nint dr[] = {0, 1, 0, -1};\nint dc[] = {1, 0, -1, 0};\nint day = 0;\nint unions = 0;\nvector<int> avgs;\nbool needMove() {\nfor (int i = 1; i <= n; ++i) {\nfor (int j = 1; j <= n; ++j) {\nfor (int d = 0; d < 4; ++d) {\nint ni, nj;\nni = i + dr[d];\nnj = j + dc[d];\nint home = map[i][j];\nint adj = map[ni][nj];\nif (L <= abs(home - adj) && abs(home - adj) <= R) {\nreturn true;\n}\n}\n}\n}\nreturn false;\n}\nvoid bfs(int r, int c) {\nint countries = 1;\nint population = map[r][c];\nqueue<pair<int, int>> q;\nq.push(make_pair(r, c));\nopen[r][c] = unions;\nwhile (!q.empty()) {\npair<int, int> p = q.front();\nq.pop();\nr = p.first;\nc = p.second;\nfor (int d = 0; d < 4; ++d) {\nint nr, nc;\nnr = r + dr[d];\nnc = c + dc[d];\nif (open[nr][nc]) {\ncontinue;\n}\nint home = map[r][c];\nint adj = map[nr][nc];\nif (L <= abs(home - adj) && abs(home - adj) <= R) {\nopen[nr][nc] = unions;\ncountries++;\npopulation += map[nr][nc];\nq.push(make_pair(nr, nc));\n}\n}\n}\navgs.push_back(population / countries);\nreturn;\n}\nvoid sol() {\nwhile (true) {\nmemset(open, 0, sizeof(open));\nif (!needMove()) {\nbreak;\n}\nday++;\nunions = 0;\navgs.clear();\navgs.push_back(-1);         for (int i = 1; i <= n; ++i) {\nfor (int j = 1; j <= n; ++j) {\nif (!open[i][j]) {\nfor (int d = 0; d < 4; ++d) {\nint ni, nj;\nni = i + dr[d];\nnj = j + dc[d];\nint home = map[i][j];\nint adj = map[ni][nj];\nif (L <= abs(home - adj) && abs(home - adj) <= R) {\nif (!open[ni][nj]) {\nunions++;                                 bfs(i, j);\n}\n}\n}\n}\n}\n}\nfor (int i = 1; i <= n; ++i) {\nfor (int j = 1; j <= n; ++j) {\nif (open[i][j]) {\nint unionNum = open[i][j];\nmap[i][j] = avgs[unionNum];\n}\n}\n}\n}\nreturn;\n}\nint main(void) {\nscanf(\"%d%d%d\", &n, &L, &R);\nfor (int i = 0; i < 52; ++i) {\nfor (int j = 0; j < 52; ++j) {\nmap[i][j] = INF;\n}\n}\nfor (int i = 1; i <= n; ++i) {\nfor (int j = 1; j <= n; ++j) {\nscanf(\"%d\", &map[i][j]);\n}\n}\nsol();\nprintf(\"%d\\n\", day);\nreturn 0;\n}"
    },
    {
        "problem_tier": 6,
        "solution_code": "#include<iostream>\n#include<vector>\nusing namespace std;\nint main(void) {\nwhile(1) {\nvector<int> measure;\nint sum = 0;\nint n;\ncin >> n;\nif(n == -1)\nbreak;\nfor(int i = 1; i < n; i++)\nif(n % i == 0)\nmeasure.push_back(i);\nfor(int i = 0; i < measure.size(); i++)\nsum += measure[i];\nif(n == sum) {\ncout << n << \"=\";\nfor(int i = 0; i < measure.size(); i++) {\nif(i == measure.size()-1)\ncout << measure[i];\nelse\ncout << measure[i] << \"+\";\n}\ncout << '\\n';\n}\nelse\ncout << n << \" is NOT perfect.\\n\";\n}\nreturn 0;\n}"
    },
    {
        "problem_tier": 12,
        "solution_code": "#include <iostream>\n#include <queue>\n#include <deque>\nusing namespace std;\nstruct Node {\nint x;\nint time;\n};\nbool visited[100001];\nint main() {\nint n, k;\ncin >> n >> k;\ndeque<Node> dq;\ndq.push_front({n, 0});\nvisited[n] = true;\nwhile (!dq.empty()) {\nNode cur = dq.front();\ndq.pop_front();\nif (cur.x == k) {\ncout << cur.time << endl;\nbreak;\n}\nif (cur.x * 2 <= 100000 && !visited[cur.x * 2]) {\ndq.push_front({cur.x * 2, cur.time});\nvisited[cur.x * 2] = true;\n}\nif (cur.x + 1 <= 100000 && !visited[cur.x + 1]) {\ndq.push_back({cur.x + 1, cur.time + 1});\nvisited[cur.x + 1] = true;\n}\nif (cur.x - 1 >= 0 && !visited[cur.x - 1]) {\ndq.push_back({cur.x - 1, cur.time + 1});\nvisited[cur.x - 1] = true;\n}\n}\nreturn 0;\n}"
    },
    {
        "problem_tier": 5,
        "solution_code": "#include <iostream>\n#include <string>\n#include <cmath>\nusing namespace std;\nint main() {\nstring word;\ncin >> word;\nint ans = 0;\nfor (int i = 0; i < word.length(); i++) {\nif (word[i] >= 'A' && word[i] <= 'F') {\nans += pow(16, word.length()-i-1) * (word[i] - 'A' + 10);\n}\nelse {\nans += pow(16, word.length()-i-1) * (word[i] - '0');\n}\n}\ncout << ans;\nreturn 0;\n}"
    },
    {
        "problem_tier": 13,
        "solution_code": "#include<iostream>\n#include<vector>\nusing namespace std;\nint n, m, y, x, k;\nint map[21][21];\nint order[1001];\nvector<int> dice(7); int dy[5] = {0, 0, 0, -1, 1};\nint dx[5] = {0, 1, -1, 0, 0};\nvoid input(){\nios_base::sync_with_stdio(false);\ncin.tie(NULL);\ncout.tie(NULL);\ncin >> n >> m >> y >> x >> k;\nfor(int i=0; i<n; i++){\nfor(int j=0; j<m; j++){\ncin >> map[i][j];\n}\n}\nfor(int i=0; i<k; i++){\ncin >> order[i];\n}\n}\nvoid rollEast(){\ndice = {0, dice[4], dice[2], dice[1], dice[6], dice[5], dice[3]};\n}\nvoid rollWest(){\ndice = {0, dice[3], dice[2], dice[6], dice[1], dice[5], dice[4]};\n}\nvoid rollNorth(){\ndice = {0, dice[5], dice[1], dice[3], dice[4], dice[6], dice[2]};\n}\nvoid rollSouth(){\ndice = {0, dice[2], dice[6], dice[3], dice[4], dice[1], dice[5]};\n}\nvoid roll(int order){\nswitch(order){\ncase 1:\nrollEast();\nbreak;\ncase 2:\nrollWest();\nbreak;\ncase 3:\nrollNorth();\nbreak;\ncase 4:\nrollSouth();\nbreak;\ndefault:\nbreak;\n}\n}\nvoid solve(){\nfor(int i=0; i<k; i++){\nint my = dy[order[i]];\nint mx = dx[order[i]];\nif(y+my >= n || y+my < 0 || x+mx >= m || x+mx < 0)\ncontinue;\n// 주사"
    },
    {
        "problem_tier": 6,
        "solution_code": "#include <iostream>\n#include <stack>\nusing namespace std;\nint main() {\nint N, B;\ncin >> N >> B;\nstack<char> result;\nwhile (1) {\nif (N < B) {\nresult.push(N);\nbreak;\n}\nresult.push((N % B) >= 10 ? (N % B) + 55 : (N % B));\nN /= B;\n}\nwhile (!result.empty()) {\nif (result.top() < 10) {\ncout << (int)result.top();\n} else {\ncout << (char)result.top();\n}\nresult.pop();\n}\nreturn 0;\n}"
    },
    {
        "problem_tier": 5,
        "solution_code": "#include <iostream>\n#include <string>\nusing namespace std;\nint main() {\nchar chess[8][8];\nint sum = 0;\nfor (int i = 0; i < 8; i++) {\nfor (int j = 0; j < 8; j++) {\ncin >> chess[i][j];\nif (((i%2 == 0 && j%2 == 0) || (i%2 != 0 && j%2 != 0)) && chess[i][j] == 'F') {\nsum++;\n}\n}\n}\ncout << sum;\nreturn 0;\n}"
    },
    {
        "problem_tier": 2,
        "solution_code": "#include<iostream>\nusing namespace std;\nint main() {\ncout << \"고려대학교\" << endl;\nreturn 0;\n}"
    },
    {
        "problem_tier": 14,
        "solution_code": "#include<iostream>\nusing namespace std;\n#define MAX 501\nint arr[MAX][MAX] = {};\nint dp[MAX][MAX] = {};\nbool visited[MAX][MAX] = {0};\nint m, n;\nint y_ar[4] = {1, 0, -1, 0};\nint x_ar[4] = {0, 1, 0, -1};\nint dfs(int cy, int cx){\nif(cy == m && cx == n){\nreturn 1;     }\nif(visited[cy][cx])         return dp[cy][cx];\nvisited[cy][cx] = 1;\nfor(int i=0; i<4; i++){\nint next_y = cy + y_ar[i];\nint next_x = cx + x_ar[i];\nif(next_y > 0 && next_y <= m && next_x > 0 && next_x <= n)\nif(arr[cy][cx] > arr[next_y][next_x])\ndp[cy][cx] += dfs(next_y, next_x);\n}\nreturn dp[cy][cx];\n}\nint main(){\ncin.tie(NULL);\nios::sync_with_stdio(false);\ncin >> m >> n;\nfor(int i=1; i<=m; i++)\nfor(int j=1; j<=n; j++)\ncin >> arr[i][j];\ncout << dfs(1, 1) << '\\n';\nreturn 0;\n}"
    },
    {
        "problem_tier": 9,
        "solution_code": "#include <iostream>\n#include <algorithm>\n#include <vector>\nusing namespace std;\nint N, M;\nvector<int> arr;\nvector<int> ret;\nvector<vector<int>> ans;\nvoid dfs(int cursor) {\nif (ret.size() == M) {\nans.push_back(ret);\nreturn;\n}\nfor (int i = cursor; i < N; ++i) {\nret.push_back(arr[i]);\ndfs(i);\nret.pop_back();\n}\n}\nint main() {\ncin.tie(NULL);\nios::sync_with_stdio(false);\ncin >> N >> M;\narr = vector<int>(N);\nfor (int i = 0; i < N; ++i)\ncin >> arr[i];\nsort(arr.begin(), arr.end());\nint i = 1;\nwhile (true) {\nif (i >= arr.size())\nbreak;\nif (arr[i] == arr[i - 1])\narr.erase(arr.begin() + i);\nelse\n++i;\n}\nN = arr.size();\ndfs(0);\nfor (auto& el : ans) {\nfor (auto& num : el)\ncout << num << \" \";\ncout << \"\\n\";\n}\nreturn 0;\n}"
    },
    {
        "problem_tier": 13,
        "solution_code": "#include <iostream>\n#include <queue>\nusing namespace std;\nint main() {\nint n;\ncin >> n;\npriority_queue<int> pq;\nfor (int i = 0; i < n; i++) {\nint temp;\ncin >> temp;\npq.push(-temp);\n}\nlong long result = 0;\nwhile(pq.size() != 1) {\nint a = -pq.top();\npq.pop();\nint b = -pq.top();\npq.pop();\nresult += (a + b);\npq.push(-(a + b));\n}\ncout << result << endl;\nreturn 0;\n}"
    },
    {
        "problem_tier": 3,
        "solution_code": "#include <iostream>\nusing namespace std;\nint main() {\nint date, carNum, count = 0;\ncin >> date;\nfor (int i = 0; i < 5; i++) {\ncin >> carNum;\nif (carNum == date) {\ncount++;\n}\n}\ncout << count << '\\n';\nreturn 0;\n}"
    },
    {
        "problem_tier": 2,
        "solution_code": "#include<iostream>\n#include<iomanip>\nusing namespace std;\nint main() {\nstring str;\ncin >> str;\ndouble res = 0;\ncout << fixed;\ncout.precision(1);\nif (str[0] == 'A') {\nres += 4.0;\n}\nelse if (str[0] == 'B') {\nres += 3.0;\n}\nelse if (str[0] == 'C') {\nres += 2.0;\n}\nelse if (str[0] == 'D') {\nres += 1.0;\n}\nif (str[1] == '+') {\nres += 0.3;\n}\nelse if (str[1] == '-') {\nres -= 0.3;\n}\ncout << res;\nreturn 0;\n}"
    },
    {
        "problem_tier": 10,
        "solution_code": "#include <iostream>\nusing namespace std;\nint main() {\nint N;\nint A[1001];\nint dp[1001];\nint maxLen = 0;\ncin >> N;\nfor(int i = 0; i < N; i++) {\ncin >> A[i];\n}\nfor(int i = 0; i < N; i++){\ndp[i] = 1;\nfor(int j = 0; j < i; j++){\nif(A[i] < A[j] && dp[i] < dp[j] + 1)\ndp[i] = dp[j] + 1;\n}\nif(maxLen < dp[i])\nmaxLen = dp[i];\n}\ncout << maxLen << endl;\nreturn 0;\n}"
    },
    {
        "problem_tier": 4,
        "solution_code": "#include<iostream>\n#include<vector>\n#include<algorithm>\nusing namespace std;\nint main(void){\nvector<int> vtr(7);\nbool isOdd = false;\nint sum = 0;\nint cnt = 0;\nfor(int i=0;i<7;i++){\ncin>>vtr[i];\nif(vtr[i]%2){\nsum+=vtr[i];\nif(!isOdd) isOdd = true;\n}\nelse{\nvtr[i] = 0;\n}\n}\nif(!isOdd)\ncout<<\"-1\";\nelse{\nsort(vtr.begin(), vtr.end());\nwhile(!vtr[cnt]){\ncnt++;\n}\ncout<<sum<<\"\\n\"<<vtr[cnt];\n}\nreturn 0;\n}"
    },
    {
        "problem_tier": 13,
        "solution_code": "#include <iostream>\n#include <vector>\n#include <algorithm>\nusing namespace std;\nvector<int> home;\nint binarySearch(int n, int c){\nint r = home[n-1];\nint l = 1;\nint ans = 0;\nwhile (l <= r){\nint cnt = 1;\nint mid = (r + l) / 2;\nint start = home[0];\nfor (int i = 1; i < n; i++)\nif (home[i] - start >= mid)\nstart = home[i], cnt++;\nif (cnt >= c)\nans = mid, l = mid + 1;\nelse\nr = mid - 1;\n}\nreturn ans;\n}\nint main(){\nint n, c;\ncin >> n >> c;\nfor (int i = 0; i < n; i++)\ncin >> home[i];\nsort(home.begin(), home.end());\ncout << binarySearch(n, c);\nreturn 0;\n}"
    },
    {
        "problem_tier": 3,
        "solution_code": "#include<iostream>\nusing namespace std;\nint main() {\nint H, M, S, D;\ncin >> H >> M >> S >> D;\nS += D;\nM += S / 60;\nS %= 60;\nH += M / 60;\nM %= 60;\nH %= 24;\ncout << H << \" \" << M << \" \" << S << endl;\nreturn 0;\n}"
    },
    {
        "problem_tier": 7,
        "solution_code": "#include <iostream>\n#include <string>\nusing namespace std;\nvoid recursion(int n, string line) {\nstring bar = \"\";\nfor (int i = 0; i < n; i++) {\nbar += \"____\";\n}\ncout << bar << \"\\\"재귀함수가 뭔가요?\\\"\\n\";\nif (n == 0) {\ncout << bar << \"\\\"재귀함수는 자기 자신을 호출하는 함수라네\\\"\\n\";\ncout << bar << \"라고 답변하였지.\\n\";\nreturn;\n}\ncout << bar << \"\\\"잘 들어보게. 옛날 옛날 한 산 꼭대기에 이세상 모든 지식을 통달한 선인이 있었어.\\n\";\ncout << bar << \"마을 사람들은 모두 그 선인에게 수많은 질문을 했고, 모두 지혜롭게 대답해 주었지.\\n\";\ncout << bar << \"그의 답은 대부분 옳았다고 하네. 그런데 어느 날, 그 선인에게 한 선비가 찾아와서 물었어.\\\"\\n\";\nrecursion(n - 1, bar);\ncout << bar << \"라고 답변하였지.\\n\";\n}\nint main() {\nint n;\ncin >> n;\ncout << \"어느 한 컴퓨터공학과 학생이 유명한 교수님을 찾아가 물었다.\\n\";\nrecursion(n, \"\");\nreturn 0;\n}"
    },
    {
        "problem_tier": 9,
        "solution_code": "#include <iostream>\n#include <string>\n#include <map>\nusing namespace std;\nint main() {\nint t;\ncin >> t;\nwhile(t--) {\nmap<string, int> m;\nint n;\ncin >> n;\nwhile(n--) {\nstring name, tag;\ncin >> name >> tag;\nif(m.find(tag) == m.end())\nm.insert(make_pair(tag, 1));\nelse\nm[tag]++;\n}\nint ans = 1;\nfor(auto i : m)\nans *= (i.second + 1);\ncout << ans - 1 << \"\\n\";\n}\nreturn 0;\n}"
    },
    {
        "problem_tier": 2,
        "solution_code": "#include <iostream>\n#include <string>\nusing namespace std;\nint main() {\nstring str;\ncin >> str;\nfor (int i = 0; i < str.length(); i++) {\nif (str[i] >= 65 && str[i] <= 90) {\nstr[i] += 32;\n}\nelse {\nstr[i] -= 32;\n}\n}\ncout << str;\nreturn 0;\n}"
    },
    {
        "problem_tier": 4,
        "solution_code": "#include <iostream>\nusing namespace std;\nint main() {\nint t;\ncin >> t;\nwhile (t--) {\nint c;\ncin >> c;\nint m[4] = {25, 10, 5, 1};\nfor (int i = 0; i < 4; i++) {\ncout << c / m[i] << \" \";\nc %= m[i];\n}\ncout << '\\n';\n}\nreturn 0;\n}"
    },
    {
        "problem_tier": 8,
        "solution_code": "#include <iostream>\n#include <vector>\n#include <algorithm>\nusing namespace std;\nint main() {\nios::sync_with_stdio(false);\nint n, m;\ncin >> n >> m;\nint answer = 0;\nvector<int> a(n);\nfor (int i = 0; i < n; i++) {\ncin >> a[i];\n}\nint left = 0, right = 0, sum = 0;\nwhile (left <= right && right <= n) {\nif (sum >= m) {\nif (sum == m)\nanswer++;\nsum -= a[left++];\n}\nelse {\nif (right == n)\nbreak;\nsum += a[right++];\n}\n}\ncout << answer << endl;\nreturn 0;\n}"
    },
    {
        "problem_tier": 4,
        "solution_code": "#include <iostream>\nusing namespace std;\nint main() {\nint n;\ncin >> n;\nfor (int i = 1; i <= n; i++) {\nfor (int j = 0; j < n - i; j++) {\ncout << \" \";\n}\nfor (int j = 0; j < i; j++) {\ncout << \"*\";\n}\ncout << endl;\n}\nfor (int i = 1; i < n; i++) {\nfor (int j = 0; j < i; j++) {\ncout << \" \";\n}\nfor (int j = 0; j < n - i; j++) {\ncout << \"*\";\n}\ncout << endl;\n}\nreturn 0;\n}"
    },
    {
        "problem_tier": 13,
        "solution_code": "#include <iostream>\n#include <vector>\n#include <algorithm>\n#define ll long long\nusing namespace std;\nll twoPointer() {\nll ans = n + 1;\nll sum = a[0];\nll l = 0, r = 0;\nwhile (l <= r && r < n) {\nif (sum < s) {\nsum += a[++r];\n}\nelse if (sum == s) {\nans = min(ans, r - l + 1);\nsum += a[++r];\n}\nelse {\nans = min(ans, r - l + 1);\nsum -= a[l++];\n}\n}\nif (ans > n) return 0;\nreturn ans;\n}\nint main() {\ncin >> n >> s;\nvector<ll> a(n);\nfor (int i = 0; i < n; i++) cin >> a[i];\ncout << twoPointer();\nreturn 0;\n}"
    },
    {
        "problem_tier": 6,
        "solution_code": "#include <iostream>\n#include <string>\nusing namespace std;\nint main() {\nint n;\ncin >> n;\nstring str[50];\nfor (int i = 0; i < n; i++) {\ncin >> str[i];\n}\nchar c;\nfor (int i = 0; i < str[0].length(); i++) {\nc = str[0][i];\nfor (int j = 0; j < n; j++) {\nif (c != str[j][i]) {\nc = '?';\nbreak;\n}\n}\ncout << c;\n}\n}"
    },
    {
        "problem_tier": 10,
        "solution_code": "#include <iostream>\n#include <algorithm>\n#include <cmath>\nusing namespace std;\nint dp[100001];\nint main() {\nios_base::sync_with_stdio(false);\ncin.tie(NULL);\ncout.tie(NULL);\nint n;\ncin >> n;\nfor (int i = 1; i <= n; i++) {\ndp[i] = 123456789;\n}\nfor (int i = 1; i * i <= n; i++) {\nfor (int j = i * i; j <= n; j++) {\ndp[j] = min(dp[j], dp[j - i * i] + 1);\n}\n}\ncout << dp[n];\nreturn 0;\n}"
    },
    {
        "problem_tier": 3,
        "solution_code": "#include<iostream>\nusing namespace std;\nint main() {\nint A, B, C;\ncin >> A >> B >> C;\nif ((A + B + C) != 180)\ncout << \"Error\\n\";\nelse if (A == B && B == C)\ncout << \"Equilateral\\n\";\nelse if (A == B || A == C || B == C)\ncout << \"Isosceles\\n\";\nelse\ncout << \"Scalene\\n\";\nreturn 0;\n}"
    },
    {
        "problem_tier": 10,
        "solution_code": "#include <iostream>\n#define MOD 10007\nusing namespace std;\nint dp[1001][1001];\nint binomialCoefficient(int n, int k) {\nfor (int i = 0; i <= n; i++) {\ndp[i][0] = 1;\ndp[i][i] = 1;\n}\nfor (int i = 2; i <= n; i++) {\nfor (int j = 1; j < i; j++) {\ndp[i][j] = (dp[i-1][j-1] + dp[i-1][j]) % MOD;\n}\n}\nreturn dp[n][k];\n}\nint main() {\nint n, k;\ncin >> n >> k;\ncout << binomialCoefficient(n, k) << endl;\nreturn 0;\n}"
    },
    {
        "problem_tier": 2,
        "solution_code": "#include<iostream>\nusing namespace std;\nint main() {\ncout << \"       _.-;;-._\" << endl;\ncout << \"      '-..-'|   ||   |\" << endl;\ncout << \"      '-..-'|_.-;;-._|\" << endl;\ncout << \"      '-..-'|   ||   |\" << endl;\ncout << \"      '-..-'|_.-''-._|\" << endl;\nreturn 0;\n}"
    },
    {
        "problem_tier": 2,
        "solution_code": "#include<iostream>\n#include<cstring>\nchar* max(char* a, char* b){\nfor(int i=0; i<strlen(a); i++){\nif(a[i] < b[i])             return b;         if(a[i] > b[i])             return a;     }\nreturn a; }\nvoid subtract(char* a, char* b){\nfor(int i=0; i<strlen(b); i++){         a[i] = a[i] - b[i] + '0';         if(a[i]<'0'){             a[i] += 10;             a[i-1]--;         }\n}\nfor(int i=strlen(b)-1; i>=0; i--){         if(a[i]<'0'){             a[i] += 10;             a[i-1]--;         }\n}\n}\nvoid dividesubtract(char* a, char* b, char* r, int index){\nr[index] = '0';     while(a[index-1] > '0' || max(a+index, b) == a+index){         subtract(a+index, b);         ++r[index];     }\n}\nvoid devide(char* a, char* b, char* r){\nint index=0;\nint digit = strlen(a) - strlen(b);     while(index <= digit)         dividesubtract(a, b, r, index++);     r[index] = '\\0'; }\nint main(){\nchar a[1001];\nchar b[1001];\nchar r[1001];     int ri=0, ai=0;\nstd::cin >> a >> b;     devide(a, b, r);\nwhile(r[ri] == '0')\nri++;     while(a[ai] == '0')\nai++;\nif(r[0] == '\\0'){         r[0] = '0';\nr[1] = '\\0';\n}\nif(a[ai] == '\\0')         ai--;\nif(r[ri] == '\\0')         ri--;\nstd::cout << r+ri << std::endl;     std::cout << a+ai << std::endl;\nreturn 0;\n}"
    },
    {
        "problem_tier": 13,
        "solution_code": "#include <iostream>\nusing namespace std;\nint board[9][9];\nbool row[9][10], col[9][10], square[3][3][10];\nvoid input() {\nfor (int i = 0; i < 9; i++) {\nfor (int j = 0; j < 9; j++) {\ncin >> board[i][j];\nif (board[i][j] != 0) {\nrow[i][board[i][j]] = true;\ncol[j][board[i][j]] = true;\nsquare[i/3][j/3][board[i][j]] = true;\n}\n}\n}\n}\nvoid printBoard() {\nfor (int i = 0; i < 9; i++) {\nfor (int j = 0; j < 9; j++) {\ncout << board[i][j] << \" \";\n}\ncout << endl;\n}\n}\nbool solveSudoku(int x, int y) {\nif (x == 8 && y == 9) {\nprintBoard();\nreturn true;\n}\nif (y == 9) {\nx++;\ny = 0;\n}\nif (board[x][y] == 0) {\nfor (int num = 1; num <= 9; num++) {\nif (!row[x][num] && !col[y][num] && !square[x/3][y/3][num]) {\nboard[x][y] = num;\nrow[x][num] = true;\ncol[y][num] = true;\nsquare[x/3][y/3][num] = true;\nif (solveSudoku(x, y+1))\nreturn true;\nboard[x][y] = 0;\nrow[x][num] = false;\ncol[y][num] = false;\nsquare[x/3][y/3][num] = false;\n}\n}\n} else {\nif (solveSudoku(x, y+1))\nreturn true;\n}\nreturn false;\n}\nint main() {\nios::sync_with_stdio(false);\ncin.tie(NULL);\ninput();\nsolveSudoku(0, 0);\nreturn 0;\n}"
    },
    {
        "problem_tier": 4,
        "solution_code": "#include <iostream>\nusing namespace std;\nint main() {\nint A, I;\ncin >> A >> I;\nI -= 0.99;\nint mel = A * I;\ncout << mel + 1;\nreturn 0;\n}"
    },
    {
        "problem_tier": 2,
        "solution_code": "#include<iostream>\nusing namespace std;\nint main() {\nint a, b;\nwhile(1) {\ncin >> a >> b;\nif(a == 0 && b == 0) {\nbreak;\n}\nif(a > b) {\ncout << \"Yes\" << endl;\n} else {\ncout << \"No\" << endl;\n}\n}\nreturn 0;\n}"
    },
    {
        "problem_tier": 5,
        "solution_code": "#include <iostream>\n#include <string>\n#include <cmath>\nusing namespace std;\nint main() {\nios_base::sync_with_stdio(0);\ncin.tie(0);\ncout.tie(0);\nstring n;\nint b, res = 0, temp = 1;\ncin >> n >> b;\nfor (int i = n.size() - 1; i >= 0; --i, temp *= b) {\nif (n[i] > '9') {\nres += (n[i] - 'A' + 10) * temp;\n} else {\nres += (n[i] - '0') * temp;\n}\n}\ncout << res << \"\\n\";\nreturn 0;\n}"
    },
    {
        "problem_tier": 5,
        "solution_code": "#include <iostream>\n#include <algorithm>\nusing namespace std;\nint main() {\nint N, K;\ncin >> N >> K;\nint arr[1000];\nfor (int i = 0; i < N; i++) {\ncin >> arr[i];\n}\nsort(arr, arr + N);\ncout << arr[N - K];\nreturn 0;\n}"
    },
    {
        "problem_tier": 10,
        "solution_code": "#include<iostream>\n#include<algorithm>\nusing namespace std;\nint main() {\nint N;\ncin >> N;\nint arr[1001];\nfor (int i = 1; i <= N; i++)\ncin >> arr[i];\nint dp[1001];\nfor (int i = 1; i <= N; i++)\ndp[i] = arr[i];\nfor (int i = 1; i <= N; i++){\nfor (int j = 1; j < i; j++){\nif (arr[i] > arr[j]){\ndp[i] = max(dp[i], dp[j] + arr[i]);\n}\n}\n}\nsort(dp, dp + N + 1);\ncout << dp[N] << endl;\nreturn 0;\n}"
    },
    {
        "problem_tier": 12,
        "solution_code": "#include <iostream>\n#include <cmath>\n#include <vector>\nusing namespace std;\nvector<bool> remote(10);\nint check(int n){\nif (n == 0){\nif (remote[0]){\nreturn 0;\n}\nelse{\nreturn 1;\n}\n}\nint len = 0;\nwhile (n > 0){\nif (remote[n % 10]){\nreturn 0;\n}\nn = n / 10;\nlen += 1;\n}\nreturn len;\n}\nint main(){\nint N, broke = 0;\ncin >> N >> broke;\nfor (int i = 0; i < broke; i++){\nint x;\ncin >> x;\nremote[x] = true;\n}\nint count = abs(N - 100);\nfor (int i = 0; i <= 1000000; i++){\nint c = i;\nint len = check(c);\nif (len > 0){\nint press = abs(c - N);\nif (count > press + len){\ncount = press + len;\n}\n}\n}\ncout << count;\nreturn 0;\n}"
    },
    {
        "problem_tier": 12,
        "solution_code": "#include <iostream>\n#include <vector>\nusing namespace std;\nint parent[1000001];\nint find(int x) {\nif (parent[x] == x)\nreturn x;\nparent[x] = find(parent[x]);\nreturn parent[x];\n}\nvoid merge(int x, int y) {\nx = find(x);\ny = find(y);\nif (x == y)\nreturn;\nparent[y] = x;\n}\nint main() {\nint n, m;\ncin >> n >> m;\nfor (int i = 0; i <= n; i++)\nparent[i] = i;\nfor (int i = 0; i < m; i++) {\nint op, a, b;\ncin >> op >> a >> b;\nif (op == 0) {\nmerge(a, b);\n} else {\nif (find(a) == find(b))\ncout << \"YES\" << endl;\nelse\ncout << \"NO\" << endl;\n}\n}\nreturn 0;\n}"
    },
    {
        "problem_tier": 4,
        "solution_code": "#include<iostream>\nusing namespace std;\nint main() {\nint t;\nint btn[] = {300, 60, 10};\nint cnt[3] = {0, };\ncin >> t;\nif (t % 10 == 0) {\nfor (int i = 0; i < 3; i++) {\nif (t >= btn[i]) {\nt -= btn[i];\ncnt[i]++;\ni--;\n}\nif (t == 0)\nbreak;\n}\ncout << cnt[0] << \" \" << cnt[1] << \" \" << cnt[2] << endl;\n}\nelse\ncout << \"-1\" << endl;\nreturn 0;\n}"
    },
    {
        "problem_tier": 12,
        "solution_code": "#include <iostream>\n#include <vector>\n#include <queue>\n#define MAX 1001\n#define INF 2147000000\nusing namespace std;\nvector<pair<int,int>> g[MAX]; priority_queue<pair<int,int>> pq; vector<int> dist(MAX,INF);\nint src, dst;\nvoid dijkstra(){\npq.push({0,src});\ndist[src]=0;\nwhile(!pq.empty()){\nint cur=pq.top().second;\nint cost=-pq.top().first;\npq.pop();\nif(dist[cur]<cost)\ncontinue;\nfor(int i=0;i<g[cur].size();i++){\nint next=g[cur][i].first;\nint nCost=g[cur][i].second+cost;\nif(dist[next]>nCost){\ndist[next]=nCost;\npq.push({-nCost,next});\n}\n}\n}\n}\nint main(){\nios_base::sync_with_stdio(0);\ncin.tie(NULL);\nint N,M,a,b,c;\ncin>>N>>M;\nwhile(M--){\ncin>>a>>b>>c;\ng[a].push_back({b,c});\n}\ncin>>src>>dst;\ndijkstra();\ncout<<dist[dst];\n}"
    },
    {
        "problem_tier": 14,
        "solution_code": "#include <iostream>\n#include <vector>\n#include <queue>\nusing namespace std;\nvector<int> compare[32001];\nint inDegree[32001];\nvoid topologySort(int n) {\nint result[32001];\nqueue<int> q;\nfor(int i=1; i<=n; i++){\nif(inDegree[i] == 0)\nq.push(i);\n}\nfor(int i=1; i<=n; i++){\nif(q.empty()){\nreturn;\n}\nint x = q.front();\nq.pop();\nresult[i] = x;\nfor(int j=0; j<compare[x].size(); j++){\nint y = compare[x][j];\nif(--inDegree[y] == 0)\nq.push(y);\n}\n}\nfor(int i=1; i<=n; i++){\nprintf(\"%d \", result[i]);\n}\n}\nint main(){\nint n;     int m;     cin >> n >> m;\nfor(int i=0; i<m; i++){\nint num1, num2;\nscanf(\"%d %d\", &num1, &num2);\ncompare[num1].push_back(num2);\ninDegree[num2]++;\n}\ntopologySort(n);\nreturn 0;\n}"
    },
    {
        "problem_tier": 8,
        "solution_code": "#include<iostream>\n#include<vector>\n#include<string>\nusing namespace std;\nvector<string> str[501][26][26];\nint main(void) {\nint n, m, cnt = 0;\nios_base::sync_with_stdio(false);\ncin.tie(NULL);\ncin >> n >> m;\nfor(int i = 0; i < n; i++) {\nstring temp;\ncin >> temp;\nint len = temp.length();\nint first = temp.front() - 97;\nint last = temp.back() - 97;\nstr[len][first][last].push_back(temp);\n}\nfor(int i = 0; i < m; i++) {\nstring temp;\ncin >> temp;\nint len = temp.length();\nint first = temp.front() - 97;\nint last = temp.back() - 97;\nfor(int j = 0; j < str[len][first][last].size(); j++) {\nif(temp.compare(str[len][first][last][j]) == 0) {\ncnt++;\n}\n}\n}\ncout << cnt;\nreturn 0;\n}"
    },
    {
        "problem_tier": 14,
        "solution_code": "#include <iostream>\n#include <queue>\n#include <vector>\nusing namespace std;\nint arr[21][21];\nint n;\nint ans = 0;\nstruct shark {\nint y;\nint x;\nint size;\nint eat;\n};\nint dist[21][21];\nint dy[4] = {1, -1, 0, 0};\nint dx[4] = {0, 0, -1, 1};\nbool find_prey(shark& s) {\nqueue<pair<int, int>> q;\nfor (int i = 0; i < 21; i++) {\nfor (int j = 0; j < 21; j++) {\ndist[i][j] = -1;\n}\n}\nq.push({s.y, s.x});\ndist[s.y][s.x] = 0;\nwhile (!q.empty()) {\nint y = q.front().first;\nint x = q.front().second;\nq.pop();\nif (arr[y][x] != 9 && arr[y][x] != 0 && arr[y][x] < s.size) {\ncontinue;\n}\nfor (int i = 0; i < 4; i++) {\nint ny = y + dy[i];\nint nx = x + dx[i];\nif (ny >= 0 && ny < n && nx >= 0 && nx < n && dist[ny][nx] == -1 && arr[ny][nx] <= s.size) {\ndist[ny][nx] = dist[y][x] + 1;\nq.push({ny, nx});\n}\n}\n}\nint my = 100;\nint mx = 100;\nint m_dist = 401;\nfor (int i = n - 1; i >= 0; i--) {\nfor (int j = n - 1; j >= 0; j--) {\nif (arr[i][j] != 0 && arr[i][j] != 9 && arr[i][j] < s.size && dist[i][j] != -1 && dist[i][j] <= m_dist) {\nm_dist = dist[i][j];\nmy = i;\nmx = j;\n}\n}\n}\nif (m_dist == 401) {\nreturn false;\n} else {\narr[s.y][s.x] = 0;\ns.y = my;\ns.x = mx;\ns.eat++;\nif (s.eat == s.size) {\ns.eat = 0;\ns.size++;\n}\narr[my][mx] = 9;\nans += dist[my][mx];\nreturn true;\n}\n}\nint main() {\nshark s;\ncin >> n;\nfor (int i = 0; i < n; i++) {\nfor (int j = 0; j < n; j++) {\ncin >> arr[i][j];\nif (arr[i][j] == 9) {\ns.y = i;\ns.x = j;\ns.size = 2;\ns.eat = 0;\n}\n}\n}\nwhile (true) {\nif (find_prey(s)) {\ncontinue;\n} else {\nbreak;\n}\n}\ncout << ans << endl;\nreturn 0;\n}"
    },
    {
        "problem_tier": 4,
        "solution_code": "#include <iostream>\nusing namespace std;\nint main() {\nint total = 0;\nint max = 0;\nfor (int i = 0; i < 4; i++) {\nint out, in;\ncin >> out >> in;\ntotal = total - out + in;\nif (total > max) {\nmax = total;\n}\n}\ncout << max << endl;\nreturn 0;\n}"
    },
    {
        "problem_tier": 10,
        "solution_code": "#include<iostream>\n#include<queue>\nusing namespace std;\nconst int MAX = 100;\nint n, a, b;\nint map[MAX][MAX] = { 0, };\nbool visited[MAX] = { 0, };\nint depth[MAX] = { 0, };\nqueue<int> q;\nvoid BFS(int v) {\nq.push(v);\nvisited[v] = true;\nwhile (!q.empty()) {\nv = q.front();\nq.pop();\nfor (int w = 1; w <= n; w++) {\nif (map[v][w] == 1 && visited[w] == 0) {\nq.push(w);\nvisited[w] = true;\ndepth[w] = depth[v] + 1;\n}\n}\n}\n}\nint main() {\ncin >> n;\ncin >> a >> b;\nint m;\ncin >> m;\nwhile (m--) {\nint x, y;\ncin >> x >> y;\nmap[x][y] = 1;\nmap[y][x] = 1;\n}\nBFS(a);\nif (depth[b] == 0)\ncout << -1;\nelse\ncout << depth[b];\nreturn 0;\n}"
    },
    {
        "problem_tier": 7,
        "solution_code": "#include <iostream>\nusing namespace std;\nint main() {\nint X;\ncin >> X;\nint ans = 0;\nwhile (X > 0) {\nif (X % 2 == 1) {\nans++;\n}\nX /= 2;\n}\ncout << ans;\nreturn 0;\n}"
    },
    {
        "problem_tier": 9,
        "solution_code": "#include <iostream>\n#include <vector>\nusing namespace std;\nint main() {\nint N;\ncin >> N;\nvector<long long> distance(N-1);\nfor (int i = 0; i < N-1; i++) {\ncin >> distance[i];\n}\nvector<long long> price(N);\nfor (int i = 0; i < N; i++) {\ncin >> price[i];\n}\nlong long answer = 0;\nlong long lowest = price[0];\nlong long partOfDistance = distance[0];\nfor (int i = 1; i < N-1; i++) {\nif (price[i] < lowest) {\nanswer += lowest * partOfDistance;\nlowest = price[i];\npartOfDistance = distance[i];\n}\nelse {\npartOfDistance += distance[i];\n}\n}\nanswer += lowest * partOfDistance;\ncout << answer;\nreturn 0;\n}"
    },
    {
        "problem_tier": 13,
        "solution_code": "#include<iostream>\n#include<stack>\n#include<vector>\nusing namespace std;\nint main() {\nint n;\ncin >> n;\nvector<int> arr(n);\nvector<int> ans(n, -1);\nstack<int> st;\nfor (int i = 0; i < n; i++) {\ncin >> arr[i];\n}\nfor (int i = 0; i < n; i++) {\nwhile (!st.empty() && arr[st.top()] < arr[i]) {\nans[st.top()] = arr[i];\nst.pop();\n}\nst.push(i);\n}\nfor (int i = 0; i < n; i++) {\ncout << ans[i] << \" \";\n}\nreturn 0;\n}"
    },
    {
        "problem_tier": 13,
        "solution_code": "#include<iostream>\n#include<algorithm>\n#include<vector>\nusing namespace std;\n#define INF 1000000000\nint main(){\nint N, M;\ncin >> N;\ncin >> M;\nvector<vector<int>> Graph(N+1, vector<int>(N+1, INF));\nint CityA, CityB, Cost;\nfor(int i=1; i<=N; ++i){\nGraph[i][i] = 0;\n}\nfor(int i=0; i<M; ++i){\ncin >> CityA >> CityB >> Cost;\nif(Graph[CityA][CityB] > Cost)\nGraph[CityA][CityB] = Cost;\n}\nfor(int k=1; k<=N; ++k){\nfor(int i=1; i<=N; ++i){\nfor(int j=1; j<=N; ++j){\nGraph[i][j] = min(Graph[i][j], Graph[i][k]+Graph[k][j]);\n}\n}\n}\nfor(int i=1; i<=N; ++i){\nfor(int j=1; j<=N; ++j){\nif(Graph[i][j] == INF){\ncout << 0 << \" \";\n}\nelse{\ncout << Graph[i][j] << \" \";\n}\n}\ncout << '\\n';\n}\nreturn 0;\n}"
    },
    {
        "problem_tier": 1,
        "solution_code": "#include<iostream>\nusing namespace std;\nint main() {\ncout << \"문제의 정답\\n\";\nreturn 0;\n}"
    },
    {
        "problem_tier": 11,
        "solution_code": "#include <iostream>\n#include <vector>\n#include <algorithm>\n#include <queue>\nusing namespace std;\nint M, N, K;\nint arr[100][100];\nint visited[100][100];\nint dy[4] = {-1, 0, 1, 0};\nint dx[4] = {0, 1, 0, -1};\nvector<int> ret;\nint DFS(int y, int x) {\nvisited[y][x] = 1;\nint ret = 1;\nfor (int i = 0; i < 4; i++) {\nint ny = y + dy[i];\nint nx = x + dx[i];\nif (ny < 0 || nx < 0 || ny >= M || nx >= N || visited[ny][nx] == 1)\ncontinue;\nif (arr[ny][nx] == 1)\ncontinue;\nret += DFS(ny, nx);\n}\nreturn ret;\n}\nint main() {\nios::sync_with_stdio(0);\ncin.tie(0);\ncin >> M >> N >> K;\nfor (int i = 0; i < K; i++) {\nint x1, y1, x2, y2;\ncin >> x1 >> y1 >> x2 >> y2;\nfor (int x = x1; x < x2; x++) {\nfor (int y = y1; y < y2; y++) {\narr[y][x] = 1;\n}\n}\n}\nfor (int i = 0; i < M; i++) {\nfor (int j = 0; j < N; j++) {\nif (arr[i][j] != 1 && visited[i][j] == 0) {\nret.push_back(DFS(i, j));\n}\n}\n}\nsort(ret.begin(), ret.end());\ncout << ret.size() << \"\\n\";\nfor (auto i : ret)\ncout << i << \" \";\nreturn 0;\n}"
    },
    {
        "problem_tier": 9,
        "solution_code": "#include<iostream>\n#include<algorithm>\nusing namespace std;\nint N, M;\nbool visited[8];\nint arr[8];\nint getnum[8];\nvoid dfs(int count){\nif(count == M){\nfor(int i = 0; i < M; i++){\ncout << arr[i] << \" \";\n}\ncout << \"\\n\";\nreturn;\n}\nfor(int i = 0; i < N; i++){\nif(visited[i])\ncontinue;\nvisited[i] = true;\narr[count] = getnum[i];\ndfs(count + 1);\nvisited[i] = false;\n}\n}\nint main(){\ncin >> N >> M;\nfor(int i = 0; i < N; i++){\ncin >> getnum[i];\n}\nsort(getnum, getnum+N);\ndfs(0);\nreturn 0;\n}"
    },
    {
        "problem_tier": 5,
        "solution_code": "#include <iostream>\nusing namespace std;\nint main() {\nint t;\ncin >> t;\nwhile (t--) {\nint a, b, mul;\ncin >> a >> b;\nmul = 1;\nb = !(b % 4) ? 4 : b % 4;\nwhile (b--)\nmul *= a;\ncout << (mul % 10 ? mul % 10 : 10) << \"\\n\";\n}\nreturn 0;\n}"
    },
    {
        "problem_tier": 13,
        "solution_code": "#include <iostream>\n#include <vector>\n#include <algorithm>\nusing namespace std;\ntypedef pair<int, pair<int, int>> T;\nint parent[10000 + 1];\nint ans;\nint findParent(int x) {\nif (parent[x] == x)\nreturn x;\nreturn parent[x] = findParent(parent[x]);\n}\nvoid unionParent(int a, int b) {\na = findParent(a);\nb = findParent(b);\nparent[b] = a;\n}\nint main(void) {\nios::sync_with_stdio(false);\ncin.tie(NULL);\ncout.tie(NULL);\nint V, E;\ncin >> V >> E;\nvector<T> v;\nfor (int i = 0; i < E; i++) {\nint a, b, c;\ncin >> a >> b >> c;\nv.push_back({ c, { a, b } });\n}\nsort(v.begin(), v.end());\nfor (int i = 1; i <= V; i++)\nparent[i] = i;\nint cnt = 0;\nfor (int i = 0; i < v.size(); i++) {\nT curEdge = v[i];\nint cost = curEdge.first;\nint now = curEdge.second.first;\nint next = curEdge.second.second;\nif (findParent(now) == findParent(next))\ncontinue;\nunionParent(now, next);\nans += cost;\nif (++cnt == V - 1)\nbreak;\n}\ncout << ans << '\\n';\nreturn 0;\n}"
    },
    {
        "problem_tier": 10,
        "solution_code": "#include<iostream>\nusing namespace std;\n#define MAX 2200\nint arr[MAX][MAX];\nint result[3];\nvoid DivideAndConquer(int x, int y, int size){\nint value = arr[y][x];\nfor(int i=y; i<y+size; ++i){\nfor(int j=x; j<x+size; ++j){\nif(value != arr[i][j]){\nint DivideSize = size/3;\nDivideAndConquer(x, y, DivideSize);\nDivideAndConquer(x+DivideSize, y, DivideSize);\nDivideAndConquer(x, y+DivideSize, DivideSize);\nDivideAndConquer(x+DivideSize, y+DivideSize, DivideSize);\nDivideAndConquer(x+(DivideSize*2), y, DivideSize);\nDivideAndConquer(x, y+(DivideSize*2), DivideSize);\nDivideAndConquer(x+(DivideSize*2), y+((DivideSize)*2), DivideSize);\nDivideAndConquer(x+(DivideSize*2), y+DivideSize, DivideSize);\nDivideAndConquer(x+DivideSize, y+(DivideSize*2), DivideSize);\nreturn;\n}\n}\n}\nif(value == -1){\n++result[0];\n}else if(value == 1){\n++result[2];\n}else if(value == 0){\n++result[1];\n}\n}\nint main(void){\nint n;\ncin >> n;\nfor(int i=0; i<n; ++i){\nfor(int j=0; j<n; ++j){\ncin >> arr[i][j];\n}\n}\nDivideAndConquer(0, 0, n);\nfor(int i=0; i<3; ++i){\ncout << result[i] << endl;\n}\nreturn 0;\n}"
    },
    {
        "problem_tier": 7,
        "solution_code": "#include <iostream>\nusing namespace std;\nint main() {\nios::sync_with_stdio(0);\ncin.tie(0);\nlong long S;\ncin >> S;\nlong long sum = 0;\nint num = 1;\nint cnt = 0;\nwhile (true) {\nsum += num;\ncnt++;\nif (sum > S) {\ncnt--;\nbreak;\n}\nnum++;\n}\ncout << cnt << endl;\nreturn 0;\n}"
    },
    {
        "problem_tier": 11,
        "solution_code": "#include<iostream>\n#define MAX 1000\n#define MOD 10007\nusing namespace std;\nint dp[MAX+1][10];\nint main(){\nios_base::sync_with_stdio(false);\ncin.tie(nullptr);\ncout.tie(nullptr);\nint n;\nint res = 0;\nfor(int i=0;i<10;++i){\ndp[1][i] = 1;\n}\ncin >> n;\nfor(int i=2;i<=n;++i){\nfor(int j=0;j<10;++j){\nfor(int k=0;k<=j;++k){\ndp[i][j] += dp[i-1][k];\nif(dp[i][j] >= MOD) dp[i][j] %= MOD;\n}\n}\n}\nfor(int i=0;i<10;++i){\nres = (res + dp[n][i]) % MOD;\n}\ncout << res << \"\\n\";\nreturn 0;\n}"
    },
    {
        "problem_tier": 13,
        "solution_code": "#include <iostream>\n#include <vector>\n#include <algorithm>\n#include <queue>\nusing namespace std;\nint map[101][101] = {0,};\nint main() {\nint N, K;\ncin >> N >> K;\nfor (int i = 0; i < K; i++) {\nint x, y;\ncin >> x >> y;\nmap[x][y] = 1;\n}\nint L;\ncin >> L;\nqueue<pair<int, char>> qDir;\nfor (int i = 0; i < L; i++) {\nint time;\nchar dir;\ncin >> time >> dir;\nqDir.push(make_pair(time, dir));\n}\nint dx[4] = {0, 1, 0, -1};\nint dy[4] = {-1, 0, 1, 0};\nint dirIdx = 1;\nint ans = 0;\nint x = 1;\nint y = 1;\nint cnt = 1;\nqueue<pair<int, int>> qSnake;\nqSnake.push(make_pair(1, 1));     map[1][1] = 2;\nwhile (1) {\nif (x > N || y > N || x < 1 || y < 1)\nbreak;\nif (map[x][y] == 2)\nbreak;\nif (!qDir.empty()) {\nif (cnt == qDir.front().first) {\nif (qDir.front().second == 'L')                     dirIdx = (dirIdx + 1) % 4;\nelse if (qDir.front().second == 'D')                     dirIdx = (dirIdx + 3) % 4;\nqDir.pop();\n}\n}\nif (map[x][y] == 0) {\nqSnake.push(make_pair(x, y));\nmap[qSnake.front().first][qSnake.front().second] = 0;\nqSnake.pop();\n} else if (map[x][y] == 1) {\nqSnake.push(make_pair(x, y));\n}\nmap[x][y] = 2;\nx = x + dx[dirIdx];\ny = y + dy[dirIdx];\ncnt++;\n}\ncout << cnt << endl;\nreturn 0;\n}"
    },
    {
        "problem_tier": 5,
        "solution_code": "#include <iostream>\n#include <vector>\nusing namespace std;\nint main() {\nios::sync_with_stdio(false);\ncin.tie(NULL);\nint N;\ncin >> N;\nvector<int> V(N);\nfor(int i = 0; i < N; i++) {\ncin >> V[i];\n}\nint B, C;\ncin >> B >> C;\nlong long sum = 0;\nfor(int i = 0; i < N; i++) {\nif(V[i] <= B) {\nsum++;\n}\nelse {\nsum += (V[i] - B) / C + 1;\nif((V[i] - B) % C != 0)\nsum++;\n}\n}\ncout << sum;\nreturn 0;\n}"
    },
    {
        "problem_tier": 13,
        "solution_code": "#include <iostream>\n#include <algorithm>\nusing namespace std;\nint alphabets[26] = {0,};\nchar graph[21][21] = {0,};\nint r, c;\nint result = 0;\nint dy[4] = {0,0,-1,1};\nint dx[4] = {-1,1,0,0};\nvoid dfs(int y, int x, int cnt){\nif(result < cnt){\nresult = cnt;\n}\nfor(int i=0; i<4; i++){\nint py = y + dy[i];\nint px = x + dx[i];\nif(0 <= py && py < r && 0 <= px && px < c && alphabets[graph[py][px]-65]==0){\nalphabets[graph[py][px]-65] = 1;\ndfs(py, px, cnt+1);\nalphabets[graph[py][px]-65] = 0;\n}\n}\n}\nint main(){\ncin >> r >> c;\nfor(int i=0; i<r; i++){\nfor(int j=0; j<c; j++){\ncin >> graph[i][j];\n}\n}\nalphabets[graph[0][0]-65] = 1;\ndfs(0, 0, 1);\ncout << result;\nreturn 0;\n}"
    },
    {
        "problem_tier": 4,
        "solution_code": "#include<iostream>\nusing namespace std;\nint main() {\nint T = 3;\nwhile (T--) {\nint flag = 0;\nfor (int i = 0; i < 4; i++) {\nint x;\ncin >> x;\nif (x) {\nflag++;\n}\n}\nswitch (flag) {\ncase 0:\ncout << \"D\\n\";\nbreak;\ncase 1:\ncout << \"C\\n\";\nbreak;\ncase 2:\ncout << \"B\\n\";\nbreak;\ncase 3:\ncout << \"A\\n\";\nbreak;\ncase 4:\ncout << \"E\\n\";\nbreak;\n}\n}\nreturn 0;\n}"
    },
    {
        "problem_tier": 7,
        "solution_code": "#include<iostream>\nusing namespace std;\nint main() {\nint E, S, M;\nint year = 1;\ncin >> E >> S >> M;\nwhile (1) {\nif ((year - E) % 15 == 0 && (year - S) % 28 == 0 && (year - M) % 19 == 0) {\ncout << year << endl;\nbreak;\n}\nelse\nyear++;\n}\nreturn 0;\n}"
    },
    {
        "problem_tier": 13,
        "solution_code": "#include <iostream>\n#include <vector>\nusing namespace std;\nint main() {\nint N;\ncin >> N;\nvector<int> arr(N);\nfor(int i = 0; i < N; i++){\ncin >> arr[i];\n}\nvector<int> dp1(N, 1);\nvector<int> dp2(N, 1);\nfor(int i = 0; i < N; i++){\nfor(int j = 0; j < i; j++){\nif(arr[j] < arr[i]){\ndp1[i] = max(dp1[i], dp1[j]+1);\n}\n}\n}\nfor(int i = N-1; i >= 0; i--){\nfor(int j = N-1; j > i; j--){\nif(arr[j] < arr[i]){\ndp2[i] = max(dp2[i], dp2[j]+1);\n}\n}\n}\nint answer = 0;\nfor(int i = 0; i < N; i++){\nanswer = max(answer, dp1[i]+dp2[i]-1);\n}\ncout << answer << endl;\nreturn 0;\n}"
    },
    {
        "problem_tier": 4,
        "solution_code": "#include<iostream>\nusing namespace std;\nint main() {\nint N;\ncin >> N;\nfor (int i = 0; i < N; i++) {\nfor (int j = 0; j <= i; j++) {\ncout << \"*\";\n}\ncout << \"\\n\";\n}\nfor (int i = N - 1; i > 0; i--) {\nfor (int j = 0; j < i; j++) {\ncout << \"*\";\n}\ncout << \"\\n\";\n}\nreturn 0;\n}"
    },
    {
        "problem_tier": 9,
        "solution_code": "#include <iostream>\n#include <deque>\nusing namespace std;\nint main() {\nint n, m;\ncin >> n >> m;\ndeque<int> dq;\nint cnt = 0;\nfor (int i = 1; i <= n; i++)\ndq.push_back(i);\nfor (int i = 0; i < m; i++) {\nint num;\ncin >> num;\nint num_index = -1;\nfor (int j = 0; j < dq.size(); j++) {\nif (num == dq[j])\nnum_index = j;\n}\nif (num_index <= dq.size() - num_index) {\nfor (int j = 0; j < num_index; j++) {\nint val = dq.front();\ndq.push_back(val);\ndq.pop_front();\ncnt++;\n}\ndq.pop_front();\n}\nelse {\nfor (int j = dq.size() - 1; j >= num_index; j--) {\nint val = dq.back();\ndq.push_front(val);\ndq.pop_back();\ncnt++;\n}\ndq.pop_front();\n}\n}\ncout << cnt << '\\n';\nreturn 0;\n}"
    },
    {
        "problem_tier": 11,
        "solution_code": "#include <iostream>\n#include <vector>\n#include <cstring>\nusing namespace std;\nvector<int> v[100];\nint visit[100];\nvoid dfs(int x) {\nfor (int i = 0; i < v[x].size(); i++) {\nif (!visit[v[x][i]]) {\nvisit[v[x][i]] = 1;\ndfs(v[x][i]);\n}\n}\n}\nint main() {\nint n, a;\ncin >> n;\nfor (int i = 0; i < n; i++) {\nfor (int j = 0; j < n; j++) {\ncin >> a;\nif (a)\nv[i].push_back(j);\n}\n}\nfor (int i = 0; i < n; i++) {\nmemset(visit, 0, sizeof(visit));\ndfs(i);\nfor (int j = 0; j < n; j++)\ncout << visit[j] << \" \";\ncout << \"\\n\";\n}\nreturn 0;\n}"
    },
    {
        "problem_tier": 3,
        "solution_code": "#include<iostream>\n#include<algorithm>\n#include<vector>\nusing namespace std;\nint main(void){\nios_base::sync_with_stdio(0);\ncin.tie(0);\nvector<int> a(3);\nfor(auto& k : a){\ncin >> k;\n}\nsort(a.begin(), a.end());\nfor(auto k : a){\ncout << k << \" \";\n}\nreturn 0;\n}"
    },
    {
        "problem_tier": 11,
        "solution_code": "#include <iostream>\n#include <vector>\n#define endl \"\\n\"\n#define MAX 1030\nusing namespace std;\nint N, M;\nint MAP[MAX][MAX];\nint Sum[MAX][MAX];\nvector<pair<pair<int, int>, pair<int, int>>> Cmd;\nvoid Input(){\ncin >> N >> M;\nfor (int i = 1; i <= N; i++)\n{\nfor (int j = 1; j <= N; j++)\n{\ncin >> MAP[i][j];\n}\n}\nfor (int i = 0; i < M; i++)\n{\nint a, b, c, d;\ncin >> a >> b >> c >> d;\nCmd.push_back(make_pair(make_pair(a, b), make_pair(c, d)));\n}\n}\nvoid Solution(){\nfor (int i = 1; i <= N; i++)\n{\nfor (int j = 1; j <= N; j++)\n{\nSum[i][j] = Sum[i - 1][j] + Sum[i][j - 1] - Sum[i - 1][j - 1] + MAP[i][j];\n}\n}\nfor (int i = 0; i < M; i++)\n{\nint x = Cmd[i].first.first;\nint y = Cmd[i].first.second;\nint xx = Cmd[i].second.first;\nint yy = Cmd[i].second.second;\ncout << Sum[xx][yy] - Sum[xx][y - 1] - Sum[x - 1][yy] + Sum[x - 1][y - 1] << endl;\n}\n}\nvoid Solve(){\nInput();\nSolution();\n}\nint main(void){\nios::sync_with_stdio(false);\ncin.tie(NULL);\ncout.tie(NULL);\nSolve();\nreturn 0;\n}"
    },
    {
        "problem_tier": 10,
        "solution_code": "#include <iostream>\n#include <list>\nusing namespace std;\nint main() {\nstring str;\ncin >> str;\nlist<char> strList;\nfor (char ch : str) {\nstrList.push_back(ch);\n}\nauto cursor = strList.end();\nint M;\ncin >> M;\nwhile (M--) {\nchar cmd;\ncin >> cmd;\nif (cmd == 'P') {\nchar ch;\ncin >> ch;\nstrList.insert(cursor, ch);\n} else if (cmd == 'L') {\nif (cursor != strList.begin()) {\ncursor--;\n}\n} else if (cmd == 'D') {\nif (cursor != strList.end()) {\ncursor++;\n}\n} else if (cmd == 'B') {\nif (cursor != strList.begin()) {\ncursor--;\ncursor = strList.erase(cursor);\n}\n}\n}\nfor (char ch : strList) {\ncout << ch;\n}\nreturn 0;\n}"
    },
    {
        "problem_tier": 13,
        "solution_code": "#include<iostream>\n#include<cstring>\n#define endl \"\\n\"\n#define MAX 500\nusing namespace std;\nint N, M, Answer;\nint MAP[MAX][MAX];\nbool Visit[MAX][MAX];\nint dx[] = { 0, 0, 1, -1 };\nint dy[] = { 1, -1, 0, 0 };\nint Bigger(int A, int B) {\nif (A > B) return A;\nreturn B;\n}\nvoid Input(){\ncin >> N >> M;\nfor (int i = 0; i < N; i++){\nfor (int j = 0; j < M; j++){\ncin >> MAP[i][j];\n}\n}\n}\nvoid DFS(int x, int y, int Sum, int Cnt){\nVisit[x][y] = true;\nif (Cnt == 3){\nAnswer = Bigger(Answer, Sum);\nreturn;\n}\nfor (int i = 0; i < 4; i++){\nint nx = x + dx[i];\nint ny = y + dy[i];\nif (nx < 0 || ny < 0 || nx >= N || ny >= M) continue;\nif (Visit[nx][ny] == true) continue;\nDFS(nx, ny, Sum + MAP[nx][ny], Cnt + 1);\nVisit[nx][ny] = false;\n}\n}\nvoid Shape1(int x, int y){\nint Tmp_Sum = 0;\nTmp_Sum = MAP[x][y] + MAP[x][y + 1] + MAP[x][y + 2] + MAP[x - 1][y + 1];\nif (Tmp_Sum > Answer) Answer = Tmp_Sum;\n}\nvoid Shape2(int x, int y){\nint Tmp_Sum = 0;\nTmp_Sum = MAP[x][y] + MAP[x][y + 1] + MAP[x][y + 2] + MAP[x + 1][y + 1];\nif (Tmp_Sum > Answer) Answer = Tmp_Sum;\n}\nvoid Shape3(int x, int y){\nint Tmp_Sum = 0;\nTmp_Sum = MAP[x][y] + MAP[x + 1][y] + MAP[x + 2][y] + MAP[x + 1][y + 1];\nif (Tmp_Sum > Answer) Answer = Tmp_Sum;\n}\nvoid Shape4(int x, int y){\nint Tmp_Sum = 0;\nTmp_Sum = MAP[x][y] + MAP[x - 1][y + 1] + MAP[x][y + 1] + MAP[x + 1][y + 1];\nif (Tmp_Sum > Answer) Answer = Tmp_Sum;\n}\nvoid Solution(){\nfor (int i = 0; i < N; i++){\nfor (int j = 0; j < M; j++){\nmemset(Visit, false, sizeof(Visit));\nDFS(i, j, MAP[i][j], 0);\nif (i - 1 >= 0 && j + 2 < M) Shape1(i, j);\nif (j + 2 < M && i + 1 < N) Shape2(i, j);\nif (i + 2 < N && j + 1 < M) Shape3(i, j);\nif (i + 1 < N && i - 1 >= 0 && j + 1 < M) Shape4(i, j);\n}\n}\n}\nvoid Solve(){\nInput();\nSolution();\ncout << Answer << endl;\n}\nint main(void){\nios::sync_with_stdio(false);\ncin.tie(NULL);\ncout.tie(NULL);\nSolve();\nreturn 0;\n}"
    },
    {
        "problem_tier": 7,
        "solution_code": "#include <iostream>\n#include <bitset>\nusing namespace std;\nint main() {\nios::sync_with_stdio(false);\ncin.tie(NULL);\nint m;\ncin >> m;\nbitset<21> s;\nwhile (m--) {\nstring cmd;\nint x;\ncin >> cmd;\nif (cmd == \"all\") {\ns.set();\n} else if (cmd == \"empty\") {\ns.reset();\n} else if (cmd == \"add\") {\ncin >> x;\ns.set(x, true);\n} else if (cmd == \"remove\") {\ncin >> x;\ns.set(x, false);\n} else if (cmd == \"check\") {\ncin >> x;\ncout << s[x] << endl;\n} else if (cmd == \"toggle\") {\ncin >> x;\ns.flip(x);\n}\n}\nreturn 0;\n}"
    },
    {
        "problem_tier": 14,
        "solution_code": "#include<iostream>\n#include<queue>\nusing namespace std;\nint N, M, breakable;\nint Map[1005][1005], visit[1005][1005][2];\nint unit[4][2] = {{0,1},{0,-1},{1,0},{-1,0}};\nqueue<pair<pair<int,int>,int>> Q;\nint BFS() {\nint x, y, next_x, next_y;\nQ.push({{1,1},1});\nvisit[1][1][1] = 1;\nwhile (!Q.empty()) {\ny = Q.front().first.first;\nx = Q.front().first.second;\nbreakable = Q.front().second;\nQ.pop();\nif (y == N && x == M)\nreturn visit[y][x][breakable];\nfor (int i = 0; i < 4; i++) {\nnext_y = y + unit[i][0];\nnext_x = x + unit[i][1];\nif (next_y >= 1 && next_y <= N && next_x >= 1 && next_x <= M) {\nif (Map[next_y][next_x] && breakable && !visit[next_y][next_x][breakable - 1]) {\nvisit[next_y][next_x][breakable - 1] = visit[y][x][breakable] + 1;\nQ.push({{next_y,next_x},breakable - 1});\n} else if (!Map[next_y][next_x] && !visit[next_y][next_x][breakable]) {\nvisit[next_y][next_x][breakable] = visit[y][x][breakable] + 1;\nQ.push({{next_y,next_x},breakable});\n}\n}\n}\n}\nreturn -1;\n}\nint main() {\ncin >> N >> M;\nfor (int i = 1; i <= N; i++)\nfor (int j = 1; j <= M; j++)\nscanf(\"%1d\", &Map[i][j]);\ncout << BFS();\nreturn 0;\n}"
    },
    {
        "problem_tier": 4,
        "solution_code": "#include <iostream>\n#define PI 3.1415926535897932\nusing namespace std;\nint main() {\ndouble r;\ncin >> r;\ncout << fixed;\ncout.precision(6);\ncout << r * r * PI << \"\\n\";\ncout << 2 * r * r << \"\\n\";\n}"
    },
    {
        "problem_tier": 12,
        "solution_code": "#include <iostream>\n#include <vector>\nusing namespace std;\nint main() {\nint n, k;\ncin >> n >> k;\nvector<int> coin(n);\nfor(int i = 0; i < n; i++)\ncin >> coin[i];\nvector<int> dp(k + 1, 0);\ndp[0] = 1;\nfor(int i = 0; i < n; i++) {\nfor(int j = coin[i]; j <= k; j++) {\ndp[j] += dp[j - coin[i]];\n}\n}\ncout << dp[k] << endl;\nreturn 0;\n}"
    },
    {
        "problem_tier": 7,
        "solution_code": "#include <iostream>\n#include <algorithm>\n#include <string>\nusing namespace std;\nint countArr[10] = {0};\nint getMaxCount(string input) {\nint max = 0;\nint len = input.length();\nfor (int i = 0; i < len; i++) {\ncountArr[input[i] - 48]++;\n}\nint temp = ceil((double)(countArr[6] + countArr[9]) / 2);\ncountArr[6] = temp;\ncountArr[9] = temp;\nfor (int i = 0; i < 10; i++) {\nif (countArr[i] > max) {\nmax = countArr[i];\n}\n}\nreturn max;\n}\nint main() {\nstring input;\ngetline(cin, input);\nint result = getMaxCount(input);\ncout << result << endl;\nreturn 0;\n}"
    },
    {
        "problem_tier": 12,
        "solution_code": "#include <iostream>\n#include <deque>\n#include <sstream>\nusing namespace std;\ndeque<int> split(string input, char delim) {\ndeque<int> answer;\nstringstream ss(input);\nstring temp;\nwhile (getline(ss, temp, delim)) {\nanswer.push_back(stoi(temp));\n}\nreturn answer;\n}\nint main(void) {\nint T;\ncin >> T;\nfor (int i = 0; i < T; i++) {\nstring p, s, num;\nint n;\ncin >> p >> n >> s;\ndeque<int> nums = split(s.substr(1, s.size() - 2), ',');\nbool isDesc = false;\nbool errorFlag = false;\nfor (char c : p) {\nif (c == 'D' && nums.empty()) {\nerrorFlag = true;\nbreak;\n} else if (c == 'D' && !isDesc) {\nnums.pop_front();\n} else if (c == 'D' && isDesc) {\nnums.pop_back();\n} else {\nisDesc = !isDesc;\n}\n}\nif (errorFlag) {\ncout << \"error\\n\";\ncontinue;\n}\ncout << \"[\";\nfor (int j = nums.size(); j > 1; j--) {\nif (isDesc) {\ncout << nums.back() << \",\";\nnums.pop_back();\n} else {\ncout << nums.front() << \",\";\nnums.pop_front();\n}\n}\nif (!nums.empty())\ncout << nums.front();\ncout << \"]\\n\";\n}\nreturn 0;\n}"
    },
    {
        "problem_tier": 12,
        "solution_code": "#include<iostream>\nusing namespace std;\n#define MAX 51\nint N, M;\nint r, c, d;\nint result = 0;\nint arr[MAX][MAX];\nbool visited[MAX][MAX];\nint dr[] = {-1, 0, 1, 0};\nint dc[] = {0, 1, 0, -1};\nint main() {\ncin >> N >> M;\ncin >> r >> c >> d;\nfor (int i = 0; i < N; i++) {\nfor (int j = 0; j < M; j++) {\ncin >> arr[i][j];\n}\n}\nwhile (true) {\nif (!visited[r][c]) {\nresult++;\nvisited[r][c] = true;\n}\nbool flag = true;\nfor (int i = 1; i <= 4; i++) {\nint nd = (4 + d - i) % 4;\nint nr = r + dr[nd];\nint nc = c + dc[nd];\nif (visited[nr][nc] || arr[nr][nc]) continue;\nflag = false;\nr = nr;\nc = nc;\nd = nd;\nbreak;\n}\nif (flag) {\nint nr = r + dr[(d + 2) % 4];\nint nc = c + dc[(d + 2) % 4];\nif (arr[nr][nc]) break;\nelse {\nr = nr;\nc = nc;\n}\n}\n}\ncout << result;\nreturn 0;\n}"
    },
    {
        "problem_tier": 8,
        "solution_code": "#include <iostream>\n#include <algorithm>\nusing namespace std;\nint main() {\nint N;\ncin >> N;\nint rope[N];\nfor (int i = 0; i < N; i++) {\ncin >> rope[i];\n}\nsort(rope, rope + N, greater<int>());\nint result = 0;\nfor (int i = 0; i < N; i++) {\nint weight = rope[i] * (i + 1);\nresult = max(result, weight);\n}\ncout << result << endl;\nreturn 0;\n}"
    },
    {
        "problem_tier": 11,
        "solution_code": "#include <iostream>\n#include <queue>\nusing namespace std;\nint dx[8] = {-1, -2, -2, -1, 1, 2, 2, 1};\nint dy[8] = {-2, -1, 1, 2, 2, 1, -1, -2};\nint bfs(int n, int x, int y, int target_x, int target_y) {\nqueue<pair<int, int>> q;\nint visited[301][301] = {0};\nq.push({x, y});\nvisited[x][y] = 1;\nwhile (!q.empty()) {\nint cur_x = q.front().first;\nint cur_y = q.front().second;\nq.pop();\nif (cur_x == target_x && cur_y == target_y) {\nreturn visited[cur_x][cur_y] - 1;\n}\nfor (int i = 0; i < 8; i++) {\nint nx = cur_x + dx[i];\nint ny = cur_y + dy[i];\nif (nx >= 0 && nx < n && ny >= 0 && ny < n && visited[nx][ny] == 0) {\nq.push({nx, ny});\nvisited[nx][ny] = visited[cur_x][cur_y] + 1;\n}\n}\n}\nreturn 0;\n}\nint main() {\nint t;\ncin >> t;\nwhile (t--) {\nint n, start_x, start_y, target_x, target_y;\ncin >> n >> start_x >> start_y >> target_x >> target_y;\nint result = bfs(n, start_x, start_y, target_x, target_y);\ncout << result << endl;\n}\nreturn 0;\n}"
    },
    {
        "problem_tier": 2,
        "solution_code": "#include <iostream>\n#include <cmath>\nusing namespace std;\nint main() {\nlong long n, m;\ncin >> n >> m;\ncout << abs(n - m);\nreturn 0;\n}"
    },
    {
        "problem_tier": 10,
        "solution_code": "#include <iostream>\n#include <vector>\nusing namespace std;\nvoid dfs(int n, vector<int>& nums, vector<int>& one_answer, int now_idx) {\nint answer_size = one_answer.size();\nif (answer_size > 6)\nreturn;\nif (answer_size == 6) {\nfor (int ans_idx = 0; ans_idx < 6; ans_idx++) {\ncout << nums[one_answer[ans_idx]] << \" \";\n}\ncout << \"\\n\";\nreturn;\n}\nfor (int n_idx = now_idx + 1; n_idx < n; n_idx++) {\nif (answer_size + (n - n_idx) < 6)\nreturn;\none_answer.push_back(n_idx);\ndfs(n, nums, one_answer, n_idx);\none_answer.pop_back();\n}\n}\nint main() {\nwhile (1) {\nint n;\ncin >> n;\nif (n == 0)\nbreak;\nvector<int> nums(n);\nvector<int> one_answer;\nfor (int i = 0; i < n; i++) {\ncin >> nums[i];\n}\nfor (int i = 0; i < n; i++) {\none_answer.push_back(i);\ndfs(n, nums, one_answer, i);\none_answer.pop_back();\n}\ncout << \"\\n\";\n}\nreturn 0;\n}"
    },
    {
        "problem_tier": 11,
        "solution_code": "#include<iostream>\n#include<queue>\n#include<cmath>\nusing namespace std;\nstruct cmp {\nbool operator()(int a, int b) {\nif(abs(a) == abs(b))\nreturn a > b;         return abs(a) > abs(b);     }\n};\nint main() {\nint n, x;\npriority_queue<int, vector<int>, cmp> q;\nvector<int> v;\ncin >> n;\nfor (int i = 0; i < n; i++) {\ncin >> x;\nif (x == 0) {\nif (q.empty()) {\nv.push_back(0);\n} else {\nv.push_back(q.top());                 q.pop();             }\n} else {\nq.push(x);         }\n}\nfor (int i = 0; i < v.size(); i++) {\ncout << v[i] << '\\n';     }\nreturn 0;\n}"
    },
    {
        "problem_tier": 11,
        "solution_code": "#include<iostream>\nusing namespace std;\nint n, r, c;\nint ans;\nvoid Z(int y, int x, int size) {\nif (y == r && x == c) {\ncout << ans << '\\n';\nreturn;\n}\nif (r < y + size && r >= y && c < x + size && c >= x) {\nZ(y, x, size / 2);         Z(y, x + size / 2, size / 2);         Z(y + size / 2, x, size / 2);         Z(y + size / 2, x + size / 2, size / 2);     }\nelse {\nans += size * size;\n}\n}\nint main() {\nios_base::sync_with_stdio(false);\ncin.tie(NULL);\ncin >> n >> r >> c;\nZ(0, 0, 1 << n);\nreturn 0;\n}"
    },
    {
        "problem_tier": 11,
        "solution_code": "#include<iostream>\n#include<string>\nusing namespace std;\nint N;\nint video[64][64];\nstring ans;\nbool haveToBePressed(int i, int j, int width) {\nint pivot = video[i][j];\nfor (int x = i; x < i + width; x++) {\nfor (int y = j; y < j + width; y++) {\nif (pivot != video[x][y])\nreturn 1;         }\n}\nreturn 0;\n}\nvoid pressVideo(int i, int j, int width) {\nif (haveToBePressed(i, j, width)) {\nans += '(';\npressVideo(i, j, width / 2);\npressVideo(i, j + width / 2, width / 2);\npressVideo(i + width / 2, j, width / 2);\npressVideo(i + width / 2, j + width / 2, width / 2);\nans += ')';\n} else {\nif (video[i][j] == 0)\nans += '0';\nelse\nans += '1';\nreturn;\n}\nreturn;\n}\nint main() {\ncin >> N;\nfor (int i = 0; i < N; i++) {\nstring tmp;\ncin >> tmp;\nfor (int j = 0; j < N; j++) {\nvideo[i][j] = tmp[j] - '0';\n}\n}\npressVideo(0, 0, N);\ncout << ans << '\\n';\nreturn 0;\n}"
    },
    {
        "problem_tier": 12,
        "solution_code": "#include <iostream>\nusing namespace std;\nint solve(int dis) {\nint answer = 0;\nint k = 2;\nif(dis == 1)\nreturn -1;\nelse if(dis == 2)\nreturn 0;\nelse{\ndis -= 2;\nwhile(dis > 0){\nif(dis >= k*2){\ndis -= k*2;\nanswer += 2;\n}\nelse if(dis >= k){\ndis -= k;\nanswer += 1;\n}\nelse{\ndis -= dis;\nanswer += 1;\n}\nk += 1;\n}\n}\nreturn answer;\n}\nint main(){\nint t;\ncin >> t;\nint x, y;\nfor(int i = 0; i < t; i++){\ncin >> x >> y;\ncout << solve(y-x) + 2 << endl;\n}\nreturn 0;\n}"
    },
    {
        "problem_tier": 5,
        "solution_code": "#include <iostream>\n#include <vector>\n#include <algorithm>\nusing namespace std;\nint main() {\nvector<int> arr(5);\nint sum = 0;\nfor (int i = 0; i < 5; i++) {\ncin >> arr[i];\nsum += arr[i];\n}\nsort(arr.begin(), arr.end());\ncout << sum / 5 << '\\n';\ncout << arr[2] << '\\n';\nreturn 0;\n}"
    },
    {
        "problem_tier": 10,
        "solution_code": "#include <iostream>\nusing namespace std;\nint N, blue, white;\nint paper[128][128];\nvoid solve(int y, int x, int size) {\nint check = paper[y][x];\nfor (int i = y; i < y + size; i++) {\nfor (int j = x; j < x + size; j++) {\nif (check == 0 && paper[i][j] == 1) {\ncheck = 2;\n}\nelse if (check == 1 && paper[i][j] == 0) {\ncheck = 2;\n}\nif (check == 2) {\nsolve(y, x, size / 2);\nsolve(y, x + size / 2, size / 2);\nsolve(y + size / 2, x, size / 2);\nsolve(y + size / 2, x + size / 2, size / 2);\nreturn;\n}\n}\n}\nif (check == 0) {\nwhite++;\n}\nelse {\nblue++;\n}\n}\nint main() {\nios_base::sync_with_stdio(false);\ncin.tie(NULL);\ncout.tie(NULL);\ncin >> N;\nfor (int i = 0; i < N; i++) {\nfor (int j = 0; j < N; j++) {\ncin >> paper[i][j];\n}\n}\nsolve(0, 0, N);\ncout << white << '\\n';\ncout << blue << '\\n';\nreturn 0;\n}"
    },
    {
        "problem_tier": 11,
        "solution_code": "#include<iostream>\n#include<algorithm>\nusing namespace std;\nint price[1001];\nint dp[1001];\nint main(){\nint n;\ncin >> n;\nfor(int i=1; i<=n; i++){\ncin >> price[i];\ndp[i] = -1;\n}\nfor(int i=1; i<=n; i++){\nfor(int j=i; j<=n; j++){\ndp[j] = max(dp[j], dp[j-i]+price[i]);\n}\n}\ncout << dp[n];\nreturn 0;\n}"
    },
    {
        "problem_tier": 8,
        "solution_code": "#include <iostream>\n#include <queue>\nusing namespace std;\nint main() {\nios_base::sync_with_stdio(false);\ncin.tie(NULL);\nqueue<int> Q;\nint N;\ncin >> N;\nfor (int i = 0; i < N; i++) {\nstring command;\ncin >> command;\nif (command == \"push\") {\nint num;\ncin >> num;\nQ.push(num);\n}\nelse if (command == \"pop\") {\nif (Q.empty()) {\ncout << \"-1\" << '\\n';\n}\nelse {\ncout << Q.front() << '\\n';\nQ.pop();\n}\n}\nelse if (command == \"size\") {\ncout << Q.size() << '\\n';\n}\nelse if (command == \"empty\") {\ncout << Q.empty() << '\\n';\n}\nelse if (command == \"front\") {\nif (Q.empty()) {\ncout << \"-1\" << '\\n';\n}\nelse {\ncout << Q.front() << '\\n';\n}\n}\nelse if (command == \"back\") {\nif (Q.empty()) {\ncout << \"-1\" << '\\n';\n}\nelse {\ncout << Q.back() << '\\n';\n}\n}\n}\nreturn 0;\n}"
    },
    {
        "problem_tier": 5,
        "solution_code": "#include <iostream>\n#include <algorithm>\nusing namespace std;\nint main() {\nint n, m, i, j;\ncin >> n >> m;\nint *a = new int[n + 1];\nfor (int i = 1; i <= n; i++)\na[i] = i;\nwhile (m--) {\ncin >> i >> j;\nfor (int t = 0; t <= (j - i) / 2; t++) {\nswap(a[t + i], a[j - t]);\n}\n}\nfor (int i = 1; i <= n; i++)\ncout << a[i] << \" \";\nreturn 0;\n}"
    },
    {
        "problem_tier": 11,
        "solution_code": "#include<bits/stdc++.h>\nusing namespace std;\nlong long cal(long long a, long long b, long long c) {\nif (b == 0) {\nreturn 1;\n}\nelse if (b == 1) {\nreturn a % c;\n}\nelse if (b % 2 == 0) {\nlong long tmp = cal(a, b/2, c);\nreturn (tmp * tmp) % c;\n}\nelse {\nreturn (a * cal(a, b-1, c)) % c;\n}\n}\nint main() {\nlong long a, b, c;\ncin >> a >> b >> c;\ncout << cal(a, b, c) << '\\n';\nreturn 0;\n}"
    },
    {
        "problem_tier": 11,
        "solution_code": "#include <iostream>\n#include <algorithm>\n#define MAX 100001\nusing namespace std;\nint main() {\nios::sync_with_stdio(false);\ncin.tie(0);\ncout.tie(0);\nint T;\ncin >> T;\nwhile (T--) {\nint n;\ncin >> n;\nint dp[2][MAX];\ndp[0][0] = dp[1][0] = 0;\nfor (int i = 1; i <= n; i++) {\ncin >> dp[0][i];\n}\nfor (int i = 1; i <= n; i++) {\ncin >> dp[1][i];\n}\nfor (int i = 2; i <= n; i++) {\ndp[0][i] = max(dp[1][i - 1], dp[1][i - 2]) + dp[0][i];\ndp[1][i] = max(dp[0][i - 1], dp[0][i - 2]) + dp[1][i];\n}\nint answer = max(dp[1][n], dp[0][n]);\ncout << answer << '\\n';\n}\nreturn 0;\n}"
    },
    {
        "problem_tier": 12,
        "solution_code": "#include <iostream>\n#include <algorithm>\n#include <vector>\nusing namespace std;\nvector<char> v;\nvector<char> password;\nint length, num;\nint vowel, conso;\nvoid printpw(int start, int cnt){\nif (cnt == length)\n{\nvowel = 0;\nconso = 0;\nfor (int i = 0; i < password.size(); i++)\n{\nif (password[i] == 'a' || password[i] == 'e' || password[i] == 'i' || password[i] == 'o' || password[i] == 'u')\nvowel++;\nelse\nconso++;\n}\nif (vowel >= 1 && conso >= 2)\n{\nfor (int i = 0; i < password.size(); i++)\n{\ncout << password[i];\n}\ncout << '\\n';\n}\nreturn;\n}\nfor (int i = start; i < v.size(); i++)\n{\npassword.push_back(v[i]);\nprintpw(i + 1, cnt + 1);\npassword.pop_back();\n}\nreturn;\n}\nint main(){\ncin >> length >> num;\nfor (int i = 0; i < num; i++)\n{\nchar c;\ncin >> c;\nv.push_back(c);\n}\nsort(v.begin(), v.end());\nprintpw(0, 0);\nreturn 0;\n}"
    },
    {
        "problem_tier": 10,
        "solution_code": "#include <iostream>\n#include <vector>\nusing namespace std;\nint parent[100001];\nvector<int> v[100001];\nvoid dfs(int x) {\nfor (int i = 0; i < v[x].size(); i++) {\nint next = v[x][i];\nif (!parent[next]) {\nparent[next] = x;\ndfs(next);\n}\n}\n}\nint main() {\nint N;\ncin >> N;\nfor (int i = 0; i < N-1; i++) {\nint a, b;\ncin >> a >> b;\nv[a].push_back(b);\nv[b].push_back(a);\n}\nparent[1] = 1;\ndfs(1);\nfor (int i = 2; i <= N; i++) {\ncout << parent[i] << '\\n';\n}\nreturn 0;\n}"
    },
    {
        "problem_tier": 10,
        "solution_code": "#include<bits/stdc++.h>\nusing namespace std;\nint main() {\nios::sync_with_stdio(false);\ncin.tie(0);\nstring input;\nstack<char> st;\nint cnt = 0;\ncin >> input;\nst.push(input[0]);\nfor(int i = 1; i < input.length(); i++) {\nif(input[i] == '(')\nst.push(input[i]);\nelse if(input[i] == ')') {\nif(input[i - 1] == '(') {\nst.pop();\ncnt += st.size();\n}\nelse if(input[i - 1] == ')') {\nst.pop();\ncnt++;\n}\n}\n}\ncout << cnt;\nreturn 0;\n}"
    },
    {
        "problem_tier": 5,
        "solution_code": "#include<iostream>\n#include<vector>\nusing namespace std;\nint main() {\nvector<int> yen = {500, 100, 50, 10, 5, 1};\nint pay, count = 0;\ncin >> pay;\npay = 1000 - pay;\nfor(int i=0; i<6; i++) {\nfor(;;) {\nif(pay >= yen[i]) {\npay -= yen[i];\ncount++;\n}\nelse\nbreak;\n}\n}\ncout << count;\nreturn 0;\n}"
    },
    {
        "problem_tier": 10,
        "solution_code": "#include <iostream>\nusing namespace std;\nint n, s; int cnt; bool isused[22]; int arr[22]; int sum;\nvoid func(int nx, int x) {\nif (sum == s && nx != 0) {\ncnt++;\n}\nfor (int i = 0; i < n; i++) {\nif (isused[i] || x > i) continue;         isused[i] = true;\nsum += arr[i];\nfunc(nx + 1, i);         isused[i] = false;\nsum -= arr[i];\n}\n}\nint main(void) {\nios::sync_with_stdio(0);\ncin.tie(0);\ncin >> n >> s;\nfor (int i = 0; i < n; i++)\ncin >> arr[i];\nfunc(0, 0);\ncout << cnt;\nreturn 0;\n}"
    },
    {
        "problem_tier": 4,
        "solution_code": "#include <iostream>\nusing namespace std;\nint main() {\nint N, K;\ncin >> N >> K;\nint cnt = 0;\nint ans[10000];\nint p = 0;\nfor (int i = 1; i < 10000; i++) {\nif (i > N) break;\nif (N % i == 0) {\ncnt++;\nans[p++] = i;\n}\n}\nif (cnt < K)\ncout << \"0\";\nelse\ncout << ans[K - 1];\nreturn 0;\n}"
    },
    {
        "problem_tier": 10,
        "solution_code": "#include <iostream>\n#include <cstring>\nusing namespace std;\n#define MAX 50\nint arr[MAX][MAX];\nbool visited[MAX][MAX];\nint w, h;\nint cnt = 0;\nint dx[8] = {-1,0,1,-1,1,-1,0,1};\nint dy[8] = {1,1,1,0,0,-1,-1,-1};\nvoid dfs(int x, int y){\nvisited[x][y] = true;\nfor(int i = 0; i < 8; i++){\nint nx = x + dx[i];\nint ny = y + dy[i];\nif(nx < 0 || nx >= w || ny < 0 || ny >= h)\ncontinue;\nif(arr[nx][ny] == 1 && visited[nx][ny] == false)\ndfs(nx, ny);\n}\n}\nint main(){\nwhile(true){\nmemset(arr, 0, sizeof(arr));\nmemset(visited, false, sizeof(visited));\ncnt = 0;\ncin >> h >> w;         if(h == 0 && w == 0)\nbreak;\nfor(int i = 0; i < w; i++){\nfor(int j = 0; j < h; j++){\ncin >> arr[i][j];\n}\n}\nfor(int i = 0; i < w; i++){\nfor(int j = 0; j < h; j++){\nif(arr[i][j] == 1 && visited[i][j] == false){\ncnt++;\ndfs(i, j);\n}\n}\n}\ncout << cnt << '\\n';\n}\nreturn 0;\n}"
    },
    {
        "problem_tier": 6,
        "solution_code": "#include <iostream>\nusing namespace std;\nint main() {\nchar arr[5][16];\nfor (int i = 0; i < 5; i++) {\ncin >> arr[i];\n}\nfor (int k = 0; k < 15; k++) {\nfor (int i = 0; i < 5; i++) {\nif (arr[i][k] != '\\0') {\ncout << arr[i][k];\n}\n}\n}\nreturn 0;\n}"
    },
    {
        "problem_tier": 4,
        "solution_code": "#include<iostream>\nusing namespace std;\nint main(){\nint n;\ncin >> n;\nfor (int i = 1; i <= n; i++) {\nfor (int j = 1; j <= i; j++) {\ncout << \"*\";\n}\nfor (int k = 1; k <= 2 * (n - i); k++) {\ncout << \" \";\n}\nfor (int l = 1; l <= i; l++) {\ncout << \"*\";\n}\ncout << '\\n';\n}\nfor (int i = 1; i < n; i++) {\nfor (int j = 1; j <= n - i; j++) {\ncout << \"*\";\n}\nfor (int k = 1; k <= i * 2; k++) {\ncout << \" \";\n}\nfor (int l = 1; l <= n - i; l++) {\ncout << \"*\";\n}\ncout << '\\n';\n}\nreturn 0;\n}"
    },
    {
        "problem_tier": 12,
        "solution_code": "#include<iostream>\n#include<vector>\n#include<algorithm>\nusing namespace std;\ntypedef struct {\nint y;\nint x;\nbool checked;\n} Chk;\nvector<pair<int, int>> house;\nvector<Chk> chicken;\nint n = 0, m = 0;\nint result = 2e9;\nvoid dfs(int cnt, int current) {\nif (cnt == m) {\nint sum = 0;\nfor (int i = 0; i < house.size(); i++) {\nint mined = 1000000000;\nfor (int j = 0; j < chicken.size(); j++) {\nif (chicken[j].checked == false) continue;\nmined = min(mined, abs(house[i].first - chicken[j].y) + abs(house[i].second - chicken[j].x));\n}\nsum += mined;\n}\nif (result > sum)\nresult = sum;\nreturn;\n}\nfor (int i = current; i < chicken.size(); i++) {\nif (chicken[i].checked == false) {\nchicken[i].checked = true;\ndfs(cnt + 1, i);\nchicken[i].checked = false;\n}\n}\nreturn;\n}\nint main() {\nios_base::sync_with_stdio(0);\ncin.tie(0), cout.tie(0);\ncin >> n >> m;\nint num = 0;\nfor (int i = 1; i <= n; i++)\nfor (int j = 1; j <= n; j++) {\ncin >> num;\nif (num == 1)\nhouse.push_back(make_pair(i, j));\nelse if (num == 2)\nchicken.push_back({ i, j, false });\n}\ndfs(0, 0);\ncout << result << endl;\nreturn 0;\n}"
    },
    {
        "problem_tier": 6,
        "solution_code": "#include <iostream>\nusing namespace std;\nint main() {\nint N, M;\ncin >> N >> M;\ncout << (N * M - 1) << '\\n';\nreturn 0;\n}"
    },
    {
        "problem_tier": 11,
        "solution_code": "#include<bits/stdc++.h>\nusing namespace std;\nint dx[4] = {0, 0, -1, 1};\nint dy[4] = {-1, 1, 0, 0};\nint area[101][101];\nint safeArea[101][101];\nint check[101][101];\nint n, ans;\nvoid immerseArea(int n, int waterHeight) {\nfor(int i=0; i<n; i++) {\nfor(int j=0; j<n; j++) {\nif(waterHeight < area[i][j])\nsafeArea[i][j] = 1;\n}\n}\n}\nvoid bfs(int i, int j) {\nqueue<pair<int, int>> q;\nq.push({i, j});\ncheck[i][j] = 1;\nwhile(!q.empty()) {\nint x = q.front().first;\nint y = q.front().second;\nq.pop();\nfor(int i=0; i<4; i++) {\nint nx = x + dx[i];\nint ny = y + dy[i];\nif(0 > nx || nx >= n || 0 > ny || ny >= n)\ncontinue;\nif(!safeArea[nx][ny])\ncontinue;\nif(!check[nx][ny]) {\ncheck[nx][ny] = 1;\nq.push({nx, ny});\n}\n}\n}\n}\nint main() {\ncin >> n;\nfor(int i=0; i<n; i++)\nfor(int j=0; j<n; j++)\ncin >> area[i][j];\nfor(int waterHeight=0; waterHeight<=100; waterHeight++) {\nmemset(safeArea, 0, sizeof(safeArea));\nmemset(check, 0, sizeof(check));\nimmerseArea(n, waterHeight);\nint cnt = 0;\nfor(int i=0; i<n; i++) {\nfor(int j=0; j<n; j++) {\nif(!check[i][j] && safeArea[i][j]) {\nbfs(i, j);\ncnt++;\n}\n}\n}\nans = max(ans, cnt);\n}\ncout << ans << '\\n';\nreturn 0;\n}"
    },
    {
        "problem_tier": 12,
        "solution_code": "#include<iostream>\n#include<string>\n#include<algorithm>\nusing namespace std;\nint dp[1001][1001] = {0,};\nint main(){\nios_base::sync_with_stdio(0);\ncin.tie(0), cout.tie(0);\nstring a, b;\ncin >> a >> b;\nfor(int i = 1; i <= b.size(); i++){\nfor(int j = 1; j <= a.size(); j++){\nif(b[i] == a[j])\ndp[i][j] = dp[i-1][j-1] + 1;\nelse\ndp[i][j] = max(dp[i-1][j], dp[i][j-1]);\n}\n}\ncout << dp[b.size()][a.size()] << endl;\nreturn 0;\n}"
    },
    {
        "problem_tier": 4,
        "solution_code": "#include <iostream>\nusing namespace std;\nint main() {\nint n;\ncin >> n;\nfor (int i = 0; i < n; i++) {\nfor (int j = 0; j < i; j++) {\ncout << \" \";\n}\nfor (int j = 2 * n - 2 * i - 1; j > 0; j--) {\ncout << \"*\";\n}\ncout << '\\n';\n}\nreturn 0;\n}"
    },
    {
        "problem_tier": 9,
        "solution_code": "#include <iostream>\n#include <vector>\nusing namespace std;\nint N;\nvector<long long> answer = {0, 1, 2};\nvoid find_answer() {\nlong long tmp;\nfor (int i = 3; i <= N; i++) {\ntmp = answer[i-1] + answer[i-2];\nanswer.push_back(tmp % 15746);\n}\n}\nint main() {\ncin >> N;\nfind_answer();\ncout << answer[N] << endl;\nreturn 0;\n}"
    },
    {
        "problem_tier": 4,
        "solution_code": "#include <iostream>\nusing namespace std;\nint main() {\nint arr[9][9];\nint maxi = -1;\nint x, y;\nfor (int i = 0; i < 9; i++) {\nfor (int j = 0; j < 9; j++) {\ncin >> arr[i][j];\nif (arr[i][j] > maxi) {\nmaxi = arr[i][j];\nx = i+1;\ny = j+1;\n}\n}\n}\ncout << maxi << \"\\n\";\ncout << x << \" \" << y << \"\\n\";\nreturn 0;\n}"
    },
    {
        "problem_tier": 4,
        "solution_code": "#include <iostream>\n#include <string>\nusing namespace std;\nint main() {\nint T;\ncin >> T;\nwhile (T--) {\nstring s;\ncin >> s;\nint add = s[0] + s[2] - '0' - '0' + '0';\ncout << add << \"\\n\";\n}\nreturn 0;\n}"
    },
    {
        "problem_tier": 3,
        "solution_code": "#include <iostream>\n#include <algorithm>\nusing namespace std;\nint main() {\nint burgers[3];\nint drinks[2];\nint cheapest_burger = 9999;\nint cheapest_drink = 9999;\nfor (int i = 0; i < 3; i++) {\ncin >> burgers[i];\nif (burgers[i] < cheapest_burger) {\ncheapest_burger = burgers[i];\n}\n}\nfor (int i = 0; i < 2; i++) {\ncin >> drinks[i];\nif (drinks[i] < cheapest_drink) {\ncheapest_drink = drinks[i];\n}\n}\nint minPrice = cheapest_burger + cheapest_drink - 50;\ncout << minPrice << endl;\nreturn 0;\n}"
    },
    {
        "problem_tier": 12,
        "solution_code": "#include<iostream>\n#include<queue>\nusing namespace std;\nstruct dimension {\nint D;\nint R;\nint C;\n};\nqueue<dimension> q3D;\nint tomato3DMap[100][100][100];\nint dx3D[] = {1, 0, -1, 0, 0, 0};\nint dy3D[] = {0, 1, 0, -1, 0, 0};\nint dh3D[] = {0, 0, 0, 0, 1, -1};\nint result = 0;\nint D, R, C;\nvoid tomato3DBFS() {\nwhile (!q3D.empty()) {\nint xx = q3D.front().R;\nint yy = q3D.front().C;\nint hh = q3D.front().D;\nq3D.pop();\nfor (int i = 0; i < 6; i++) {\nint nx = xx + dx3D[i];\nint ny = yy + dy3D[i];\nint nh = hh + dh3D[i];\nif (nx >= 0 && ny >= 0 && nh >= 0 && nx < R && ny < C && nh < D) {\nif (tomato3DMap[nh][nx][ny] == 0) {\ntomato3DMap[nh][nx][ny] = tomato3DMap[hh][xx][yy] + 1;\nq3D.push({nh, nx, ny});\n}\n}\n}\n}\n}\nvoid tomato3D() {\nint flag = 1;\ncin >> C >> R >> D;\nfor (int i = 0; i < D; i++) {\nfor (int j = 0; j < R; j++) {\nfor (int k = 0; k < C; k++) {\ncin >> tomato3DMap[i][j][k];\nif (tomato3DMap[i][j][k] == 1) {\nq3D.push({i, j, k});\n}\n}\n}\n}\nfor (int i = 0; i < D; i++) {\nfor (int j = 0; j < R; j++) {\nfor (int k = 0; k < C; k++) {\nif (tomato3DMap[i][j][k] == 0) {\nflag = 0;\nbreak;\n}\n}\nif (!flag) {\nbreak;\n}\n}\nif (!flag) {\nbreak;\n}\n}\nif (flag) {\ncout << 0 << \"\\n\";\n}\nelse {\ntomato3DBFS();\nfor (int i = 0; i < D; i++) {\nfor (int j = 0; j < R; j++) {\nfor (int k = 0; k < C; k++) {\nif (tomato3DMap[i][j][k] == 0) {\ncout << -1 << \"\\n\";\nreturn;\n}\nif (result < tomato3DMap[i][j][k]) {\nresult = tomato3DMap[i][j][k];\n}\n}\n}\n}\ncout << result - 1 << \"\\n\";\n}\n}\nint main() {\ntomato3D();\nreturn 0;\n}"
    },
    {
        "problem_tier": 3,
        "solution_code": "#include <iostream>\n#include <string>\nusing namespace std;\nint main() {\nstring s;\nint alphaNum[26] = {0,};\ncin >> s;\nfor(int i=0; i<s.size(); i++) {\nalphaNum[s[i]-'a']++;\n}\nfor(int i=0; i<26; i++) {\ncout << alphaNum[i] << \" \";\n}\nreturn 0;\n}"
    },
    {
        "problem_tier": 2,
        "solution_code": "#include <stdio.h>\n#include <time.h>\nint main() {\nstruct tm* t;\ntime_t timer;\ntimer = time(NULL);\nt = localtime(&timer);\nprintf(\"%d-%02d-%02d\", t->tm_year+1900, t->tm_mon+1, t->tm_mday);\nreturn 0;\n}"
    },
    {
        "problem_tier": 8,
        "solution_code": "#include <iostream>\n#include <unordered_map>\n#include <string>\nusing namespace std;\nint main() {\nint N, M;\nunordered_map<int, string> m1;\nunordered_map<string, int> m2;\ncin >> N >> M;\nfor (int i = 1; i <= N; i++) {\nstring name;\ncin >> name;\nm1.insert(pair<int, string>(i, name));\nm2.insert(pair<string, int>(name, i));\n}\nstring* quiz = new string[M];\nstring* ans = new string[M];\nfor (int i = 0; i < M; i++) {\ncin >> quiz[i];\n}\nfor (int i = 0; i < M; i++) {\nif (quiz[i].at(0) < 'A') {             int n = stoi(quiz[i]);\nans[i] = m1.find(n)->second;\n}\nelse {             int m = m2.find(quiz[i])->second;\nans[i] = to_string(m);\n}\n}\nfor (int i = 0; i < M; i++) {\nif (ans[i].at(0) < 'A') {             printf(\"%d\\n\", stoi(ans[i]));\n}\nelse {             cout << ans[i] << \"\\n\";\n}\n}\n}"
    },
    {
        "problem_tier": 10,
        "solution_code": "#include <iostream>\n#include <vector>\n#include <algorithm>\n#include <map>\nusing namespace std;\nint main() {\nios_base::sync_with_stdio(false);\ncin.tie(NULL);\ncout.tie(NULL);\nint n;\ncin >> n;\nvector<int> v(n);\nmap<int, int> m;\nfor (int i = 0; i < n; i++) {\ncin >> v[i];\n}\nvector<int> sorted_v = v;\nsort(sorted_v.begin(), sorted_v.end());\nsorted_v.erase(unique(sorted_v.begin(), sorted_v.end()), sorted_v.end());\nfor (int i = 0; i < sorted_v.size(); i++) {\nm[sorted_v[i]] = i;\n}\nfor (int i = 0; i < n; i++) {\ncout << m[v[i]] << \" \";\n}\nreturn 0;\n}"
    },
    {
        "problem_tier": 11,
        "solution_code": "#include<iostream>\n#include<string>\nusing namespace std;\nclass Tree{\nstring data;\nTree *left, *right;\npublic:\nTree(){\ndata = \"\";\nleft = NULL;\nright = NULL;\n}\nvoid setData(char data){\nthis->data = data;\n}\nvoid setLeft(Tree *left){\nthis->left = left;\n}\nvoid setRight(Tree *right){\nthis->right = right;\n}\nstatic void preorder(Tree *root){\nif(root){\ncout << root->data;\npreorder(root->left);\npreorder(root->right);\n}\n}\nstatic void inorder(Tree *root){\nif(root){\ninorder(root->left);\ncout << root->data;\ninorder(root->right);\n}\n}\nstatic void postorder(Tree *root){\nif(root){\npostorder(root->left);\npostorder(root->right);\ncout << root->data;\n}\n}\n};\nint main(){\nint n;\ncin >> n;\nTree *tree = new Tree[n+1];\nfor(int i=0;i<n;i++){\nchar data, left, right;\ncin >> data >> left >> right;\nif(data != '.')\ntree[(int)(data-'A')].setData(data);\nif(left != '.')\ntree[(int)(data-'A')].setLeft(&tree[(int)(left-'A')]);\nelse\ntree[(int)(data-'A')].setLeft(NULL);\nif(right != '.')\ntree[(int)(data-'A')].setRight(&tree[(int)(right-'A')]);\nelse\ntree[(int)(data-'A')].setRight(NULL);\n}\nTree *root = &tree[0];\nTree::preorder(root);\ncout << \"\\n\";\nTree::inorder(root);\ncout << \"\\n\";\nTree::postorder(root);\ncout << \"\\n\";\nreturn 0;\n}"
    },
    {
        "problem_tier": 12,
        "solution_code": "#include <iostream>\n#include <queue>\n#include <utility>\nusing namespace std;\nint dx[4] = {1, 0, -1, 0};\nint dy[4] = {0, 1, 0, -1};\nint check[101][101] = {0};\nstring color[101];\nint main(void){\nios::sync_with_stdio(NULL);\ncin.tie(NULL);\nqueue<pair<int,int>> Q;\nqueue<pair<int,int>> Q2;\nint N;\nint colorCount = 0;\nint noColorCount = 0;\ncin >> N;\nfor(int i=0;i<N;i++)\ncin >> color[i];\nfor(int i=0;i<N;i++){\nfor(int j=0;j<N;j++){\nif(color[i][j]=='R' || color[i][j]=='G' || color[i][j]=='B'){\nif(check[i][j]==0){\ncolorCount++;\ncheck[i][j] = 1;\nQ.push({i,j});\nwhile(!Q.empty()){\npair<int,int> cur = Q.front();\nQ.pop();\nfor(int k=0;k<4;k++){\nint nx = cur.first + dx[k];\nint ny = cur.second + dy[k];\nif(nx<0 || nx>=N || ny<0 || ny>=N) continue;\nif(check[nx][ny]==1) continue;\nif(color[nx][ny] != color[i][j]) continue;\ncheck[nx][ny] = 1;\nQ.push({nx,ny});\n}\n}\n}\n}\n}\n}\nfor(int i=0;i<101;i++){\nfor(int j=0;j<101;j++){\ncheck[i][j] = 0;\n}\n}\nfor(int i=0;i<N;i++){\nfor(int j=0;j<N;j++){\nif((color[i][j]=='R' || color[i][j]=='G' || color[i][j]=='B') && check[i][j]==0){\nnoColorCount++;\ncheck[i][j] = 1;\nQ2.push({i,j});\nwhile(!Q2.empty()){\npair<int,int> cur = Q2.front();\nQ2.pop();\nfor(int k=0;k<4;k++){\nint nx = cur.first + dx[k];\nint ny = cur.second + dy[k];\nif(nx<0 || nx>=N || ny<0 || ny>=N) continue;\nif(check[nx][ny]==1) continue;\nif((color[i][j]=='R' && color[nx][ny]=='G') || (color[i][j]=='G' && color[nx][ny]=='R')){\ncheck[nx][ny] = 1;\nQ2.push({nx,ny});\ncontinue;\n}\nif(color[nx][ny] != color[i][j]) continue;\ncheck[nx][ny] = 1;\nQ2.push({nx,ny});\n}\n}\n}\n}\n}\ncout << colorCount << \" \" << noColorCount;\nreturn 0;\n}"
    },
    {
        "problem_tier": 10,
        "solution_code": "#include <iostream>\n#include <algorithm>\nusing namespace std;\nbool isPrime(int num) {\nif (num < 2) return false;\nfor (int i = 2; i * i <= num; i++) {\nif (num % i == 0) return false;\n}\nreturn true;\n}\nint main() {\nios_base::sync_with_stdio(0);\ncin.tie(0);\nint T;\ncin >> T;\nwhile (T--) {\nint n;\ncin >> n;\nint a = n / 2;\nint b = n / 2;\nwhile (true) {\nif (isPrime(a) && isPrime(b)) break;\na--;\nb++;\n}\ncout << a << \" \" << b << \"\\n\";\n}\nreturn 0;\n}"
    },
    {
        "problem_tier": 5,
        "solution_code": "#include <iostream>\n#include <algorithm>\nusing namespace std;\nint main() {\nint N, M;\ncin >> N >> M;\nint* arr = new int[N + 1];\nfor (int i = 1; i <= N; i++) {\narr[i] = i;\n}\nint a, b;\nwhile (M > 0) {\ncin >> a >> b;\nswap(arr[a], arr[b]);\nM--;\n}\nfor (int i = 1; i <= N; i++) {\ncout << arr[i] << \" \";\n}\nreturn 0;\n}"
    },
    {
        "problem_tier": 10,
        "solution_code": "#include <iostream>\n#include <queue>\nusing namespace std;\nint main() {\nios_base::sync_with_stdio(false);\ncin.tie(NULL);\ncout.tie(NULL);\nint N;\ncin >> N;\npriority_queue<int> pq;\nwhile (N--) {\nint input;\ncin >> input;\nif (input == 0) {\nif (pq.empty()) {\ncout << 0 << \"\\n\";\ncontinue;\n}\ncout << pq.top() << \"\\n\";\npq.pop();\n} else {\npq.push(input);\n}\n}\nreturn 0;\n}"
    },
    {
        "problem_tier": 11,
        "solution_code": "#include <iostream>\n#include <vector>\n#include <cmath>\nusing namespace std;\nint N;\nint map[22][22];\nbool chk[22];\nint ans = 0x7fffffff;\nvoid Calc(){\nint A, B;\nA = B = 0;\nfor(int i=1; i<=N; i++){\nif(chk[i] == true){\nfor(int j=1; j<=N; j++){\nif(chk[j] == true)\nA += map[i][j];\n}\n}\nelse{\nfor(int j=1; j<=N; j++){\nif(chk[j] == false)\nB += map[i][j];\n}\n}\n}\nint tmp = abs(A-B);\nif(tmp < ans)\nans = tmp;\n}\nvoid DFS(int node, int start){\nif(node == N/2){\nCalc();\nreturn;\n}\nfor(int i=start; i<=N; i++){\nchk[i] = true;\nDFS(node+1, i+1);\nchk[i] = false;\n}\n}\nint main(){\nscanf(\"%d\", &N);\nfor(int i=1; i<=N; i++){\nfor(int j=1; j<=N; j++){\nscanf(\"%d\", &map[i][j]);\n}\n}\nDFS(0, 1);\nprintf(\"%d\\n\", ans);\nreturn 0;\n}"
    },
    {
        "problem_tier": 4,
        "solution_code": "#include <iostream>\nusing namespace std;\nint main() {\nint n, m;\nint arr[101] = {0, };\ncin >> n >> m;\nfor (int i = 0; i < m; i++) {\nint a, b, c;\ncin >> a >> b >> c;\nfor (int k = a; k <= b; k++) {\narr[k] = c;\n}\n}\nfor (int i = 1; i <= n; i++) {\ncout << arr[i] << \" \";\n}\nreturn 0;\n}"
    },
    {
        "problem_tier": 5,
        "solution_code": "#include <iostream>\nusing namespace std;\nint memo_fibo(int n) {\nif (n == 0) return 0;\nelse if (n == 1) return 1;\nelse {\nint d[n+1] = {0,};\nd[0] = 0;\nd[1] = 1;\nfor (int i = 2; i <= n; i++) {\nd[i] = d[i-1] + d[i-2];\n}\nreturn d[n];\n}\n}\nint main() {\nint N;\ncin >> N;\nint fibo = memo_fibo(N);\ncout << fibo << '\\n';\nreturn 0;\n}"
    },
    {
        "problem_tier": 4,
        "solution_code": "#include <iostream>\nusing namespace std;\nint main() {\nwhile (true) {\nint a, b;\ncin >> a >> b;\nif (a == 0 && b == 0) {\nbreak;\n}\nif (b % a == 0) {\ncout << \"factor\" << endl;\n} else if (a % b == 0) {\ncout << \"multiple\" << endl;\n} else {\ncout << \"neither\" << endl;\n}\n}\nreturn 0;\n}"
    },
    {
        "problem_tier": 10,
        "solution_code": "#include <iostream>\n#include <queue>\nusing namespace std;\nint main() {\nios_base::sync_with_stdio(false);\ncin.tie(NULL);\nint N, input;\npriority_queue<int, vector<int>, greater<int>> pq;\ncin >> N;\nfor (int i = 0; i < N; i++) {\ncin >> input;\nif (input == 0) {\nif (!pq.empty()) {\ncout << pq.top() << \"\\n\";\npq.pop();\n} else {\ncout << \"0\\n\";\n}\n} else {\npq.push(input);\n}\n}\nreturn 0;\n}"
    },
    {
        "problem_tier": 6,
        "solution_code": "#include <iostream>\n#include <string>\n#include <algorithm>\nusing namespace std;\nint main() {\nstring num;\nwhile (1) {\ncin >> num;\nif (num == \"0\")\nbreak;\nstring reverse_num = num;\nreverse(reverse_num.begin(), reverse_num.end());\nif (num == reverse_num)\ncout << \"yes\" << endl;\nelse\ncout << \"no\" << endl;\n}\nreturn 0;\n}"
    },
    {
        "problem_tier": 12,
        "solution_code": "#include <iostream>\n#include <algorithm>\nusing namespace std;\nint w[100 + 1];\nint v[100 + 1];\nint dp[100 + 1][100000 + 1];\nint main() {\nios::sync_with_stdio(false);\ncin.tie(NULL);\nint N, K;\ncin >> N >> K;\nfor (int i = 1; i <= N; i++) {\ncin >> w[i] >> v[i];\n}\nfor (int i = 1; i <= N; i++) {\nfor (int j = 1; j <= K; j++) {\nif (j - w[i] < 0)\ndp[i][j] = dp[i - 1][j];\nelse\ndp[i][j] = max(dp[i - 1][j], dp[i - 1][j - w[i]] + v[i]);\n}\n}\ncout << dp[N][K];\nreturn 0;\n}"
    },
    {
        "problem_tier": 4,
        "solution_code": "#include <iostream>\nusing namespace std;\nint main() {\nint N;\ncin >> N;\nfor (int i = N; i >= 1; i--) {\nfor (int j = i; j < N; j++)\ncout << \" \";\nfor (int j = 1; j <= i * 2 - 1; j++)\ncout << \"*\";\ncout << \"\\n\";\n}\nfor (int i = 2; i <= N; i++) {\nfor (int j = i; j < N; j++)\ncout << \" \";\nfor (int j = 1; j <= i * 2 - 1; j++)\ncout << \"*\";\ncout << \"\\n\";\n}\nreturn 0;\n}"
    },
    {
        "problem_tier": 13,
        "solution_code": "#include <iostream>\n#include <vector>\n#include <queue>\n#include <limits>\n#define INF std::numeric_limits<int>::max()\nint V, E, K;\nstd::vector<std::pair<int, int>> adj[20001];\nstd::vector<int> dist;\nvoid dijkstra() {\ndist.resize(V + 1, INF);\ndist[K] = 0;\nstd::priority_queue<std::pair<int, int>, std::vector<std::pair<int, int>>, std::greater<std::pair<int, int>>> pq;\npq.push(std::make_pair(0, K));\nwhile (!pq.empty()) {\nauto cur = pq.top();\npq.pop();\nint curDist = cur.first;\nint curNode = cur.second;\nif (dist[curNode] != curDist) continue;\nfor (auto& nxt : adj[curNode]) {\nint cost = nxt.first;\nint nxtNode = nxt.second;\nif (dist[nxtNode] > curDist + cost) {\ndist[nxtNode] = curDist + cost;\npq.push(std::make_pair(dist[nxtNode], nxtNode));\n}\n}\n}\n}\nint main() {\nstd::ios::sync_with_stdio(false);\nstd::cin.tie(nullptr);\nstd::cout.tie(nullptr);\nstd::cin >> V >> E >> K;\nfor (int i = 0; i < E; i++) {\nint u, v, w;\nstd::cin >> u >> v >> w;\nadj[u].push_back(std::make_pair(w, v));\n}\ndijkstra();\nfor (int i = 1; i <= V; i++) {\nif (dist[i] == INF) {\nstd::cout << \"INF\" << std::endl;\n} else {\nstd::cout << dist[i] << std::endl;\n}\n}\nreturn 0;\n}"
    },
    {
        "problem_tier": 3,
        "solution_code": "#include<iostream>\nusing namespace std;\nint main() {\nint R1, S;\ncin >> R1 >> S;\ncout << S * 2 - R1;\nreturn 0;\n}"
    },
    {
        "problem_tier": 7,
        "solution_code": "#include <iostream>\nusing namespace std;\nint main(void) {\ncin.tie(NULL);\ncout.tie(NULL);\nios_base::sync_with_stdio(false);\nint cnt = 0;\nint n;\ncin >> n;\nif (n < 5) {\ncnt = 0;\n}\nelse {\nfor (int i = 5; i <= n; i *= 5) {\ncnt += n / i;\n}\n}\ncout << cnt << endl;\nreturn 0;\n}"
    },
    {
        "problem_tier": 12,
        "solution_code": "#include <iostream>\nusing namespace std;\nchar arr[7000][7000];\nvoid star(int x, int y, int num) {\nif (num == 1) {\narr[x][y] = '*';\nreturn;\n}\nint conquer = num / 3;\nstar(x, y, conquer);\nstar(x, y + conquer, conquer);\nstar(x, y + conquer * 2, conquer);\nstar(x + conquer, y, conquer);\nstar(x + conquer, y + conquer * 2, conquer);\nstar(x + conquer * 2, y, conquer);\nstar(x + conquer * 2, y + conquer, conquer);\nstar(x + conquer * 2, y + conquer * 2, conquer);\n}\nint main() {\nios_base::sync_with_stdio(false);\ncin.tie(NULL);\ncout.tie(NULL);\nint N;\ncin >> N;\nfor (int i = 0; i < N; i++) {\nfor (int j = 0; j < N; j++) {\narr[i][j] = ' ';\n}\n}\nstar(0, 0, N);\nfor (int i = 0; i < N; i++) {\nfor (int j = 0; j < N; j++) {\ncout << arr[i][j];\n}\ncout << '\\n';\n}\nreturn 0;\n}"
    },
    {
        "problem_tier": 13,
        "solution_code": "#include <iostream>\n#include <vector>\n#include <queue>\n#include <utility>\n#include <algorithm>\nusing namespace std;\nint map[8][8];\nint origin[8][8];\nbool visit[8][8];\nvector<pair<int, int>> zeros;\nvector<int> temp;\nint m, n;\nint ans;\nint dx[4] = {-1, +1, 0, 0};\nint dy[4] = {0, 0, -1, +1};\nint spread(vector<int> temp);\nvoid bfs(int i, int j);\nint main() {\ncin >> m >> n;\nfor (int i = 0; i < m; i++) {\nfor (int j = 0; j < n; j++) {\ncin >> origin[i][j];\nmap[i][j] = origin[i][j];\nif (origin[i][j] == 0) {\nzeros.push_back(make_pair(i, j));             }\n}\n}\nfor (int i = 0; i < zeros.size() - 3; i++)\ntemp.push_back(0);\nfor (int i = 0; i < 3; i++)\ntemp.push_back(1);\ndo {\nint result = spread(temp);\nans = max(result, ans);\nfor (int i = 0; i < m; i++) {\nfor (int j = 0; j < n; j++) {\nmap[i][j] = origin[i][j];\nvisit[i][j] = false;\n}\n}\n} while (next_permutation(temp.begin(), temp.end()));\ncout << ans;\nreturn 0;\n}"
    },
    {
        "problem_tier": 9,
        "solution_code": "#include <iostream>\n#include <algorithm>\n#include <vector>\n#include <cmath>\n#include <array>\nusing namespace std;\narray<int, 8001> countNum = {0};\narray<int, 8001>::iterator highIndex;\nint avgNum(vector<int> a);\nint midNum(vector<int> a);\nint unqNum(array<int, 8001> a, array<int, 8001>::iterator b);\nint rangeNum(vector<int> a);\nint main(){\nios::sync_with_stdio(false);\ncin.tie(NULL);\ncout.tie(NULL);\nint N, num, mode;\nvector<int> vec;\ncin >> N;\nfor (auto i = 0; i < N; i++){\ncin >> num;\nvec.push_back(num);\ncountNum[num + 4000]++;\n}\ncout << avgNum(vec) << \"\\n\";\ncout << midNum(vec) << \"\\n\";\ncout << unqNum(countNum, highIndex) << \"\\n\";\ncout << rangeNum(vec) << \"\\n\";\n}\nint avgNum(vector<int> a){\ndouble sum = 0;\nfor (int i: a)\nsum += i;\nreturn round(sum / a.size());\n}\nint midNum(vector<int> a){\nsort(a.begin(), a.end());\nint mid = a.size() / 2;\nreturn a[mid];\n}\nint unqNum(array<int, 8001> countNum, array<int, 8001>::iterator highNum){\nint unq = 0;\nhighNum = max_element(countNum.begin(), countNum.end());\nif (*highNum != *max_element(highNum + 1, countNum.end()))\nunq = (int)(highNum - countNum.begin()) - 4000;\nelse\nunq = (int)(max_element(highNum + 1, countNum.end()) - countNum.begin()) - 4000;\nreturn unq;\n}\nint rangeNum(vector<int> a){\nsort(a.begin(), a.end());\nreturn a[a.size() - 1] - a[0];\n}"
    },
    {
        "problem_tier": 11,
        "solution_code": "#include <iostream>\n#include <vector>\n#include <algorithm>\nusing namespace std;\nint N;\nvector<int> num;\nvector<int> oper;\nint mymin = 1000000001;\nint mymax = -1000000001;\nvoid getanswer(int result, int idx) {\nif (idx == N) {\nif (result > mymax)\nmymax = result;\nif (result < mymin)\nmymin = result;\nreturn;\n}\nfor (int i = 0; i < 4; i++) {\nif (oper[i] > 0) {\noper[i]--;\nif (i == 0)\ngetanswer(result + num[idx], idx + 1);\nelse if (i == 1)\ngetanswer(result - num[idx], idx + 1);\nelse if (i == 2)\ngetanswer(result * num[idx], idx + 1);\nelse\ngetanswer(result / num[idx], idx + 1);\noper[i]++;\n}\n}\nreturn;\n}\nint main() {\ncin >> N;\nfor (int i = 0; i < N; i++)\ncin >> num[i];\nfor (int i = 0; i < 4; i++)\ncin >> oper[i];\ngetanswer(num[0], 1);\ncout << mymax << '\\n';\ncout << mymin;\nreturn 0;\n}"
    },
    {
        "problem_tier": 7,
        "solution_code": "#include <iostream>\n#include <vector>\nusing namespace std;\nint main() {\nint n;\ncin >> n;\nvector<vector<int>> paper(101, vector<int>(101, 0));\nint cnt = 0;     for (int i = 0; i < n; i++) {\nint x, y;\ncin >> x >> y;\nfor (int i = y; i < y + 10; i++) {\nfor (int j = x; j < x + 10; j++) {\nif (paper[i][j] == 0) {                     paper[i][j] = 1;                     cnt++;                 }\n}\n}\n}\ncout << cnt << endl;\nreturn 0;\n}"
    },
    {
        "problem_tier": 2,
        "solution_code": "#include <iostream>\nusing namespace std;\nint main() {\nchar words[1001];\nint num;\ncin >> words >> num;\ncout << words[num-1];\nreturn 0;\n}"
    },
    {
        "problem_tier": 9,
        "solution_code": "#include <iostream>\n#include <algorithm>\nusing namespace std;\nint N;\nint T[16], P[16];\nint dp[16];\nvoid input() {\ncin >> N;\nfor (int i = 1; i <= N; i++) {\ncin >> T[i] >> P[i];\n}\n}\nvoid solution() {\nint max_pay = 0;\nfor (int i = 1; i <= N + 1; i++) {\ndp[i] = max(dp[i], dp[i - 1]);\nif (i + T[i] <= N + 1) {\ndp[i + T[i]] = max(dp[i + T[i]], P[i] + dp[i]);\n}\nmax_pay = max(max_pay, dp[i]);\n}\ncout << max_pay;\n}\nint main() {\nios_base::sync_with_stdio(false);\ncin.tie(nullptr);\ninput();\nsolution();\nreturn 0;\n}"
    },
    {
        "problem_tier": 9,
        "solution_code": "#include <iostream>\n#include <vector>\nusing namespace std;\nint main() {\nios_base::sync_with_stdio(false);\ncin.tie(NULL);\ncout.tie(NULL);\nint N, M;\ncin >> N >> M;\nvector<int> nums(N + 1);\nvector<int> dp(N + 1);\nfor (int i = 1; i <= N; i++) {\ncin >> nums[i];\ndp[i] = dp[i - 1] + nums[i];\n}\nfor (int i = 0; i < M; i++) {\nint s, e;\ncin >> s >> e;\ncout << dp[e] - dp[s - 1] << '\\n';\n}\nreturn 0;\n}"
    },
    {
        "problem_tier": 9,
        "solution_code": "#include <iostream>\nusing namespace std;\nlong long int dp[91];\nint main(void){\nios::sync_with_stdio(false);\ncin.tie(0);\nint n;\ncin >> n;\ndp[1] = 1;\ndp[2] = 1;\nfor(int i = 3; i <= n; i++){\ndp[i] = dp[i-2] + dp[i-1];\n}\ncout << dp[n];\nreturn 0;\n}"
    },
    {
        "problem_tier": 7,
        "solution_code": "#include <iostream>\n#include <algorithm>\nusing namespace std;\nint main() {\nios::sync_with_stdio(false);\ncin.tie(NULL);\ncout.tie(NULL);\nint N, M;\ncin >> N;\nint* arr = new int[N];\nfor (int i = 0; i < N; i++) {\ncin >> arr[i];\n}\nsort(arr, arr + N);\ncin >> M;\nfor (int i = 0; i < M; i++) {\nint num;\ncin >> num;\nif (binary_search(arr, arr + N, num)) {\ncout << '1' << ' ';\n} else {\ncout << '0' << ' ';\n}\n}\nreturn 0;\n}"
    },
    {
        "problem_tier": 2,
        "solution_code": "#include <iostream>\nusing namespace std;\nint main() {\nint n, m;\nint arr[101][101], arr2[101][101], arr3[101][101];\ncin >> n >> m;\nfor (int i = 0; i < n; i++) {\nfor (int j = 0; j < m; j++) {\ncin >> arr[i][j];\n}\n}\nfor (int i = 0; i < n; i++) {\nfor (int j = 0; j < m; j++) {\ncin >> arr2[i][j];\n}\n}\nfor (int i = 0; i < n; i++) {\nfor (int j = 0; j < m; j++) {\narr3[i][j] = arr[i][j] + arr2[i][j];\n}\n}\nfor (int i = 0; i < n; i++) {\nfor (int j = 0; j < m; j++) {\ncout << arr3[i][j] << \" \";\n}\ncout << '\\n';\n}\nreturn 0;\n}"
    },
    {
        "problem_tier": 4,
        "solution_code": "#include <iostream>\n#include <string>\nusing namespace std;\nint main() {\nstring str;\nwhile (getline(cin, str)) {\ncout << str << endl;\n}\nreturn 0;\n}"
    },
    {
        "problem_tier": 6,
        "solution_code": "#include<iostream>\n#include<algorithm>\nusing namespace std;\nint arr[51];\nint main() {\nios_base::sync_with_stdio(false);\ncin.tie(NULL);\ncout.tie(NULL);\nint n;\ncin >> n;\nfor(int i=0; i<n; i++) {\ncin >> arr[i];\n}\nsort(arr, arr+n);\nint ans = arr[0] * arr[n-1];\ncout << ans;\nreturn 0;\n}"
    },
    {
        "problem_tier": 8,
        "solution_code": "#include <iostream>\n#include <string>\n#include <stack>\nusing namespace std;\nint main() {\nwhile (true) {\nstring input;\ngetline(cin, input);\nif (input == \".\") {\nbreak;\n}\nstack<char> s;\nbool flag = false;\nfor (int i = 0; i < input.length(); i++) {\nchar c = input[i];\nif ((c == '(') || (c == '[')) {\ns.push(c);\n}\nelse if (c == ')') {\nif (!s.empty() && s.top() == '(') {\ns.pop();\n}\nelse {\nflag = true;\nbreak;\n}\n}\nelse if (c == ']') {\nif (!s.empty() && s.top() == '[') {\ns.pop();\n}\nelse {\nflag = true;\nbreak;\n}\n}\n}\nif (flag == false && s.empty()) {\ncout << \"yes\" << endl;\n}\nelse {\ncout << \"no\" << endl;\n}\n}\nreturn 0;\n}"
    },
    {
        "problem_tier": 5,
        "solution_code": "#include <iostream>\n#include <string>\n#include <stack>\nusing namespace std;\nint main() {\nstring str;\ncin >> str;\nstack<char> stk;\nint sameCnt = 0;\nint mid = (str.size() / 2);     bool result = false;\nbool oddEven;\nif (str.size() % 2)\noddEven = false;\nelse\noddEven = true;\nif (oddEven) {         for (int i = 0; i < mid; i++) {\nstk.push(str[i]);\n}\nfor (int i = mid; i < str.size(); i++) {\nif (str[i] == stk.top())\nsameCnt++;\nstk.pop();\n}\nif (sameCnt == mid)             result = true;\n} else {         for (int i = 0; i < mid; i++) {\nstk.push(str[i]);\n}\nfor (int i = mid + 1; i < str.size(); i++) {\nif (str[i] == stk.top())\nsameCnt++;\nstk.pop();\n}\nif (sameCnt == mid)             result = true;\n}\ncout << result;\nreturn 0;\n}"
    },
    {
        "problem_tier": 9,
        "solution_code": "#include<iostream>\n#define MAX 9\nusing namespace std;\nint N, M;\nint arr[MAX] = {0,};\nbool visited[MAX] = {0,};\nvoid dfs(int cnt) {\nif(cnt == M) {     for(int i=0; i<M; i++) {\ncout << arr[i] << \" \";\n}\ncout << '\\n';\nreturn;\n}\nfor(int i=1; i<=N; i++) {\nvisited[i] = true;     arr[cnt] = i;\ndfs(cnt+1);\nvisited[i] = false;\n}\n}\nint main() {\ncin >> N >> M;\ndfs(0);\nreturn 0;\n}"
    },
    {
        "problem_tier": 10,
        "solution_code": "#include<iostream>\nusing namespace std;\nint arr[300000];\nint n;\nint main(){\nwhile(1){\nint cnt=0;\ncin>>n;\nfor(int i=0;i<=2*n;i++){\narr[i]=0;\n}\nif(n==0) break;\nfor(int i=2;i<=2*n;i++){\nif(arr[i]==0){                 arr[i]=0;\n}\nfor(int j=i+i;j<=2*n;j+=i){\nif(arr[j]!=1){                     arr[j]=1;\n}\n}\n}\nfor(int i=n+1;i<=2*n;i++){\nif(arr[i]==0){\ncnt++;\n}\n}\ncout<<cnt<<'\\n';\n}\nreturn 0;\n}"
    },
    {
        "problem_tier": 10,
        "solution_code": "#include <iostream>\n#include <algorithm>\nusing namespace std;\nint main() {\nint K, N;\ncin >> K >> N;\nunsigned int list[10000];\nfor (int i = 0; i < K; i++) {\ncin >> list[i];\n}\nunsigned int left = 1;\nunsigned int right = *max_element(list, list + K);\nunsigned int ans = 0;\nwhile (left <= right) {\nunsigned int mid = (left + right) / 2;\nunsigned int now = 0;\nfor (int i = 0; i < K; i++) {\nnow += list[i] / mid;\n}\nif (now >= N) {\nleft = mid + 1;\nans = max(ans, mid);\n} else {\nright = mid - 1;\n}\n}\ncout << ans << '\\n';\nreturn 0;\n}"
    },
    {
        "problem_tier": 9,
        "solution_code": "#include <iostream>\n#define MAX 9\nusing namespace std;\nint N, M;\nint arr[MAX];\nvoid dfs(int num, int cnt){\nif(cnt == M){\nfor(int i=0; i<M; i++)\ncout << arr[i] << ' ';\ncout << '\\n';\nreturn;\n}\nfor(int i=num; i<=N; i++){\narr[cnt] = i;\ndfs(i, cnt+1);\n}\n}\nint main(){\ncin >> N >> M;\ndfs(1, 0);\nreturn 0;\n}"
    },
    {
        "problem_tier": 8,
        "solution_code": "#include <iostream>\n#include <vector>\n#include <string>\n#include <algorithm>\n#include <map>\nusing namespace std;\nint main() {\nint n, m, cnt = 0;\nstring s;\nvector<string> result;\nmap<string, bool> list;\ncin >> n >> m;\nfor (int i = 0; i < n; i++) {\ncin >> s;\nlist.insert(make_pair(s, true));\n}\nfor (int i = 0; i < m; i++) {\ncin >> s;\nif (list[s]) {\nresult.push_back(s);\ncnt++;\n}\n}\ncout << cnt << '\\n';\nsort(result.begin(), result.end());\nfor (int i = 0; i < result.size(); i++) {\ncout << result[i] << '\\n';\n}\nreturn 0;\n}"
    },
    {
        "problem_tier": 2,
        "solution_code": "#include <iostream>\n#include <string>\nusing namespace std;\nint main() {\nint n;\nstring s;\ncin >> n;\nwhile (n--) {\ncin >> s;\ncout << s[0] << s[s.size() - 1] << '\\n';\n}\nreturn 0;\n}"
    },
    {
        "problem_tier": 11,
        "solution_code": "#include <iostream>\n#define DIV 1000000000\nusing namespace std;\nint dp[101][10];\nint main() {\nios::sync_with_stdio(false);\ncin.tie(0);\ncout.tie(0);\nint n;\ncin >> n;\nfor (int i = 1; i <= 9; i++) {\ndp[1][i] = 1;\n}\nfor (int i = 2; i <= n; i++) {\nfor (int j = 0; j <= 9; j++) {\nif (j == 0) {\ndp[i][j] = dp[i-1][j+1] % DIV;\n} else if (j == 9) {\ndp[i][j] == dp[i-1][j-1] % DIV;\n} else {\ndp[i][j] = (dp[i-1][j-1] + dp[i-1][j+1]) % DIV;\n}\n}\n}\nint ans = 0;\nfor (int i = 0; i <= 9; i++) {\nans = (ans+dp[n][i]) % DIV;\n}\ncout << ans;\nreturn 0;\n}"
    },
    {
        "problem_tier": 8,
        "solution_code": "#include <iostream>\n#include <algorithm>\n#include <vector>\nusing namespace std;\nint main() {\nint N;\ncin >> N;\nvector<int> A(N);\nvector<int> B(N);\nfor (int i = 0; i < N; i++) {\ncin >> A[i];\n}\nfor (int i = 0; i < N; i++) {\ncin >> B[i];\n}\nsort(A.begin(), A.end());     sort(B.begin(), B.end(), greater<int>());\nint sum = 0;\nfor (int i = 0; i < N; i++) {\nsum += A[i] * B[i];\n}\ncout << sum << endl;\nreturn 0;\n}"
    },
    {
        "problem_tier": 12,
        "solution_code": "#include <iostream>\n#include <vector>\nusing namespace std;\nvector<pair<int, int>> Answer;\nvoid Hanoi(int num, int start, int mid, int end) {\nif (num == 1) {\nAnswer.push_back(make_pair(start, end));\nreturn;\n}\nHanoi(num - 1, start, end, mid);\nAnswer.push_back(make_pair(start, end));\nHanoi(num - 1, mid, start, end);\n}\nint main(void) {\nint N;\ncin >> N;\nHanoi(N, 1, 2, 3);\ncout << Answer.size() << endl;\nfor (int i = 0; i < Answer.size(); i++) {\ncout << Answer[i].first << \" \" << Answer[i].second << endl;\n}\nreturn 0;\n}"
    },
    {
        "problem_tier": 13,
        "solution_code": "#include <iostream>\n#include <vector>\nusing namespace std;\nint N;\nint answer = 0;\nvector<int> visited(15);\nbool Check(int qCnt){\nfor(int i=0; i<qCnt; i++){\nif(visited[qCnt]==visited[i] || qCnt-i==abs(visited[qCnt]-visited[i]))\nreturn 0;     }\nreturn 1; }\nvoid N_Queen(int qCnt){\nif(qCnt == N){\nanswer++;\nreturn;\n}\nfor(int j=0; j<N; j++){\nvisited[qCnt] = j;         if (Check(qCnt))\nN_Queen(qCnt + 1);     }\n}\nint main(){\ncin >> N;\nN_Queen(0);\ncout << answer;\n}"
    },
    {
        "problem_tier": 9,
        "solution_code": "#include <iostream>\n#include <queue>\n#include <algorithm>\nusing namespace std;\nint main() {\nint t;\ncin >> t;\nwhile (t--) {\nint n, m;\ncin >> n >> m;\nqueue<pair<int, int>> que;\npriority_queue<int> pq;\nfor (int i = 0; i < n; i++) {\nint p;\ncin >> p;\nque.push({p, i});             pq.push(p);\n}\nint ans = 1;\nwhile (1) {\nint p = que.front().first;\nint nth = que.front().second;\nif (p != pq.top()) {\nque.pop();\nque.push({p, nth});\n}\nelse {\nif (nth == m) break;\nelse {\nque.pop();\npq.pop();\nans++;\n}\n}\n}\ncout << ans << '\\n';\n}\nreturn 0;\n}"
    },
    {
        "problem_tier": 6,
        "solution_code": "#include <iostream>\nusing namespace std;\nint gcd(int a, int b){\nwhile(b != 0){\nint tmp = a % b;\na = b;\nb = tmp;\n}\nreturn a;\n}\nint lcm(int a, int b){\nreturn (a * b) / gcd(a, b);\n}\nint main(){\nint T;\ncin >> T;\nwhile(T--){\nint A, B;\ncin >> A >> B;\ncout << lcm(A, B) << '\\n';\n}\nreturn 0;\n}"
    },
    {
        "problem_tier": 6,
        "solution_code": "#include <iostream>\nusing namespace std;\nlong long fibo[91];\nlong long dp(int num){\nif(num == 1 || num == 2)\nreturn 1;\nlong long& ret = fibo[num];\nif(ret)\nreturn ret;\nret = 0;\nreturn ret = dp(num-1) + dp(num-2);\n}\nint main(){\nint n;\ncin >> n;\ncout << dp(n);\nreturn 0;\n}"
    },
    {
        "problem_tier": 11,
        "solution_code": "#include <iostream>\n#include <algorithm>\nusing namespace std;\nint dp[10001];\nint wine[10001];\nint main() {\ncin.tie(0);\nios_base::sync_with_stdio(0);\nint n;\ncin >> n;\nfor (int i = 1; i <= n; i++) {\ncin >> wine[i];\n}\ndp[1] = wine[1];\ndp[2] = wine[1] + wine[2];\nfor (int i = 3; i <= n; i++) {\ndp[i] = max({dp[i-1], wine[i]+dp[i-2], wine[i]+dp[i-3]+wine[i-1]});\n}\ncout << dp[n] << \"\\n\";\nreturn 0;\n}"
    },
    {
        "problem_tier": 6,
        "solution_code": "#include <iostream>\nusing namespace std;\nint factorial(int t) {\nint ans = 1;\nfor (int i = t; i > 0; i--) {\nans *= i;\n}\nreturn ans;\n}\nint main() {\nint n, k;\ncin >> n >> k;\nint result = factorial(n) / (factorial(k) * factorial(n - k));\ncout << result;\nreturn 0;\n}"
    },
    {
        "problem_tier": 7,
        "solution_code": "#include <iostream>\n#include <queue>\nusing namespace std;\nint main() {\nint N, K;\ncin >> N >> K;\nqueue<int> q;\nfor (int i = 1; i <= N; i++) {\nq.push(i);\n}\ncout << \"<\";\nint count = 1;\nwhile (!q.empty()) {\nif (count % K == 0) {\nint ans = q.front();\nq.pop();\nif (q.empty()) {\ncout << ans << \">\";\n}\nelse {\ncout << ans << \", \";\n}\n}\nelse {\nint num = q.front();\nq.pop();\nq.push(num);\n}\ncount++;\n}\nreturn 0;\n}"
    },
    {
        "problem_tier": 4,
        "solution_code": "#include<iostream>\nusing namespace std;\nint main(){\nint n;\ncin>>n;\nfor(int i=0; i<n; i++){\nfor(int j=0; j<n-i-1; j++){\ncout<<\" \";\n}\nfor(int j=0; j<i+i+1; j++){\ncout<<\"*\";\n}\ncout<<endl;\n}\nreturn 0;\n}"
    },
    {
        "problem_tier": 10,
        "solution_code": "#include <iostream>\n#include <vector>\n#include <algorithm>\nusing namespace std;\nint n, m;\nvector<long long> v;\nlong long binary(long long left, long long right) {\nlong long result = 0;\nwhile (left <= right) {\nlong long mid = (left + right) / 2;\nlong long tmp = 0;\nfor (int i = 0; i < v.size(); i++) {\ntmp += (v[i] > mid) ? v[i] - mid : 0;\n}\nif (tmp >= m) {\nif (result < mid) result = mid;\nleft = mid + 1;\n} else {\nright = mid - 1;\n}\n}\nreturn result;\n}\nint main() {\nios_base::sync_with_stdio(0);\ncin.tie(0);\ncin >> n >> m;\nfor (int i = 0; i < n; i++) {\nlong long tmp;\ncin >> tmp;\nv.push_back(tmp);\n}\nsort(v.begin(), v.end());\ncout << binary(0, v[n - 1]);\nreturn 0;\n}"
    },
    {
        "problem_tier": 9,
        "solution_code": "#include <iostream>\nusing namespace std;\nint dp[1001];\nint tile(int x) {\nif (x == 1) return 1;\nif (x == 2) return 3;\nif (dp[x] != 0) return dp[x];\nreturn dp[x] = (tile(x-1) + 2*tile(x-2)) % 10007;\n}\nint main() {\nint n;\ncin >> n;\ncout << tile(n);\nreturn 0;\n}"
    },
    {
        "problem_tier": 4,
        "solution_code": "#include<iostream>\nusing namespace std;\nint main() {\nint x[3];\nint y[3];\nfor(int i=0; i<3; i++)\ncin >> x[i] >> y[i];\nif(x[0] == x[1])\ncout << x[2] << \" \";\nelse if(x[0] == x[2])\ncout << x[1] << \" \";\nelse\ncout << x[0] << \" \";\nif(y[0] == y[1])\ncout << y[2];\nelse if(y[0] == y[2])\ncout << y[1];\nelse\ncout << y[0];\nreturn 0;\n}"
    },
    {
        "problem_tier": 10,
        "solution_code": "#include<iostream>\n#include<string>\nusing namespace std;\nint main() {\nstring input;\ncin >> input;\nint result = 0;\nstring num;\nbool isMinus = false;\nfor (int i = 0; i <= input.size(); i++) {\nif (input[i] == '-' || input[i] == '+' || i==input.size()) {\nif (isMinus) {\nresult -= stoi(num);\nnum = \"\";\n}\nelse {\nresult += stoi(num);\nnum = \"\";\n}\n}\nelse {\nnum += input[i];\n}\nif (input[i] == '-') {\nisMinus = true;\n}\n}\ncout << result;\nreturn 0;\n}"
    },
    {
        "problem_tier": 7,
        "solution_code": "#include <iostream>\nusing namespace std;\nint combination(int n, int r) {\nint memo[n+1][r+1];\nfor(int i=0;i<=n;i++){\nfor(int j=0;j<=min(i, r);j++){\nif(j==0 || j==i)\nmemo[i][j]=1;\nelse\nmemo[i][j]=memo[i-1][j-1]+memo[i-1][j];\n}\n}\nreturn memo[n][r];\n}\nint main() {\nint T;\ncin >> T;\nwhile(T--) {\nint N, M;\ncin >> N >> M;\ncout << combination(M, N) << endl;\n}\nreturn 0;\n}"
    },
    {
        "problem_tier": 4,
        "solution_code": "#include <iostream>\n#include <string>\nusing namespace std;\nint main() {\nstring str;\ncin >> str;\nfor (int i = 0; i < str.size(); i++) {\ncout << str[i];\nif (i % 10 == 9) {\ncout << endl;\n}\n}\nreturn 0;\n}"
    },
    {
        "problem_tier": 2,
        "solution_code": "#include<iostream>\nusing namespace std;\nint main(){\nint n;\ncin >> n;\nfor(int i=0;i<n/4;i++){\ncout << \"long\";\n}\ncout << \"int\";\nreturn 0;\n}"
    },
    {
        "problem_tier": 10,
        "solution_code": "#include <iostream>\n#include <vector>\n#include <queue>\nusing namespace std;\nvector<bool> visited(1001, false);\nvector<int> graph[1001];\nvoid createGraph(int ver) {\nfor (int i = 0; i < ver; i++) {\nint u, v;\ncin >> u >> v;\ngraph[u].push_back(v);\ngraph[v].push_back(u);\n}\n}\nvoid dfs(int here) {\nvisited[here] = true;\nfor (int i = 0; i < graph[here].size(); i++) {\nint there = graph[here][i];\nif (!visited[there])\ndfs(there);\n}\n}\nint main() {\nint cnt = 0;\nint n, m;\ncin >> n >> m;\ncreateGraph(m);\nfor (int i = 1; i <= n; i++) {\nif (!visited[i])\ncnt++;\ndfs(i);\n}\ncout << cnt;\nreturn 0;\n}"
    },
    {
        "problem_tier": 9,
        "solution_code": "#include <iostream>\nusing namespace std;\nlong long dp[101] = {0, 1, 1};\nlong long P(int N) {\nif (dp[N] != 0)\nreturn dp[N];\nelse\nreturn dp[N] = P(N - 2) + P(N - 3);\n}\nint main() {\nint T;\nint N;\ncin >> T;\nfor (int i = 0; i < T; i++) {\ncin >> N;\ncout << P(N) << '\\n';\n}\nreturn 0;\n}"
    },
    {
        "problem_tier": 9,
        "solution_code": "#include<iostream>\nusing namespace std;\nint main(){\nint T;\nint x1, y1, r1, x2, y2, r2;\nint d, cond1, cond2;\ncin >> T;\nfor(int test=0; test<T; test++){\ncin >> x1 >> y1 >> r1 >> x2 >> y2 >> r2;\nd = (x1-x2)*(x1-x2) + (y1-y2)*(y1-y2);\ncond1 = (r1-r2)*(r1-r2);\ncond2 = (r1+r2)*(r1+r2);\nif(d == 0){\nif(cond1 == 0)\ncout << \"-1\" << '\\n';\nelse\ncout << \"0\" << '\\n';\n}\nelse if(d == cond1 || d == cond2)\ncout << \"1\" << '\\n';\nelse if(cond1 < d && d < cond2)\ncout << \"2\" << '\\n';\nelse\ncout << \"0\" << '\\n';\n}\nreturn 0;\n}"
    },
    {
        "problem_tier": 8,
        "solution_code": "#include <iostream>\n#include <map>\nusing namespace std;\nint main() {\nios_base::sync_with_stdio(0);\ncin.tie(0);\nint N, M, x;\ncin >> N;\nmap<int, int> arr;\nfor (int i = 0; i < N; i++) {\ncin >> x;\narr[x]++;\n}\ncin >> M;\nfor (int i = 0; i < M; i++) {\ncin >> x;\ncout << arr[x] << \" \";\n}\nreturn 0;\n}"
    },
    {
        "problem_tier": 8,
        "solution_code": "#include <iostream>\n#include <queue>\nusing namespace std;\nint main() {\nint n, k;\ncin >> n >> k;\nqueue<int> q;\nfor (int i = 1; i <= n; i++) {\nq.push(i);\n}\ncout << \"<\";\nwhile (!q.empty()) {\nfor (int i = 1; i <= k; i++) {\nint tmp = q.front();\nq.pop();\nif (i != k) {\nq.push(tmp);\n}\nelse {\ncout << tmp;\nif (!q.empty()) {\ncout << \", \";\n}\n}\n}\n}\ncout << \">\";\nreturn 0;\n}"
    },
    {
        "problem_tier": 10,
        "solution_code": "#include<iostream>\n#include<algorithm>\nusing namespace std;\nint main(){\nint n;\ncin>>n;\nint dp[n];\nfor(int i=0; i<n; i++){\ncin>>dp[i];\n}\nint maxSum=dp[0];\nfor(int i=1; i<n; i++){\ndp[i]=max(dp[i], dp[i-1]+dp[i]);\nmaxSum=max(dp[i], maxSum);\n}\ncout<<maxSum<<endl;\nreturn 0;\n}"
    },
    {
        "problem_tier": 6,
        "solution_code": "#include<iostream>\nusing namespace std;\nint main() {\nint month, date;\ncin >> month >> date;\nint daysInMonth[12] = { 31,28,31,30,31,30,31,31,30,31,30,31 };\nint totalDays = 0;\ntotalDays += date;\nfor (int i = 0; i < (month - 1); i++) {\ntotalDays += daysInMonth[i];\n}\nswitch (totalDays % 7) {\ncase 0:\ncout << \"SUN\";\nbreak;\ncase 1:\ncout << \"MON\";\nbreak;\ncase 2:\ncout << \"TUE\";\nbreak;\ncase 3:\ncout << \"WED\";\nbreak;\ncase 4:\ncout << \"THU\";\nbreak;\ncase 5:\ncout << \"FRI\";\nbreak;\ncase 6:\ncout << \"SAT\";\nbreak;\n}\nreturn 0;\n}"
    },
    {
        "problem_tier": 8,
        "solution_code": "#include <iostream>\n#include <deque>\n#include <string>\nusing namespace std;\nint main() {\ndeque<int> dq;\nint n;\ncin >> n;\nfor (int i = 0; i < n; i++) {\nstring command;\ncin >> command;\nif (command == \"push_front\") {\nint num;\ncin >> num;\ndq.push_front(num);\n}\nelse if (command == \"push_back\") {\nint num;\ncin >> num;\ndq.push_back(num);\n}\nelse if (command == \"pop_front\") {\nif (dq.empty()) {\ncout << -1 << endl;\n}\nelse {\ncout << dq.front() << endl;\ndq.pop_front();\n}\n}\nelse if (command == \"pop_back\") {\nif (dq.empty()) {\ncout << -1 << endl;\n}\nelse {\ncout << dq.back() << endl;\ndq.pop_back();\n}\n}\nelse if (command == \"size\") {\ncout << dq.size() << endl;\n}\nelse if (command == \"empty\") {\ncout << dq.empty() << endl;\n}\nelse if (command == \"front\") {\nif (dq.empty()) {\ncout << -1 << endl;\n}\nelse {\ncout << dq.front() << endl;\n}\n}\nelse if (command == \"back\") {\nif (dq.empty()) {\ncout << -1 << endl;\n}\nelse {\ncout << dq.back() << endl;\n}\n}\n}\nreturn 0;\n}"
    },
    {
        "problem_tier": 9,
        "solution_code": "#include <iostream>\n#define MAX 9\nusing namespace std;\nint N, M;\nint arr[MAX] = {0,};\nbool visited[MAX] = {0,};\nvoid dfs(int num, int cnt) {\nif (cnt == M) {\nfor (int i = 0; i < M; i++) {\ncout << arr[i] << ' ';\n}\ncout << '\\n';\nreturn;\n}\nfor (int i = num; i <= N; i++) {\nif (!visited[i]) {\nvisited[i] = true;\narr[cnt] = i;\ndfs(i + 1, cnt + 1);\nvisited[i] = false;\n}\n}\n}\nint main() {\ncin >> N >> M;\ndfs(1, 0);\nreturn 0;\n}"
    },
    {
        "problem_tier": 11,
        "solution_code": "#include <iostream>\n#include <algorithm>\nusing namespace std;\nint arr[501][501];\nint dp[501][501];\nint main() {\nint n;\ncin >> n;\nfor(int i=1; i<=n; i++) {\nfor(int j=1; j<=i; j++) {\ncin >> arr[i][j];\n}\n}\ndp[1][1] = arr[1][1];\nfor(int i=2; i<=n; i++) {\nfor(int j=1; j<=i; j++) {\ndp[i][j] = max(dp[i-1][j-1], dp[i-1][j]) + arr[i][j];\n}\n}\nint maxRes = 0;\nfor(int i=1; i<=n; i++) {\nmaxRes = max(maxRes, dp[n][i]);\n}\ncout << maxRes;\nreturn 0;\n}"
    },
    {
        "problem_tier": 4,
        "solution_code": "#include <iostream>\nusing namespace std;\nint main() {\nint n;\ncin >> n;\nfor(int i = 0; i < n-1; i++){\nfor(int j = 1; j <= n-i-1; j++){\ncout << \" \";\n}\nfor(int k = 1; k <= (i*2+1); k++){\ncout << \"*\";\n}\ncout << endl;\n}\nfor(int i = 0; i < n; i++){\nfor(int j = 0; j < i; j++){\ncout << \" \";\n}\nfor(int k = 1; k <= (n*2-(i*2+1)); k++){\ncout << \"*\";\n}\ncout << endl;\n}\nreturn 0;\n}"
    },
    {
        "problem_tier": 4,
        "solution_code": "#include <iostream>\n#include <algorithm>\nusing namespace std;\nint main() {\nwhile (1) {\nint a[3];\ncin >> a[0] >> a[1] >> a[2];\nif (a[0] == 0 && a[1] == 0 && a[2] == 0) {\nbreak;\n} else {\nsort(a, a + 3);\nif (a[0] * a[0] + a[1] * a[1] == a[2] * a[2]) {\ncout << \"right\" << '\\n';\n} else {\ncout << \"wrong\" << '\\n';\n}\n}\n}\nreturn 0;\n}"
    },
    {
        "problem_tier": 6,
        "solution_code": "#include <iostream>\n#include <algorithm>\nusing namespace std;\nint main() {\nint arr[9];\nint sum = 0;\nfor (int i = 0; i < 9; i++) {\ncin >> arr[i];\nsum += arr[i];\n}\nsort(arr, arr + 9);\nfor (int i = 0; i < 8; i++) {\nfor (int j = i + 1; j < 9; j++) {\nif (sum - (arr[i] + arr[j]) == 100) {\nfor (int k = 0; k < 9; k++) {\nif (k != i && k != j) {\ncout << arr[k] << '\\n';\n}\n}\nreturn 0;\n}"
    },
    {
        "problem_tier": 2,
        "solution_code": "#include<iostream>\n#include<vector>\n#include<string>\nusing namespace std;\nint main() {\nstring s1, s2;\ncin >> s1 >> s2;\nif (s1.size() < s2.size()) {\nswap(s1, s2);\n}\nvector<int> num1(s1.size() + 1);\nvector<int> num2(s1.size() + 1, 0);\nfor (int i = 0; i < s1.size(); i++) {\nnum1[i + 1] = s1[i] - '0';\n}\nfor (int i = 0; i < s2.size(); i++) {\nnum2[i + (s1.size() - s2.size()) + 1] = s2[i] - '0';\n}\nvector<int> result(s1.size() + 1, 0);\nint carry = 0;\nfor (int i = s1.size(); i > 0; i--) {\nresult[i] = num1[i] + num2[i] + carry;\ncarry = result[i] / 10;\nresult[i] %= 10;\n}\nresult[0] = carry;\nif (result[0] != 0) {\ncout << result[0];\n}\nfor (int i = 1; i <= s1.size(); i++) {\ncout << result[i];\n}\nreturn 0;\n}"
    },
    {
        "problem_tier": 3,
        "solution_code": "#include <iostream>\nusing namespace std;\nint main() {\nint total = 0;\nfor (int i = 0; i < 5; i++) {\nint score;\ncin >> score;\nif (score < 40) {\nscore = 40;\n}\ntotal += score;\n}\ncout << total / 5;\nreturn 0;\n}"
    },
    {
        "problem_tier": 10,
        "solution_code": "#include <iostream>\n#include <stack>\n#include <vector>\nusing namespace std;\nint main() {\nint n;\ncin >> n;\nvector<int> numbers(n);\nfor(int i = 0; i < n; i++) {\ncin >> numbers[i];\n}\nstack<int> s;\nvector<char> result;\nint idx = 0;\nfor(int i = 1; i <= n; i++) {\ns.push(i);\nresult.push_back('+');\nwhile(!s.empty() && s.top() == numbers[idx]) {\ns.pop();\nresult.push_back('-');\nidx++;\n}\n}\nif(!s.empty()) {\ncout << \"NO\" << endl;\n} else {\nfor(auto c : result) {\ncout << c << endl;\n}\n}\nreturn 0;\n}"
    },
    {
        "problem_tier": 7,
        "solution_code": "#include <iostream>\n#include <vector>\n#include <algorithm>\n#include <utility>\nusing namespace std;\nbool compare(pair<int, int> a, pair<int, int> b){\nif(a.second != b.second){\nreturn a.second < b.second;\n}\nelse{\nreturn a.first < b.first;\n}\n}\nint main(){\nios_base::sync_with_stdio(false);\ncin.tie(NULL);\ncout.tie(NULL);\nint N;\ncin >> N;\nvector<pair<int, int>> vec;\nint x, y;\nfor(int i=0; i<N; i++){\ncin >> x >> y;\nvec.push_back(make_pair(x, y));\n}\nsort(vec.begin(), vec.end(), compare);\nfor(int i=0; i<N; i++){\ncout << vec[i].first << \" \" << vec[i].second << \"\\n\";\n}\nreturn 0;\n}"
    },
    {
        "problem_tier": 10,
        "solution_code": "#include <iostream>\n#include <vector>\nusing namespace std;\nint main() {\nint N;\ncin >> N;\nvector<int> arr(N+1);\nvector<int> dp(N+1, 1);\nfor (int i = 1; i <= N; i++) {\ncin >> arr[i];\n}\nfor (int i = 2; i <= N; i++) {\nfor (int j = 1; j < i; j++) {\nif (arr[j] < arr[i]) {\ndp[i] = max(dp[j] + 1, dp[i]);\n}\n}\n}\nint result = 1;\nfor (int i = 1; i <= N; i++) {\nresult = max(result, dp[i]);\n}\ncout << result;\nreturn 0;\n}"
    },
    {
        "problem_tier": 9,
        "solution_code": "#include <iostream>\n#define MAX 9\nusing namespace std;\nint n, m;\nint arr[MAX] = {0,};\nbool visited[MAX] = {0,};\nvoid dfs(int depth){\nif(depth == m){\nfor(int i=0; i<m; i++){\ncout << arr[i] << \" \";\n}\ncout << \"\\n\";\nreturn;\n}\nfor(int i=1; i<=n; i++){\nif(!visited[i]){\nvisited[i] = true;\narr[depth] = i;\ndfs(depth+1);\nvisited[i] = false;\n}\n}\n}\nint main(){\ncin >> n >> m;\ndfs(0);\nreturn 0;\n}"
    },
    {
        "problem_tier": 2,
        "solution_code": "#include <iostream>\nusing namespace std;\nint main() {\nint a, b, c, d, e;\ncin >> a >> b >> c >> d >> e;\ncout << (a*a + b*b + c*c + d*d + e*e) % 10;\nreturn 0;\n}"
    },
    {
        "problem_tier": 7,
        "solution_code": "#include <iostream>\nusing namespace std;\nint main()\n{\nint n;\ncin >> n;\nint count = 0;\nint number = 666;\nwhile(true)\n{\nif(to_string(number).find(\"666\") != string::npos)\ncount++;\nif(count == n)\n{\ncout << number << endl;\nbreak;\n}\nnumber++;\n}\nreturn 0;\n}"
    },
    {
        "problem_tier": 11,
        "solution_code": "#include<iostream>\n#include<queue>\nusing namespace std;\nint main() {\nint n = 0, k = 0;\nint result = 0;\nint visited[100001] = {0,};\nqueue<int> que;\ncin >> n >> k;\nque.push(n);\nvisited[n] = 1;\nwhile(!que.empty()) {\nint p = que.front();\nque.pop();\nif(p == k) {\ncout << visited[p] - 1 << endl;\nreturn 0;\n}"
    },
    {
        "problem_tier": 8,
        "solution_code": "#include <iostream>\n#include <queue>\n#include <string>\nusing namespace std;\nint main() {\nios::sync_with_stdio(0);\ncin.tie(0);\nqueue<int> Q;\nint N;\ncin >> N;\nwhile (N--) {\nstring str;\ncin >> str;\nif (str == \"push\") {\nint X;\ncin >> X;\nQ.push(X);\n}\nelse if (str == \"pop\") {\nif (!Q.empty()) {\ncout << Q.front() << \"\\n\";\nQ.pop();\n}\nelse {\ncout << \"-1\\n\";\n}\n}\nelse if (str == \"size\") {\ncout << Q.size() << \"\\n\";\n}\nelse if (str == \"empty\") {\ncout << Q.empty() << \"\\n\";\n}\nelse if (str == \"front\") {\nif (!Q.empty()) {\ncout << Q.front() << \"\\n\";\n}\nelse {\ncout << \"-1\\n\";\n}\n}\nelse if (str == \"back\") {\nif (!Q.empty()) {\ncout << Q.back() << \"\\n\";\n}\nelse {\ncout << \"-1\\n\";\n}\n}\n}\nreturn 0;\n}"
    },
    {
        "problem_tier": 8,
        "solution_code": "#include <iostream>\n#include <queue>\nusing namespace std;\nint main() {\nios::sync_with_stdio(0);\ncin.tie(0);\nqueue<int> Q;\nint N;\ncin >> N;\nfor (int i = 1; i <= N; i++) {\nQ.push(i);\n}\nwhile (Q.size() > 1) {\nQ.pop();\nQ.push(Q.front());\nQ.pop();\n}\ncout << Q.front();\nreturn 0;\n}"
    },
    {
        "problem_tier": 12,
        "solution_code": "#include <iostream>\n#include <queue>\n#include <cstring>\n#define MAX_SIZE 1000 + 1\nusing namespace std;\nstruct tomato {\nint y, x;\n};\nqueue<tomato> q;\nint dx[4] = { 1, 0, -1, 0 };\nint dy[4] = { 0, 1, 0 , -1 };\nint n, m, result = 0;\nint graph[MAX_SIZE][MAX_SIZE];\nbool IsInside(int ny, int nx) {\nreturn (0 <= nx && 0 <= ny && nx < m && ny < n);\n}\nvoid bfs(void) {\nwhile (!q.empty()) {\nint y = q.front().y;\nint x = q.front().x;\nq.pop();\nfor (int i = 0; i < 4; i++) {\nint ny = y + dy[i];\nint nx = x + dx[i];\nif (IsInside(ny, nx) == 1 && graph[ny][nx] == 0) {\ngraph[ny][nx] = graph[y][x] + 1;\nq.push({ ny, nx });\n}\n}\n}\n}\nint main() {\ncin >> m >> n;\nfor (int i = 0; i < n; i++) {\nfor (int j = 0; j < m; j++) {\ncin >> graph[i][j];\nif (graph[i][j] == 1) {\nq.push({ i, j });\n}\n}\n}\nbfs();\nfor (int i = 0; i < n; i++) {\nfor (int j = 0; j < m; j++) {\nif (graph[i][j] == 0) {\ncout << -1;\nreturn 0;\n}"
    },
    {
        "problem_tier": 6,
        "solution_code": "#include <iostream>\nusing namespace std;\nint main() {\nint N;\ncin >> N;\nif (N == 1)\nreturn 0;\nfor (int i = 2; i <= N; i++) {\nwhile (N % i == 0) {\ncout << i << endl;\nN /= i;\n}"
    },
    {
        "problem_tier": 8,
        "solution_code": "#include<iostream>\n#include<algorithm>\n#include<utility>\n#include<string>\nusing namespace std;\nstring WB[8] = {\"WBWBWBWB\",\"BWBWBWBW\",\"WBWBWBWB\",\"BWBWBWBW\",\"WBWBWBWB\",\"BWBWBWBW\",\"WBWBWBWB\",\"BWBWBWBW\"};\nstring BW[8] = {\"BWBWBWBW\",\"WBWBWBWB\",\"BWBWBWBW\",\"WBWBWBWB\",\"BWBWBWBW\",\"WBWBWBWB\",\"BWBWBWBW\",\"WBWBWBWB\"};\nstring board[50];\nint WB_cnt(int x, int y){\nint cnt = 0;\nfor(int i=0; i<8; i++){\nfor(int j=0; j<8; j++){\nif(board[x+i][y+j] != WB[i][j])\ncnt++;\n}\n}\nreturn cnt;\n}\nint BW_cnt(int x, int y){\nint cnt = 0;\nfor(int i=0; i<8; i++){\nfor(int j=0; j<8; j++){\nif(board[x+i][y+j] != BW[i][j])\ncnt++;\n}\n}\nreturn cnt;\n}\nint main(){\npair<int, int> p1;\ncin >> p1.first >> p1.second;\nint min_val = 12345;\nfor(int i=0; i<p1.first; i++){\ncin >> board[i];\n}\nfor(int i=0; i+8<=p1.first; i++){\nfor(int j=0; j+8<=p1.second; j++){\nint tmp;\ntmp = min(WB_cnt(i, j), BW_cnt(i, j));\nif(tmp < min_val){\nmin_val = tmp;\n}\n}\n}\ncout << min_val;\nreturn 0;\n}"
    },
    {
        "problem_tier": 9,
        "solution_code": "#include <iostream>\n#include <algorithm>\n#define MAX 301\nusing namespace std;\nint N;\nint stairs[MAX];\nint dp[MAX];\nint main() {\ncin >> N;\nfor (int i = 1; i <= N; i++) {\ncin >> stairs[i];\n}\ndp[1] = stairs[1];\ndp[2] = max(stairs[1] + stairs[2], stairs[2]);\ndp[3] = max(stairs[1] + stairs[3], stairs[2] + stairs[3]);\nfor (int i = 4; i <= N; i++) {\ndp[i] = max(stairs[i] + dp[i - 2], stairs[i] + stairs[i - 1] + dp[i - 3]);\n}\ncout << dp[N] << endl;\nreturn 0;\n}"
    },
    {
        "problem_tier": 11,
        "solution_code": "#include <iostream>\n#include <algorithm>\n#define MAX 1000*1000+1\nusing namespace std;\nint dp[1001][3];\nint cost[1001][3];\nint main() {\nios::sync_with_stdio(false);\ncin.tie(NULL);\ncout.tie(NULL);\nint n;\ncin >> n;\nint r, g, b;\nfor(int i=1; i<=n; i++){\ncin >> r >> g >> b;\ncost[i][0] = r;\ncost[i][1] = g;\ncost[i][2] = b;\n}\ndp[1][0] = cost[1][0];\ndp[1][1] = cost[1][1];\ndp[1][2] = cost[1][2];\nfor(int i=2; i<=n; i++){\ndp[i][0] = min(dp[i-1][1], dp[i-1][2]) + cost[i][0];\ndp[i][1] = min(dp[i-1][0], dp[i-1][2]) + cost[i][1];\ndp[i][2] = min(dp[i-1][1], dp[i-1][0]) + cost[i][2];\n}\nint minimum = MAX;\nfor(int i=0; i<=2; i++){\nminimum = min(minimum, dp[n][i]);\n}\ncout << minimum;\nreturn 0;\n}"
    },
    {
        "problem_tier": 11,
        "solution_code": "#include <iostream>\n#include <algorithm>\n#include <vector>\nusing namespace std;\nint main() {\nint n;\ncin >> n;\nvector<pair<int, int>> v(n);\nfor (int i = 0; i < n; i++) {\ncin >> v[i].second >> v[i].first;\n}\nsort(v.begin(), v.end());\nint endTime = -1;\nint ans = 0;\nfor (int i = 0; i < n; i++) {\nif (endTime <= v[i].second) {\nendTime = v[i].first;\nans++;\n}\n}\ncout << ans << endl;\nreturn 0;\n}"
    },
    {
        "problem_tier": 2,
        "solution_code": "#include<iostream>\nusing namespace std;\nint main() {\nint submit[31] = {0};     int num;\nwhile(cin >> num) {\nsubmit[num] = 1;     }\nfor(int i=1; i<31; i++) {\nif(submit[i] == 0)\ncout << i << '\\n';\n}\nreturn 0;\n}"
    },
    {
        "problem_tier": 7,
        "solution_code": "#include <iostream>\n#include <vector>\nusing namespace std;\nint main() {\nint n, x, y;\ncin >> n;\nvector<pair<int, int>> v;\nfor (int i = 0; i < n; i++) {\ncin >> x >> y;\nv.push_back(make_pair(x, y));\n}\nfor (int j = 0; j < n; j++) {\nint count = 1;\nfor (int k = 0; k < n; k++) {\nif (v[j].first < v[k].first && v[j].second < v[k].second) {\ncount++;\n}\n}\ncout << count << endl;\n}\nreturn 0;\n}"
    },
    {
        "problem_tier": 7,
        "solution_code": "#include <iostream>\n#include <vector>\n#include <algorithm>\nusing namespace std;\nstruct person {\nint age;\nstring name;\n};\nbool compare(const person& a, const person& b) {\nreturn a.age < b.age;\n}\nint main() {\nint N;\ncin >> N;\nvector<person> people(N);\nfor (int i = 0; i < N; i++) {\ncin >> people[i].age >> people[i].name;\n}\nstable_sort(people.begin(), people.end(), compare);\nfor (int i = 0; i < N; i++) {\ncout << people[i].age << \" \" << people[i].name << \"\\n\";\n}\nreturn 0;\n}"
    },
    {
        "problem_tier": 2,
        "solution_code": "#include<iostream>\n#include<string>\nusing namespace std;\nint main() {\nstring s;\ncin >> s;\ncout << s.size();\nreturn 0;\n}"
    },
    {
        "problem_tier": 9,
        "solution_code": "#include<iostream>\nusing namespace std;\nint main(){\nint n;\ncin >> n;\nint dp[1001];\ndp[1] = 1;\ndp[2] = 2;\nfor (int i = 3; i <= n; i++){\ndp[i] = (dp[i - 1] + dp[i - 2]) % 10007;\n}\ncout << dp[n];\nreturn 0;\n}"
    },
    {
        "problem_tier": 5,
        "solution_code": "#include <iostream>\n#include <vector>\nusing namespace std;\nbool isPrime(int n) {\nif (n <= 1) return false;\nfor (int i = 2; i*i <= n; i++) {\nif (n % i == 0) return false;\n}\nreturn true;\n}\nint main() {\nint m, n;\ncin >> m >> n;\nvector<int> primes;\nint sum = 0;\nint minPrime = -1;\nfor (int i = m; i <= n; i++) {\nif (isPrime(i)) {\nprimes.push_back(i);\nsum += i;\nif (minPrime == -1) {\nminPrime = i;\n}\n}\n}\nif (primes.size() == 0) {\ncout << -1;\n} else {\ncout << sum << \"\\n\" << minPrime;\n}\nreturn 0;\n}"
    },
    {
        "problem_tier": 10,
        "solution_code": "#include <iostream>\n#include <queue>\n#define MAX 51\nusing namespace std;\nint map[MAX][MAX] = {0,};\nbool visited[MAX][MAX] = {false};\nint dx[4] = {-1, 0, 1, 0};\nint dy[4] = {0, 1, 0, -1};\nint m; int n; int k; int testCaseNum; int cnt = 0;\nvoid bfs(int x, int y) {\nqueue<pair<int, int>> q;\nq.push(pair<int, int>(x, y));\nvisited[x][y] = true;\nwhile(!q.empty()) {\npair<int, int> cur = q.front();\nq.pop();\nfor (int i = 0; i < 4; i++) {\nint nx = cur.first + dx[i];\nint ny = cur.second + dy[i];\nif(nx > -1 && ny > -1 && nx < m && ny < n && map[nx][ny] == 1 && visited[nx][ny] == false) {\nvisited[nx][ny] = true;\nq.push(pair<int, int>(nx, ny));\n}\n}\n}\n}\nvoid init() {\ncnt = 0;\nfor(int i = 0; i < m; i++) {\nfor (int j = 0; j < n; j++) {\nmap[i][j] = 0;\nvisited[i][j] = false;\n}\n}\n}\nint main() {\ncin >> testCaseNum;\nfor (int i = 0; i < testCaseNum; i++) {\ncin >> m >> n >> k;\nfor (int j = 0; j < k; j++) {\nint temp, temp2;\ncin >> temp >> temp2;             map[temp][temp2] = 1;\n}\nfor (int j = 0; j < m; j++) {\nfor (int t = 0; t < n; t++) {\nif (map[j][t] == 1 && visited[j][t] == false) {\nbfs(j, t);\ncnt++;\n}\n}\n}\ncout << cnt;\ncout<<endl;\ninit();\n}\nreturn 0;\n}"
    },
    {
        "problem_tier": 5,
        "solution_code": "#include <iostream>\nusing namespace std;\nint main(){\nint arr[8];\nint asc = 0;\nint dsc = 0;\nfor(int i=0; i<8; i++){\ncin>>arr[i];\nif(arr[i] == i+1)\nasc += 1;\nelse if(arr[i] == 8 - i)\ndsc += 1;\n}\nif(asc == 8)\ncout<<\"ascending\";\nelse if(dsc == 8)\ncout<<\"descending\";\nelse\ncout<<\"mixed\";\nreturn 0;\n}"
    },
    {
        "problem_tier": 6,
        "solution_code": "#include <iostream>\nusing namespace std;\nint arr[15][15];\nint main() {\nint T;\ncin >> T;     for (int i = 0; i < 15; i++) {\narr[0][i] = i;\n}\nfor (int i = 1; i < 15; i++) {\nfor (int j = 1; j < 15; j++) {\nfor (int k = 1; k <= j; k++) {\narr[i][j] += arr[i-1][k];\n}\n}\n}\nwhile (T--) {\nint K, N;\ncin >> K >> N;\ncout << arr[K][N] << \"\\n\";\n}\nreturn 0;\n}"
    },
    {
        "problem_tier": 8,
        "solution_code": "#include <iostream>\n#include <stack>\nusing namespace std;\nint main() {\nstack<int> s;\nint K;\nint num;\nint sum = 0;\ncin >> K;\nfor (int i = 0; i < K; i++) {\ncin >> num;\nif (num == 0) {\ns.pop();\n} else {\ns.push(num);\n}\n}\nint stack_size = s.size();\nfor (int i = 0; i < stack_size; i++) {\nsum += s.top();\ns.pop();\n}\ncout << sum;\nreturn 0;\n}"
    },
    {
        "problem_tier": 7,
        "solution_code": "#include <iostream>\n#include <vector>\n#include <algorithm>\nusing namespace std;\nbool desc(int a, int b) {\nreturn a > b;\n}\nint main(void) {\nstring s;\ncin >> s;\nint len = s.length();\nvector<int> arr(len);\nfor (int i = 0; i < len; i++) {\narr[i] = s[i] - '0';\n}\nsort(arr.begin(), arr.end(), desc);\nfor (int i = 0; i < len; i++) {\ncout << arr[i];\n}\nreturn 0;\n}"
    },
    {
        "problem_tier": 7,
        "solution_code": "#include <iostream>\n#include <algorithm>\n#include <vector>\nusing namespace std;\nstruct Point {\nint x;\nint y;\n};\nbool compare(Point a, Point b) {\nif (a.x == b.x) {\nreturn a.y < b.y;\n}\nreturn a.x < b.x;\n}\nint main() {\nios::sync_with_stdio(false);\ncin.tie(NULL);\ncout.tie(NULL);\nint n;\ncin >> n;\nvector<Point> points(n);\nfor (int i = 0; i < n; i++) {\ncin >> points[i].x >> points[i].y;\n}\nsort(points.begin(), points.end(), compare);\nfor (int i = 0; i < n; i++) {\ncout << points[i].x << \" \" << points[i].y << \"\\n\";\n}\nreturn 0;\n}"
    },
    {
        "problem_tier": 8,
        "solution_code": "#include <iostream>\n#include <algorithm>\n#include <vector>\nusing namespace std;\nvector<int> a;\nint solve(int num){\nint mid, right, left;\nright = a.size() - 1;\nleft = 0;\nmid = (right + left) / 2;\nint result = 0;\nwhile(right - left >= 0){\nif(a[mid] == num){\nresult = 1;\nbreak;\n}\nelse if(a[mid] > num){\nright = mid - 1;\n}\nelse if(a[mid] < num){\nleft = mid + 1;\n}\nmid = (right + left) / 2;\n}\nreturn result;\n}\nint main(void){\nint N, M;\ncin >> N;\nfor(int i = 0; i < N; i++){\nint num;\ncin >> num;\na.push_back(num);\n}\nsort(a.begin(), a.end());\ncin >> M;\nfor(int i = 0; i < M; i++){\nint num;\nscanf(\"%d\", &num);\nprintf(\"%d\\n\", solve(num));\n}\nreturn 0;\n}"
    },
    {
        "problem_tier": 6,
        "solution_code": "#include <iostream>\nusing namespace std;\nint main() {\nios_base::sync_with_stdio(false);\ncin.tie(NULL);\ncout.tie(NULL);\nint N;\ncin >> N;\nint input[10001] = {0};\nfor (int i = 0; i < N; i++) {\nint in;\ncin >> in;\ninput[in] += 1;\n}\nfor (int i = 1; i < 10001; i++) {\nfor (int j = 0; j < input[i]; j++) {\ncout << i << '\\n';\n}\n}\nreturn 0;\n}"
    },
    {
        "problem_tier": 11,
        "solution_code": "#include <iostream>\n#include <vector>\n#include <algorithm>\n#include <string>\nusing namespace std;\nconst int MAX = 25;\nint N;\nint map[MAX][MAX] = { 0, };\nbool visited[MAX][MAX] = { 0, };\nint dy[] = { 0,0,1,-1 };\nint dx[] = { 1,-1,0,0 };\nint label = 1;\nvector<int> v;\nint house = 0;\nvoid DFS(int y, int x) {\nvisited[y][x] = true;\nmap[y][x] = label;\nhouse++;\nfor (int i = 0; i < 4; i++) {\nint nx = x + dx[i];\nint ny = y + dy[i];\nif (nx < 0 || ny < 0 || nx >= N || ny >= N)\ncontinue;\nif (map[ny][nx] == 1 && visited[ny][nx] == 0) {\nDFS(ny, nx);\n}\n}\n}\nint main() {\ncin >> N;\nfor (int i = 0; i < N; i++) {\nstring input;\ncin >> input;\nfor (int j = 0; j < N; j++) {\nmap[i][j] = input.at(j) - '0';\n}\n}\nfor (int i = 0; i < N; i++) {\nfor (int j = 0; j < N; j++) {\nif (map[i][j] == 1 && visited[i][j] == 0) {\nDFS(i, j);\nlabel++;\nv.push_back(house);\nhouse = 0;\n}\n}\n}\nsort(v.begin(), v.end());\ncout << label - 1 << endl;\nfor (int i = 0; i < v.size(); i++) {\ncout << v[i] << endl;\n}\n}"
    },
    {
        "problem_tier": 6,
        "solution_code": "#include<iostream>\n#include<algorithm>\nusing namespace std;\nint gcd(int x, int y) {\nif (y == 0)\nreturn x;\nreturn gcd(y, x % y);\n}\nint main() {\nint x, y;\ncin >> x >> y;\nint result_gcd = gcd(x, y);\ncout << result_gcd << endl;     cout << x * y / result_gcd;\nreturn 0;\n}"
    },
    {
        "problem_tier": 9,
        "solution_code": "#include <iostream>\n#include <deque>\nusing namespace std;\nvoid DFS(deque<int> adj_list[], deque<bool>& check, int i, int& cnt) {\ncheck[i-1] = true;\nfor (int j = 0; j < adj_list[i-1].size(); ++j) {\nif (check[adj_list[i-1][j]-1] == false) {\nDFS(adj_list, check, adj_list[i-1][j], cnt);\ncnt++;\n}\n}\n}\nint main(int argc, char** argv) {\nint cmpr, num, first, second;\nint cnt = 0;\ncin >> cmpr >> num;\ndeque<int> adj_list[cmpr];\ndeque<bool> check(cmpr, false);\nwhile (num--) {\ncin >> first >> second;\nadj_list[first-1].push_back(second);\nadj_list[second-1].push_back(first);\n}\nDFS(adj_list, check, 1, cnt);\ncout << cnt;\nreturn 0;\n}"
    },
    {
        "problem_tier": 9,
        "solution_code": "#include<iostream>\nusing namespace std;\npair<int, int> dp[41];\nvoid countFibo(int n){\ndp[0] = make_pair(1, 0);\ndp[1] = make_pair(0, 1);\nfor(int i=2; i<=n; i++){\ndp[i] = make_pair((dp[i-1].first + dp[i-2].first), (dp[i-1].second + dp[i-2].second));\n}\n}\nint main(){\nint T, n;\ncin >> T;\nfor(int i=0; i<T; i++){\ncin >> n;\ncountFibo(n);\ncout << dp[n].first << \" \" << dp[n].second << '\\n';\n}\nreturn 0;\n}"
    },
    {
        "problem_tier": 7,
        "solution_code": "#include<iostream>\nusing namespace std;\nint main() {\nint n;\ncin >> n;\nint index = 0;\nint sum;\nwhile(1) {\nindex++;\nsum = index * (index + 1) / 2;\nif(n <= sum)\nbreak;\n}\nint num = n - (index - 1) * index / 2;\nif(index % 2 == 0)\ncout << num << '/' << index - num + 1;\nelse\ncout << index - num + 1 << '/' << num;\nreturn 0;\n}"
    },
    {
        "problem_tier": 4,
        "solution_code": "#include<iostream>\nusing namespace std;\nint main(){\nint n;\ncin >> n;\nfor(int i=1; i<=n; ++i){\nfor(int j=1; j<=i-1; ++j){\ncout << \" \";\n}\nfor(int j=1; j<=n-i+1; ++j){\ncout << \"*\";\n}\ncout << endl;\n}\nreturn 0;\n}"
    },
    {
        "problem_tier": 9,
        "solution_code": "#include<iostream>\nusing namespace std;\nint dp[11];\nint main() {\nios_base::sync_with_stdio(false);\ncin.tie(0);\ncout.tie(0);\nint T;\ncin >> T;\ndp[1] = 1;\ndp[2] = 2;\ndp[3] = 4;\nfor (int i = 4; i < 11; i++) {\ndp[i] = dp[i-1] + dp[i-2] + dp[i-3];\n}\nwhile (T--) {\nint num;\ncin >> num;\ncout << dp[num] << '\\n';\n}\nreturn 0;\n}"
    },
    {
        "problem_tier": 5,
        "solution_code": "#include<iostream>\nusing namespace std;\nint calculate(int n){\nint compare = n;     int temp = n;\nwhile(temp > 0){         compare += temp % 10;         temp /= 10;     }\nif(compare == n)         return true;\nelse\nreturn false; }\nint main(){\nint n;\ncin >> n;     int result = 0;     int temp;\nif(n > 54)         temp = n - 54;\nelse\ntemp = 0;\nwhile(temp < n){         if(calculate() == true){             result = temp;             break;\n}\ntemp++;     }\ncout << result;\nreturn 0;\n}"
    },
    {
        "problem_tier": 4,
        "solution_code": "#include <iostream>\n#include <algorithm>\nusing namespace std;\nint main() {\nint x, y, w, h;\ncin >> x >> y >> w >> h;\nint tmp1 = min(x, y);\nint tmp2 = min(w - x, h - y);\ncout << min(tmp1, tmp2);\nreturn 0;\n}"
    },
    {
        "problem_tier": 3,
        "solution_code": "#include <iostream>\nusing namespace std;\nint main() {\nint totalPrice, t, sum = 0;\ncin >> totalPrice >> t;\nfor (int i = 0; i < t; i++) {\nint a, b;\ncin >> a >> b;\nsum += a * b;\n}\nif (totalPrice == sum) {\ncout << \"Yes\";\n} else {\ncout << \"No\";\n}\nreturn 0;\n}"
    },
    {
        "problem_tier": 4,
        "solution_code": "#include<iostream>\nusing namespace std;\nint main() {\nint t;\ncin >> t;\nfor (int i = 0; i < t; i++) {\nint h, w, n;\ncin >> h >> w >> n;\nint result;\nif (n % h == 0) {\nresult = h * 100 + (n / h);\n}\nelse {\nresult = (n % h) * 100 + (n / h) + 1;\n}\ncout << result << endl;\n}\nreturn 0;\n}"
    },
    {
        "problem_tier": 7,
        "solution_code": "#include <iostream>\n#include <vector>\n#include <algorithm>\nusing namespace std;\nstruct Word {\nstring str;\nWord(string s) : str(s) {}\nbool operator<(const Word& other) const {\nif (str.size() == other.str.size()) {\nreturn str < other.str;\n}\nreturn str.size() < other.str.size();\n}\n};\nint main() {\nint n;\ncin >> n;\nvector<Word> words;\nfor (int i = 0; i < n; i++) {\nstring s;\ncin >> s;\nwords.push_back(Word(s));\n}\nsort(words.begin(), words.end());\nfor (int i = 0; i < words.size(); i++) {\nif (i > 0 && words[i].str == words[i - 1].str) {\ncontinue;\n}\ncout << words[i].str << '\\n';\n}\nreturn 0;\n}"
    },
    {
        "problem_tier": 2,
        "solution_code": "#include <iostream>\nusing namespace std;\nint main() {\ncout << \"         ,r'\\\"7\\n\";\ncout << \"r`-_,  ,'  ,/\\n\";\ncout << \" \\\\\\\". \\\".L_r'\\n\";\ncout << \"  `~\\\\/ \\n\";\ncout << \"     |\\n\";\ncout << \"     |\\n\";\nreturn 0;\n}"
    },
    {
        "problem_tier": 2,
        "solution_code": "#include <iostream>\nusing namespace std;\nint main() {\ncout << \"105\\n\";\ncout << \"woojn90\\n\";\nreturn 0;\n}"
    },
    {
        "problem_tier": 2,
        "solution_code": "#include <iostream>\nusing namespace std;\nint main() {\nint find[6] = {0};\nint piece[6] = {1, 1, 2, 2, 2, 8};\nfor (int i = 0; i < 6; i++) {\ncin >> find[i];\ncout << piece[i] - find[i] << ' ';\n}\nreturn 0;\n}"
    },
    {
        "problem_tier": 11,
        "solution_code": "#include<iostream>\n#include<queue>\n#define MAX 101\nusing namespace std;\nint N, M; int maze[MAX][MAX]; int visited[MAX][MAX]; int dist[MAX][MAX]; int x_dir[4] = {-1, 1, 0, 0}; int y_dir[4] = {0, 0, -1, 1}; queue<pair<int,int>> q;\nvoid bfs(int start_x, int start_y) {\nvisited[start_x][start_y] = 1;     q.push(make_pair(start_x, start_y));     dist[start_x][start_y]++;\nwhile(!q.empty()) {\nint x = q.front().first;\nint y = q.front().second;\nq.pop();\nfor(int i=0; i<4; ++i) {\nint x_new = x + x_dir[i];\nint y_new = y + y_dir[i];\nif((0 <= x_new && x_new < N) && (0 <= y_new && y_new < M) && !visited[x_new][y_new] && maze[x_new][y_new] == 1) {\nvisited[x_new][y_new] = 1;                 q.push(make_pair(x_new, y_new));                 dist[x_new][y_new] = dist[x][y] + 1;             }\n}\n}\n}\nint main() {\ncin >> N >> M;\nfor(int i=0; i<N; ++i) {         string row;         cin >> row;\nfor(int j=0; j<M; ++j) {             maze[i][j] = row[j] - '0';         }\n}\nbfs(0, 0);     cout << dist[N-1][M-1];     return 0;\n}"
    },
    {
        "problem_tier": 2,
        "solution_code": "#include <iostream>\nusing namespace std;\nint main() {\nint n, f, a[100], cnt = 0;\ncin >> n;\nfor (int i = 0; i < n; i++) {\ncin >> a[i];\n}\ncin >> f;\nfor (int i = 0; i < n; i++) {\nif (f == a[i]) cnt++;\n}\ncout << cnt << '\\n';\nreturn 0;\n}"
    },
    {
        "problem_tier": 9,
        "solution_code": "#include <iostream>\n#include <cmath>\nusing namespace std;\nbool isPrime(int num) {\nif(num < 2)\nreturn false;\nfor(int i=2; i<=sqrt(num); i++) {\nif(num % i == 0)\nreturn false;\n}\nreturn true;\n}\nint main() {\nint m, n;\ncin >> m >> n;\nfor(int i=m; i<=n; i++) {\nif(isPrime(i))\ncout << i << '\\n';\n}\nreturn 0;\n}"
    },
    {
        "problem_tier": 2,
        "solution_code": "#include <iostream>\nusing namespace std;\nint main() {\nlong long a, b, c;\ncin >> a >> b >> c;\ncout << a + b + c << endl;\nreturn 0;\n}"
    },
    {
        "problem_tier": 4,
        "solution_code": "#include <iostream>\n#include <algorithm>\nusing namespace std;\nint main() {\nint arr[3];\nfor (int i = 0; i < 3; i++) {\ncin >> arr[i];\n}\nsort(arr, arr + 3);\ncout << arr[1];\nreturn 0;\n}"
    },
    {
        "problem_tier": 2,
        "solution_code": "#include<iostream>\n#include<string>\nusing namespace std;\nint main(){\nstring str;\nwhile (true){\ngetline(cin, str);\nif (str == \"\")\nbreak;\ncout << str << endl;\n}\nreturn 0;\n}"
    },
    {
        "problem_tier": 5,
        "solution_code": "#include<iostream>\nusing namespace std;\nint fibo(int n){\nif(n==0){\nreturn 0;\n}\nelse if(n==1){\nreturn 1;\n}\nelse{\nreturn fibo(n-1) + fibo(n-2);\n}\n}\nint main(){\nint n;\ncin >> n;\ncout << fibo(n) << endl;\nreturn 0;\n}"
    },
    {
        "problem_tier": 8,
        "solution_code": "#include <iostream>\n#include <vector>\n#include <algorithm>\nusing namespace std;\nint cmp(int a, int b){\nreturn a > b;\n}\nint main(){\nint n, k, ans=0;\ncin >> n >> k;\nvector<int> v(n);\nfor(int i=0; i<n; i++){\ncin >> v[i];\n}\nsort(v.begin(), v.end(), cmp);\nfor(int i=0; i<n; i++){\nwhile(k - v[i] >= 0){\nans++;\nk -= v[i];\n}\n}\ncout << ans << '\\n';\nreturn 0;\n}"
    },
    {
        "problem_tier": 5,
        "solution_code": "#include <iostream>\nusing namespace std;\nint main() {\nint A, B, C;\ncin >> A >> B >> C;\nif (B >= C) {\ncout << \"-1\";\n} else {\nint res = A / (C - B) + 1;\ncout << res;\n}\nreturn 0;\n}"
    },
    {
        "problem_tier": 3,
        "solution_code": "#include <iostream>\nusing namespace std;\nint main() {\nint N;\ncin >> N;\nfor (int i = N; i >= 1; i--) {\nfor (int j = i; j >= 1; j--) {\ncout << \"*\";\n}\ncout << endl;\n}\nreturn 0;\n}"
    },
    {
        "problem_tier": 8,
        "solution_code": "#include <iostream>\n#include <vector>\n#include <algorithm>\nusing namespace std;\nint main(void) {\nint N;\ncin >> N;\nvector<int> v;\nfor (int i = 0; i < N; i++) {\nint P;\ncin >> P;\nv.push_back(P);\n}\nsort(v.begin(), v.end());\nint result = 0;\nfor (int i = 0; i < N; i++) {\nresult += v[i] * (N - i);\n}\ncout << result;\nreturn 0;\n}"
    },
    {
        "problem_tier": 6,
        "solution_code": "#include<iostream>\nusing namespace std;\nint main(){\nint a, b, v;\ncin >> a >> b >> v;\nint day = 1;\nday += (v - a) / (a - b);\nif ((v - a) % (a - b) != 0)\nday++;\nif (a >= v)\ncout << \"1\";\nelse\ncout << day;\nreturn 0;\n}"
    },
    {
        "problem_tier": 10,
        "solution_code": "#include <iostream>\n#include <queue>\nusing namespace std;\n#define MAX 1001\nint N, M, V; int map[MAX][MAX]; bool visited[MAX]; queue<int> q;\nvoid reset() {\nfor (int i = 1; i <= N; i++) {\nvisited[i] = false;\n}\n}\nvoid DFS(int v) {\nvisited[v] = true;\ncout << v << \" \";\nfor (int i = 1; i <= N; i++) {\nif (map[v][i] == 1 && visited[i] == false) {             DFS(i);\n}\n}\n}\nvoid BFS(int v) {\nq.push(v);\nvisited[v] = true;\ncout << v << \" \";\nwhile (!q.empty()) {\nv = q.front();\nq.pop();\nfor (int w = 1; w <= N; w++) {\nif (map[v][w] == 1 && visited[w] == false) {                 q.push(w);\nvisited[w] = true;\ncout << w << \" \";\n}\n}\n}\n}\nint main() {\ncin >> N >> M >> V;\nfor (int i = 0; i < M; i++) {\nint a, b;\ncin >> a >> b;\nmap[a][b] = 1;\nmap[b][a] = 1;\n}\nreset();\nDFS(V);\ncout << '\\n';\nreset();\nBFS(V);\nreturn 0;\n}"
    },
    {
        "problem_tier": 5,
        "solution_code": "#include <vector>\nlong long sum(std::vector<int>& a) {\nlong long ans = 0;\nfor (int i = 0; i < a.size(); i++) {\nans += a[i];\n}\nreturn ans;\n}"
    },
    {
        "problem_tier": 7,
        "solution_code": "#include <iostream>\n#include <vector>\n#include <algorithm>\nint main() {\nstd::ios::sync_with_stdio(false);\nstd::cin.tie(0);\nstd::cout.tie(0);\nint total_no;\nstd::cin >> total_no;\nstd::vector<int> numbers(total_no);\nfor (int i = 0; i < total_no; i++) {\nstd::cin >> numbers[i];\n}\nstd::sort(numbers.begin(), numbers.end());\nfor (auto& num : numbers) {\nstd::cout << num << \"\\n\";\n}\nreturn 0;\n}"
    },
    {
        "problem_tier": 7,
        "solution_code": "#include <iostream>\n#include <string>\n#include <vector>\nusing namespace std;\nint main() {\nvector<string> croatian = {\"c=\", \"c-\", \"dz=\", \"d-\", \"lj\", \"nj\", \"s=\", \"z=\"};\nint idx;\nstring str;\ncin >> str;\nfor (int i = 0; i < croatian.size(); i++) {\nwhile (1) {\nidx = str.find(croatian[i]);\nif (idx == string::npos)\nbreak;\nstr.replace(idx, croatian[i].length(), \"#\");\n}\n}\ncout << str.length();\nreturn 0;\n}"
    },
    {
        "problem_tier": 9,
        "solution_code": "#include <iostream>\n#include <queue>\nusing namespace std;\nint d[1000001];\nint main() {\nint n;\ncin >> n;\nqueue<int> q;\nq.push(n);\nwhile (!q.empty()) {\nint x = q.front();\nq.pop();\nif (x == 1) {\ncout << d[1] << endl;\nbreak;\n}\nif (x % 3 == 0 && d[x / 3] == 0) {\nq.push(x / 3);\nd[x / 3] = d[x] + 1;\n}\nif (x % 2 == 0 && d[x / 2] == 0) {\nq.push(x / 2);\nd[x / 2] = d[x] + 1;\n}\nif (d[x - 1] == 0) {\nq.push(x - 1);\nd[x - 1] = d[x] + 1;\n}\n}\nreturn 0;\n}"
    },
    {
        "problem_tier": 5,
        "solution_code": "#include<iostream>\nusing namespace std;\nint main(){\nint n, m, hap=0;\nint a[101];\ncin >> n >> m;\nfor(int i=0; i<n; i++){\ncin >> a[i];\n}\nfor(int i=0; i<n; i++){\nfor(int j=i+1; j<n; j++){\nfor(int k=j+1; k<n; k++){\nif(a[i]+a[j]+a[k] <= m && a[i]+a[j]+a[k] > hap){\nhap = a[i]+a[j]+a[k];\n}\n}\n}\n}\ncout << hap << '\\n';\nreturn 0;\n}"
    },
    {
        "problem_tier": 5,
        "solution_code": "#include <iostream>\n#include <string>\nusing namespace std;\nint main() {\nstring s;\nint total = 0;\ncin >> s;\nfor (int i = 0; i < s.size(); i++) {\ntotal += ((int)s[i] - 65) / 3 + 3;\nif (s[i] == 'S' || s[i] == 'V' || s[i] == 'Y' || s[i] == 'Z') {\ntotal--;\n}\n}\ncout << total;\nreturn 0;\n}"
    },
    {
        "problem_tier": 8,
        "solution_code": "#include <iostream>\n#include <stack>\n#include <string>\nusing namespace std;\nint main() {\nint n;\ncin >> n;\nstack<int> st;\nwhile (n > 0) {\nn--;\nstring s;\ncin >> s;\nif (s == \"push\") {\nint x;\ncin >> x;\nst.push(x);\n}\nelse if (s == \"pop\") {\nif (st.empty()) {\ncout << -1 << endl;\n}\nelse {\ncout << st.top() << endl;\nst.pop();\n}\n}\nelse if (s == \"size\") {\ncout << st.size() << endl;\n}\nelse if (s == \"empty\") {\ncout << st.empty() << endl;\n}\nelse if (s == \"top\") {\nif (st.empty())\ncout << -1 << endl;\nelse\ncout << st.top() << endl;\n}\n}\nreturn 0;\n}"
    },
    {
        "problem_tier": 5,
        "solution_code": "#include<iostream>\nusing namespace std;\nint main(){\nint number;\ncin >> number;\nint i = 0;\nfor(int sum=2; sum <= number; i++){\nsum += 6*i;\n}\nif(number == 1)\ni = 1;\ncout << i;\nreturn 0;\n}"
    },
    {
        "problem_tier": 7,
        "solution_code": "#include <iostream>\n#include <string>\nusing namespace std;\nint main() {\nint N;\ncin >> N;\nint count = N;\nwhile (N--) {\nstring word;\ncin >> word;\nbool visited[26] = { false };\nfor (int i = 0; i < word.length(); i++) {\nif (visited[word[i] - 'a']) {\ncount--;\nbreak;\n}\nif (word[i] != word[i + 1]) {\nvisited[word[i] - 'a'] = true;\n}\n}\n}\ncout << count << endl;\nreturn 0;\n}"
    },
    {
        "problem_tier": 8,
        "solution_code": "#include <iostream>\n#include <string>\n#include <stack>\nusing namespace std;\nint main(void) {\nint k;\ncin >> k;\nwhile (k > 0) {\nk--;\nstring input;\ncin >> input;\nstack<char> st;\nstring answer = \"YES\";\nfor (int i = 0; i < input.length(); i++) {\nif (input[i] == '(') {\nst.push(input[i]);\n}\nelse if (!st.empty() && input[i] == ')' && st.top() == '(') {\nst.pop();\n}\nelse {\nanswer = \"NO\";\nbreak;\n}\n}\nif (!st.empty())\nanswer = \"NO\";\ncout << answer << endl;\n}\nreturn 0;\n}"
    },
    {
        "problem_tier": 2,
        "solution_code": "#include <iostream>\nusing namespace std;\nint main() {\nint a, b;\ncin >> a;     cin >> b;     cout << a + b;     return 0;\n}"
    },
    {
        "problem_tier": 8,
        "solution_code": "#include <iostream>\nusing namespace std;\nint main() {\nint n, cnt = 0;\ncin >> n;\nif(n < 100) {\ncout << n;\n} else {\nfor(int i = 100; i <= n; i++) {\nint a = i;\nint num[3], sub[2], indx = 0;\nwhile(a != 0) {\nnum[indx] = a % 10;\na /= 10;\nindx++;\n}\nfor(int j = 0; j < indx-1; j++) {\nsub[j] = num[j] - num[j+1];\n}\nbool isit = true;\nfor(int j = 0; j < indx-2; j++) {\nif(sub[j] != sub[j+1]) {\nisit = false;\nbreak;\n}\n}\nif(isit) {\ncnt++;\n}\n}\ncout << cnt + 99;\n}\nreturn 0;\n}"
    },
    {
        "problem_tier": 7,
        "solution_code": "#include<iostream>\nusing namespace std;\nint main(){\nbool check[10001] = {0};\nint sum;\nint a;\nfor (int i = 1; i < 10001;i++){\nsum = 0;\na = i;\nwhile(a != 0){\nsum += a % 10;             a /= 10;\n}\nif(i+sum < 10001){\ncheck[i + sum] = true;\n}\n}\nfor (int i = 1; i < 10001;i++){\nif(!check[i]){             cout << i << '\\n';\n}\n}\nreturn 0;\n}"
    },
    {
        "problem_tier": 2,
        "solution_code": "#include <iostream>\nusing namespace std;\nint factorial(int n) {\nif (n <= 1)\nreturn 1;\nelse\nreturn n * factorial(n - 1);\n}\nint main() {\nint num;\ncin >> num;\ncout << factorial(num) << '\\n';\n}"
    },
    {
        "problem_tier": 5,
        "solution_code": "#include <iostream>\n#include <cmath>\nusing namespace std;\nbool checkPrime(int num) {\nif (num == 2 || num == 3) return true;\nelse {\nfor (int i = 2; i <= sqrt(num); i++) {\nif (num % i == 0) return false;\n}\nreturn true;\n}\n}\nint main() {\nbool isPrime[1001];\nmemset(isPrime, true, sizeof(isPrime));\nisPrime[1] = false;\nfor (int i = 2; i <= 1000; i++) {\nif (isPrime[i] == true && checkPrime(i)) {\nfor (int j = i * 2; j < 1001; j += i) {\nisPrime[j] = false;\n}\n}\n}\nint t, n, answer = 0;\ncin >> t;\nfor (int i = 0; i < t; i++) {\ncin >> n;\nif (isPrime[n]) answer += 1;\n}\ncout << answer;\nreturn 0;\n}"
    },
    {
        "problem_tier": 5,
        "solution_code": "#include<iostream>\n#include<algorithm>\n#include<vector>\nusing namespace std;\nint main() {\nint N;\nint nTmp;\nvector<int> v;\ncin >> N;\nfor (int i = 0; i < N; i++) {\ncin >> nTmp;\nv.push_back(nTmp);\n}\nsort(v.begin(), v.end());\nfor (int j = 0; j < v.size(); j++) {\ncout << v[j] << endl;\n}\nreturn 0;\n}"
    },
    {
        "problem_tier": 3,
        "solution_code": "#include <iostream>\n#include <algorithm>\nusing namespace std;\nint main() {\nint a, b, c;\ncin >> a >> b >> c;\nif (a == b && b == c) {\ncout << 10000 + a * 1000;\n}\nelse if (a == b || a == c) {\ncout << 1000 + a * 100;\n}\nelse if (b == c) {\ncout << 1000 + b * 100;\n}\nelse {\nint max_num = max(max(a, b), c);\ncout << max_num * 100;\n}\nreturn 0;\n}"
    },
    {
        "problem_tier": 6,
        "solution_code": "#include<iostream>\nusing namespace std;\nint main() {\nint C, N;\ncin >> C;\nfor(int i = 0; i < C; i++) {\nfloat average = 0;\nint sum = 0;\nint count = 0;\ncin >> N;\nint score[N];\nfor(int j = 0; j < N; j++) {\ncin >> score[j];\nsum += score[j];\n}\naverage = (double)sum / N;\nfor(int j = 0; j < N; j++) {\nif(score[j] > average) {\ncount++;\n}\n}\ncout.precision(3);\ncout << fixed << (double)count / N * 100 << \"%\" << endl;\n}\nreturn 0;\n}"
    },
    {
        "problem_tier": 5,
        "solution_code": "#include <iostream>\n#include <string>\nusing namespace std;\nint main(void) {\nstring x, y;\ncin >> x >> y;\nstring bigger;\nfor(int i = 2; i >= 0; i--) {\nif(x[i] > y[i]) {\nbigger = x;\nbreak;\n} else if(x[i] < y[i]) {\nbigger = y;\nbreak;\n}\n}\ncout << bigger[2] << bigger[1] << bigger[0];\nreturn 0;\n}"
    },
    {
        "problem_tier": 4,
        "solution_code": "#include <iostream>\nusing namespace std;\nint main() {\nint h, m, t;\ncin >> h >> m >> t;\nh += t / 60;\nm += t % 60;\nif (m >= 60) {\nh += 1;\nm -= 60;\n}\nif (h >= 24) {\nh -= 24;\n}\nprintf(\"%d %d\", h, m);\nreturn 0;\n}"
    },
    {
        "problem_tier": 6,
        "solution_code": "#include<iostream>\nusing namespace std;\nint main() {\nstring s;\nint arr[26] = {0};\nint max = 0;\nint index = 0;\ncin >> s;\nfor(int i=0; i<s.length(); i++){\nif(s[i] < 97){\narr[s[i]-65]++;         }\nelse{\narr[s[i]-97]++;         }\n}\nfor(int i=0; i<26; i++){\nif(max < arr[i]){\nmax = arr[i];\nindex = i;\n}\n}\nfor(int i=0; i<26; i++){\nif(i == index){\ncontinue;\n}\nelse if(max == arr[i]){\ncout << \"?\" << endl;\nreturn 0;\n}"
    },
    {
        "problem_tier": 8,
        "solution_code": "#include<iostream>\nusing namespace std;\nint dp[5001];\nint main(){\nint n;\ncin >> n;\ndp[3] = dp[5] = 1;\nfor(int i=6; i<=n; i++){\nif(dp[i-3]) dp[i] = dp[i-3] + 1;\nif(dp[i-5]) dp[i] = dp[i] ? min(dp[i], dp[i-5]+1) : dp[i-5]+1;\n}\ncout << (dp[n] == 0 ? -1 : dp[n]) << endl;\nreturn 0;\n}"
    },
    {
        "problem_tier": 5,
        "solution_code": "#include <iostream>\n#include <string>\nusing namespace std;\nint main() {\nint T, R;\nstring S;\ncin >> T;\nfor (int i = 0; i < T; i++) {\ncin >> R >> S;\nfor (int k = 0; k < S.length(); k++) {\nfor (int j = 0; j < R; j++)\ncout << S[k];\n}\ncout << endl;\n}\nreturn 0;\n}"
    },
    {
        "problem_tier": 5,
        "solution_code": "#include <iostream>\nusing namespace std;\nint main() {\nint n;\ncin >> n;\nfor (int i = 0; i < n; i++) {\nstring quiz;\ncin >> quiz;\nint score = 0;\nint alpha = 1;\nfor (int j = 0; j < quiz.length(); j++) {\nif (quiz[j] == 'O') {\nscore += alpha;\nalpha++;\n}\nelse {\nalpha = 1;\n}\n}\ncout << score << endl;\n}\nreturn 0;\n}"
    },
    {
        "problem_tier": 5,
        "solution_code": "#include <iostream>\n#include <string>\nusing namespace std;\nint main() {\nstring s;\ncin >> s;\nint alphaNum[26];\nfor (int i = 0; i < 26; i++) {\nalphaNum[i] = -1;\n}\nfor (int i = s.size() - 1; i >= 0; i--) {\nalphaNum[s[i] - 'a'] = i;\n}\nfor (int i = 0; i < 26; i++) {\ncout << alphaNum[i] << \" \";\n}\nreturn 0;\n}"
    },
    {
        "problem_tier": 5,
        "solution_code": "#include<iostream>\nusing namespace std;\nint main() {\nint A, B, C;\ncin >> A >> B >> C;\nint mul = A * B * C;\nint count[10] = {0,};\nwhile(mul != 0) {\nint digit = mul % 10;\nmul /= 10;\ncount[digit]++;\n}\nfor(int i = 0; i < 10; i++) {\ncout << count[i] << endl;\n}\nreturn 0;\n}"
    },
    {
        "problem_tier": 5,
        "solution_code": "#include<iostream>\nusing namespace std;\nint main() {\nstring input;\ngetline(cin, input);\nint count = 0;\nbool isWord = false;\nfor (int i = 0; i < input.length(); i++) {\nif (input[i] != ' ') {\nif (!isWord) {\nisWord = true;\ncount++;\n}\n}\nelse {\nisWord = false;\n}\n}\ncout << count;\nreturn 0;\n}"
    },
    {
        "problem_tier": 2,
        "solution_code": "#include <iostream>\nint main() {\nint n;\nstd::cin >> n;\nstd::cout << n - 543 << std::endl;\nreturn 0;\n}"
    },
    {
        "problem_tier": 5,
        "solution_code": "#include <iostream>\nusing namespace std;\nint main(){\nint num;\nint rm[42] = {0};\nint count = 0;\nfor(int i=0; i<10; i++){\ncin >> num;\nrm[num % 42]++;\n}\nfor(int i=0; i<42; i++){\nif(rm[i] != 0)\ncount++;\n}\ncout << count << endl;\nreturn 0;\n}"
    },
    {
        "problem_tier": 6,
        "solution_code": "#include <iostream>\nusing namespace std;\nint main() {\nint N;\ncin >> N;\nint origin = N;\nint result = -1;\nint u, t, s;\nint cnt = 0;\nwhile (result != origin) {\nif (N < 10) {\nu = N;\nt = 0;\n}\nelse {\nu = N % 10;\nt = N / 10;\n}\ns = u + t;\ns = s % 10;\nresult = u * 10 + s;\nN = result;\ncnt++;\n}\ncout << cnt;\nreturn 0;\n}"
    },
    {
        "problem_tier": 2,
        "solution_code": "#include <iostream>\nusing namespace std;\nint main() {\nstring id;\ncin >> id;\ncout << id << \"??!\";\nreturn 0;\n}"
    },
    {
        "problem_tier": 2,
        "solution_code": "#include<iostream>\nusing namespace std;\nint main() {\nchar c;\ncin >> c;\ncout << (int)c;\nreturn 0;\n}"
    },
    {
        "problem_tier": 6,
        "solution_code": "#include <iostream>\nusing namespace std;\nint main() {\nint n;\ncin >> n;\ndouble score[1000] = {};\ndouble max = 0, result = 0;\nfor (int i = 0; i < n; i++) {\ncin >> score[i];\nif (score[i] > max)\nmax = score[i];\nresult += score[i];\n}\nresult = (result / max * 100) / n;\ncout << fixed;\ncout.precision(6);\ncout << result << endl;\nreturn 0;\n}"
    },
    {
        "problem_tier": 3,
        "solution_code": "#include <iostream>\nusing namespace std;\nint main() {\nint n;     cin >> n;\nchar ch;\nint total = 0;\nfor (int i = 0; i < n; i++) {\ncin >> ch;\ntotal += ch - '0';     }\ncout << total << endl;\nreturn 0;\n}"
    },
    {
        "problem_tier": 3,
        "solution_code": "#include <iostream>\nint main() {\nstd::ios_base::sync_with_stdio(false);\nstd::cin.tie(NULL);\nint t;\nstd::cin >> t;\nfor (int i = 0; i < t; i++) {\nint a, b;\nstd::cin >> a >> b;\nstd::cout << a + b << '\\n';\n}\nreturn 0;\n}"
    },
    {
        "problem_tier": 2,
        "solution_code": "#include <iostream>\nusing namespace std;\nint main() {\nios::sync_with_stdio(false);\ncin.tie(NULL);\nint a, b;\nwhile (true) {\ncin >> a >> b;\nif (cin.eof())             break;\ncout << a + b << \"\\n\";\n}\nreturn 0;\n}"
    },
    {
        "problem_tier": 4,
        "solution_code": "#include<iostream>\n#include<algorithm>\nusing namespace std;\nint main() {\nint arr[9];\nfor (int i = 0; i < 9; i++) {\ncin >> arr[i];\n}\nint maxValue = *max_element(arr, arr + 9);\nint maxIndex = max_element(arr, arr + 9) - arr + 1;\ncout << maxValue << \"\\n\" << maxIndex << endl;\nreturn 0;\n}"
    },
    {
        "problem_tier": 2,
        "solution_code": "#include<iostream>\nusing namespace std;\nint main() {\nint T;\ncin >> T;\nfor (int i = 1; i <= T; i++) {\nint a, b;\ncin >> a >> b;\nint c = a + b;\ncout << \"Case #\" << i << \": \" << a << \" + \" << b << \" = \" << c << endl;\n}\nreturn 0;\n}"
    },
    {
        "problem_tier": 3,
        "solution_code": "#include <iostream>\nusing namespace std;\nint main() {\nint n;\ncin >> n;\nfor (int i = n; i >= 1; i--) {\ncout << i << \"\\n\";\n}\nreturn 0;\n}"
    },
    {
        "problem_tier": 2,
        "solution_code": "#include <iostream>\nusing namespace std;\nint main() {\nint T;\ncin >> T;\nfor (int i = 1; i <= T; i++) {\nint A, B;\ncin >> A >> B;\ncout << A + B << endl;\n}\nreturn 0;\n}"
    },
    {
        "problem_tier": 4,
        "solution_code": "#include <iostream>\n#include <algorithm>\nusing namespace std;\nint main() {\nint N;\ncin >> N;\nint arr[N];\nfor (int i = 0; i < N; i++) {\ncin >> arr[i];\n}\nsort(arr, arr + N);\ncout << arr[0] << \" \" << arr[N-1];\nreturn 0;\n}"
    },
    {
        "problem_tier": 2,
        "solution_code": "#include<iostream>\nusing namespace std;\nint main(){\nint A, B;\ncin >> A >> B;\nwhile(A || B){\ncout << A + B << \"\\n\";\ncin >> A >> B;\n}\nreturn 0;\n}"
    },
    {
        "problem_tier": 2,
        "solution_code": "#include<iostream>\nusing namespace std;\nint main() {\nint n;\ncin >> n;\nfor (int i = 1; i <= n; i++) {\ncout << i << '\\n';\n}\nreturn 0;\n}"
    },
    {
        "problem_tier": 2,
        "solution_code": "#include <iostream>\nusing namespace std;\nint main() {\nint x, y;\ncin >> x >> y;\nif (x > 0 && y > 0) {\ncout << \"1\";\n} else if (x < 0 && y > 0) {\ncout << \"2\";\n} else if (x < 0 && y < 0) {\ncout << \"3\";\n} else {\ncout << \"4\";\n}\nreturn 0;\n}"
    },
    {
        "problem_tier": 2,
        "solution_code": "#include <iostream>\nusing namespace std;\nint main(int argc, char const *argv[]) {\nint N, X;\ncin >> N >> X;\nint arr[10000];\nfor (int i = 0; i < N; i++) {\ncin >> arr[i];\n}\nfor (int i = 0; i < N; i++) {\nif (arr[i] < X) {\ncout << arr[i] << \" \";\t        }\n}\nreturn 0;\n}"
    },
    {
        "problem_tier": 4,
        "solution_code": "#include<iostream>\nusing namespace std;\nint main(void){\nint hour, min;\ncin >> hour >> min;\nif(min < 45){\nmin += 15;\nhour--;\nif(hour < 0)\nhour = 23;\n}\nelse{\nmin -= 45;\n}\ncout << hour << \" \" << min;\nreturn 0;\n}"
    },
    {
        "problem_tier": 2,
        "solution_code": "#include<iostream>\nusing namespace std;\nint main(void) {\nint t;\ncin >> t;\nfor(int i=0; i<t; i++) {\nint a, b;\ncin >> a >> b;\ncout << a + b << endl;\n}\n}"
    },
    {
        "problem_tier": 4,
        "solution_code": "#include<iostream>\nusing namespace std;\nint main(){\nint A, B;\ncin >> A >> B;\ncout << A * (B % 10) << '\\n';\ncout << A * ((B / 10) % 10) << '\\n';\ncout << A * (B / 100) << '\\n';\ncout << A * B << '\\n';\nreturn 0;\n}"
    },
    {
        "problem_tier": 2,
        "solution_code": "#include <iostream>\nusing namespace std;\nint main(){\nint n;\nint sum = 0;\ncin >> n;\nfor(int i=1; i<=n; i++){\nsum += i;\n}\ncout<<sum<<endl;\n}"
    },
    {
        "problem_tier": 3,
        "solution_code": "#include<iostream>\nusing namespace std;\nint main() {\nint N;\ncin >> N;\nfor (int i = 1; i <= N; i++) {\nfor (int j = N; j > i; j--) {\ncout << ' ';\n}\nfor (int k = 1; k <= i; k++) {\ncout << '*';\n}\ncout << endl;\n}\nreturn 0;\n}"
    },
    {
        "problem_tier": 2,
        "solution_code": "#include<iostream>\nusing namespace std;\nint main() {\nint year;\ncin >> year;\nif ((year % 4 == 0 && year % 100 != 0) || year % 400 == 0) {\ncout << \"1\" << endl;\n}\nelse {\ncout << \"0\" << endl;\n}\nreturn 0;\n}"
    },
    {
        "problem_tier": 2,
        "solution_code": "#include<cstdio>\nint main(){\nprintf(\"|\\\\_/|\\n\");\nprintf(\"|q p|   /}\\n\");\nprintf(\"( 0 )\\\"\\\"\\\"\\\\\\n\");\nprintf(\"|\\\"^\\\"`    |\\n\");\nprintf(\"||_/=\\\\\\\\__|\\n\");\nreturn 0;\n}"
    },
    {
        "problem_tier": 2,
        "solution_code": "#include <iostream>\nusing namespace std;\nint main() {\ncout << \"\\\\    /\\\\\" << endl;\ncout << \" )  ( ')\" << endl;\ncout << \"(  /  )\" << endl;\ncout << \" \\\\(__)|\" << endl;\nreturn 0;\n}"
    },
    {
        "problem_tier": 2,
        "solution_code": "#include<iostream>\nusing namespace std;\nint main() {\nint n;\ncin >> n;\nfor(int i=1; i<=n; i++){\nfor(int k=0; k<i; k++)\ncout << \"*\";\ncout << \"\\n\";\n}\nreturn 0;\n}"
    },
    {
        "problem_tier": 2,
        "solution_code": "#include<iostream>\nusing namespace std;\nint main() {\nint a, b, c;\ncin >> a >> b >> c;\ncout << (a + b) % c << endl;\ncout << ((a % c) + (b % c)) % c << endl;\ncout << (a * b) % c << endl;\ncout << ((a % c) * (b % c)) % c << endl;\nreturn 0;\n}"
    },
    {
        "problem_tier": 2,
        "solution_code": "#include <iostream>\nint main() {\nint a, b;\nstd::cin >> a >> b;\nif (a > b)\nstd::cout << \">\" << std::endl;\nelse if (a < b)\nstd::cout << \"<\" << std::endl;\nelse\nstd::cout << \"==\" << std::endl;\nreturn 0;\n}"
    },
    {
        "problem_tier": 2,
        "solution_code": "#include<iostream>\nusing namespace std;\nint main() {\nint n, i;\ncin >> n;\nfor(i = 1; i < 10; i++) {\ncout << n << \" * \" << i << \" = \" << n * i << \"\\n\";\n}\nreturn 0;\n}"
    },
    {
        "problem_tier": 2,
        "solution_code": "#include<iostream>\nusing namespace std;\nint main(){\nint score;\ncin >> score;\nif(score >= 90)\ncout << \"A\" << endl;\nelse if(score >= 80)\ncout << \"B\" << endl;\nelse if(score >= 70)\ncout << \"C\" << endl;\nelse if(score >= 60)\ncout << \"D\" << endl;\nelse\ncout << \"F\" << endl;\nreturn 0;\n}"
    },
    {
        "problem_tier": 2,
        "solution_code": "#include <iostream>\nusing namespace std;\nint main() {\ncout << \"강한친구 대한육군\" << endl;\ncout << \"강한친구 대한육군\" << endl;\nreturn 0;\n}"
    },
    {
        "problem_tier": 2,
        "solution_code": "#include<iostream>\nusing namespace std;\nint main() {\nint a, b;\ncin >> a >> b;\ncout << a + b << endl;\ncout << a - b << endl;\ncout << a * b << endl;\ncout << a / b << endl;\ncout << a % b << endl;\nreturn 0;\n}"
    },
    {
        "problem_tier": 2,
        "solution_code": "#include <iostream>\nint main() {\ndouble a, b;\nstd::cin >> a >> b;\nstd::cout << std::fixed;\nstd::cout.precision(9);\nstd::cout << a/b;\nreturn 0;\n}"
    },
    {
        "problem_tier": 2,
        "solution_code": "#include <iostream>\nusing namespace std;\nint main(int argc, char const *argv[]) {\nint A, B;\ncin >> A >> B;\ncout << A * B;\nreturn 0;\n}"
    },
    {
        "problem_tier": 2,
        "solution_code": "#include<iostream>\nusing namespace std;\nint main() {\nint a, b;\ncin >> a >> b;\ncout << a - b;\nreturn 0;\n}"
    },
    {
        "problem_tier": 2,
        "solution_code": "#include<iostream>\nusing namespace std;\nint main(void) {\nint A, B;\ncin >> A >> B;\ncout << A + B << endl;\nreturn 0;\n}"
    },
    {
        "problem_tier": 2,
        "solution_code": "#include <iostream>\nint main() {\nstd::cout << \"Hello World!\";\nreturn 0;\n}"
    }
]